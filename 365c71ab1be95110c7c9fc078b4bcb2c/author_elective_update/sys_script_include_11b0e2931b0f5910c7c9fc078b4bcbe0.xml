<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_include">
    <sys_script_include action="DELETE">
        <access>public</access>
        <active>true</active>
        <api_name>x_tsigh_cmb.xlsx</api_name>
        <caller_access/>
        <client_callable>true</client_callable>
        <description>xlsx.js (C) 2013-present SheetJS -- http://sheetjs.com</description>
        <name>xlsx</name>
        <script>/*! xlsx.js (C) 2013-present xlsx -- http://sheetjs.com */&#13;
/* vim: set ts=2: */&#13;
/*exported XLSX */&#13;
/*global global, exports, module, require:false, process:false, Buffer:false, ArrayBuffer:false, DataView:false, Deno:false, Set:false */&#13;
var XLSX = {};&#13;
function make_xlsx_lib(XLSX){&#13;
XLSX.version = '0.18.12';&#13;
var current_codepage = 1200, current_ansi = 1252;&#13;
/*global cptable:true, window */&#13;
var $cptable;&#13;
&#13;
var VALID_ANSI = [ 874, 932, 936, 949, 950, 1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258, 10000 ];&#13;
/* ECMA-376 Part I 18.4.1 charset to codepage mapping */&#13;
var CS2CP = ({&#13;
0:    1252, /* ANSI */&#13;
1:   65001, /* DEFAULT */&#13;
2:   65001, /* SYMBOL */&#13;
77:  10000, /* MAC */&#13;
128:   932, /* SHIFTJIS */&#13;
129:   949, /* HANGUL */&#13;
130:  1361, /* JOHAB */&#13;
134:   936, /* GB2312 */&#13;
136:   950, /* CHINESEBIG5 */&#13;
161:  1253, /* GREEK */&#13;
162:  1254, /* TURKISH */&#13;
163:  1258, /* VIETNAMESE */&#13;
177:  1255, /* HEBREW */&#13;
178:  1256, /* ARABIC */&#13;
186:  1257, /* BALTIC */&#13;
204:  1251, /* RUSSIAN */&#13;
222:   874, /* THAI */&#13;
238:  1250, /* EASTEUROPE */&#13;
255:  1252, /* OEM */&#13;
69:   6969  /* MISC */&#13;
});&#13;
&#13;
var set_ansi = function(cp) { if(VALID_ANSI.indexOf(cp) == -1) return; current_ansi = CS2CP[0] = cp; };&#13;
function reset_ansi() { set_ansi(1252); }&#13;
&#13;
var set_cp = function(cp) { current_codepage = cp; set_ansi(cp); };&#13;
function reset_cp() { set_cp(1200); reset_ansi(); }&#13;
&#13;
function char_codes(data) { var o = []; for(var i = 0, len = data.length; i &lt; len; ++i) o[i] = data.charCodeAt(i); return o; }&#13;
&#13;
function utf16leread(data) {&#13;
	var o = [];&#13;
	for(var i = 0; i &lt; (data.length&gt;&gt;1); ++i) o[i] = String.fromCharCode(data.charCodeAt(2*i) + (data.charCodeAt(2*i+1)&lt;&lt;8));&#13;
	return o.join("");&#13;
}&#13;
function utf16beread(data) {&#13;
	var o = [];&#13;
	for(var i = 0; i &lt; (data.length&gt;&gt;1); ++i) o[i] = String.fromCharCode(data.charCodeAt(2*i+1) + (data.charCodeAt(2*i)&lt;&lt;8));&#13;
	return o.join("");&#13;
}&#13;
&#13;
var debom = function(data) {&#13;
	var c1 = data.charCodeAt(0), c2 = data.charCodeAt(1);&#13;
	if(c1 == 0xFF &amp;&amp; c2 == 0xFE) return utf16leread(data.slice(2));&#13;
	if(c1 == 0xFE &amp;&amp; c2 == 0xFF) return utf16beread(data.slice(2));&#13;
	if(c1 == 0xFEFF) return data.slice(1);&#13;
	return data;&#13;
};&#13;
&#13;
var _getchar = function _gc1(x) { return String.fromCharCode(x); };&#13;
var _getansi = function _ga1(x) { return String.fromCharCode(x); };&#13;
&#13;
function set_cptable(cptable) {&#13;
	$cptable = cptable;&#13;
	set_cp = function(cp) { current_codepage = cp; set_ansi(cp); };&#13;
	debom = function(data) {&#13;
		if(data.charCodeAt(0) === 0xFF &amp;&amp; data.charCodeAt(1) === 0xFE) { return $cptable.utils.decode(1200, char_codes(data.slice(2))); }&#13;
		return data;&#13;
	};&#13;
	_getchar = function _gc2(x) {&#13;
		if(current_codepage === 1200) return String.fromCharCode(x);&#13;
		return $cptable.utils.decode(current_codepage, [x&amp;255,x&gt;&gt;8])[0];&#13;
	};&#13;
	_getansi = function _ga2(x) {&#13;
		return $cptable.utils.decode(current_ansi, [x])[0];&#13;
	};&#13;
	cpdoit();&#13;
}&#13;
var DENSE = null;&#13;
var DIF_XL = true;&#13;
var Base64_map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";&#13;
function Base64_encode(input) {&#13;
  var o = "";&#13;
  var c1 = 0, c2 = 0, c3 = 0, e1 = 0, e2 = 0, e3 = 0, e4 = 0;&#13;
  for (var i = 0; i &lt; input.length; ) {&#13;
    c1 = input.charCodeAt(i++);&#13;
    e1 = c1 &gt;&gt; 2;&#13;
    c2 = input.charCodeAt(i++);&#13;
    e2 = (c1 &amp; 3) &lt;&lt; 4 | c2 &gt;&gt; 4;&#13;
    c3 = input.charCodeAt(i++);&#13;
    e3 = (c2 &amp; 15) &lt;&lt; 2 | c3 &gt;&gt; 6;&#13;
    e4 = c3 &amp; 63;&#13;
    if (isNaN(c2)) {&#13;
      e3 = e4 = 64;&#13;
    } else if (isNaN(c3)) {&#13;
      e4 = 64;&#13;
    }&#13;
    o += Base64_map.charAt(e1) + Base64_map.charAt(e2) + Base64_map.charAt(e3) + Base64_map.charAt(e4);&#13;
  }&#13;
  return o;&#13;
}&#13;
function Base64_encode_pass(input) {&#13;
  var o = "";&#13;
  var c1 = 0, c2 = 0, c3 = 0, e1 = 0, e2 = 0, e3 = 0, e4 = 0;&#13;
  for (var i = 0; i &lt; input.length; ) {&#13;
    c1 = input.charCodeAt(i++);&#13;
    if (c1 &gt; 255)&#13;
      c1 = 95;&#13;
    e1 = c1 &gt;&gt; 2;&#13;
    c2 = input.charCodeAt(i++);&#13;
    if (c2 &gt; 255)&#13;
      c2 = 95;&#13;
    e2 = (c1 &amp; 3) &lt;&lt; 4 | c2 &gt;&gt; 4;&#13;
    c3 = input.charCodeAt(i++);&#13;
    if (c3 &gt; 255)&#13;
      c3 = 95;&#13;
    e3 = (c2 &amp; 15) &lt;&lt; 2 | c3 &gt;&gt; 6;&#13;
    e4 = c3 &amp; 63;&#13;
    if (isNaN(c2)) {&#13;
      e3 = e4 = 64;&#13;
    } else if (isNaN(c3)) {&#13;
      e4 = 64;&#13;
    }&#13;
    o += Base64_map.charAt(e1) + Base64_map.charAt(e2) + Base64_map.charAt(e3) + Base64_map.charAt(e4);&#13;
  }&#13;
  return o;&#13;
}&#13;
function Base64_decode(input) {&#13;
  var o = "";&#13;
  var c1 = 0, c2 = 0, c3 = 0, e1 = 0, e2 = 0, e3 = 0, e4 = 0;&#13;
  input = input.replace(/^data:([^\/]+\/[^\/]+)?;base64\,/, "").replace(/[^\w\+\/\=]/g, "");&#13;
  for (var i = 0; i &lt; input.length; ) {&#13;
    e1 = Base64_map.indexOf(input.charAt(i++));&#13;
    e2 = Base64_map.indexOf(input.charAt(i++));&#13;
    c1 = e1 &lt;&lt; 2 | e2 &gt;&gt; 4;&#13;
    o += String.fromCharCode(c1);&#13;
    e3 = Base64_map.indexOf(input.charAt(i++));&#13;
    c2 = (e2 &amp; 15) &lt;&lt; 4 | e3 &gt;&gt; 2;&#13;
    if (e3 !== 64) {&#13;
      o += String.fromCharCode(c2);&#13;
    }&#13;
    e4 = Base64_map.indexOf(input.charAt(i++));&#13;
    c3 = (e3 &amp; 3) &lt;&lt; 6 | e4;&#13;
    if (e4 !== 64) {&#13;
      o += String.fromCharCode(c3);&#13;
    }&#13;
  }&#13;
  return o;&#13;
}&#13;
var has_buf = (function() { return typeof Buffer !== 'undefined' &amp;&amp; typeof process !== 'undefined' &amp;&amp; typeof process.versions !== 'undefined' &amp;&amp; !!process.versions.node; })();&#13;
&#13;
var Buffer_from = (function() {&#13;
	if(typeof Buffer !== 'undefined') {&#13;
		var nbfs = !Buffer.from;&#13;
		if(!nbfs) try { Buffer.from("foo", "utf8"); } catch(e) { nbfs = true; }&#13;
		return nbfs ? function(buf, enc) { return (enc) ? new Buffer(buf, enc) : new Buffer(buf); } : Buffer.from.bind(Buffer);&#13;
	}&#13;
	return function() {};&#13;
})();&#13;
var buf_utf16le = (function() {&#13;
	if(typeof Buffer === 'undefined') return false;&#13;
	var x = Buffer_from([65,0]);&#13;
	if(!x) return false;&#13;
	var o = x.toString("utf16le");&#13;
	return o.length == 1;&#13;
})();&#13;
&#13;
&#13;
function new_raw_buf(len) {&#13;
	/* jshint -W056 */&#13;
	if(has_buf) return Buffer.alloc ? Buffer.alloc(len) : new Buffer(len);&#13;
	return typeof Uint8Array != "undefined" ? new Uint8Array(len) : new Array(len);&#13;
	/* jshint +W056 */&#13;
}&#13;
&#13;
function new_unsafe_buf(len) {&#13;
	/* jshint -W056 */&#13;
	if(has_buf) return Buffer.allocUnsafe ? Buffer.allocUnsafe(len) : new Buffer(len);&#13;
	return typeof Uint8Array != "undefined" ? new Uint8Array(len) : new Array(len);&#13;
	/* jshint +W056 */&#13;
}&#13;
&#13;
var s2a = function s2a(s) {&#13;
	if(has_buf) return Buffer_from(s, "binary");&#13;
	return s.split("").map(function(x){ return x.charCodeAt(0) &amp; 0xff; });&#13;
};&#13;
&#13;
function s2ab(s) {&#13;
	if(typeof ArrayBuffer === 'undefined') return s2a(s);&#13;
	var buf = new ArrayBuffer(s.length), view = new Uint8Array(buf);&#13;
	for (var i=0; i!=s.length; ++i) view[i] = s.charCodeAt(i) &amp; 0xFF;&#13;
	return buf;&#13;
}&#13;
&#13;
function a2s(data) {&#13;
	if(Array.isArray(data)) return data.map(function(c) { return String.fromCharCode(c); }).join("");&#13;
	var o = []; for(var i = 0; i &lt; data.length; ++i) o[i] = String.fromCharCode(data[i]); return o.join("");&#13;
}&#13;
&#13;
function a2u(data) {&#13;
	if(typeof Uint8Array === 'undefined') throw new Error("Unsupported");&#13;
	return new Uint8Array(data);&#13;
}&#13;
&#13;
function ab2a(data) {&#13;
	if(typeof ArrayBuffer == 'undefined') throw new Error("Unsupported");&#13;
	if(data instanceof ArrayBuffer) return ab2a(new Uint8Array(data));&#13;
var o = new Array(data.length);&#13;
	for(var i = 0; i &lt; data.length; ++i) o[i] = data[i];&#13;
	return o;&#13;
}&#13;
&#13;
var bconcat = has_buf ? function(bufs) { return Buffer.concat(bufs.map(function(buf) { return Buffer.isBuffer(buf) ? buf : Buffer_from(buf); })); } : function(bufs) {&#13;
	if(typeof Uint8Array !== "undefined") {&#13;
		var i = 0, maxlen = 0;&#13;
		for(i = 0; i &lt; bufs.length; ++i) maxlen += bufs[i].length;&#13;
		var o = new Uint8Array(maxlen);&#13;
		var len = 0;&#13;
		for(i = 0, maxlen = 0; i &lt; bufs.length; maxlen += len, ++i) {&#13;
			len = bufs[i].length;&#13;
			if(bufs[i] instanceof Uint8Array) o.set(bufs[i], maxlen);&#13;
			else if(typeof bufs[i] == "string") o.set(new Uint8Array(s2a(bufs[i])), maxlen);&#13;
			else o.set(new Uint8Array(bufs[i]), maxlen);&#13;
		}&#13;
		return o;&#13;
	}&#13;
	return [].concat.apply([], bufs.map(function(buf) { return Array.isArray(buf) ? buf : [].slice.call(buf); }));&#13;
};&#13;
&#13;
function utf8decode(content) {&#13;
	var out = [], widx = 0, L = content.length + 250;&#13;
	var o = new_raw_buf(content.length + 255);&#13;
	for(var ridx = 0; ridx &lt; content.length; ++ridx) {&#13;
		var c = content.charCodeAt(ridx);&#13;
		if(c &lt; 0x80) o[widx++] = c;&#13;
		else if(c &lt; 0x800) {&#13;
			o[widx++] = (192|((c&gt;&gt;6)&amp;31));&#13;
			o[widx++] = (128|(c&amp;63));&#13;
		} else if(c &gt;= 0xD800 &amp;&amp; c &lt; 0xE000) {&#13;
			c = (c&amp;1023)+64;&#13;
			var d = content.charCodeAt(++ridx)&amp;1023;&#13;
			o[widx++] = (240|((c&gt;&gt;8)&amp;7));&#13;
			o[widx++] = (128|((c&gt;&gt;2)&amp;63));&#13;
			o[widx++] = (128|((d&gt;&gt;6)&amp;15)|((c&amp;3)&lt;&lt;4));&#13;
			o[widx++] = (128|(d&amp;63));&#13;
		} else {&#13;
			o[widx++] = (224|((c&gt;&gt;12)&amp;15));&#13;
			o[widx++] = (128|((c&gt;&gt;6)&amp;63));&#13;
			o[widx++] = (128|(c&amp;63));&#13;
		}&#13;
		if(widx &gt; L) {&#13;
			out.push(o.slice(0, widx));&#13;
			widx = 0;&#13;
			o = new_raw_buf(65535);&#13;
			L = 65530;&#13;
		}&#13;
	}&#13;
	out.push(o.slice(0, widx));&#13;
	return bconcat(out);&#13;
}&#13;
&#13;
var chr0 = /\u0000/g, chr1 = /[\u0001-\u0006]/g;&#13;
/* ssf.js (C) 2013-present xlsx -- http://sheetjs.com */&#13;
/*jshint -W041 */&#13;
function _strrev(x) { var o = "", i = x.length-1; while(i&gt;=0) o += x.charAt(i--); return o; }&#13;
function pad0(v,d){var t=""+v; return t.length&gt;=d?t:fill('0',d-t.length)+t;}&#13;
function pad_(v,d){var t=""+v;return t.length&gt;=d?t:fill(' ',d-t.length)+t;}&#13;
function rpad_(v,d){var t=""+v; return t.length&gt;=d?t:t+fill(' ',d-t.length);}&#13;
function pad0r1(v,d){var t=""+Math.round(v); return t.length&gt;=d?t:fill('0',d-t.length)+t;}&#13;
function pad0r2(v,d){var t=""+v; return t.length&gt;=d?t:fill('0',d-t.length)+t;}&#13;
var p2_32 = Math.pow(2,32);&#13;
function pad0r(v,d){if(v&gt;p2_32||v&lt;-p2_32) return pad0r1(v,d); var i = Math.round(v); return pad0r2(i,d); }&#13;
/* yes, in 2022 this is still faster than string compare */&#13;
function SSF_isgeneral(s, i) { i = i || 0; return s.length &gt;= 7 + i &amp;&amp; (s.charCodeAt(i)|32) === 103 &amp;&amp; (s.charCodeAt(i+1)|32) === 101 &amp;&amp; (s.charCodeAt(i+2)|32) === 110 &amp;&amp; (s.charCodeAt(i+3)|32) === 101 &amp;&amp; (s.charCodeAt(i+4)|32) === 114 &amp;&amp; (s.charCodeAt(i+5)|32) === 97 &amp;&amp; (s.charCodeAt(i+6)|32) === 108; }&#13;
var days = [&#13;
	['Sun', 'Sunday'],&#13;
	['Mon', 'Monday'],&#13;
	['Tue', 'Tuesday'],&#13;
	['Wed', 'Wednesday'],&#13;
	['Thu', 'Thursday'],&#13;
	['Fri', 'Friday'],&#13;
	['Sat', 'Saturday']&#13;
];&#13;
var months = [&#13;
	['J', 'Jan', 'January'],&#13;
	['F', 'Feb', 'February'],&#13;
	['M', 'Mar', 'March'],&#13;
	['A', 'Apr', 'April'],&#13;
	['M', 'May', 'May'],&#13;
	['J', 'Jun', 'June'],&#13;
	['J', 'Jul', 'July'],&#13;
	['A', 'Aug', 'August'],&#13;
	['S', 'Sep', 'September'],&#13;
	['O', 'Oct', 'October'],&#13;
	['N', 'Nov', 'November'],&#13;
	['D', 'Dec', 'December']&#13;
];&#13;
function SSF_init_table(t) {&#13;
	if(!t) t = {};&#13;
	t[0]=  'General';&#13;
	t[1]=  '0';&#13;
	t[2]=  '0.00';&#13;
	t[3]=  '#,##0';&#13;
	t[4]=  '#,##0.00';&#13;
	t[9]=  '0%';&#13;
	t[10]= '0.00%';&#13;
	t[11]= '0.00E+00';&#13;
	t[12]= '# ?/?';&#13;
	t[13]= '# ??/??';&#13;
	t[14]= 'm/d/yy';&#13;
	t[15]= 'd-mmm-yy';&#13;
	t[16]= 'd-mmm';&#13;
	t[17]= 'mmm-yy';&#13;
	t[18]= 'h:mm AM/PM';&#13;
	t[19]= 'h:mm:ss AM/PM';&#13;
	t[20]= 'h:mm';&#13;
	t[21]= 'h:mm:ss';&#13;
	t[22]= 'm/d/yy h:mm';&#13;
	t[37]= '#,##0 ;(#,##0)';&#13;
	t[38]= '#,##0 ;[Red](#,##0)';&#13;
	t[39]= '#,##0.00;(#,##0.00)';&#13;
	t[40]= '#,##0.00;[Red](#,##0.00)';&#13;
	t[45]= 'mm:ss';&#13;
	t[46]= '[h]:mm:ss';&#13;
	t[47]= 'mmss.0';&#13;
	t[48]= '##0.0E+0';&#13;
	t[49]= '@';&#13;
	t[56]= '"上午/下午 "hh"時"mm"分"ss"秒 "';&#13;
	return t;&#13;
}&#13;
/* repeated to satiate webpack */&#13;
var table_fmt = {&#13;
	0:  'General',&#13;
	1:  '0',&#13;
	2:  '0.00',&#13;
	3:  '#,##0',&#13;
	4:  '#,##0.00',&#13;
	9:  '0%',&#13;
	10: '0.00%',&#13;
	11: '0.00E+00',&#13;
	12: '# ?/?',&#13;
	13: '# ??/??',&#13;
	14: 'm/d/yy',&#13;
	15: 'd-mmm-yy',&#13;
	16: 'd-mmm',&#13;
	17: 'mmm-yy',&#13;
	18: 'h:mm AM/PM',&#13;
	19: 'h:mm:ss AM/PM',&#13;
	20: 'h:mm',&#13;
	21: 'h:mm:ss',&#13;
	22: 'm/d/yy h:mm',&#13;
	37: '#,##0 ;(#,##0)',&#13;
	38: '#,##0 ;[Red](#,##0)',&#13;
	39: '#,##0.00;(#,##0.00)',&#13;
	40: '#,##0.00;[Red](#,##0.00)',&#13;
	45: 'mm:ss',&#13;
	46: '[h]:mm:ss',&#13;
	47: 'mmss.0',&#13;
	48: '##0.0E+0',&#13;
	49: '@',&#13;
	56: '"上午/下午 "hh"時"mm"分"ss"秒 "'&#13;
};&#13;
&#13;
/* Defaults determined by systematically testing in Excel 2019 */&#13;
&#13;
/* These formats appear to default to other formats in the table */&#13;
var SSF_default_map = {&#13;
	5:  37, 6:  38, 7:  39, 8:  40,         //  5 -&gt; 37 ...  8 -&gt; 40&#13;
&#13;
	23:  0, 24:  0, 25:  0, 26:  0,         // 23 -&gt;  0 ... 26 -&gt;  0&#13;
&#13;
	27: 14, 28: 14, 29: 14, 30: 14, 31: 14, // 27 -&gt; 14 ... 31 -&gt; 14&#13;
&#13;
	50: 14, 51: 14, 52: 14, 53: 14, 54: 14, // 50 -&gt; 14 ... 58 -&gt; 14&#13;
	55: 14, 56: 14, 57: 14, 58: 14,&#13;
	59:  1, 60:  2, 61:  3, 62:  4,         // 59 -&gt;  1 ... 62 -&gt;  4&#13;
&#13;
	67:  9, 68: 10,                         // 67 -&gt;  9 ... 68 -&gt; 10&#13;
	69: 12, 70: 13, 71: 14,                 // 69 -&gt; 12 ... 71 -&gt; 14&#13;
	72: 14, 73: 15, 74: 16, 75: 17,         // 72 -&gt; 14 ... 75 -&gt; 17&#13;
	76: 20, 77: 21, 78: 22,                 // 76 -&gt; 20 ... 78 -&gt; 22&#13;
	79: 45, 80: 46, 81: 47,                 // 79 -&gt; 45 ... 81 -&gt; 47&#13;
	82: 0                                   // 82 -&gt;  0 ... 65536 -&gt; 0 (omitted)&#13;
};&#13;
&#13;
&#13;
/* These formats technically refer to Accounting formats with no equivalent */&#13;
var SSF_default_str = {&#13;
	//  5 -- Currency,   0 decimal, black negative&#13;
	5:  '"$"#,##0_);\\("$"#,##0\\)',&#13;
	63: '"$"#,##0_);\\("$"#,##0\\)',&#13;
&#13;
	//  6 -- Currency,   0 decimal, red   negative&#13;
	6:  '"$"#,##0_);[Red]\\("$"#,##0\\)',&#13;
	64: '"$"#,##0_);[Red]\\("$"#,##0\\)',&#13;
&#13;
	//  7 -- Currency,   2 decimal, black negative&#13;
	7:  '"$"#,##0.00_);\\("$"#,##0.00\\)',&#13;
	65: '"$"#,##0.00_);\\("$"#,##0.00\\)',&#13;
&#13;
	//  8 -- Currency,   2 decimal, red   negative&#13;
	8:  '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',&#13;
	66: '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',&#13;
&#13;
	// 41 -- Accounting, 0 decimal, No Symbol&#13;
	41: '_(* #,##0_);_(* \\(#,##0\\);_(* "-"_);_(@_)',&#13;
&#13;
	// 42 -- Accounting, 0 decimal, $  Symbol&#13;
	42: '_("$"* #,##0_);_("$"* \\(#,##0\\);_("$"* "-"_);_(@_)',&#13;
&#13;
	// 43 -- Accounting, 2 decimal, No Symbol&#13;
	43: '_(* #,##0.00_);_(* \\(#,##0.00\\);_(* "-"??_);_(@_)',&#13;
&#13;
	// 44 -- Accounting, 2 decimal, $  Symbol&#13;
	44: '_("$"* #,##0.00_);_("$"* \\(#,##0.00\\);_("$"* "-"??_);_(@_)'&#13;
};&#13;
&#13;
function SSF_frac(x, D, mixed) {&#13;
	var sgn = x &lt; 0 ? -1 : 1;&#13;
	var B = x * sgn;&#13;
	var P_2 = 0, P_1 = 1, P = 0;&#13;
	var Q_2 = 1, Q_1 = 0, Q = 0;&#13;
	var A = Math.floor(B);&#13;
	while(Q_1 &lt; D) {&#13;
		A = Math.floor(B);&#13;
		P = A * P_1 + P_2;&#13;
		Q = A * Q_1 + Q_2;&#13;
		if((B - A) &lt; 0.00000005) break;&#13;
		B = 1 / (B - A);&#13;
		P_2 = P_1; P_1 = P;&#13;
		Q_2 = Q_1; Q_1 = Q;&#13;
	}&#13;
	if(Q &gt; D) { if(Q_1 &gt; D) { Q = Q_2; P = P_2; } else { Q = Q_1; P = P_1; } }&#13;
	if(!mixed) return [0, sgn * P, Q];&#13;
	var q = Math.floor(sgn * P/Q);&#13;
	return [q, sgn*P - q*Q, Q];&#13;
}&#13;
function SSF_parse_date_code(v,opts,b2) {&#13;
	if(v &gt; 2958465 || v &lt; 0) return null;&#13;
	var date = (v|0), time = Math.floor(86400 * (v - date)), dow=0;&#13;
	var dout=[];&#13;
	var out={D:date, T:time, u:86400*(v-date)-time,y:0,m:0,d:0,H:0,M:0,S:0,q:0};&#13;
	if(Math.abs(out.u) &lt; 1e-6) out.u = 0;&#13;
	if(opts &amp;&amp; opts.date1904) date += 1462;&#13;
	if(out.u &gt; 0.9999) {&#13;
		out.u = 0;&#13;
		if(++time == 86400) { out.T = time = 0; ++date; ++out.D; }&#13;
	}&#13;
	if(date === 60) {dout = b2 ? [1317,10,29] : [1900,2,29]; dow=3;}&#13;
	else if(date === 0) {dout = b2 ? [1317,8,29] : [1900,1,0]; dow=6;}&#13;
	else {&#13;
		if(date &gt; 60) --date;&#13;
		/* 1 = Jan 1 1900 in Gregorian */&#13;
		var d = new Date(1900, 0, 1);&#13;
		d.setDate(d.getDate() + date - 1);&#13;
		dout = [d.getFullYear(), d.getMonth()+1,d.getDate()];&#13;
		dow = d.getDay();&#13;
		if(date &lt; 60) dow = (dow + 6) % 7;&#13;
		if(b2) dow = SSF_fix_hijri(d, dout);&#13;
	}&#13;
	out.y = dout[0]; out.m = dout[1]; out.d = dout[2];&#13;
	out.S = time % 60; time = Math.floor(time / 60);&#13;
	out.M = time % 60; time = Math.floor(time / 60);&#13;
	out.H = time;&#13;
	out.q = dow;&#13;
	return out;&#13;
}&#13;
var SSFbasedate = new Date(1899, 11, 31, 0, 0, 0);&#13;
var SSFdnthresh = SSFbasedate.getTime();&#13;
var SSFbase1904 = new Date(1900, 2, 1, 0, 0, 0);&#13;
function datenum_local(v, date1904) {&#13;
	var epoch = v.getTime();&#13;
	if(date1904) epoch -= 1461*24*60*60*1000;&#13;
	else if(v &gt;= SSFbase1904) epoch += 24*60*60*1000;&#13;
	return (epoch - (SSFdnthresh + (v.getTimezoneOffset() - SSFbasedate.getTimezoneOffset()) * 60000)) / (24 * 60 * 60 * 1000);&#13;
}&#13;
/* ECMA-376 18.8.30 numFmt*/&#13;
/* Note: `toPrecision` uses standard form when prec &gt; E and E &gt;= -6 */&#13;
/* exponent &gt;= -9 and &lt;= 9 */&#13;
function SSF_strip_decimal(o) {&#13;
	return (o.indexOf(".") == -1) ? o : o.replace(/(?:\.0*|(\.\d*[1-9])0+)$/, "$1");&#13;
}&#13;
&#13;
/* General Exponential always shows 2 digits exp and trims the mantissa */&#13;
function SSF_normalize_exp(o) {&#13;
	if(o.indexOf("E") == -1) return o;&#13;
	return o.replace(/(?:\.0*|(\.\d*[1-9])0+)[Ee]/,"$1E").replace(/(E[+-])(\d)$/,"$10$2");&#13;
}&#13;
&#13;
/* exponent &gt;= -9 and &lt;= 9 */&#13;
function SSF_small_exp(v) {&#13;
	var w = (v&lt;0?12:11);&#13;
	var o = SSF_strip_decimal(v.toFixed(12)); if(o.length &lt;= w) return o;&#13;
	o = v.toPrecision(10); if(o.length &lt;= w) return o;&#13;
	return v.toExponential(5);&#13;
}&#13;
&#13;
/* exponent &gt;= 11 or &lt;= -10 likely exponential */&#13;
function SSF_large_exp(v) {&#13;
	var o = SSF_strip_decimal(v.toFixed(11));&#13;
	return (o.length &gt; (v&lt;0?12:11) || o === "0" || o === "-0") ? v.toPrecision(6) : o;&#13;
}&#13;
&#13;
function SSF_general_num(v) {&#13;
	var V = Math.floor(Math.log(Math.abs(v))*Math.LOG10E), o;&#13;
&#13;
	if(V &gt;= -4 &amp;&amp; V &lt;= -1) o = v.toPrecision(10+V);&#13;
	else if(Math.abs(V) &lt;= 9) o = SSF_small_exp(v);&#13;
	else if(V === 10) o = v.toFixed(10).substr(0,12);&#13;
	else o = SSF_large_exp(v);&#13;
&#13;
	return SSF_strip_decimal(SSF_normalize_exp(o.toUpperCase()));&#13;
}&#13;
&#13;
&#13;
/*&#13;
	"General" rules:&#13;
	- text is passed through ("@")&#13;
	- booleans are rendered as TRUE/FALSE&#13;
	- "up to 11 characters" displayed for numbers&#13;
	- Default date format (code 14) used for Dates&#13;
&#13;
	The longest 32-bit integer text is "-2147483648", exactly 11 chars&#13;
	TODO: technically the display depends on the width of the cell&#13;
*/&#13;
function SSF_general(v, opts) {&#13;
	switch(typeof v) {&#13;
		case 'string': return v;&#13;
		case 'boolean': return v ? "TRUE" : "FALSE";&#13;
		case 'number': return (v|0) === v ? v.toString(10) : SSF_general_num(v);&#13;
		case 'undefined': return "";&#13;
		case 'object':&#13;
			if(v == null) return "";&#13;
			if(v instanceof Date) return SSF_format(14, datenum_local(v, opts &amp;&amp; opts.date1904), opts);&#13;
	}&#13;
	throw new Error("unsupported value in General format: " + v);&#13;
}&#13;
&#13;
function SSF_fix_hijri(date, o) {&#13;
  /* TODO: properly adjust y/m/d and  */&#13;
  o[0] -= 581;&#13;
  var dow = date.getDay();&#13;
  if(date &lt; 60) dow = (dow + 6) % 7;&#13;
  return dow;&#13;
}&#13;
//var THAI_DIGITS = "\u0E50\u0E51\u0E52\u0E53\u0E54\u0E55\u0E56\u0E57\u0E58\u0E59".split("");&#13;
function SSF_write_date(type, fmt, val, ss0) {&#13;
	var o="", ss=0, tt=0, y = val.y, out, outl = 0;&#13;
	switch(type) {&#13;
		case 98: /* 'b' buddhist year */&#13;
			y = val.y + 543;&#13;
			/* falls through */&#13;
		case 121: /* 'y' year */&#13;
		switch(fmt.length) {&#13;
			case 1: case 2: out = y % 100; outl = 2; break;&#13;
			default: out = y % 10000; outl = 4; break;&#13;
		} break;&#13;
		case 109: /* 'm' month */&#13;
		switch(fmt.length) {&#13;
			case 1: case 2: out = val.m; outl = fmt.length; break;&#13;
			case 3: return months[val.m-1][1];&#13;
			case 5: return months[val.m-1][0];&#13;
			default: return months[val.m-1][2];&#13;
		} break;&#13;
		case 100: /* 'd' day */&#13;
		switch(fmt.length) {&#13;
			case 1: case 2: out = val.d; outl = fmt.length; break;&#13;
			case 3: return days[val.q][0];&#13;
			default: return days[val.q][1];&#13;
		} break;&#13;
		case 104: /* 'h' 12-hour */&#13;
		switch(fmt.length) {&#13;
			case 1: case 2: out = 1+(val.H+11)%12; outl = fmt.length; break;&#13;
			default: throw 'bad hour format: ' + fmt;&#13;
		} break;&#13;
		case 72: /* 'H' 24-hour */&#13;
		switch(fmt.length) {&#13;
			case 1: case 2: out = val.H; outl = fmt.length; break;&#13;
			default: throw 'bad hour format: ' + fmt;&#13;
		} break;&#13;
		case 77: /* 'M' minutes */&#13;
		switch(fmt.length) {&#13;
			case 1: case 2: out = val.M; outl = fmt.length; break;&#13;
			default: throw 'bad minute format: ' + fmt;&#13;
		} break;&#13;
		case 115: /* 's' seconds */&#13;
			if(fmt != 's' &amp;&amp; fmt != 'ss' &amp;&amp; fmt != '.0' &amp;&amp; fmt != '.00' &amp;&amp; fmt != '.000') throw 'bad second format: ' + fmt;&#13;
			if(val.u === 0 &amp;&amp; (fmt == "s" || fmt == "ss")) return pad0(val.S, fmt.length);&#13;
if(ss0 &gt;= 2) tt = ss0 === 3 ? 1000 : 100;&#13;
			else tt = ss0 === 1 ? 10 : 1;&#13;
			ss = Math.round((tt)*(val.S + val.u));&#13;
			if(ss &gt;= 60*tt) ss = 0;&#13;
			if(fmt === 's') return ss === 0 ? "0" : ""+ss/tt;&#13;
			o = pad0(ss,2 + ss0);&#13;
			if(fmt === 'ss') return o.substr(0,2);&#13;
			return "." + o.substr(2,fmt.length-1);&#13;
		case 90: /* 'Z' absolute time */&#13;
		switch(fmt) {&#13;
			case '[h]': case '[hh]': out = val.D*24+val.H; break;&#13;
			case '[m]': case '[mm]': out = (val.D*24+val.H)*60+val.M; break;&#13;
			case '[s]': case '[ss]': out = ((val.D*24+val.H)*60+val.M)*60+Math.round(val.S+val.u); break;&#13;
			default: throw 'bad abstime format: ' + fmt;&#13;
		} outl = fmt.length === 3 ? 1 : 2; break;&#13;
		case 101: /* 'e' era */&#13;
			out = y; outl = 1; break;&#13;
	}&#13;
	var outstr = outl &gt; 0 ? pad0(out, outl) : "";&#13;
	return outstr;&#13;
}&#13;
&#13;
&#13;
/*jshint -W086 */&#13;
/*jshint +W086 */&#13;
function commaify(s) {&#13;
	var w = 3;&#13;
	if(s.length &lt;= w) return s;&#13;
	var j = (s.length % w), o = s.substr(0,j);&#13;
	for(; j!=s.length; j+=w) o+=(o.length &gt; 0 ? "," : "") + s.substr(j,w);&#13;
	return o;&#13;
}&#13;
var pct1 = /%/g;&#13;
function write_num_pct(type, fmt, val){&#13;
	var sfmt = fmt.replace(pct1,""), mul = fmt.length - sfmt.length;&#13;
	return write_num(type, sfmt, val * Math.pow(10,2*mul)) + fill("%",mul);&#13;
}&#13;
&#13;
function write_num_cm(type, fmt, val){&#13;
	var idx = fmt.length - 1;&#13;
	while(fmt.charCodeAt(idx-1) === 44) --idx;&#13;
	return write_num(type, fmt.substr(0,idx), val / Math.pow(10,3*(fmt.length-idx)));&#13;
}&#13;
&#13;
function write_num_exp(fmt, val){&#13;
	var o;&#13;
	var idx = fmt.indexOf("E") - fmt.indexOf(".") - 1;&#13;
	if(fmt.match(/^#+0.0E\+0$/)) {&#13;
		if(val == 0) return "0.0E+0";&#13;
		else if(val &lt; 0) return "-" + write_num_exp(fmt, -val);&#13;
		var period = fmt.indexOf("."); if(period === -1) period=fmt.indexOf('E');&#13;
		var ee = Math.floor(Math.log(val)*Math.LOG10E)%period;&#13;
		if(ee &lt; 0) ee += period;&#13;
		o = (val/Math.pow(10,ee)).toPrecision(idx+1+(period+ee)%period);&#13;
		if(o.indexOf("e") === -1) {&#13;
			var fakee = Math.floor(Math.log(val)*Math.LOG10E);&#13;
			if(o.indexOf(".") === -1) o = o.charAt(0) + "." + o.substr(1) + "E+" + (fakee - o.length+ee);&#13;
			else o += "E+" + (fakee - ee);&#13;
			while(o.substr(0,2) === "0.") {&#13;
				o = o.charAt(0) + o.substr(2,period) + "." + o.substr(2+period);&#13;
				o = o.replace(/^0+([1-9])/,"$1").replace(/^0+\./,"0.");&#13;
			}&#13;
			o = o.replace(/\+-/,"-");&#13;
		}&#13;
		o = o.replace(/^([+-]?)(\d*)\.(\d*)[Ee]/,function($$,$1,$2,$3) { return $1 + $2 + $3.substr(0,(period+ee)%period) + "." + $3.substr(ee) + "E"; });&#13;
	} else o = val.toExponential(idx);&#13;
	if(fmt.match(/E\+00$/) &amp;&amp; o.match(/e[+-]\d$/)) o = o.substr(0,o.length-1) + "0" + o.charAt(o.length-1);&#13;
	if(fmt.match(/E\-/) &amp;&amp; o.match(/e\+/)) o = o.replace(/e\+/,"e");&#13;
	return o.replace("e","E");&#13;
}&#13;
var frac1 = /# (\?+)( ?)\/( ?)(\d+)/;&#13;
function write_num_f1(r, aval, sign) {&#13;
	var den = parseInt(r[4],10), rr = Math.round(aval * den), base = Math.floor(rr/den);&#13;
	var myn = (rr - base*den), myd = den;&#13;
	return sign + (base === 0 ? "" : ""+base) + " " + (myn === 0 ? fill(" ", r[1].length + 1 + r[4].length) : pad_(myn,r[1].length) + r[2] + "/" + r[3] + pad0(myd,r[4].length));&#13;
}&#13;
function write_num_f2(r, aval, sign) {&#13;
	return sign + (aval === 0 ? "" : ""+aval) + fill(" ", r[1].length + 2 + r[4].length);&#13;
}&#13;
var dec1 = /^#*0*\.([0#]+)/;&#13;
var closeparen = /\).*[0#]/;&#13;
var phone = /\(###\) ###\\?-####/;&#13;
function hashq(str) {&#13;
	var o = "", cc;&#13;
	for(var i = 0; i != str.length; ++i) switch((cc=str.charCodeAt(i))) {&#13;
		case 35: break;&#13;
		case 63: o+= " "; break;&#13;
		case 48: o+= "0"; break;&#13;
		default: o+= String.fromCharCode(cc);&#13;
	}&#13;
	return o;&#13;
}&#13;
function rnd(val, d) { var dd = Math.pow(10,d); return ""+(Math.round(val * dd)/dd); }&#13;
function dec(val, d) {&#13;
	var _frac = val - Math.floor(val), dd = Math.pow(10,d);&#13;
	if (d &lt; ('' + Math.round(_frac * dd)).length) return 0;&#13;
	return Math.round(_frac * dd);&#13;
}&#13;
function carry(val, d) {&#13;
	if (d &lt; ('' + Math.round((val-Math.floor(val))*Math.pow(10,d))).length) {&#13;
		return 1;&#13;
	}&#13;
	return 0;&#13;
}&#13;
function flr(val) {&#13;
	if(val &lt; 2147483647 &amp;&amp; val &gt; -2147483648) return ""+(val &gt;= 0 ? (val|0) : (val-1|0));&#13;
	return ""+Math.floor(val);&#13;
}&#13;
function write_num_flt(type, fmt, val) {&#13;
	if(type.charCodeAt(0) === 40 &amp;&amp; !fmt.match(closeparen)) {&#13;
		var ffmt = fmt.replace(/\( */,"").replace(/ \)/,"").replace(/\)/,"");&#13;
		if(val &gt;= 0) return write_num_flt('n', ffmt, val);&#13;
		return '(' + write_num_flt('n', ffmt, -val) + ')';&#13;
	}&#13;
	if(fmt.charCodeAt(fmt.length - 1) === 44) return write_num_cm(type, fmt, val);&#13;
	if(fmt.indexOf('%') !== -1) return write_num_pct(type, fmt, val);&#13;
	if(fmt.indexOf('E') !== -1) return write_num_exp(fmt, val);&#13;
	if(fmt.charCodeAt(0) === 36) return "$"+write_num_flt(type,fmt.substr(fmt.charAt(1)==' '?2:1),val);&#13;
	var o;&#13;
	var r, ri, ff, aval = Math.abs(val), sign = val &lt; 0 ? "-" : "";&#13;
	if(fmt.match(/^00+$/)) return sign + pad0r(aval,fmt.length);&#13;
	if(fmt.match(/^[#?]+$/)) {&#13;
		o = pad0r(val,0); if(o === "0") o = "";&#13;
		return o.length &gt; fmt.length ? o : hashq(fmt.substr(0,fmt.length-o.length)) + o;&#13;
	}&#13;
	if((r = fmt.match(frac1))) return write_num_f1(r, aval, sign);&#13;
	if(fmt.match(/^#+0+$/)) return sign + pad0r(aval,fmt.length - fmt.indexOf("0"));&#13;
	if((r = fmt.match(dec1))) {&#13;
		o = rnd(val, r[1].length).replace(/^([^\.]+)$/,"$1."+hashq(r[1])).replace(/\.$/,"."+hashq(r[1])).replace(/\.(\d*)$/,function($$, $1) { return "." + $1 + fill("0", hashq(r[1]).length-$1.length); });&#13;
		return fmt.indexOf("0.") !== -1 ? o : o.replace(/^0\./,".");&#13;
	}&#13;
	fmt = fmt.replace(/^#+([0.])/, "$1");&#13;
	if((r = fmt.match(/^(0*)\.(#*)$/))) {&#13;
		return sign + rnd(aval, r[2].length).replace(/\.(\d*[1-9])0*$/,".$1").replace(/^(-?\d*)$/,"$1.").replace(/^0\./,r[1].length?"0.":".");&#13;
	}&#13;
	if((r = fmt.match(/^#{1,3},##0(\.?)$/))) return sign + commaify(pad0r(aval,0));&#13;
	if((r = fmt.match(/^#,##0\.([#0]*0)$/))) {&#13;
		return val &lt; 0 ? "-" + write_num_flt(type, fmt, -val) : commaify(""+(Math.floor(val) + carry(val, r[1].length))) + "." + pad0(dec(val, r[1].length),r[1].length);&#13;
	}&#13;
	if((r = fmt.match(/^#,#*,#0/))) return write_num_flt(type,fmt.replace(/^#,#*,/,""),val);&#13;
	if((r = fmt.match(/^([0#]+)(\\?-([0#]+))+$/))) {&#13;
		o = _strrev(write_num_flt(type, fmt.replace(/[\\-]/g,""), val));&#13;
		ri = 0;&#13;
		return _strrev(_strrev(fmt.replace(/\\/g,"")).replace(/[0#]/g,function(x){return ri&lt;o.length?o.charAt(ri++):x==='0'?'0':"";}));&#13;
	}&#13;
	if(fmt.match(phone)) {&#13;
		o = write_num_flt(type, "##########", val);&#13;
		return "(" + o.substr(0,3) + ") " + o.substr(3, 3) + "-" + o.substr(6);&#13;
	}&#13;
	var oa = "";&#13;
	if((r = fmt.match(/^([#0?]+)( ?)\/( ?)([#0?]+)/))) {&#13;
		ri = Math.min(r[4].length,7);&#13;
		ff = SSF_frac(aval, Math.pow(10,ri)-1, false);&#13;
		o = "" + sign;&#13;
		oa = write_num("n", r[1], ff[1]);&#13;
		if(oa.charAt(oa.length-1) == " ") oa = oa.substr(0,oa.length-1) + "0";&#13;
		o += oa + r[2] + "/" + r[3];&#13;
		oa = rpad_(ff[2],ri);&#13;
		if(oa.length &lt; r[4].length) oa = hashq(r[4].substr(r[4].length-oa.length)) + oa;&#13;
		o += oa;&#13;
		return o;&#13;
	}&#13;
	if((r = fmt.match(/^# ([#0?]+)( ?)\/( ?)([#0?]+)/))) {&#13;
		ri = Math.min(Math.max(r[1].length, r[4].length),7);&#13;
		ff = SSF_frac(aval, Math.pow(10,ri)-1, true);&#13;
		return sign + (ff[0]||(ff[1] ? "" : "0")) + " " + (ff[1] ? pad_(ff[1],ri) + r[2] + "/" + r[3] + rpad_(ff[2],ri): fill(" ", 2*ri+1 + r[2].length + r[3].length));&#13;
	}&#13;
	if((r = fmt.match(/^[#0?]+$/))) {&#13;
		o = pad0r(val, 0);&#13;
		if(fmt.length &lt;= o.length) return o;&#13;
		return hashq(fmt.substr(0,fmt.length-o.length)) + o;&#13;
	}&#13;
	if((r = fmt.match(/^([#0?]+)\.([#0]+)$/))) {&#13;
		o = "" + val.toFixed(Math.min(r[2].length,10)).replace(/([^0])0+$/,"$1");&#13;
		ri = o.indexOf(".");&#13;
		var lres = fmt.indexOf(".") - ri, rres = fmt.length - o.length - lres;&#13;
		return hashq(fmt.substr(0,lres) + o + fmt.substr(fmt.length-rres));&#13;
	}&#13;
	if((r = fmt.match(/^00,000\.([#0]*0)$/))) {&#13;
		ri = dec(val, r[1].length);&#13;
		return val &lt; 0 ? "-" + write_num_flt(type, fmt, -val) : commaify(flr(val)).replace(/^\d,\d{3}$/,"0$&amp;").replace(/^\d*$/,function($$) { return "00," + ($$.length &lt; 3 ? pad0(0,3-$$.length) : "") + $$; }) + "." + pad0(ri,r[1].length);&#13;
	}&#13;
	switch(fmt) {&#13;
		case "###,##0.00": return write_num_flt(type, "#,##0.00", val);&#13;
		case "###,###":&#13;
		case "##,###":&#13;
		case "#,###": var x = commaify(pad0r(aval,0)); return x !== "0" ? sign + x : "";&#13;
		case "###,###.00": return write_num_flt(type, "###,##0.00",val).replace(/^0\./,".");&#13;
		case "#,###.00": return write_num_flt(type, "#,##0.00",val).replace(/^0\./,".");&#13;
		default:&#13;
	}&#13;
	throw new Error("unsupported format |" + fmt + "|");&#13;
}&#13;
function write_num_cm2(type, fmt, val){&#13;
	var idx = fmt.length - 1;&#13;
	while(fmt.charCodeAt(idx-1) === 44) --idx;&#13;
	return write_num(type, fmt.substr(0,idx), val / Math.pow(10,3*(fmt.length-idx)));&#13;
}&#13;
function write_num_pct2(type, fmt, val){&#13;
	var sfmt = fmt.replace(pct1,""), mul = fmt.length - sfmt.length;&#13;
	return write_num(type, sfmt, val * Math.pow(10,2*mul)) + fill("%",mul);&#13;
}&#13;
function write_num_exp2(fmt, val){&#13;
	var o;&#13;
	var idx = fmt.indexOf("E") - fmt.indexOf(".") - 1;&#13;
	if(fmt.match(/^#+0.0E\+0$/)) {&#13;
		if(val == 0) return "0.0E+0";&#13;
		else if(val &lt; 0) return "-" + write_num_exp2(fmt, -val);&#13;
		var period = fmt.indexOf("."); if(period === -1) period=fmt.indexOf('E');&#13;
		var ee = Math.floor(Math.log(val)*Math.LOG10E)%period;&#13;
		if(ee &lt; 0) ee += period;&#13;
		o = (val/Math.pow(10,ee)).toPrecision(idx+1+(period+ee)%period);&#13;
		if(!o.match(/[Ee]/)) {&#13;
			var fakee = Math.floor(Math.log(val)*Math.LOG10E);&#13;
			if(o.indexOf(".") === -1) o = o.charAt(0) + "." + o.substr(1) + "E+" + (fakee - o.length+ee);&#13;
			else o += "E+" + (fakee - ee);&#13;
			o = o.replace(/\+-/,"-");&#13;
		}&#13;
		o = o.replace(/^([+-]?)(\d*)\.(\d*)[Ee]/,function($$,$1,$2,$3) { return $1 + $2 + $3.substr(0,(period+ee)%period) + "." + $3.substr(ee) + "E"; });&#13;
	} else o = val.toExponential(idx);&#13;
	if(fmt.match(/E\+00$/) &amp;&amp; o.match(/e[+-]\d$/)) o = o.substr(0,o.length-1) + "0" + o.charAt(o.length-1);&#13;
	if(fmt.match(/E\-/) &amp;&amp; o.match(/e\+/)) o = o.replace(/e\+/,"e");&#13;
	return o.replace("e","E");&#13;
}&#13;
function write_num_int(type, fmt, val) {&#13;
	if(type.charCodeAt(0) === 40 &amp;&amp; !fmt.match(closeparen)) {&#13;
		var ffmt = fmt.replace(/\( */,"").replace(/ \)/,"").replace(/\)/,"");&#13;
		if(val &gt;= 0) return write_num_int('n', ffmt, val);&#13;
		return '(' + write_num_int('n', ffmt, -val) + ')';&#13;
	}&#13;
	if(fmt.charCodeAt(fmt.length - 1) === 44) return write_num_cm2(type, fmt, val);&#13;
	if(fmt.indexOf('%') !== -1) return write_num_pct2(type, fmt, val);&#13;
	if(fmt.indexOf('E') !== -1) return write_num_exp2(fmt, val);&#13;
	if(fmt.charCodeAt(0) === 36) return "$"+write_num_int(type,fmt.substr(fmt.charAt(1)==' '?2:1),val);&#13;
	var o;&#13;
	var r, ri, ff, aval = Math.abs(val), sign = val &lt; 0 ? "-" : "";&#13;
	if(fmt.match(/^00+$/)) return sign + pad0(aval,fmt.length);&#13;
	if(fmt.match(/^[#?]+$/)) {&#13;
		o = (""+val); if(val === 0) o = "";&#13;
		return o.length &gt; fmt.length ? o : hashq(fmt.substr(0,fmt.length-o.length)) + o;&#13;
	}&#13;
	if((r = fmt.match(frac1))) return write_num_f2(r, aval, sign);&#13;
	if(fmt.match(/^#+0+$/)) return sign + pad0(aval,fmt.length - fmt.indexOf("0"));&#13;
	if((r = fmt.match(dec1))) {&#13;
o = (""+val).replace(/^([^\.]+)$/,"$1."+hashq(r[1])).replace(/\.$/,"."+hashq(r[1]));&#13;
		o = o.replace(/\.(\d*)$/,function($$, $1) {&#13;
return "." + $1 + fill("0", hashq(r[1]).length-$1.length); });&#13;
		return fmt.indexOf("0.") !== -1 ? o : o.replace(/^0\./,".");&#13;
	}&#13;
	fmt = fmt.replace(/^#+([0.])/, "$1");&#13;
	if((r = fmt.match(/^(0*)\.(#*)$/))) {&#13;
		return sign + (""+aval).replace(/\.(\d*[1-9])0*$/,".$1").replace(/^(-?\d*)$/,"$1.").replace(/^0\./,r[1].length?"0.":".");&#13;
	}&#13;
	if((r = fmt.match(/^#{1,3},##0(\.?)$/))) return sign + commaify((""+aval));&#13;
	if((r = fmt.match(/^#,##0\.([#0]*0)$/))) {&#13;
		return val &lt; 0 ? "-" + write_num_int(type, fmt, -val) : commaify((""+val)) + "." + fill('0',r[1].length);&#13;
	}&#13;
	if((r = fmt.match(/^#,#*,#0/))) return write_num_int(type,fmt.replace(/^#,#*,/,""),val);&#13;
	if((r = fmt.match(/^([0#]+)(\\?-([0#]+))+$/))) {&#13;
		o = _strrev(write_num_int(type, fmt.replace(/[\\-]/g,""), val));&#13;
		ri = 0;&#13;
		return _strrev(_strrev(fmt.replace(/\\/g,"")).replace(/[0#]/g,function(x){return ri&lt;o.length?o.charAt(ri++):x==='0'?'0':"";}));&#13;
	}&#13;
	if(fmt.match(phone)) {&#13;
		o = write_num_int(type, "##########", val);&#13;
		return "(" + o.substr(0,3) + ") " + o.substr(3, 3) + "-" + o.substr(6);&#13;
	}&#13;
	var oa = "";&#13;
	if((r = fmt.match(/^([#0?]+)( ?)\/( ?)([#0?]+)/))) {&#13;
		ri = Math.min(r[4].length,7);&#13;
		ff = SSF_frac(aval, Math.pow(10,ri)-1, false);&#13;
		o = "" + sign;&#13;
		oa = write_num("n", r[1], ff[1]);&#13;
		if(oa.charAt(oa.length-1) == " ") oa = oa.substr(0,oa.length-1) + "0";&#13;
		o += oa + r[2] + "/" + r[3];&#13;
		oa = rpad_(ff[2],ri);&#13;
		if(oa.length &lt; r[4].length) oa = hashq(r[4].substr(r[4].length-oa.length)) + oa;&#13;
		o += oa;&#13;
		return o;&#13;
	}&#13;
	if((r = fmt.match(/^# ([#0?]+)( ?)\/( ?)([#0?]+)/))) {&#13;
		ri = Math.min(Math.max(r[1].length, r[4].length),7);&#13;
		ff = SSF_frac(aval, Math.pow(10,ri)-1, true);&#13;
		return sign + (ff[0]||(ff[1] ? "" : "0")) + " " + (ff[1] ? pad_(ff[1],ri) + r[2] + "/" + r[3] + rpad_(ff[2],ri): fill(" ", 2*ri+1 + r[2].length + r[3].length));&#13;
	}&#13;
	if((r = fmt.match(/^[#0?]+$/))) {&#13;
		o = "" + val;&#13;
		if(fmt.length &lt;= o.length) return o;&#13;
		return hashq(fmt.substr(0,fmt.length-o.length)) + o;&#13;
	}&#13;
	if((r = fmt.match(/^([#0]+)\.([#0]+)$/))) {&#13;
		o = "" + val.toFixed(Math.min(r[2].length,10)).replace(/([^0])0+$/,"$1");&#13;
		ri = o.indexOf(".");&#13;
		var lres = fmt.indexOf(".") - ri, rres = fmt.length - o.length - lres;&#13;
		return hashq(fmt.substr(0,lres) + o + fmt.substr(fmt.length-rres));&#13;
	}&#13;
	if((r = fmt.match(/^00,000\.([#0]*0)$/))) {&#13;
		return val &lt; 0 ? "-" + write_num_int(type, fmt, -val) : commaify(""+val).replace(/^\d,\d{3}$/,"0$&amp;").replace(/^\d*$/,function($$) { return "00," + ($$.length &lt; 3 ? pad0(0,3-$$.length) : "") + $$; }) + "." + pad0(0,r[1].length);&#13;
	}&#13;
	switch(fmt) {&#13;
		case "###,###":&#13;
		case "##,###":&#13;
		case "#,###": var x = commaify(""+aval); return x !== "0" ? sign + x : "";&#13;
		default:&#13;
			if(fmt.match(/\.[0#?]*$/)) return write_num_int(type, fmt.slice(0,fmt.lastIndexOf(".")), val) + hashq(fmt.slice(fmt.lastIndexOf(".")));&#13;
	}&#13;
	throw new Error("unsupported format |" + fmt + "|");&#13;
}&#13;
function write_num(type, fmt, val) {&#13;
	return (val|0) === val ? write_num_int(type, fmt, val) : write_num_flt(type, fmt, val);&#13;
}&#13;
function SSF_split_fmt(fmt) {&#13;
	var out = [];&#13;
	var in_str = false/*, cc*/;&#13;
	for(var i = 0, j = 0; i &lt; fmt.length; ++i) switch((/*cc=*/fmt.charCodeAt(i))) {&#13;
		case 34: /* '"' */&#13;
			in_str = !in_str; break;&#13;
		case 95: case 42: case 92: /* '_' '*' '\\' */&#13;
			++i; break;&#13;
		case 59: /* ';' */&#13;
			out[out.length] = fmt.substr(j,i-j);&#13;
			j = i+1;&#13;
	}&#13;
	out[out.length] = fmt.substr(j);&#13;
	if(in_str === true) throw new Error("Format |" + fmt + "| unterminated string ");&#13;
	return out;&#13;
}&#13;
&#13;
var SSF_abstime = /\[[HhMmSs\u0E0A\u0E19\u0E17]*\]/;&#13;
function fmt_is_date(fmt) {&#13;
	var i = 0, /*cc = 0,*/ c = "", o = "";&#13;
	while(i &lt; fmt.length) {&#13;
		switch((c = fmt.charAt(i))) {&#13;
			case 'G': if(SSF_isgeneral(fmt, i)) i+= 6; i++; break;&#13;
			case '"': for(;(/*cc=*/fmt.charCodeAt(++i)) !== 34 &amp;&amp; i &lt; fmt.length;){/*empty*/} ++i; break;&#13;
			case '\\': i+=2; break;&#13;
			case '_': i+=2; break;&#13;
			case '@': ++i; break;&#13;
			case 'B': case 'b':&#13;
				if(fmt.charAt(i+1) === "1" || fmt.charAt(i+1) === "2") return true;&#13;
				/* falls through */&#13;
			case 'M': case 'D': case 'Y': case 'H': case 'S': case 'E':&#13;
				/* falls through */&#13;
			case 'm': case 'd': case 'y': case 'h': case 's': case 'e': case 'g': return true;&#13;
			case 'A': case 'a': case '上':&#13;
				if(fmt.substr(i, 3).toUpperCase() === "A/P") return true;&#13;
				if(fmt.substr(i, 5).toUpperCase() === "AM/PM") return true;&#13;
				if(fmt.substr(i, 5).toUpperCase() === "上午/下午") return true;&#13;
				++i; break;&#13;
			case '[':&#13;
				o = c;&#13;
				while(fmt.charAt(i++) !== ']' &amp;&amp; i &lt; fmt.length) o += fmt.charAt(i);&#13;
				if(o.match(SSF_abstime)) return true;&#13;
				break;&#13;
			case '.':&#13;
				/* falls through */&#13;
			case '0': case '#':&#13;
				while(i &lt; fmt.length &amp;&amp; ("0#?.,E+-%".indexOf(c=fmt.charAt(++i)) &gt; -1 || (c=='\\' &amp;&amp; fmt.charAt(i+1) == "-" &amp;&amp; "0#".indexOf(fmt.charAt(i+2))&gt;-1))){/* empty */}&#13;
				break;&#13;
			case '?': while(fmt.charAt(++i) === c){/* empty */} break;&#13;
			case '*': ++i; if(fmt.charAt(i) == ' ' || fmt.charAt(i) == '*') ++i; break;&#13;
			case '(': case ')': ++i; break;&#13;
			case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9':&#13;
				while(i &lt; fmt.length &amp;&amp; "0123456789".indexOf(fmt.charAt(++i)) &gt; -1){/* empty */} break;&#13;
			case ' ': ++i; break;&#13;
			default: ++i; break;&#13;
		}&#13;
	}&#13;
	return false;&#13;
}&#13;
&#13;
function eval_fmt(fmt, v, opts, flen) {&#13;
	var out = [], o = "", i = 0, c = "", lst='t', dt, j, cc;&#13;
	var hr='H';&#13;
	/* Tokenize */&#13;
	while(i &lt; fmt.length) {&#13;
		switch((c = fmt.charAt(i))) {&#13;
			case 'G': /* General */&#13;
				if(!SSF_isgeneral(fmt, i)) throw new Error('unrecognized character ' + c + ' in ' +fmt);&#13;
				out[out.length] = {t:'G', v:'General'}; i+=7; break;&#13;
			case '"': /* Literal text */&#13;
				for(o="";(cc=fmt.charCodeAt(++i)) !== 34 &amp;&amp; i &lt; fmt.length;) o += String.fromCharCode(cc);&#13;
				out[out.length] = {t:'t', v:o}; ++i; break;&#13;
			case '\\': var w = fmt.charAt(++i), t = (w === "(" || w === ")") ? w : 't';&#13;
				out[out.length] = {t:t, v:w}; ++i; break;&#13;
			case '_': out[out.length] = {t:'t', v:" "}; i+=2; break;&#13;
			case '@': /* Text Placeholder */&#13;
				out[out.length] = {t:'T', v:v}; ++i; break;&#13;
			case 'B': case 'b':&#13;
				if(fmt.charAt(i+1) === "1" || fmt.charAt(i+1) === "2") {&#13;
					if(dt==null) { dt=SSF_parse_date_code(v, opts, fmt.charAt(i+1) === "2"); if(dt==null) return ""; }&#13;
					out[out.length] = {t:'X', v:fmt.substr(i,2)}; lst = c; i+=2; break;&#13;
				}&#13;
				/* falls through */&#13;
			case 'M': case 'D': case 'Y': case 'H': case 'S': case 'E':&#13;
				c = c.toLowerCase();&#13;
				/* falls through */&#13;
			case 'm': case 'd': case 'y': case 'h': case 's': case 'e': case 'g':&#13;
				if(v &lt; 0) return "";&#13;
				if(dt==null) { dt=SSF_parse_date_code(v, opts); if(dt==null) return ""; }&#13;
				o = c; while(++i &lt; fmt.length &amp;&amp; fmt.charAt(i).toLowerCase() === c) o+=c;&#13;
				if(c === 'm' &amp;&amp; lst.toLowerCase() === 'h') c = 'M';&#13;
				if(c === 'h') c = hr;&#13;
				out[out.length] = {t:c, v:o}; lst = c; break;&#13;
			case 'A': case 'a': case '上':&#13;
				var q={t:c, v:c};&#13;
				if(dt==null) dt=SSF_parse_date_code(v, opts);&#13;
				if(fmt.substr(i, 3).toUpperCase() === "A/P") { if(dt!=null) q.v = dt.H &gt;= 12 ? fmt.charAt(i+2) : c; q.t = 'T'; hr='h';i+=3;}&#13;
				else if(fmt.substr(i,5).toUpperCase() === "AM/PM") { if(dt!=null) q.v = dt.H &gt;= 12 ? "PM" : "AM"; q.t = 'T'; i+=5; hr='h'; }&#13;
				else if(fmt.substr(i,5).toUpperCase() === "上午/下午") { if(dt!=null) q.v = dt.H &gt;= 12 ? "下午" : "上午"; q.t = 'T'; i+=5; hr='h'; }&#13;
				else { q.t = "t"; ++i; }&#13;
				if(dt==null &amp;&amp; q.t === 'T') return "";&#13;
				out[out.length] = q; lst = c; break;&#13;
			case '[':&#13;
				o = c;&#13;
				while(fmt.charAt(i++) !== ']' &amp;&amp; i &lt; fmt.length) o += fmt.charAt(i);&#13;
				if(o.slice(-1) !== ']') throw 'unterminated "[" block: |' + o + '|';&#13;
				if(o.match(SSF_abstime)) {&#13;
					if(dt==null) { dt=SSF_parse_date_code(v, opts); if(dt==null) return ""; }&#13;
					out[out.length] = {t:'Z', v:o.toLowerCase()};&#13;
					lst = o.charAt(1);&#13;
				} else if(o.indexOf("$") &gt; -1) {&#13;
					o = (o.match(/\$([^-\[\]]*)/)||[])[1]||"$";&#13;
					if(!fmt_is_date(fmt)) out[out.length] = {t:'t',v:o};&#13;
				}&#13;
				break;&#13;
			/* Numbers */&#13;
			case '.':&#13;
				if(dt != null) {&#13;
					o = c; while(++i &lt; fmt.length &amp;&amp; (c=fmt.charAt(i)) === "0") o += c;&#13;
					out[out.length] = {t:'s', v:o}; break;&#13;
				}&#13;
				/* falls through */&#13;
			case '0': case '#':&#13;
				o = c; while(++i &lt; fmt.length &amp;&amp; "0#?.,E+-%".indexOf(c=fmt.charAt(i)) &gt; -1) o += c;&#13;
				out[out.length] = {t:'n', v:o}; break;&#13;
			case '?':&#13;
				o = c; while(fmt.charAt(++i) === c) o+=c;&#13;
				out[out.length] = {t:c, v:o}; lst = c; break;&#13;
			case '*': ++i; if(fmt.charAt(i) == ' ' || fmt.charAt(i) == '*') ++i; break; // **&#13;
			case '(': case ')': out[out.length] = {t:(flen===1?'t':c), v:c}; ++i; break;&#13;
			case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9':&#13;
				o = c; while(i &lt; fmt.length &amp;&amp; "0123456789".indexOf(fmt.charAt(++i)) &gt; -1) o+=fmt.charAt(i);&#13;
				out[out.length] = {t:'D', v:o}; break;&#13;
			case ' ': out[out.length] = {t:c, v:c}; ++i; break;&#13;
			case '$': out[out.length] = {t:'t', v:'$'}; ++i; break;&#13;
			default:&#13;
				if(",$-+/():!^&amp;'~{}&lt;&gt;=€acfijklopqrtuvwxzP".indexOf(c) === -1) throw new Error('unrecognized character ' + c + ' in ' + fmt);&#13;
				out[out.length] = {t:'t', v:c}; ++i; break;&#13;
		}&#13;
	}&#13;
&#13;
	/* Scan for date/time parts */&#13;
	var bt = 0, ss0 = 0, ssm;&#13;
	for(i=out.length-1, lst='t'; i &gt;= 0; --i) {&#13;
		switch(out[i].t) {&#13;
			case 'h': case 'H': out[i].t = hr; lst='h'; if(bt &lt; 1) bt = 1; break;&#13;
			case 's':&#13;
				if((ssm=out[i].v.match(/\.0+$/))) ss0=Math.max(ss0,ssm[0].length-1);&#13;
				if(bt &lt; 3) bt = 3;&#13;
			/* falls through */&#13;
			case 'd': case 'y': case 'M': case 'e': lst=out[i].t; break;&#13;
			case 'm': if(lst === 's') { out[i].t = 'M'; if(bt &lt; 2) bt = 2; } break;&#13;
			case 'X': /*if(out[i].v === "B2");*/&#13;
				break;&#13;
			case 'Z':&#13;
				if(bt &lt; 1 &amp;&amp; out[i].v.match(/[Hh]/)) bt = 1;&#13;
				if(bt &lt; 2 &amp;&amp; out[i].v.match(/[Mm]/)) bt = 2;&#13;
				if(bt &lt; 3 &amp;&amp; out[i].v.match(/[Ss]/)) bt = 3;&#13;
		}&#13;
	}&#13;
	/* time rounding depends on presence of minute / second / usec fields */&#13;
	switch(bt) {&#13;
		case 0: break;&#13;
		case 1:&#13;
if(dt.u &gt;= 0.5) { dt.u = 0; ++dt.S; }&#13;
			if(dt.S &gt;=  60) { dt.S = 0; ++dt.M; }&#13;
			if(dt.M &gt;=  60) { dt.M = 0; ++dt.H; }&#13;
			break;&#13;
		case 2:&#13;
if(dt.u &gt;= 0.5) { dt.u = 0; ++dt.S; }&#13;
			if(dt.S &gt;=  60) { dt.S = 0; ++dt.M; }&#13;
			break;&#13;
	}&#13;
&#13;
	/* replace fields */&#13;
	var nstr = "", jj;&#13;
	for(i=0; i &lt; out.length; ++i) {&#13;
		switch(out[i].t) {&#13;
			case 't': case 'T': case ' ': case 'D': break;&#13;
			case 'X': out[i].v = ""; out[i].t = ";"; break;&#13;
			case 'd': case 'm': case 'y': case 'h': case 'H': case 'M': case 's': case 'e': case 'b': case 'Z':&#13;
out[i].v = SSF_write_date(out[i].t.charCodeAt(0), out[i].v, dt, ss0);&#13;
				out[i].t = 't'; break;&#13;
			case 'n': case '?':&#13;
				jj = i+1;&#13;
				while(out[jj] != null &amp;&amp; (&#13;
					(c=out[jj].t) === "?" || c === "D" ||&#13;
					((c === " " || c === "t") &amp;&amp; out[jj+1] != null &amp;&amp; (out[jj+1].t === '?' || out[jj+1].t === "t" &amp;&amp; out[jj+1].v === '/')) ||&#13;
					(out[i].t === '(' &amp;&amp; (c === ' ' || c === 'n' || c === ')')) ||&#13;
					(c === 't' &amp;&amp; (out[jj].v === '/' || out[jj].v === ' ' &amp;&amp; out[jj+1] != null &amp;&amp; out[jj+1].t == '?'))&#13;
				)) {&#13;
					out[i].v += out[jj].v;&#13;
					out[jj] = {v:"", t:";"}; ++jj;&#13;
				}&#13;
				nstr += out[i].v;&#13;
				i = jj-1; break;&#13;
			case 'G': out[i].t = 't'; out[i].v = SSF_general(v,opts); break;&#13;
		}&#13;
	}&#13;
	var vv = "", myv, ostr;&#13;
	if(nstr.length &gt; 0) {&#13;
		if(nstr.charCodeAt(0) == 40) /* '(' */ {&#13;
			myv = (v&lt;0&amp;&amp;nstr.charCodeAt(0) === 45 ? -v : v);&#13;
			ostr = write_num('n', nstr, myv);&#13;
		} else {&#13;
			myv = (v&lt;0 &amp;&amp; flen &gt; 1 ? -v : v);&#13;
			ostr = write_num('n', nstr, myv);&#13;
			if(myv &lt; 0 &amp;&amp; out[0] &amp;&amp; out[0].t == 't') {&#13;
				ostr = ostr.substr(1);&#13;
				out[0].v = "-" + out[0].v;&#13;
			}&#13;
		}&#13;
		jj=ostr.length-1;&#13;
		var decpt = out.length;&#13;
		for(i=0; i &lt; out.length; ++i) if(out[i] != null &amp;&amp; out[i].t != 't' &amp;&amp; out[i].v.indexOf(".") &gt; -1) { decpt = i; break; }&#13;
		var lasti=out.length;&#13;
		if(decpt === out.length &amp;&amp; ostr.indexOf("E") === -1) {&#13;
			for(i=out.length-1; i&gt;= 0;--i) {&#13;
				if(out[i] == null || 'n?'.indexOf(out[i].t) === -1) continue;&#13;
				if(jj&gt;=out[i].v.length-1) { jj -= out[i].v.length; out[i].v = ostr.substr(jj+1, out[i].v.length); }&#13;
				else if(jj &lt; 0) out[i].v = "";&#13;
				else { out[i].v = ostr.substr(0, jj+1); jj = -1; }&#13;
				out[i].t = 't';&#13;
				lasti = i;&#13;
			}&#13;
			if(jj&gt;=0 &amp;&amp; lasti&lt;out.length) out[lasti].v = ostr.substr(0,jj+1) + out[lasti].v;&#13;
		}&#13;
		else if(decpt !== out.length &amp;&amp; ostr.indexOf("E") === -1) {&#13;
			jj = ostr.indexOf(".")-1;&#13;
			for(i=decpt; i&gt;= 0; --i) {&#13;
				if(out[i] == null || 'n?'.indexOf(out[i].t) === -1) continue;&#13;
				j=out[i].v.indexOf(".")&gt;-1&amp;&amp;i===decpt?out[i].v.indexOf(".")-1:out[i].v.length-1;&#13;
				vv = out[i].v.substr(j+1);&#13;
				for(; j&gt;=0; --j) {&#13;
					if(jj&gt;=0 &amp;&amp; (out[i].v.charAt(j) === "0" || out[i].v.charAt(j) === "#")) vv = ostr.charAt(jj--) + vv;&#13;
				}&#13;
				out[i].v = vv;&#13;
				out[i].t = 't';&#13;
				lasti = i;&#13;
			}&#13;
			if(jj&gt;=0 &amp;&amp; lasti&lt;out.length) out[lasti].v = ostr.substr(0,jj+1) + out[lasti].v;&#13;
			jj = ostr.indexOf(".")+1;&#13;
			for(i=decpt; i&lt;out.length; ++i) {&#13;
				if(out[i] == null || ('n?('.indexOf(out[i].t) === -1 &amp;&amp; i !== decpt)) continue;&#13;
				j=out[i].v.indexOf(".")&gt;-1&amp;&amp;i===decpt?out[i].v.indexOf(".")+1:0;&#13;
				vv = out[i].v.substr(0,j);&#13;
				for(; j&lt;out[i].v.length; ++j) {&#13;
					if(jj&lt;ostr.length) vv += ostr.charAt(jj++);&#13;
				}&#13;
				out[i].v = vv;&#13;
				out[i].t = 't';&#13;
				lasti = i;&#13;
			}&#13;
		}&#13;
	}&#13;
	for(i=0; i&lt;out.length; ++i) if(out[i] != null &amp;&amp; 'n?'.indexOf(out[i].t)&gt;-1) {&#13;
		myv = (flen &gt;1 &amp;&amp; v &lt; 0 &amp;&amp; i&gt;0 &amp;&amp; out[i-1].v === "-" ? -v:v);&#13;
		out[i].v = write_num(out[i].t, out[i].v, myv);&#13;
		out[i].t = 't';&#13;
	}&#13;
	var retval = "";&#13;
	for(i=0; i !== out.length; ++i) if(out[i] != null) retval += out[i].v;&#13;
	return retval;&#13;
}&#13;
&#13;
var cfregex2 = /\[(=|&gt;[=]?|&lt;[&gt;=]?)(-?\d+(?:\.\d*)?)\]/;&#13;
function chkcond(v, rr) {&#13;
	if(rr == null) return false;&#13;
	var thresh = parseFloat(rr[2]);&#13;
	switch(rr[1]) {&#13;
		case "=":  if(v == thresh) return true; break;&#13;
		case "&gt;":  if(v &gt;  thresh) return true; break;&#13;
		case "&lt;":  if(v &lt;  thresh) return true; break;&#13;
		case "&lt;&gt;": if(v != thresh) return true; break;&#13;
		case "&gt;=": if(v &gt;= thresh) return true; break;&#13;
		case "&lt;=": if(v &lt;= thresh) return true; break;&#13;
	}&#13;
	return false;&#13;
}&#13;
function choose_fmt(f, v) {&#13;
	var fmt = SSF_split_fmt(f);&#13;
	var l = fmt.length, lat = fmt[l-1].indexOf("@");&#13;
	if(l&lt;4 &amp;&amp; lat&gt;-1) --l;&#13;
	if(fmt.length &gt; 4) throw new Error("cannot find right format for |" + fmt.join("|") + "|");&#13;
	if(typeof v !== "number") return [4, fmt.length === 4 || lat&gt;-1?fmt[fmt.length-1]:"@"];&#13;
	switch(fmt.length) {&#13;
		case 1: fmt = lat&gt;-1 ? ["General", "General", "General", fmt[0]] : [fmt[0], fmt[0], fmt[0], "@"]; break;&#13;
		case 2: fmt = lat&gt;-1 ? [fmt[0], fmt[0], fmt[0], fmt[1]] : [fmt[0], fmt[1], fmt[0], "@"]; break;&#13;
		case 3: fmt = lat&gt;-1 ? [fmt[0], fmt[1], fmt[0], fmt[2]] : [fmt[0], fmt[1], fmt[2], "@"]; break;&#13;
		case 4: break;&#13;
	}&#13;
	var ff = v &gt; 0 ? fmt[0] : v &lt; 0 ? fmt[1] : fmt[2];&#13;
	if(fmt[0].indexOf("[") === -1 &amp;&amp; fmt[1].indexOf("[") === -1) return [l, ff];&#13;
	if(fmt[0].match(/\[[=&lt;&gt;]/) != null || fmt[1].match(/\[[=&lt;&gt;]/) != null) {&#13;
		var m1 = fmt[0].match(cfregex2);&#13;
		var m2 = fmt[1].match(cfregex2);&#13;
		return chkcond(v, m1) ? [l, fmt[0]] : chkcond(v, m2) ? [l, fmt[1]] : [l, fmt[m1 != null &amp;&amp; m2 != null ? 2 : 1]];&#13;
	}&#13;
	return [l, ff];&#13;
}&#13;
function SSF_format(fmt,v,o) {&#13;
	if(o == null) o = {};&#13;
	var sfmt = "";&#13;
	switch(typeof fmt) {&#13;
		case "string":&#13;
			if(fmt == "m/d/yy" &amp;&amp; o.dateNF) sfmt = o.dateNF;&#13;
			else sfmt = fmt;&#13;
			break;&#13;
		case "number":&#13;
			if(fmt == 14 &amp;&amp; o.dateNF) sfmt = o.dateNF;&#13;
			else sfmt = (o.table != null ? (o.table) : table_fmt)[fmt];&#13;
			if(sfmt == null) sfmt = (o.table &amp;&amp; o.table[SSF_default_map[fmt]]) || table_fmt[SSF_default_map[fmt]];&#13;
			if(sfmt == null) sfmt = SSF_default_str[fmt] || "General";&#13;
			break;&#13;
	}&#13;
	if(SSF_isgeneral(sfmt,0)) return SSF_general(v, o);&#13;
	if(v instanceof Date) v = datenum_local(v, o.date1904);&#13;
	var f = choose_fmt(sfmt, v);&#13;
	if(SSF_isgeneral(f[1])) return SSF_general(v, o);&#13;
	if(v === true) v = "TRUE"; else if(v === false) v = "FALSE";&#13;
	else if(v === "" || v == null) return "";&#13;
	return eval_fmt(f[1], v, o, f[0]);&#13;
}&#13;
function SSF_load(fmt, idx) {&#13;
	if(typeof idx != 'number') {&#13;
		idx = +idx || -1;&#13;
for(var i = 0; i &lt; 0x0188; ++i) {&#13;
if(table_fmt[i] == undefined) { if(idx &lt; 0) idx = i; continue; }&#13;
			if(table_fmt[i] == fmt) { idx = i; break; }&#13;
		}&#13;
if(idx &lt; 0) idx = 0x187;&#13;
	}&#13;
table_fmt[idx] = fmt;&#13;
	return idx;&#13;
}&#13;
function SSF_load_table(tbl) {&#13;
	for(var i=0; i!=0x0188; ++i)&#13;
		if(tbl[i] !== undefined) SSF_load(tbl[i], i);&#13;
}&#13;
&#13;
function make_ssf() {&#13;
	table_fmt = SSF_init_table();&#13;
}&#13;
&#13;
var SSF = {&#13;
	format: SSF_format,&#13;
	load: SSF_load,&#13;
	_table: table_fmt,&#13;
	load_table: SSF_load_table,&#13;
	parse_date_code: SSF_parse_date_code,&#13;
	is_date: fmt_is_date,&#13;
	get_table: function get_table() { return SSF._table = table_fmt; }&#13;
};&#13;
&#13;
var SSFImplicit/*{[number]:string}*/ = ({&#13;
	"5": '"$"#,##0_);\\("$"#,##0\\)',&#13;
	"6": '"$"#,##0_);[Red]\\("$"#,##0\\)',&#13;
	"7": '"$"#,##0.00_);\\("$"#,##0.00\\)',&#13;
	"8": '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',&#13;
	"23": 'General', "24": 'General', "25": 'General', "26": 'General',&#13;
	"27": 'm/d/yy', "28": 'm/d/yy', "29": 'm/d/yy', "30": 'm/d/yy', "31": 'm/d/yy',&#13;
	"32": 'h:mm:ss', "33": 'h:mm:ss', "34": 'h:mm:ss', "35": 'h:mm:ss',&#13;
	"36": 'm/d/yy',&#13;
	"41": '_(* #,##0_);_(* \(#,##0\);_(* "-"_);_(@_)',&#13;
	"42": '_("$"* #,##0_);_("$"* \(#,##0\);_("$"* "-"_);_(@_)',&#13;
	"43": '_(* #,##0.00_);_(* \(#,##0.00\);_(* "-"??_);_(@_)',&#13;
	"44": '_("$"* #,##0.00_);_("$"* \(#,##0.00\);_("$"* "-"??_);_(@_)',&#13;
	"50": 'm/d/yy', "51": 'm/d/yy', "52": 'm/d/yy', "53": 'm/d/yy', "54": 'm/d/yy',&#13;
	"55": 'm/d/yy', "56": 'm/d/yy', "57": 'm/d/yy', "58": 'm/d/yy',&#13;
	"59": '0',&#13;
	"60": '0.00',&#13;
	"61": '#,##0',&#13;
	"62": '#,##0.00',&#13;
	"63": '"$"#,##0_);\\("$"#,##0\\)',&#13;
	"64": '"$"#,##0_);[Red]\\("$"#,##0\\)',&#13;
	"65": '"$"#,##0.00_);\\("$"#,##0.00\\)',&#13;
	"66": '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',&#13;
	"67": '0%',&#13;
	"68": '0.00%',&#13;
	"69": '# ?/?',&#13;
	"70": '# ??/??',&#13;
	"71": 'm/d/yy',&#13;
	"72": 'm/d/yy',&#13;
	"73": 'd-mmm-yy',&#13;
	"74": 'd-mmm',&#13;
	"75": 'mmm-yy',&#13;
	"76": 'h:mm',&#13;
	"77": 'h:mm:ss',&#13;
	"78": 'm/d/yy h:mm',&#13;
	"79": 'mm:ss',&#13;
	"80": '[h]:mm:ss',&#13;
	"81": 'mmss.0'&#13;
});&#13;
&#13;
/* dateNF parse TODO: move to SSF */&#13;
var dateNFregex = /[dD]+|[mM]+|[yYeE]+|[Hh]+|[Ss]+/g;&#13;
function dateNF_regex(dateNF) {&#13;
	var fmt = typeof dateNF == "number" ? table_fmt[dateNF] : dateNF;&#13;
	fmt = fmt.replace(dateNFregex, "(\\d+)");&#13;
	return new RegExp("^" + fmt + "$");&#13;
}&#13;
function dateNF_fix(str, dateNF, match) {&#13;
	var Y = -1, m = -1, d = -1, H = -1, M = -1, S = -1;&#13;
	(dateNF.match(dateNFregex)||[]).forEach(function(n, i) {&#13;
		var v = parseInt(match[i+1], 10);&#13;
		switch(n.toLowerCase().charAt(0)) {&#13;
			case 'y': Y = v; break; case 'd': d = v; break;&#13;
			case 'h': H = v; break; case 's': S = v; break;&#13;
			case 'm': if(H &gt;= 0) M = v; else m = v; break;&#13;
		}&#13;
	});&#13;
	if(S &gt;= 0 &amp;&amp; M == -1 &amp;&amp; m &gt;= 0) { M = m; m = -1; }&#13;
	var datestr = (("" + (Y&gt;=0?Y: new Date().getFullYear())).slice(-4) + "-" + ("00" + (m&gt;=1?m:1)).slice(-2) + "-" + ("00" + (d&gt;=1?d:1)).slice(-2));&#13;
	if(datestr.length == 7) datestr = "0" + datestr;&#13;
	if(datestr.length == 8) datestr = "20" + datestr;&#13;
	var timestr = (("00" + (H&gt;=0?H:0)).slice(-2) + ":" + ("00" + (M&gt;=0?M:0)).slice(-2) + ":" + ("00" + (S&gt;=0?S:0)).slice(-2));&#13;
	if(H == -1 &amp;&amp; M == -1 &amp;&amp; S == -1) return datestr;&#13;
	if(Y == -1 &amp;&amp; m == -1 &amp;&amp; d == -1) return timestr;&#13;
	return datestr + "T" + timestr;&#13;
}&#13;
&#13;
/* table of bad formats written by third-party tools */&#13;
var bad_formats = {&#13;
	"d.m": "d\\.m" // Issue #2571 Google Sheets writes invalid format 'd.m', correct format is 'd"."m' or 'd\\.m'&#13;
};&#13;
&#13;
function SSF__load(fmt, idx) {&#13;
	return SSF_load(bad_formats[fmt] || fmt, idx);&#13;
}&#13;
&#13;
/* cfb.js (C) 2013-present xlsx -- http://sheetjs.com */&#13;
/* vim: set ts=2: */&#13;
/*jshint eqnull:true */&#13;
/*exported CFB */&#13;
/*global Uint8Array:false, Uint16Array:false */&#13;
&#13;
/* crc32.js (C) 2014-present xlsx -- http://sheetjs.com */&#13;
/* vim: set ts=2: */&#13;
/*exported CRC32 */&#13;
var CRC32 = (function() {&#13;
var CRC32 = {};&#13;
CRC32.version = '1.2.0';&#13;
/* see perf/crc32table.js */&#13;
/*global Int32Array */&#13;
function signed_crc_table() {&#13;
	var c = 0, table = new Array(256);&#13;
&#13;
	for(var n =0; n != 256; ++n){&#13;
		c = n;&#13;
		c = ((c&amp;1) ? (-306674912 ^ (c &gt;&gt;&gt; 1)) : (c &gt;&gt;&gt; 1));&#13;
		c = ((c&amp;1) ? (-306674912 ^ (c &gt;&gt;&gt; 1)) : (c &gt;&gt;&gt; 1));&#13;
		c = ((c&amp;1) ? (-306674912 ^ (c &gt;&gt;&gt; 1)) : (c &gt;&gt;&gt; 1));&#13;
		c = ((c&amp;1) ? (-306674912 ^ (c &gt;&gt;&gt; 1)) : (c &gt;&gt;&gt; 1));&#13;
		c = ((c&amp;1) ? (-306674912 ^ (c &gt;&gt;&gt; 1)) : (c &gt;&gt;&gt; 1));&#13;
		c = ((c&amp;1) ? (-306674912 ^ (c &gt;&gt;&gt; 1)) : (c &gt;&gt;&gt; 1));&#13;
		c = ((c&amp;1) ? (-306674912 ^ (c &gt;&gt;&gt; 1)) : (c &gt;&gt;&gt; 1));&#13;
		c = ((c&amp;1) ? (-306674912 ^ (c &gt;&gt;&gt; 1)) : (c &gt;&gt;&gt; 1));&#13;
		table[n] = c;&#13;
	}&#13;
&#13;
	return typeof Int32Array !== 'undefined' ? new Int32Array(table) : table;&#13;
}&#13;
&#13;
var T0 = signed_crc_table();&#13;
function slice_by_16_tables(T) {&#13;
	var c = 0, v = 0, n = 0, table = typeof Int32Array !== 'undefined' ? new Int32Array(4096) : new Array(4096) ;&#13;
&#13;
	for(n = 0; n != 256; ++n) table[n] = T[n];&#13;
	for(n = 0; n != 256; ++n) {&#13;
		v = T[n];&#13;
		for(c = 256 + n; c &lt; 4096; c += 256) v = table[c] = (v &gt;&gt;&gt; 8) ^ T[v &amp; 0xFF];&#13;
	}&#13;
	var out = [];&#13;
	for(n = 1; n != 16; ++n) out[n - 1] = typeof Int32Array !== 'undefined' ? table.subarray(n * 256, n * 256 + 256) : table.slice(n * 256, n * 256 + 256);&#13;
	return out;&#13;
}&#13;
var TT = slice_by_16_tables(T0);&#13;
var T1 = TT[0],  T2 = TT[1],  T3 = TT[2],  T4 = TT[3],  T5 = TT[4];&#13;
var T6 = TT[5],  T7 = TT[6],  T8 = TT[7],  T9 = TT[8],  Ta = TT[9];&#13;
var Tb = TT[10], Tc = TT[11], Td = TT[12], Te = TT[13], Tf = TT[14];&#13;
function crc32_bstr(bstr, seed) {&#13;
	var C = seed ^ -1;&#13;
	for(var i = 0, L = bstr.length; i &lt; L;) C = (C&gt;&gt;&gt;8) ^ T0[(C^bstr.charCodeAt(i++))&amp;0xFF];&#13;
	return ~C;&#13;
}&#13;
&#13;
function crc32_buf(B, seed) {&#13;
	var C = seed ^ -1, L = B.length - 15, i = 0;&#13;
	for(; i &lt; L;) C =&#13;
		Tf[B[i++] ^ (C &amp; 255)] ^&#13;
		Te[B[i++] ^ ((C &gt;&gt; 8) &amp; 255)] ^&#13;
		Td[B[i++] ^ ((C &gt;&gt; 16) &amp; 255)] ^&#13;
		Tc[B[i++] ^ (C &gt;&gt;&gt; 24)] ^&#13;
		Tb[B[i++]] ^ Ta[B[i++]] ^ T9[B[i++]] ^ T8[B[i++]] ^&#13;
		T7[B[i++]] ^ T6[B[i++]] ^ T5[B[i++]] ^ T4[B[i++]] ^&#13;
		T3[B[i++]] ^ T2[B[i++]] ^ T1[B[i++]] ^ T0[B[i++]];&#13;
	L += 15;&#13;
	while(i &lt; L) C = (C&gt;&gt;&gt;8) ^ T0[(C^B[i++])&amp;0xFF];&#13;
	return ~C;&#13;
}&#13;
&#13;
function crc32_str(str, seed) {&#13;
	var C = seed ^ -1;&#13;
	for(var i = 0, L = str.length, c = 0, d = 0; i &lt; L;) {&#13;
		c = str.charCodeAt(i++);&#13;
		if(c &lt; 0x80) {&#13;
			C = (C&gt;&gt;&gt;8) ^ T0[(C^c)&amp;0xFF];&#13;
		} else if(c &lt; 0x800) {&#13;
			C = (C&gt;&gt;&gt;8) ^ T0[(C ^ (192|((c&gt;&gt;6)&amp;31)))&amp;0xFF];&#13;
			C = (C&gt;&gt;&gt;8) ^ T0[(C ^ (128|(c&amp;63)))&amp;0xFF];&#13;
		} else if(c &gt;= 0xD800 &amp;&amp; c &lt; 0xE000) {&#13;
			c = (c&amp;1023)+64; d = str.charCodeAt(i++)&amp;1023;&#13;
			C = (C&gt;&gt;&gt;8) ^ T0[(C ^ (240|((c&gt;&gt;8)&amp;7)))&amp;0xFF];&#13;
			C = (C&gt;&gt;&gt;8) ^ T0[(C ^ (128|((c&gt;&gt;2)&amp;63)))&amp;0xFF];&#13;
			C = (C&gt;&gt;&gt;8) ^ T0[(C ^ (128|((d&gt;&gt;6)&amp;15)|((c&amp;3)&lt;&lt;4)))&amp;0xFF];&#13;
			C = (C&gt;&gt;&gt;8) ^ T0[(C ^ (128|(d&amp;63)))&amp;0xFF];&#13;
		} else {&#13;
			C = (C&gt;&gt;&gt;8) ^ T0[(C ^ (224|((c&gt;&gt;12)&amp;15)))&amp;0xFF];&#13;
			C = (C&gt;&gt;&gt;8) ^ T0[(C ^ (128|((c&gt;&gt;6)&amp;63)))&amp;0xFF];&#13;
			C = (C&gt;&gt;&gt;8) ^ T0[(C ^ (128|(c&amp;63)))&amp;0xFF];&#13;
		}&#13;
	}&#13;
	return ~C;&#13;
}&#13;
CRC32.table = T0;&#13;
CRC32.bstr = crc32_bstr;&#13;
CRC32.buf = crc32_buf;&#13;
CRC32.str = crc32_str;&#13;
return CRC32;&#13;
})();&#13;
/* [MS-CFB] v20171201 */&#13;
var CFB = (function _CFB(){&#13;
var exports = {};&#13;
exports.version = '1.2.2';&#13;
/* [MS-CFB] 2.6.4 */&#13;
function namecmp(l, r) {&#13;
	var L = l.split("/"), R = r.split("/");&#13;
	for(var i = 0, c = 0, Z = Math.min(L.length, R.length); i &lt; Z; ++i) {&#13;
		if((c = L[i].length - R[i].length)) return c;&#13;
		if(L[i] != R[i]) return L[i] &lt; R[i] ? -1 : 1;&#13;
	}&#13;
	return L.length - R.length;&#13;
}&#13;
function dirname(p) {&#13;
	if(p.charAt(p.length - 1) == "/") return (p.slice(0,-1).indexOf("/") === -1) ? p : dirname(p.slice(0, -1));&#13;
	var c = p.lastIndexOf("/");&#13;
	return (c === -1) ? p : p.slice(0, c+1);&#13;
}&#13;
&#13;
function filename(p) {&#13;
	if(p.charAt(p.length - 1) == "/") return filename(p.slice(0, -1));&#13;
	var c = p.lastIndexOf("/");&#13;
	return (c === -1) ? p : p.slice(c+1);&#13;
}&#13;
/* -------------------------------------------------------------------------- */&#13;
/* DOS Date format:&#13;
   high|YYYYYYYm.mmmddddd.HHHHHMMM.MMMSSSSS|low&#13;
   add 1980 to stored year&#13;
   stored second should be doubled&#13;
*/&#13;
&#13;
/* write JS date to buf as a DOS date */&#13;
function write_dos_date(buf, date) {&#13;
	if(typeof date === "string") date = new Date(date);&#13;
	var hms = date.getHours();&#13;
	hms = hms &lt;&lt; 6 | date.getMinutes();&#13;
	hms = hms &lt;&lt; 5 | (date.getSeconds()&gt;&gt;&gt;1);&#13;
	buf.write_shift(2, hms);&#13;
	var ymd = (date.getFullYear() - 1980);&#13;
	ymd = ymd &lt;&lt; 4 | (date.getMonth()+1);&#13;
	ymd = ymd &lt;&lt; 5 | date.getDate();&#13;
	buf.write_shift(2, ymd);&#13;
}&#13;
&#13;
/* read four bytes from buf and interpret as a DOS date */&#13;
function parse_dos_date(buf) {&#13;
	var hms = buf.read_shift(2) &amp; 0xFFFF;&#13;
	var ymd = buf.read_shift(2) &amp; 0xFFFF;&#13;
	var val = new Date();&#13;
	var d = ymd &amp; 0x1F; ymd &gt;&gt;&gt;= 5;&#13;
	var m = ymd &amp; 0x0F; ymd &gt;&gt;&gt;= 4;&#13;
	val.setMilliseconds(0);&#13;
	val.setFullYear(ymd + 1980);&#13;
	val.setMonth(m-1);&#13;
	val.setDate(d);&#13;
	var S = hms &amp; 0x1F; hms &gt;&gt;&gt;= 5;&#13;
	var M = hms &amp; 0x3F; hms &gt;&gt;&gt;= 6;&#13;
	val.setHours(hms);&#13;
	val.setMinutes(M);&#13;
	val.setSeconds(S&lt;&lt;1);&#13;
	return val;&#13;
}&#13;
function parse_extra_field(blob) {&#13;
	prep_blob(blob, 0);&#13;
	var o = {};&#13;
	var flags = 0;&#13;
	while(blob.l &lt;= blob.length - 4) {&#13;
		var type = blob.read_shift(2);&#13;
		var sz = blob.read_shift(2), tgt = blob.l + sz;&#13;
		var p = {};&#13;
		switch(type) {&#13;
			/* UNIX-style Timestamps */&#13;
			case 0x5455: {&#13;
				flags = blob.read_shift(1);&#13;
				if(flags &amp; 1) p.mtime = blob.read_shift(4);&#13;
				/* for some reason, CD flag corresponds to LFH */&#13;
				if(sz &gt; 5) {&#13;
					if(flags &amp; 2) p.atime = blob.read_shift(4);&#13;
					if(flags &amp; 4) p.ctime = blob.read_shift(4);&#13;
				}&#13;
				if(p.mtime) p.mt = new Date(p.mtime*1000);&#13;
			} break;&#13;
			/* ZIP64 Extended Information Field */&#13;
			case 0x0001: {&#13;
				var sz1 = blob.read_shift(4), sz2 = blob.read_shift(4);&#13;
				p.usz = (sz2 * Math.pow(2,32) + sz1);&#13;
				sz1 = blob.read_shift(4); sz2 = blob.read_shift(4);&#13;
				p.csz = (sz2 * Math.pow(2,32) + sz1);&#13;
				// NOTE: volume fields are skipped&#13;
			} break;&#13;
		}&#13;
		blob.l = tgt;&#13;
		o[type] = p;&#13;
	}&#13;
	return o;&#13;
}&#13;
var fs;&#13;
function get_fs() { return fs || (fs = _fs); }&#13;
function parse(file, options) {&#13;
if(file[0] == 0x50 &amp;&amp; file[1] == 0x4b) return parse_zip(file, options);&#13;
if((file[0] | 0x20) == 0x6d &amp;&amp; (file[1]|0x20) == 0x69) return parse_mad(file, options);&#13;
if(file.length &lt; 512) throw new Error("CFB file size " + file.length + " &lt; 512");&#13;
var mver = 3;&#13;
var ssz = 512;&#13;
var nmfs = 0; // number of mini FAT sectors&#13;
var difat_sec_cnt = 0;&#13;
var dir_start = 0;&#13;
var minifat_start = 0;&#13;
var difat_start = 0;&#13;
&#13;
var fat_addrs = []; // locations of FAT sectors&#13;
&#13;
/* [MS-CFB] 2.2 Compound File Header */&#13;
var blob = file.slice(0,512);&#13;
prep_blob(blob, 0);&#13;
&#13;
/* major version */&#13;
var mv = check_get_mver(blob);&#13;
mver = mv[0];&#13;
switch(mver) {&#13;
	case 3: ssz = 512; break; case 4: ssz = 4096; break;&#13;
	case 0: if(mv[1] == 0) return parse_zip(file, options);&#13;
	/* falls through */&#13;
	default: throw new Error("Major Version: Expected 3 or 4 saw " + mver);&#13;
}&#13;
&#13;
/* reprocess header */&#13;
if(ssz !== 512) { blob = file.slice(0,ssz); prep_blob(blob, 28 /* blob.l */); }&#13;
/* Save header for final object */&#13;
var header = file.slice(0,ssz);&#13;
&#13;
check_shifts(blob, mver);&#13;
&#13;
// Number of Directory Sectors&#13;
var dir_cnt = blob.read_shift(4, 'i');&#13;
if(mver === 3 &amp;&amp; dir_cnt !== 0) throw new Error('# Directory Sectors: Expected 0 saw ' + dir_cnt);&#13;
&#13;
// Number of FAT Sectors&#13;
blob.l += 4;&#13;
&#13;
// First Directory Sector Location&#13;
dir_start = blob.read_shift(4, 'i');&#13;
&#13;
// Transaction Signature&#13;
blob.l += 4;&#13;
&#13;
// Mini Stream Cutoff Size&#13;
blob.chk('00100000', 'Mini Stream Cutoff Size: ');&#13;
&#13;
// First Mini FAT Sector Location&#13;
minifat_start = blob.read_shift(4, 'i');&#13;
&#13;
// Number of Mini FAT Sectors&#13;
nmfs = blob.read_shift(4, 'i');&#13;
&#13;
// First DIFAT sector location&#13;
difat_start = blob.read_shift(4, 'i');&#13;
&#13;
// Number of DIFAT Sectors&#13;
difat_sec_cnt = blob.read_shift(4, 'i');&#13;
&#13;
// Grab FAT Sector Locations&#13;
for(var q = -1, j = 0; j &lt; 109; ++j) { /* 109 = (512 - blob.l)&gt;&gt;&gt;2; */&#13;
	q = blob.read_shift(4, 'i');&#13;
	if(q&lt;0) break;&#13;
	fat_addrs[j] = q;&#13;
}&#13;
&#13;
/** Break the file up into sectors */&#13;
var sectors = sectorify(file, ssz);&#13;
&#13;
sleuth_fat(difat_start, difat_sec_cnt, sectors, ssz, fat_addrs);&#13;
&#13;
/** Chains */&#13;
var sector_list = make_sector_list(sectors, dir_start, fat_addrs, ssz);&#13;
&#13;
sector_list[dir_start].name = "!Directory";&#13;
if(nmfs &gt; 0 &amp;&amp; minifat_start !== ENDOFCHAIN) sector_list[minifat_start].name = "!MiniFAT";&#13;
sector_list[fat_addrs[0]].name = "!FAT";&#13;
sector_list.fat_addrs = fat_addrs;&#13;
sector_list.ssz = ssz;&#13;
&#13;
/* [MS-CFB] 2.6.1 Compound File Directory Entry */&#13;
var files = {}, Paths = [], FileIndex = [], FullPaths = [];&#13;
read_directory(dir_start, sector_list, sectors, Paths, nmfs, files, FileIndex, minifat_start);&#13;
&#13;
build_full_paths(FileIndex, FullPaths, Paths);&#13;
Paths.shift();&#13;
&#13;
var o = {&#13;
	FileIndex: FileIndex,&#13;
	FullPaths: FullPaths&#13;
};&#13;
&#13;
// $FlowIgnore&#13;
if(options &amp;&amp; options.raw) o.raw = {header: header, sectors: sectors};&#13;
return o;&#13;
} // parse&#13;
&#13;
/* [MS-CFB] 2.2 Compound File Header -- read up to major version */&#13;
function check_get_mver(blob) {&#13;
	if(blob[blob.l] == 0x50 &amp;&amp; blob[blob.l + 1] == 0x4b) return [0, 0];&#13;
	// header signature 8&#13;
	blob.chk(HEADER_SIGNATURE, 'Header Signature: ');&#13;
&#13;
	// clsid 16&#13;
	//blob.chk(HEADER_CLSID, 'CLSID: ');&#13;
	blob.l += 16;&#13;
&#13;
	// minor version 2&#13;
	var mver = blob.read_shift(2, 'u');&#13;
&#13;
	return [blob.read_shift(2,'u'), mver];&#13;
}&#13;
function check_shifts(blob, mver) {&#13;
	var shift = 0x09;&#13;
&#13;
	// Byte Order&#13;
	//blob.chk('feff', 'Byte Order: '); // note: some writers put 0xffff&#13;
	blob.l += 2;&#13;
&#13;
	// Sector Shift&#13;
	switch((shift = blob.read_shift(2))) {&#13;
		case 0x09: if(mver != 3) throw new Error('Sector Shift: Expected 9 saw ' + shift); break;&#13;
		case 0x0c: if(mver != 4) throw new Error('Sector Shift: Expected 12 saw ' + shift); break;&#13;
		default: throw new Error('Sector Shift: Expected 9 or 12 saw ' + shift);&#13;
	}&#13;
&#13;
	// Mini Sector Shift&#13;
	blob.chk('0600', 'Mini Sector Shift: ');&#13;
&#13;
	// Reserved&#13;
	blob.chk('000000000000', 'Reserved: ');&#13;
}&#13;
&#13;
/** Break the file up into sectors */&#13;
function sectorify(file, ssz) {&#13;
	var nsectors = Math.ceil(file.length/ssz)-1;&#13;
	var sectors = [];&#13;
	for(var i=1; i &lt; nsectors; ++i) sectors[i-1] = file.slice(i*ssz,(i+1)*ssz);&#13;
	sectors[nsectors-1] = file.slice(nsectors*ssz);&#13;
	return sectors;&#13;
}&#13;
&#13;
/* [MS-CFB] 2.6.4 Red-Black Tree */&#13;
function build_full_paths(FI, FP, Paths) {&#13;
	var i = 0, L = 0, R = 0, C = 0, j = 0, pl = Paths.length;&#13;
	var dad = [], q = [];&#13;
&#13;
	for(; i &lt; pl; ++i) { dad[i]=q[i]=i; FP[i]=Paths[i]; }&#13;
&#13;
	for(; j &lt; q.length; ++j) {&#13;
		i = q[j];&#13;
		L = FI[i].L; R = FI[i].R; C = FI[i].C;&#13;
		if(dad[i] === i) {&#13;
			if(L !== -1 /*NOSTREAM*/ &amp;&amp; dad[L] !== L) dad[i] = dad[L];&#13;
			if(R !== -1 &amp;&amp; dad[R] !== R) dad[i] = dad[R];&#13;
		}&#13;
		if(C !== -1 /*NOSTREAM*/) dad[C] = i;&#13;
		if(L !== -1 &amp;&amp; i != dad[i]) { dad[L] = dad[i]; if(q.lastIndexOf(L) &lt; j) q.push(L); }&#13;
		if(R !== -1 &amp;&amp; i != dad[i]) { dad[R] = dad[i]; if(q.lastIndexOf(R) &lt; j) q.push(R); }&#13;
	}&#13;
	for(i=1; i &lt; pl; ++i) if(dad[i] === i) {&#13;
		if(R !== -1 /*NOSTREAM*/ &amp;&amp; dad[R] !== R) dad[i] = dad[R];&#13;
		else if(L !== -1 &amp;&amp; dad[L] !== L) dad[i] = dad[L];&#13;
	}&#13;
&#13;
	for(i=1; i &lt; pl; ++i) {&#13;
		if(FI[i].type === 0 /* unknown */) continue;&#13;
		j = i;&#13;
		if(j != dad[j]) do {&#13;
			j = dad[j];&#13;
			FP[i] = FP[j] + "/" + FP[i];&#13;
		} while (j !== 0 &amp;&amp; -1 !== dad[j] &amp;&amp; j != dad[j]);&#13;
		dad[i] = -1;&#13;
	}&#13;
&#13;
	FP[0] += "/";&#13;
	for(i=1; i &lt; pl; ++i) {&#13;
		if(FI[i].type !== 2 /* stream */) FP[i] += "/";&#13;
	}&#13;
}&#13;
&#13;
function get_mfat_entry(entry, payload, mini) {&#13;
	var start = entry.start, size = entry.size;&#13;
	//return (payload.slice(start*MSSZ, start*MSSZ + size));&#13;
	var o = [];&#13;
	var idx = start;&#13;
	while(mini &amp;&amp; size &gt; 0 &amp;&amp; idx &gt;= 0) {&#13;
		o.push(payload.slice(idx * MSSZ, idx * MSSZ + MSSZ));&#13;
		size -= MSSZ;&#13;
		idx = __readInt32LE(mini, idx * 4);&#13;
	}&#13;
	if(o.length === 0) return (new_buf(0));&#13;
	return (bconcat(o).slice(0, entry.size));&#13;
}&#13;
&#13;
/** Chase down the rest of the DIFAT chain to build a comprehensive list&#13;
    DIFAT chains by storing the next sector number as the last 32 bits */&#13;
function sleuth_fat(idx, cnt, sectors, ssz, fat_addrs) {&#13;
	var q = ENDOFCHAIN;&#13;
	if(idx === ENDOFCHAIN) {&#13;
		if(cnt !== 0) throw new Error("DIFAT chain shorter than expected");&#13;
	} else if(idx !== -1 /*FREESECT*/) {&#13;
		var sector = sectors[idx], m = (ssz&gt;&gt;&gt;2)-1;&#13;
		if(!sector) return;&#13;
		for(var i = 0; i &lt; m; ++i) {&#13;
			if((q = __readInt32LE(sector,i*4)) === ENDOFCHAIN) break;&#13;
			fat_addrs.push(q);&#13;
		}&#13;
		if(cnt &gt;= 1) sleuth_fat(__readInt32LE(sector,ssz-4),cnt - 1, sectors, ssz, fat_addrs);&#13;
	}&#13;
}&#13;
&#13;
/** Follow the linked list of sectors for a given starting point */&#13;
function get_sector_list(sectors, start, fat_addrs, ssz, chkd) {&#13;
	var buf = [], buf_chain = [];&#13;
	if(!chkd) chkd = [];&#13;
	var modulus = ssz - 1, j = 0, jj = 0;&#13;
	for(j=start; j&gt;=0;) {&#13;
		chkd[j] = true;&#13;
		buf[buf.length] = j;&#13;
		buf_chain.push(sectors[j]);&#13;
		var addr = fat_addrs[Math.floor(j*4/ssz)];&#13;
		jj = ((j*4) &amp; modulus);&#13;
		if(ssz &lt; 4 + jj) throw new Error("FAT boundary crossed: " + j + " 4 "+ssz);&#13;
		if(!sectors[addr]) break;&#13;
		j = __readInt32LE(sectors[addr], jj);&#13;
	}&#13;
	return {nodes: buf, data:__toBuffer([buf_chain])};&#13;
}&#13;
&#13;
/** Chase down the sector linked lists */&#13;
function make_sector_list(sectors, dir_start, fat_addrs, ssz) {&#13;
	var sl = sectors.length, sector_list = ([]);&#13;
	var chkd = [], buf = [], buf_chain = [];&#13;
	var modulus = ssz - 1, i=0, j=0, k=0, jj=0;&#13;
	for(i=0; i &lt; sl; ++i) {&#13;
		buf = ([]);&#13;
		k = (i + dir_start); if(k &gt;= sl) k-=sl;&#13;
		if(chkd[k]) continue;&#13;
		buf_chain = [];&#13;
		var seen = [];&#13;
		for(j=k; j&gt;=0;) {&#13;
			seen[j] = true;&#13;
			chkd[j] = true;&#13;
			buf[buf.length] = j;&#13;
			buf_chain.push(sectors[j]);&#13;
			var addr = fat_addrs[Math.floor(j*4/ssz)];&#13;
			jj = ((j*4) &amp; modulus);&#13;
			if(ssz &lt; 4 + jj) throw new Error("FAT boundary crossed: " + j + " 4 "+ssz);&#13;
			if(!sectors[addr]) break;&#13;
			j = __readInt32LE(sectors[addr], jj);&#13;
			if(seen[j]) break;&#13;
		}&#13;
		sector_list[k] = ({nodes: buf, data:__toBuffer([buf_chain])});&#13;
	}&#13;
	return sector_list;&#13;
}&#13;
&#13;
/* [MS-CFB] 2.6.1 Compound File Directory Entry */&#13;
function read_directory(dir_start, sector_list, sectors, Paths, nmfs, files, FileIndex, mini) {&#13;
	var minifat_store = 0, pl = (Paths.length?2:0);&#13;
	var sector = sector_list[dir_start].data;&#13;
	var i = 0, namelen = 0, name;&#13;
	for(; i &lt; sector.length; i+= 128) {&#13;
		var blob = sector.slice(i, i+128);&#13;
		prep_blob(blob, 64);&#13;
		namelen = blob.read_shift(2);&#13;
		name = __utf16le(blob,0,namelen-pl);&#13;
		Paths.push(name);&#13;
		var o = ({&#13;
			name:  name,&#13;
			type:  blob.read_shift(1),&#13;
			color: blob.read_shift(1),&#13;
			L:     blob.read_shift(4, 'i'),&#13;
			R:     blob.read_shift(4, 'i'),&#13;
			C:     blob.read_shift(4, 'i'),&#13;
			clsid: blob.read_shift(16),&#13;
			state: blob.read_shift(4, 'i'),&#13;
			start: 0,&#13;
			size: 0&#13;
		});&#13;
		var ctime = blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2);&#13;
		if(ctime !== 0) o.ct = read_date(blob, blob.l-8);&#13;
		var mtime = blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2);&#13;
		if(mtime !== 0) o.mt = read_date(blob, blob.l-8);&#13;
		o.start = blob.read_shift(4, 'i');&#13;
		o.size = blob.read_shift(4, 'i');&#13;
		if(o.size &lt; 0 &amp;&amp; o.start &lt; 0) { o.size = o.type = 0; o.start = ENDOFCHAIN; o.name = ""; }&#13;
		if(o.type === 5) { /* root */&#13;
			minifat_store = o.start;&#13;
			if(nmfs &gt; 0 &amp;&amp; minifat_store !== ENDOFCHAIN) sector_list[minifat_store].name = "!StreamData";&#13;
			/*minifat_size = o.size;*/&#13;
		} else if(o.size &gt;= 4096 /* MSCSZ */) {&#13;
			o.storage = 'fat';&#13;
			if(sector_list[o.start] === undefined) sector_list[o.start] = get_sector_list(sectors, o.start, sector_list.fat_addrs, sector_list.ssz);&#13;
			sector_list[o.start].name = o.name;&#13;
			o.content = (sector_list[o.start].data.slice(0,o.size));&#13;
		} else {&#13;
			o.storage = 'minifat';&#13;
			if(o.size &lt; 0) o.size = 0;&#13;
			else if(minifat_store !== ENDOFCHAIN &amp;&amp; o.start !== ENDOFCHAIN &amp;&amp; sector_list[minifat_store]) {&#13;
				o.content = get_mfat_entry(o, sector_list[minifat_store].data, (sector_list[mini]||{}).data);&#13;
			}&#13;
		}&#13;
		if(o.content) prep_blob(o.content, 0);&#13;
		files[name] = o;&#13;
		FileIndex.push(o);&#13;
	}&#13;
}&#13;
&#13;
function read_date(blob, offset) {&#13;
	return new Date(( ( (__readUInt32LE(blob,offset+4)/1e7)*Math.pow(2,32)+__readUInt32LE(blob,offset)/1e7 ) - 11644473600)*1000);&#13;
}&#13;
&#13;
function read_file(filename, options) {&#13;
	get_fs();&#13;
	return parse(fs.readFileSync(filename), options);&#13;
}&#13;
&#13;
function read(blob, options) {&#13;
	var type = options &amp;&amp; options.type;&#13;
	if(!type) {&#13;
		if(has_buf &amp;&amp; Buffer.isBuffer(blob)) type = "buffer";&#13;
	}&#13;
	switch(type || "base64") {&#13;
		case "file": return read_file(blob, options);&#13;
		case "base64": return parse(s2a(Base64_decode(blob)), options);&#13;
		case "binary": return parse(s2a(blob), options);&#13;
	}&#13;
	return parse(blob, options);&#13;
}&#13;
&#13;
function init_cfb(cfb, opts) {&#13;
	var o = opts || {}, root = o.root || "Root Entry";&#13;
	if(!cfb.FullPaths) cfb.FullPaths = [];&#13;
	if(!cfb.FileIndex) cfb.FileIndex = [];&#13;
	if(cfb.FullPaths.length !== cfb.FileIndex.length) throw new Error("inconsistent CFB structure");&#13;
	if(cfb.FullPaths.length === 0) {&#13;
		cfb.FullPaths[0] = root + "/";&#13;
		cfb.FileIndex[0] = ({ name: root, type: 5 });&#13;
	}&#13;
	if(o.CLSID) cfb.FileIndex[0].clsid = o.CLSID;&#13;
	seed_cfb(cfb);&#13;
}&#13;
function seed_cfb(cfb) {&#13;
	var nm = "\u0001Sh33tJ5";&#13;
	if(CFB.find(cfb, "/" + nm)) return;&#13;
	var p = new_buf(4); p[0] = 55; p[1] = p[3] = 50; p[2] = 54;&#13;
	cfb.FileIndex.push(({ name: nm, type: 2, content:p, size:4, L:69, R:69, C:69 }));&#13;
	cfb.FullPaths.push(cfb.FullPaths[0] + nm);&#13;
	rebuild_cfb(cfb);&#13;
}&#13;
function rebuild_cfb(cfb, f) {&#13;
	init_cfb(cfb);&#13;
	var gc = false, s = false;&#13;
	for(var i = cfb.FullPaths.length - 1; i &gt;= 0; --i) {&#13;
		var _file = cfb.FileIndex[i];&#13;
		switch(_file.type) {&#13;
			case 0:&#13;
				if(s) gc = true;&#13;
				else { cfb.FileIndex.pop(); cfb.FullPaths.pop(); }&#13;
				break;&#13;
			case 1: case 2: case 5:&#13;
				s = true;&#13;
				if(isNaN(_file.R * _file.L * _file.C)) gc = true;&#13;
				if(_file.R &gt; -1 &amp;&amp; _file.L &gt; -1 &amp;&amp; _file.R == _file.L) gc = true;&#13;
				break;&#13;
			default: gc = true; break;&#13;
		}&#13;
	}&#13;
	if(!gc &amp;&amp; !f) return;&#13;
&#13;
	var now = new Date(1987, 1, 19), j = 0;&#13;
	// Track which names exist&#13;
	var fullPaths = Object.create ? Object.create(null) : {};&#13;
	var data = [];&#13;
	for(i = 0; i &lt; cfb.FullPaths.length; ++i) {&#13;
		fullPaths[cfb.FullPaths[i]] = true;&#13;
		if(cfb.FileIndex[i].type === 0) continue;&#13;
		data.push([cfb.FullPaths[i], cfb.FileIndex[i]]);&#13;
	}&#13;
	for(i = 0; i &lt; data.length; ++i) {&#13;
		var dad = dirname(data[i][0]);&#13;
		s = fullPaths[dad];&#13;
		while(!s) {&#13;
			while(dirname(dad) &amp;&amp; !fullPaths[dirname(dad)]) dad = dirname(dad);&#13;
&#13;
			data.push([dad, ({&#13;
				name: filename(dad).replace("/",""),&#13;
				type: 1,&#13;
				clsid: HEADER_CLSID,&#13;
				ct: now, mt: now,&#13;
				content: null&#13;
			})]);&#13;
&#13;
			// Add name to set&#13;
			fullPaths[dad] = true;&#13;
&#13;
			dad = dirname(data[i][0]);&#13;
			s = fullPaths[dad];&#13;
		}&#13;
	}&#13;
&#13;
	data.sort(function(x,y) { return namecmp(x[0], y[0]); });&#13;
	cfb.FullPaths = []; cfb.FileIndex = [];&#13;
	for(i = 0; i &lt; data.length; ++i) { cfb.FullPaths[i] = data[i][0]; cfb.FileIndex[i] = data[i][1]; }&#13;
	for(i = 0; i &lt; data.length; ++i) {&#13;
		var elt = cfb.FileIndex[i];&#13;
		var nm = cfb.FullPaths[i];&#13;
&#13;
		elt.name =  filename(nm).replace("/","");&#13;
		elt.L = elt.R = elt.C = -(elt.color = 1);&#13;
		elt.size = elt.content ? elt.content.length : 0;&#13;
		elt.start = 0;&#13;
		elt.clsid = (elt.clsid || HEADER_CLSID);&#13;
		if(i === 0) {&#13;
			elt.C = data.length &gt; 1 ? 1 : -1;&#13;
			elt.size = 0;&#13;
			elt.type = 5;&#13;
		} else if(nm.slice(-1) == "/") {&#13;
			for(j=i+1;j &lt; data.length; ++j) if(dirname(cfb.FullPaths[j])==nm) break;&#13;
			elt.C = j &gt;= data.length ? -1 : j;&#13;
			for(j=i+1;j &lt; data.length; ++j) if(dirname(cfb.FullPaths[j])==dirname(nm)) break;&#13;
			elt.R = j &gt;= data.length ? -1 : j;&#13;
			elt.type = 1;&#13;
		} else {&#13;
			if(dirname(cfb.FullPaths[i+1]||"") == dirname(nm)) elt.R = i + 1;&#13;
			elt.type = 2;&#13;
		}&#13;
	}&#13;
&#13;
}&#13;
&#13;
function _write(cfb, options) {&#13;
	var _opts = options || {};&#13;
	/* MAD is order-sensitive, skip rebuild and sort */&#13;
	if(_opts.fileType == 'mad') return write_mad(cfb, _opts);&#13;
	rebuild_cfb(cfb);&#13;
	switch(_opts.fileType) {&#13;
		case 'zip': return write_zip(cfb, _opts);&#13;
		//case 'mad': return write_mad(cfb, _opts);&#13;
	}&#13;
	var L = (function(cfb){&#13;
		var mini_size = 0, fat_size = 0;&#13;
		for(var i = 0; i &lt; cfb.FileIndex.length; ++i) {&#13;
			var file = cfb.FileIndex[i];&#13;
			if(!file.content) continue;&#13;
			var flen = file.content.length;&#13;
			if(flen &gt; 0){&#13;
				if(flen &lt; 0x1000) mini_size += (flen + 0x3F) &gt;&gt; 6;&#13;
				else fat_size += (flen + 0x01FF) &gt;&gt; 9;&#13;
			}&#13;
		}&#13;
		var dir_cnt = (cfb.FullPaths.length +3) &gt;&gt; 2;&#13;
		var mini_cnt = (mini_size + 7) &gt;&gt; 3;&#13;
		var mfat_cnt = (mini_size + 0x7F) &gt;&gt; 7;&#13;
		var fat_base = mini_cnt + fat_size + dir_cnt + mfat_cnt;&#13;
		var fat_cnt = (fat_base + 0x7F) &gt;&gt; 7;&#13;
		var difat_cnt = fat_cnt &lt;= 109 ? 0 : Math.ceil((fat_cnt-109)/0x7F);&#13;
		while(((fat_base + fat_cnt + difat_cnt + 0x7F) &gt;&gt; 7) &gt; fat_cnt) difat_cnt = ++fat_cnt &lt;= 109 ? 0 : Math.ceil((fat_cnt-109)/0x7F);&#13;
		var L =  [1, difat_cnt, fat_cnt, mfat_cnt, dir_cnt, fat_size, mini_size, 0];&#13;
		cfb.FileIndex[0].size = mini_size &lt;&lt; 6;&#13;
		L[7] = (cfb.FileIndex[0].start=L[0]+L[1]+L[2]+L[3]+L[4]+L[5])+((L[6]+7) &gt;&gt; 3);&#13;
		return L;&#13;
	})(cfb);&#13;
	var o = new_buf(L[7] &lt;&lt; 9);&#13;
	var i = 0, T = 0;&#13;
	{&#13;
		for(i = 0; i &lt; 8; ++i) o.write_shift(1, HEADER_SIG[i]);&#13;
		for(i = 0; i &lt; 8; ++i) o.write_shift(2, 0);&#13;
		o.write_shift(2, 0x003E);&#13;
		o.write_shift(2, 0x0003);&#13;
		o.write_shift(2, 0xFFFE);&#13;
		o.write_shift(2, 0x0009);&#13;
		o.write_shift(2, 0x0006);&#13;
		for(i = 0; i &lt; 3; ++i) o.write_shift(2, 0);&#13;
		o.write_shift(4, 0);&#13;
		o.write_shift(4, L[2]);&#13;
		o.write_shift(4, L[0] + L[1] + L[2] + L[3] - 1);&#13;
		o.write_shift(4, 0);&#13;
		o.write_shift(4, 1&lt;&lt;12);&#13;
		o.write_shift(4, L[3] ? L[0] + L[1] + L[2] - 1: ENDOFCHAIN);&#13;
		o.write_shift(4, L[3]);&#13;
		o.write_shift(-4, L[1] ? L[0] - 1: ENDOFCHAIN);&#13;
		o.write_shift(4, L[1]);&#13;
		for(i = 0; i &lt; 109; ++i) o.write_shift(-4, i &lt; L[2] ? L[1] + i : -1);&#13;
	}&#13;
	if(L[1]) {&#13;
		for(T = 0; T &lt; L[1]; ++T) {&#13;
			for(; i &lt; 236 + T * 127; ++i) o.write_shift(-4, i &lt; L[2] ? L[1] + i : -1);&#13;
			o.write_shift(-4, T === L[1] - 1 ? ENDOFCHAIN : T + 1);&#13;
		}&#13;
	}&#13;
	var chainit = function(w) {&#13;
		for(T += w; i&lt;T-1; ++i) o.write_shift(-4, i+1);&#13;
		if(w) { ++i; o.write_shift(-4, ENDOFCHAIN); }&#13;
	};&#13;
	T = i = 0;&#13;
	for(T+=L[1]; i&lt;T; ++i) o.write_shift(-4, consts.DIFSECT);&#13;
	for(T+=L[2]; i&lt;T; ++i) o.write_shift(-4, consts.FATSECT);&#13;
	chainit(L[3]);&#13;
	chainit(L[4]);&#13;
	var j = 0, flen = 0;&#13;
	var file = cfb.FileIndex[0];&#13;
	for(; j &lt; cfb.FileIndex.length; ++j) {&#13;
		file = cfb.FileIndex[j];&#13;
		if(!file.content) continue;&#13;
flen = file.content.length;&#13;
		if(flen &lt; 0x1000) continue;&#13;
		file.start = T;&#13;
		chainit((flen + 0x01FF) &gt;&gt; 9);&#13;
	}&#13;
	chainit((L[6] + 7) &gt;&gt; 3);&#13;
	while(o.l &amp; 0x1FF) o.write_shift(-4, consts.ENDOFCHAIN);&#13;
	T = i = 0;&#13;
	for(j = 0; j &lt; cfb.FileIndex.length; ++j) {&#13;
		file = cfb.FileIndex[j];&#13;
		if(!file.content) continue;&#13;
flen = file.content.length;&#13;
		if(!flen || flen &gt;= 0x1000) continue;&#13;
		file.start = T;&#13;
		chainit((flen + 0x3F) &gt;&gt; 6);&#13;
	}&#13;
	while(o.l &amp; 0x1FF) o.write_shift(-4, consts.ENDOFCHAIN);&#13;
	for(i = 0; i &lt; L[4]&lt;&lt;2; ++i) {&#13;
		var nm = cfb.FullPaths[i];&#13;
		if(!nm || nm.length === 0) {&#13;
			for(j = 0; j &lt; 17; ++j) o.write_shift(4, 0);&#13;
			for(j = 0; j &lt; 3; ++j) o.write_shift(4, -1);&#13;
			for(j = 0; j &lt; 12; ++j) o.write_shift(4, 0);&#13;
			continue;&#13;
		}&#13;
		file = cfb.FileIndex[i];&#13;
		if(i === 0) file.start = file.size ? file.start - 1 : ENDOFCHAIN;&#13;
		var _nm = (i === 0 &amp;&amp; _opts.root) || file.name;&#13;
		if(_nm.length &gt; 32) {&#13;
			console.error("Name " + _nm + " will be truncated to " + _nm.slice(0,32));&#13;
			_nm = _nm.slice(0, 32);&#13;
		}&#13;
		flen = 2*(_nm.length+1);&#13;
		o.write_shift(64, _nm, "utf16le");&#13;
		o.write_shift(2, flen);&#13;
		o.write_shift(1, file.type);&#13;
		o.write_shift(1, file.color);&#13;
		o.write_shift(-4, file.L);&#13;
		o.write_shift(-4, file.R);&#13;
		o.write_shift(-4, file.C);&#13;
		if(!file.clsid) for(j = 0; j &lt; 4; ++j) o.write_shift(4, 0);&#13;
		else o.write_shift(16, file.clsid, "hex");&#13;
		o.write_shift(4, file.state || 0);&#13;
		o.write_shift(4, 0); o.write_shift(4, 0);&#13;
		o.write_shift(4, 0); o.write_shift(4, 0);&#13;
		o.write_shift(4, file.start);&#13;
		o.write_shift(4, file.size); o.write_shift(4, 0);&#13;
	}&#13;
	for(i = 1; i &lt; cfb.FileIndex.length; ++i) {&#13;
		file = cfb.FileIndex[i];&#13;
if(file.size &gt;= 0x1000) {&#13;
			o.l = (file.start+1) &lt;&lt; 9;&#13;
			if (has_buf &amp;&amp; Buffer.isBuffer(file.content)) {&#13;
				file.content.copy(o, o.l, 0, file.size);&#13;
				// o is a 0-filled Buffer so just set next offset&#13;
				o.l += (file.size + 511) &amp; -512;&#13;
			} else {&#13;
				for(j = 0; j &lt; file.size; ++j) o.write_shift(1, file.content[j]);&#13;
				for(; j &amp; 0x1FF; ++j) o.write_shift(1, 0);&#13;
			}&#13;
		}&#13;
	}&#13;
	for(i = 1; i &lt; cfb.FileIndex.length; ++i) {&#13;
		file = cfb.FileIndex[i];&#13;
if(file.size &gt; 0 &amp;&amp; file.size &lt; 0x1000) {&#13;
			if (has_buf &amp;&amp; Buffer.isBuffer(file.content)) {&#13;
				file.content.copy(o, o.l, 0, file.size);&#13;
				// o is a 0-filled Buffer so just set next offset&#13;
				o.l += (file.size + 63) &amp; -64;&#13;
			} else {&#13;
				for(j = 0; j &lt; file.size; ++j) o.write_shift(1, file.content[j]);&#13;
				for(; j &amp; 0x3F; ++j) o.write_shift(1, 0);&#13;
			}&#13;
		}&#13;
	}&#13;
	if (has_buf) {&#13;
		o.l = o.length;&#13;
	} else {&#13;
		// When using Buffer, already 0-filled&#13;
		while(o.l &lt; o.length) o.write_shift(1, 0);&#13;
	}&#13;
	return o;&#13;
}&#13;
/* [MS-CFB] 2.6.4 (Unicode 3.0.1 case conversion) */&#13;
function find(cfb, path) {&#13;
	var UCFullPaths = cfb.FullPaths.map(function(x) { return x.toUpperCase(); });&#13;
	var UCPaths = UCFullPaths.map(function(x) { var y = x.split("/"); return y[y.length - (x.slice(-1) == "/" ? 2 : 1)]; });&#13;
	var k = false;&#13;
	if(path.charCodeAt(0) === 47 /* "/" */) { k = true; path = UCFullPaths[0].slice(0, -1) + path; }&#13;
	else k = path.indexOf("/") !== -1;&#13;
	var UCPath = path.toUpperCase();&#13;
	var w = k === true ? UCFullPaths.indexOf(UCPath) : UCPaths.indexOf(UCPath);&#13;
	if(w !== -1) return cfb.FileIndex[w];&#13;
&#13;
	var m = !UCPath.match(chr1);&#13;
	UCPath = UCPath.replace(chr0,'');&#13;
	if(m) UCPath = UCPath.replace(chr1,'!');&#13;
	for(w = 0; w &lt; UCFullPaths.length; ++w) {&#13;
		if((m ? UCFullPaths[w].replace(chr1,'!') : UCFullPaths[w]).replace(chr0,'') == UCPath) return cfb.FileIndex[w];&#13;
		if((m ? UCPaths[w].replace(chr1,'!') : UCPaths[w]).replace(chr0,'') == UCPath) return cfb.FileIndex[w];&#13;
	}&#13;
	return null;&#13;
}&#13;
/** CFB Constants */&#13;
var MSSZ = 64; /* Mini Sector Size = 1&lt;&lt;6 */&#13;
//var MSCSZ = 4096; /* Mini Stream Cutoff Size */&#13;
/* 2.1 Compound File Sector Numbers and Types */&#13;
var ENDOFCHAIN = -2;&#13;
/* 2.2 Compound File Header */&#13;
var HEADER_SIGNATURE = 'd0cf11e0a1b11ae1';&#13;
var HEADER_SIG = [0xD0, 0xCF, 0x11, 0xE0, 0xA1, 0xB1, 0x1A, 0xE1];&#13;
var HEADER_CLSID = '00000000000000000000000000000000';&#13;
var consts = {&#13;
	/* 2.1 Compund File Sector Numbers and Types */&#13;
	MAXREGSECT: -6,&#13;
	DIFSECT: -4,&#13;
	FATSECT: -3,&#13;
	ENDOFCHAIN: ENDOFCHAIN,&#13;
	FREESECT: -1,&#13;
	/* 2.2 Compound File Header */&#13;
	HEADER_SIGNATURE: HEADER_SIGNATURE,&#13;
	HEADER_MINOR_VERSION: '3e00',&#13;
	MAXREGSID: -6,&#13;
	NOSTREAM: -1,&#13;
	HEADER_CLSID: HEADER_CLSID,&#13;
	/* 2.6.1 Compound File Directory Entry */&#13;
	EntryTypes: ['unknown','storage','stream','lockbytes','property','root']&#13;
};&#13;
&#13;
function write_file(cfb, filename, options) {&#13;
	get_fs();&#13;
	var o = _write(cfb, options);&#13;
fs.writeFileSync(filename, o);&#13;
}&#13;
&#13;
function a2s(o) {&#13;
	var out = new Array(o.length);&#13;
	for(var i = 0; i &lt; o.length; ++i) out[i] = String.fromCharCode(o[i]);&#13;
	return out.join("");&#13;
}&#13;
&#13;
function write(cfb, options) {&#13;
	var o = _write(cfb, options);&#13;
	switch(options &amp;&amp; options.type || "buffer") {&#13;
		case "file": get_fs(); fs.writeFileSync(options.filename, (o)); return o;&#13;
		case "binary": return typeof o == "string" ? o : a2s(o);&#13;
		case "base64": return Base64_encode(typeof o == "string" ? o : a2s(o));&#13;
		case "buffer": if(has_buf) return Buffer.isBuffer(o) ? o : Buffer_from(o);&#13;
			/* falls through */&#13;
		case "array": return typeof o == "string" ? s2a(o) : o;&#13;
	}&#13;
	return o;&#13;
}&#13;
/* node &lt; 8.1 zlib does not expose bytesRead, so default to pure JS */&#13;
var _zlib;&#13;
function use_zlib(zlib) { try {&#13;
	var InflateRaw = zlib.InflateRaw;&#13;
	var InflRaw = new InflateRaw();&#13;
	InflRaw._processChunk(new Uint8Array([3, 0]), InflRaw._finishFlushFlag);&#13;
	if(InflRaw.bytesRead) _zlib = zlib;&#13;
	else throw new Error("zlib does not expose bytesRead");&#13;
} catch(e) {console.error("cannot use native zlib: " + (e.message || e)); } }&#13;
&#13;
function _inflateRawSync(payload, usz) {&#13;
	if(!_zlib) return _inflate(payload, usz);&#13;
	var InflateRaw = _zlib.InflateRaw;&#13;
	var InflRaw = new InflateRaw();&#13;
	var out = InflRaw._processChunk(payload.slice(payload.l), InflRaw._finishFlushFlag);&#13;
	payload.l += InflRaw.bytesRead;&#13;
	return out;&#13;
}&#13;
&#13;
function _deflateRawSync(payload) {&#13;
	return _zlib ? _zlib.deflateRawSync(payload) : _deflate(payload);&#13;
}&#13;
var CLEN_ORDER = [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];&#13;
&#13;
/*  LEN_ID = [ 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285 ]; */&#13;
var LEN_LN = [   3,   4,   5,   6,   7,   8,   9,  10,  11,  13 , 15,  17,  19,  23,  27,  31,  35,  43,  51,  59,  67,  83,  99, 115, 131, 163, 195, 227, 258 ];&#13;
&#13;
/*  DST_ID = [  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13,  14,  15,  16,  17,  18,  19,   20,   21,   22,   23,   24,   25,   26,    27,    28,    29 ]; */&#13;
var DST_LN = [  1,  2,  3,  4,  5,  7,  9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577 ];&#13;
&#13;
function bit_swap_8(n) { var t = (((((n&lt;&lt;1)|(n&lt;&lt;11)) &amp; 0x22110) | (((n&lt;&lt;5)|(n&lt;&lt;15)) &amp; 0x88440))); return ((t&gt;&gt;16) | (t&gt;&gt;8) |t)&amp;0xFF; }&#13;
&#13;
var use_typed_arrays = typeof Uint8Array !== 'undefined';&#13;
&#13;
var bitswap8 = use_typed_arrays ? new Uint8Array(1&lt;&lt;8) : [];&#13;
for(var q = 0; q &lt; (1&lt;&lt;8); ++q) bitswap8[q] = bit_swap_8(q);&#13;
&#13;
function bit_swap_n(n, b) {&#13;
	var rev = bitswap8[n &amp; 0xFF];&#13;
	if(b &lt;= 8) return rev &gt;&gt;&gt; (8-b);&#13;
	rev = (rev &lt;&lt; 8) | bitswap8[(n&gt;&gt;8)&amp;0xFF];&#13;
	if(b &lt;= 16) return rev &gt;&gt;&gt; (16-b);&#13;
	rev = (rev &lt;&lt; 8) | bitswap8[(n&gt;&gt;16)&amp;0xFF];&#13;
	return rev &gt;&gt;&gt; (24-b);&#13;
}&#13;
&#13;
/* helpers for unaligned bit reads */&#13;
function read_bits_2(buf, bl) { var w = (bl&amp;7), h = (bl&gt;&gt;&gt;3); return ((buf[h]|(w &lt;= 6 ? 0 : buf[h+1]&lt;&lt;8))&gt;&gt;&gt;w)&amp; 0x03; }&#13;
function read_bits_3(buf, bl) { var w = (bl&amp;7), h = (bl&gt;&gt;&gt;3); return ((buf[h]|(w &lt;= 5 ? 0 : buf[h+1]&lt;&lt;8))&gt;&gt;&gt;w)&amp; 0x07; }&#13;
function read_bits_4(buf, bl) { var w = (bl&amp;7), h = (bl&gt;&gt;&gt;3); return ((buf[h]|(w &lt;= 4 ? 0 : buf[h+1]&lt;&lt;8))&gt;&gt;&gt;w)&amp; 0x0F; }&#13;
function read_bits_5(buf, bl) { var w = (bl&amp;7), h = (bl&gt;&gt;&gt;3); return ((buf[h]|(w &lt;= 3 ? 0 : buf[h+1]&lt;&lt;8))&gt;&gt;&gt;w)&amp; 0x1F; }&#13;
function read_bits_7(buf, bl) { var w = (bl&amp;7), h = (bl&gt;&gt;&gt;3); return ((buf[h]|(w &lt;= 1 ? 0 : buf[h+1]&lt;&lt;8))&gt;&gt;&gt;w)&amp; 0x7F; }&#13;
&#13;
/* works up to n = 3 * 8 + 1 = 25 */&#13;
function read_bits_n(buf, bl, n) {&#13;
	var w = (bl&amp;7), h = (bl&gt;&gt;&gt;3), f = ((1&lt;&lt;n)-1);&#13;
	var v = buf[h] &gt;&gt;&gt; w;&#13;
	if(n &lt; 8 - w) return v &amp; f;&#13;
	v |= buf[h+1]&lt;&lt;(8-w);&#13;
	if(n &lt; 16 - w) return v &amp; f;&#13;
	v |= buf[h+2]&lt;&lt;(16-w);&#13;
	if(n &lt; 24 - w) return v &amp; f;&#13;
	v |= buf[h+3]&lt;&lt;(24-w);&#13;
	return v &amp; f;&#13;
}&#13;
&#13;
/* helpers for unaligned bit writes */&#13;
function write_bits_3(buf, bl, v) { var w = bl &amp; 7, h = bl &gt;&gt;&gt; 3;&#13;
	if(w &lt;= 5) buf[h] |= (v &amp; 7) &lt;&lt; w;&#13;
	else {&#13;
		buf[h] |= (v &lt;&lt; w) &amp; 0xFF;&#13;
		buf[h+1] = (v&amp;7) &gt;&gt; (8-w);&#13;
	}&#13;
	return bl + 3;&#13;
}&#13;
&#13;
function write_bits_1(buf, bl, v) {&#13;
	var w = bl &amp; 7, h = bl &gt;&gt;&gt; 3;&#13;
	v = (v&amp;1) &lt;&lt; w;&#13;
	buf[h] |= v;&#13;
	return bl + 1;&#13;
}&#13;
function write_bits_8(buf, bl, v) {&#13;
	var w = bl &amp; 7, h = bl &gt;&gt;&gt; 3;&#13;
	v &lt;&lt;= w;&#13;
	buf[h] |=  v &amp; 0xFF; v &gt;&gt;&gt;= 8;&#13;
	buf[h+1] = v;&#13;
	return bl + 8;&#13;
}&#13;
function write_bits_16(buf, bl, v) {&#13;
	var w = bl &amp; 7, h = bl &gt;&gt;&gt; 3;&#13;
	v &lt;&lt;= w;&#13;
	buf[h] |=  v &amp; 0xFF; v &gt;&gt;&gt;= 8;&#13;
	buf[h+1] = v &amp; 0xFF;&#13;
	buf[h+2] = v &gt;&gt;&gt; 8;&#13;
	return bl + 16;&#13;
}&#13;
&#13;
/* until ArrayBuffer#realloc is a thing, fake a realloc */&#13;
function realloc(b, sz) {&#13;
	var L = b.length, M = 2*L &gt; sz ? 2*L : sz + 5, i = 0;&#13;
	if(L &gt;= sz) return b;&#13;
	if(has_buf) {&#13;
		var o = new_unsafe_buf(M);&#13;
		// $FlowIgnore&#13;
		if(b.copy) b.copy(o);&#13;
		else for(; i &lt; b.length; ++i) o[i] = b[i];&#13;
		return o;&#13;
	} else if(use_typed_arrays) {&#13;
		var a = new Uint8Array(M);&#13;
		if(a.set) a.set(b);&#13;
		else for(; i &lt; L; ++i) a[i] = b[i];&#13;
		return a;&#13;
	}&#13;
	b.length = M;&#13;
	return b;&#13;
}&#13;
&#13;
/* zero-filled arrays for older browsers */&#13;
function zero_fill_array(n) {&#13;
	var o = new Array(n);&#13;
	for(var i = 0; i &lt; n; ++i) o[i] = 0;&#13;
	return o;&#13;
}&#13;
&#13;
/* build tree (used for literals and lengths) */&#13;
function build_tree(clens, cmap, MAX) {&#13;
	var maxlen = 1, w = 0, i = 0, j = 0, ccode = 0, L = clens.length;&#13;
&#13;
	var bl_count  = use_typed_arrays ? new Uint16Array(32) : zero_fill_array(32);&#13;
	for(i = 0; i &lt; 32; ++i) bl_count[i] = 0;&#13;
&#13;
	for(i = L; i &lt; MAX; ++i) clens[i] = 0;&#13;
	L = clens.length;&#13;
&#13;
	var ctree = use_typed_arrays ? new Uint16Array(L) : zero_fill_array(L); // []&#13;
&#13;
	/* build code tree */&#13;
	for(i = 0; i &lt; L; ++i) {&#13;
		bl_count[(w = clens[i])]++;&#13;
		if(maxlen &lt; w) maxlen = w;&#13;
		ctree[i] = 0;&#13;
	}&#13;
	bl_count[0] = 0;&#13;
	for(i = 1; i &lt;= maxlen; ++i) bl_count[i+16] = (ccode = (ccode + bl_count[i-1])&lt;&lt;1);&#13;
	for(i = 0; i &lt; L; ++i) {&#13;
		ccode = clens[i];&#13;
		if(ccode != 0) ctree[i] = bl_count[ccode+16]++;&#13;
	}&#13;
&#13;
	/* cmap[maxlen + 4 bits] = (off&amp;15) + (lit&lt;&lt;4) reverse mapping */&#13;
	var cleni = 0;&#13;
	for(i = 0; i &lt; L; ++i) {&#13;
		cleni = clens[i];&#13;
		if(cleni != 0) {&#13;
			ccode = bit_swap_n(ctree[i], maxlen)&gt;&gt;(maxlen-cleni);&#13;
			for(j = (1&lt;&lt;(maxlen + 4 - cleni)) - 1; j&gt;=0; --j)&#13;
				cmap[ccode|(j&lt;&lt;cleni)] = (cleni&amp;15) | (i&lt;&lt;4);&#13;
		}&#13;
	}&#13;
	return maxlen;&#13;
}&#13;
&#13;
/* Fixed Huffman */&#13;
var fix_lmap = use_typed_arrays ? new Uint16Array(512) : zero_fill_array(512);&#13;
var fix_dmap = use_typed_arrays ? new Uint16Array(32)  : zero_fill_array(32);&#13;
if(!use_typed_arrays) {&#13;
	for(var i = 0; i &lt; 512; ++i) fix_lmap[i] = 0;&#13;
	for(i = 0; i &lt; 32; ++i) fix_dmap[i] = 0;&#13;
}&#13;
(function() {&#13;
	var dlens = [];&#13;
	var i = 0;&#13;
	for(;i&lt;32; i++) dlens.push(5);&#13;
	build_tree(dlens, fix_dmap, 32);&#13;
&#13;
	var clens = [];&#13;
	i = 0;&#13;
	for(; i&lt;=143; i++) clens.push(8);&#13;
	for(; i&lt;=255; i++) clens.push(9);&#13;
	for(; i&lt;=279; i++) clens.push(7);&#13;
	for(; i&lt;=287; i++) clens.push(8);&#13;
	build_tree(clens, fix_lmap, 288);&#13;
})();var _deflateRaw = (function _deflateRawIIFE() {&#13;
	var DST_LN_RE = use_typed_arrays ? new Uint8Array(0x8000) : [];&#13;
	var j = 0, k = 0;&#13;
	for(; j &lt; DST_LN.length - 1; ++j) {&#13;
		for(; k &lt; DST_LN[j+1]; ++k) DST_LN_RE[k] = j;&#13;
	}&#13;
	for(;k &lt; 32768; ++k) DST_LN_RE[k] = 29;&#13;
&#13;
	var LEN_LN_RE = use_typed_arrays ? new Uint8Array(0x103) : [];&#13;
	for(j = 0, k = 0; j &lt; LEN_LN.length - 1; ++j) {&#13;
		for(; k &lt; LEN_LN[j+1]; ++k) LEN_LN_RE[k] = j;&#13;
	}&#13;
&#13;
	function write_stored(data, out) {&#13;
		var boff = 0;&#13;
		while(boff &lt; data.length) {&#13;
			var L = Math.min(0xFFFF, data.length - boff);&#13;
			var h = boff + L == data.length;&#13;
			out.write_shift(1, +h);&#13;
			out.write_shift(2, L);&#13;
			out.write_shift(2, (~L) &amp; 0xFFFF);&#13;
			while(L-- &gt; 0) out[out.l++] = data[boff++];&#13;
		}&#13;
		return out.l;&#13;
	}&#13;
&#13;
	/* Fixed Huffman */&#13;
	function write_huff_fixed(data, out) {&#13;
		var bl = 0;&#13;
		var boff = 0;&#13;
		var addrs = use_typed_arrays ? new Uint16Array(0x8000) : [];&#13;
		while(boff &lt; data.length) {&#13;
			var L = /* data.length - boff; */ Math.min(0xFFFF, data.length - boff);&#13;
&#13;
			/* write a stored block for short data */&#13;
			if(L &lt; 10) {&#13;
				bl = write_bits_3(out, bl, +!!(boff + L == data.length)); // jshint ignore:line&#13;
				if(bl &amp; 7) bl += 8 - (bl &amp; 7);&#13;
				out.l = (bl / 8) | 0;&#13;
				out.write_shift(2, L);&#13;
				out.write_shift(2, (~L) &amp; 0xFFFF);&#13;
				while(L-- &gt; 0) out[out.l++] = data[boff++];&#13;
				bl = out.l * 8;&#13;
				continue;&#13;
			}&#13;
&#13;
			bl = write_bits_3(out, bl, +!!(boff + L == data.length) + 2); // jshint ignore:line&#13;
			var hash = 0;&#13;
			while(L-- &gt; 0) {&#13;
				var d = data[boff];&#13;
				hash = ((hash &lt;&lt; 5) ^ d) &amp; 0x7FFF;&#13;
&#13;
				var match = -1, mlen = 0;&#13;
&#13;
				if((match = addrs[hash])) {&#13;
					match |= boff &amp; ~0x7FFF;&#13;
					if(match &gt; boff) match -= 0x8000;&#13;
					if(match &lt; boff) while(data[match + mlen] == data[boff + mlen] &amp;&amp; mlen &lt; 250) ++mlen;&#13;
				}&#13;
&#13;
				if(mlen &gt; 2) {&#13;
					/* Copy Token  */&#13;
					d = LEN_LN_RE[mlen];&#13;
					if(d &lt;= 22) bl = write_bits_8(out, bl, bitswap8[d+1]&gt;&gt;1) - 1;&#13;
					else {&#13;
						write_bits_8(out, bl, 3);&#13;
						bl += 5;&#13;
						write_bits_8(out, bl, bitswap8[d-23]&gt;&gt;5);&#13;
						bl += 3;&#13;
					}&#13;
					var len_eb = (d &lt; 8) ? 0 : ((d - 4)&gt;&gt;2);&#13;
					if(len_eb &gt; 0) {&#13;
						write_bits_16(out, bl, mlen - LEN_LN[d]);&#13;
						bl += len_eb;&#13;
					}&#13;
&#13;
					d = DST_LN_RE[boff - match];&#13;
					bl = write_bits_8(out, bl, bitswap8[d]&gt;&gt;3);&#13;
					bl -= 3;&#13;
&#13;
					var dst_eb = d &lt; 4 ? 0 : (d-2)&gt;&gt;1;&#13;
					if(dst_eb &gt; 0) {&#13;
						write_bits_16(out, bl, boff - match - DST_LN[d]);&#13;
						bl += dst_eb;&#13;
					}&#13;
					for(var q = 0; q &lt; mlen; ++q) {&#13;
						addrs[hash] = boff &amp; 0x7FFF;&#13;
						hash = ((hash &lt;&lt; 5) ^ data[boff]) &amp; 0x7FFF;&#13;
						++boff;&#13;
					}&#13;
					L-= mlen - 1;&#13;
				} else {&#13;
					/* Literal Token */&#13;
					if(d &lt;= 143) d = d + 48;&#13;
					else bl = write_bits_1(out, bl, 1);&#13;
					bl = write_bits_8(out, bl, bitswap8[d]);&#13;
					addrs[hash] = boff &amp; 0x7FFF;&#13;
					++boff;&#13;
				}&#13;
			}&#13;
&#13;
			bl = write_bits_8(out, bl, 0) - 1;&#13;
		}&#13;
		out.l = ((bl + 7)/8)|0;&#13;
		return out.l;&#13;
	}&#13;
	return function _deflateRaw(data, out) {&#13;
		if(data.length &lt; 8) return write_stored(data, out);&#13;
		return write_huff_fixed(data, out);&#13;
	};&#13;
})();&#13;
&#13;
function _deflate(data) {&#13;
	var buf = new_buf(50+Math.floor(data.length*1.1));&#13;
	var off = _deflateRaw(data, buf);&#13;
	return buf.slice(0, off);&#13;
}&#13;
/* modified inflate function also moves original read head */&#13;
&#13;
var dyn_lmap = use_typed_arrays ? new Uint16Array(32768) : zero_fill_array(32768);&#13;
var dyn_dmap = use_typed_arrays ? new Uint16Array(32768) : zero_fill_array(32768);&#13;
var dyn_cmap = use_typed_arrays ? new Uint16Array(128)   : zero_fill_array(128);&#13;
var dyn_len_1 = 1, dyn_len_2 = 1;&#13;
&#13;
/* 5.5.3 Expanding Huffman Codes */&#13;
function dyn(data, boff) {&#13;
	/* nomenclature from RFC1951 refers to bit values; these are offset by the implicit constant */&#13;
	var _HLIT = read_bits_5(data, boff) + 257; boff += 5;&#13;
	var _HDIST = read_bits_5(data, boff) + 1; boff += 5;&#13;
	var _HCLEN = read_bits_4(data, boff) + 4; boff += 4;&#13;
	var w = 0;&#13;
&#13;
	/* grab and store code lengths */&#13;
	var clens = use_typed_arrays ? new Uint8Array(19) : zero_fill_array(19);&#13;
	var ctree = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ];&#13;
	var maxlen = 1;&#13;
	var bl_count =  use_typed_arrays ? new Uint8Array(8) : zero_fill_array(8);&#13;
	var next_code = use_typed_arrays ? new Uint8Array(8) : zero_fill_array(8);&#13;
	var L = clens.length; /* 19 */&#13;
	for(var i = 0; i &lt; _HCLEN; ++i) {&#13;
		clens[CLEN_ORDER[i]] = w = read_bits_3(data, boff);&#13;
		if(maxlen &lt; w) maxlen = w;&#13;
		bl_count[w]++;&#13;
		boff += 3;&#13;
	}&#13;
&#13;
	/* build code tree */&#13;
	var ccode = 0;&#13;
	bl_count[0] = 0;&#13;
	for(i = 1; i &lt;= maxlen; ++i) next_code[i] = ccode = (ccode + bl_count[i-1])&lt;&lt;1;&#13;
	for(i = 0; i &lt; L; ++i) if((ccode = clens[i]) != 0) ctree[i] = next_code[ccode]++;&#13;
	/* cmap[7 bits from stream] = (off&amp;7) + (lit&lt;&lt;3) */&#13;
	var cleni = 0;&#13;
	for(i = 0; i &lt; L; ++i) {&#13;
		cleni = clens[i];&#13;
		if(cleni != 0) {&#13;
			ccode = bitswap8[ctree[i]]&gt;&gt;(8-cleni);&#13;
			for(var j = (1&lt;&lt;(7-cleni))-1; j&gt;=0; --j) dyn_cmap[ccode|(j&lt;&lt;cleni)] = (cleni&amp;7) | (i&lt;&lt;3);&#13;
		}&#13;
	}&#13;
&#13;
	/* read literal and dist codes at once */&#13;
	var hcodes = [];&#13;
	maxlen = 1;&#13;
	for(; hcodes.length &lt; _HLIT + _HDIST;) {&#13;
		ccode = dyn_cmap[read_bits_7(data, boff)];&#13;
		boff += ccode &amp; 7;&#13;
		switch((ccode &gt;&gt;&gt;= 3)) {&#13;
			case 16:&#13;
				w = 3 + read_bits_2(data, boff); boff += 2;&#13;
				ccode = hcodes[hcodes.length - 1];&#13;
				while(w-- &gt; 0) hcodes.push(ccode);&#13;
				break;&#13;
			case 17:&#13;
				w = 3 + read_bits_3(data, boff); boff += 3;&#13;
				while(w-- &gt; 0) hcodes.push(0);&#13;
				break;&#13;
			case 18:&#13;
				w = 11 + read_bits_7(data, boff); boff += 7;&#13;
				while(w -- &gt; 0) hcodes.push(0);&#13;
				break;&#13;
			default:&#13;
				hcodes.push(ccode);&#13;
				if(maxlen &lt; ccode) maxlen = ccode;&#13;
				break;&#13;
		}&#13;
	}&#13;
&#13;
	/* build literal / length trees */&#13;
	var h1 = hcodes.slice(0, _HLIT), h2 = hcodes.slice(_HLIT);&#13;
	for(i = _HLIT; i &lt; 286; ++i) h1[i] = 0;&#13;
	for(i = _HDIST; i &lt; 30; ++i) h2[i] = 0;&#13;
	dyn_len_1 = build_tree(h1, dyn_lmap, 286);&#13;
	dyn_len_2 = build_tree(h2, dyn_dmap, 30);&#13;
	return boff;&#13;
}&#13;
&#13;
/* return [ data, bytesRead ] */&#13;
function inflate(data, usz) {&#13;
	/* shortcircuit for empty buffer [0x03, 0x00] */&#13;
	if(data[0] == 3 &amp;&amp; !(data[1] &amp; 0x3)) { return [new_raw_buf(usz), 2]; }&#13;
&#13;
	/* bit offset */&#13;
	var boff = 0;&#13;
&#13;
	/* header includes final bit and type bits */&#13;
	var header = 0;&#13;
&#13;
	var outbuf = new_unsafe_buf(usz ? usz : (1&lt;&lt;18));&#13;
	var woff = 0;&#13;
	var OL = outbuf.length&gt;&gt;&gt;0;&#13;
	var max_len_1 = 0, max_len_2 = 0;&#13;
&#13;
	while((header&amp;1) == 0) {&#13;
		header = read_bits_3(data, boff); boff += 3;&#13;
		if((header &gt;&gt;&gt; 1) == 0) {&#13;
			/* Stored block */&#13;
			if(boff &amp; 7) boff += 8 - (boff&amp;7);&#13;
			/* 2 bytes sz, 2 bytes bit inverse */&#13;
			var sz = data[boff&gt;&gt;&gt;3] | data[(boff&gt;&gt;&gt;3)+1]&lt;&lt;8;&#13;
			boff += 32;&#13;
			/* push sz bytes */&#13;
			if(sz &gt; 0) {&#13;
				if(!usz &amp;&amp; OL &lt; woff + sz) { outbuf = realloc(outbuf, woff + sz); OL = outbuf.length; }&#13;
				while(sz-- &gt; 0) { outbuf[woff++] = data[boff&gt;&gt;&gt;3]; boff += 8; }&#13;
			}&#13;
			continue;&#13;
		} else if((header &gt;&gt; 1) == 1) {&#13;
			/* Fixed Huffman */&#13;
			max_len_1 = 9; max_len_2 = 5;&#13;
		} else {&#13;
			/* Dynamic Huffman */&#13;
			boff = dyn(data, boff);&#13;
			max_len_1 = dyn_len_1; max_len_2 = dyn_len_2;&#13;
		}&#13;
		for(;;) { // while(true) is apparently out of vogue in modern JS circles&#13;
			if(!usz &amp;&amp; (OL &lt; woff + 32767)) { outbuf = realloc(outbuf, woff + 32767); OL = outbuf.length; }&#13;
			/* ingest code and move read head */&#13;
			var bits = read_bits_n(data, boff, max_len_1);&#13;
			var code = (header&gt;&gt;&gt;1) == 1 ? fix_lmap[bits] : dyn_lmap[bits];&#13;
			boff += code &amp; 15; code &gt;&gt;&gt;= 4;&#13;
			/* 0-255 are literals, 256 is end of block token, 257+ are copy tokens */&#13;
			if(((code&gt;&gt;&gt;8)&amp;0xFF) === 0) outbuf[woff++] = code;&#13;
			else if(code == 256) break;&#13;
			else {&#13;
				code -= 257;&#13;
				var len_eb = (code &lt; 8) ? 0 : ((code-4)&gt;&gt;2); if(len_eb &gt; 5) len_eb = 0;&#13;
				var tgt = woff + LEN_LN[code];&#13;
				/* length extra bits */&#13;
				if(len_eb &gt; 0) {&#13;
					tgt += read_bits_n(data, boff, len_eb);&#13;
					boff += len_eb;&#13;
				}&#13;
&#13;
				/* dist code */&#13;
				bits = read_bits_n(data, boff, max_len_2);&#13;
				code = (header&gt;&gt;&gt;1) == 1 ? fix_dmap[bits] : dyn_dmap[bits];&#13;
				boff += code &amp; 15; code &gt;&gt;&gt;= 4;&#13;
				var dst_eb = (code &lt; 4 ? 0 : (code-2)&gt;&gt;1);&#13;
				var dst = DST_LN[code];&#13;
				/* dist extra bits */&#13;
				if(dst_eb &gt; 0) {&#13;
					dst += read_bits_n(data, boff, dst_eb);&#13;
					boff += dst_eb;&#13;
				}&#13;
&#13;
				/* in the common case, manual byte copy is faster than TA set / Buffer copy */&#13;
				if(!usz &amp;&amp; OL &lt; tgt) { outbuf = realloc(outbuf, tgt + 100); OL = outbuf.length; }&#13;
				while(woff &lt; tgt) { outbuf[woff] = outbuf[woff - dst]; ++woff; }&#13;
			}&#13;
		}&#13;
	}&#13;
	if(usz) return [outbuf, (boff+7)&gt;&gt;&gt;3];&#13;
	return [outbuf.slice(0, woff), (boff+7)&gt;&gt;&gt;3];&#13;
}&#13;
&#13;
function _inflate(payload, usz) {&#13;
	var data = payload.slice(payload.l||0);&#13;
	var out = inflate(data, usz);&#13;
	payload.l += out[1];&#13;
	return out[0];&#13;
}&#13;
&#13;
function warn_or_throw(wrn, msg) {&#13;
	if(wrn) { if(typeof console !== 'undefined') console.error(msg); }&#13;
	else throw new Error(msg);&#13;
}&#13;
&#13;
function parse_zip(file, options) {&#13;
	var blob = file;&#13;
	prep_blob(blob, 0);&#13;
&#13;
	var FileIndex = [], FullPaths = [];&#13;
	var o = {&#13;
		FileIndex: FileIndex,&#13;
		FullPaths: FullPaths&#13;
	};&#13;
	init_cfb(o, { root: options.root });&#13;
&#13;
	/* find end of central directory, start just after signature */&#13;
	var i = blob.length - 4;&#13;
	while((blob[i] != 0x50 || blob[i+1] != 0x4b || blob[i+2] != 0x05 || blob[i+3] != 0x06) &amp;&amp; i &gt;= 0) --i;&#13;
	blob.l = i + 4;&#13;
&#13;
	/* parse end of central directory */&#13;
	blob.l += 4;&#13;
	var fcnt = blob.read_shift(2);&#13;
	blob.l += 6;&#13;
	var start_cd = blob.read_shift(4);&#13;
&#13;
	/* parse central directory */&#13;
	blob.l = start_cd;&#13;
&#13;
	for(i = 0; i &lt; fcnt; ++i) {&#13;
		/* trust local file header instead of CD entry */&#13;
		blob.l += 20;&#13;
		var csz = blob.read_shift(4);&#13;
		var usz = blob.read_shift(4);&#13;
		var namelen = blob.read_shift(2);&#13;
		var efsz = blob.read_shift(2);&#13;
		var fcsz = blob.read_shift(2);&#13;
		blob.l += 8;&#13;
		var offset = blob.read_shift(4);&#13;
		var EF = parse_extra_field(blob.slice(blob.l+namelen, blob.l+namelen+efsz));&#13;
		blob.l += namelen + efsz + fcsz;&#13;
&#13;
		var L = blob.l;&#13;
		blob.l = offset + 4;&#13;
		/* ZIP64 lengths */&#13;
		if(EF &amp;&amp; EF[0x0001]) {&#13;
			if((EF[0x0001]||{}).usz) usz = EF[0x0001].usz;&#13;
			if((EF[0x0001]||{}).csz) csz = EF[0x0001].csz;&#13;
		}&#13;
		parse_local_file(blob, csz, usz, o, EF);&#13;
		blob.l = L;&#13;
	}&#13;
&#13;
	return o;&#13;
}&#13;
&#13;
&#13;
/* head starts just after local file header signature */&#13;
function parse_local_file(blob, csz, usz, o, EF) {&#13;
	/* [local file header] */&#13;
	blob.l += 2;&#13;
	var flags = blob.read_shift(2);&#13;
	var meth = blob.read_shift(2);&#13;
	var date = parse_dos_date(blob);&#13;
&#13;
	if(flags &amp; 0x2041) throw new Error("Unsupported ZIP encryption");&#13;
	var crc32 = blob.read_shift(4);&#13;
	var _csz = blob.read_shift(4);&#13;
	var _usz = blob.read_shift(4);&#13;
&#13;
	var namelen = blob.read_shift(2);&#13;
	var efsz = blob.read_shift(2);&#13;
&#13;
	// TODO: flags &amp; (1&lt;&lt;11) // UTF8&#13;
	var name = ""; for(var i = 0; i &lt; namelen; ++i) name += String.fromCharCode(blob[blob.l++]);&#13;
	if(efsz) {&#13;
		var ef = parse_extra_field(blob.slice(blob.l, blob.l + efsz));&#13;
		if((ef[0x5455]||{}).mt) date = ef[0x5455].mt;&#13;
		if((ef[0x0001]||{}).usz) _usz = ef[0x0001].usz;&#13;
		if((ef[0x0001]||{}).csz) _csz = ef[0x0001].csz;&#13;
		if(EF) {&#13;
			if((EF[0x5455]||{}).mt) date = EF[0x5455].mt;&#13;
			if((EF[0x0001]||{}).usz) _usz = ef[0x0001].usz;&#13;
			if((EF[0x0001]||{}).csz) _csz = ef[0x0001].csz;&#13;
		}&#13;
	}&#13;
	blob.l += efsz;&#13;
&#13;
	/* [encryption header] */&#13;
&#13;
	/* [file data] */&#13;
	var data = blob.slice(blob.l, blob.l + _csz);&#13;
	switch(meth) {&#13;
		case 8: data = _inflateRawSync(blob, _usz); break;&#13;
		case 0: break; // TODO: scan for magic number&#13;
		default: throw new Error("Unsupported ZIP Compression method " + meth);&#13;
	}&#13;
&#13;
	/* [data descriptor] */&#13;
	var wrn = false;&#13;
	if(flags &amp; 8) {&#13;
		crc32 = blob.read_shift(4);&#13;
		if(crc32 == 0x08074b50) { crc32 = blob.read_shift(4); wrn = true; }&#13;
		_csz = blob.read_shift(4);&#13;
		_usz = blob.read_shift(4);&#13;
	}&#13;
&#13;
	if(_csz != csz) warn_or_throw(wrn, "Bad compressed size: " + csz + " != " + _csz);&#13;
	if(_usz != usz) warn_or_throw(wrn, "Bad uncompressed size: " + usz + " != " + _usz);&#13;
	//var _crc32 = CRC32.buf(data, 0);&#13;
	//if((crc32&gt;&gt;0) != (_crc32&gt;&gt;0)) warn_or_throw(wrn, "Bad CRC32 checksum: " + crc32 + " != " + _crc32);&#13;
	cfb_add(o, name, data, {unsafe: true, mt: date});&#13;
}&#13;
function write_zip(cfb, options) {&#13;
	var _opts = options || {};&#13;
	var out = [], cdirs = [];&#13;
	var o = new_buf(1);&#13;
	var method = (_opts.compression ? 8 : 0), flags = 0;&#13;
	var desc = false;&#13;
	if(desc) flags |= 8;&#13;
	var i = 0, j = 0;&#13;
&#13;
	var start_cd = 0, fcnt = 0;&#13;
	var root = cfb.FullPaths[0], fp = root, fi = cfb.FileIndex[0];&#13;
	var crcs = [];&#13;
	var sz_cd = 0;&#13;
&#13;
	for(i = 1; i &lt; cfb.FullPaths.length; ++i) {&#13;
		fp = cfb.FullPaths[i].slice(root.length); fi = cfb.FileIndex[i];&#13;
		if(!fi.size || !fi.content || fp == "\u0001Sh33tJ5") continue;&#13;
		var start = start_cd;&#13;
&#13;
		/* TODO: CP437 filename */&#13;
		var namebuf = new_buf(fp.length);&#13;
		for(j = 0; j &lt; fp.length; ++j) namebuf.write_shift(1, fp.charCodeAt(j) &amp; 0x7F);&#13;
		namebuf = namebuf.slice(0, namebuf.l);&#13;
		crcs[fcnt] = typeof fi.content == "string" ? CRC32.bstr(fi.content, 0) : CRC32.buf(fi.content, 0);&#13;
&#13;
		var outbuf = typeof fi.content == "string" ? s2a(fi.content) : fi.content;&#13;
		if(method == 8) outbuf = _deflateRawSync(outbuf);&#13;
&#13;
		/* local file header */&#13;
		o = new_buf(30);&#13;
		o.write_shift(4, 0x04034b50);&#13;
		o.write_shift(2, 20);&#13;
		o.write_shift(2, flags);&#13;
		o.write_shift(2, method);&#13;
		/* TODO: last mod file time/date */&#13;
		if(fi.mt) write_dos_date(o, fi.mt);&#13;
		else o.write_shift(4, 0);&#13;
		o.write_shift(-4, (flags &amp; 8) ? 0 : crcs[fcnt]);&#13;
		o.write_shift(4,  (flags &amp; 8) ? 0 : outbuf.length);&#13;
		o.write_shift(4,  (flags &amp; 8) ? 0 : fi.content.length);&#13;
		o.write_shift(2, namebuf.length);&#13;
		o.write_shift(2, 0);&#13;
&#13;
		start_cd += o.length;&#13;
		out.push(o);&#13;
		start_cd += namebuf.length;&#13;
		out.push(namebuf);&#13;
&#13;
		/* TODO: extra fields? */&#13;
&#13;
		/* TODO: encryption header ? */&#13;
&#13;
		start_cd += outbuf.length;&#13;
		out.push(outbuf);&#13;
&#13;
		/* data descriptor */&#13;
		if(flags &amp; 8) {&#13;
			o = new_buf(12);&#13;
			o.write_shift(-4, crcs[fcnt]);&#13;
			o.write_shift(4, outbuf.length);&#13;
			o.write_shift(4, fi.content.length);&#13;
			start_cd += o.l;&#13;
			out.push(o);&#13;
		}&#13;
&#13;
		/* central directory */&#13;
		o = new_buf(46);&#13;
		o.write_shift(4, 0x02014b50);&#13;
		o.write_shift(2, 0);&#13;
		o.write_shift(2, 20);&#13;
		o.write_shift(2, flags);&#13;
		o.write_shift(2, method);&#13;
		o.write_shift(4, 0); /* TODO: last mod file time/date */&#13;
		o.write_shift(-4, crcs[fcnt]);&#13;
&#13;
		o.write_shift(4, outbuf.length);&#13;
		o.write_shift(4, fi.content.length);&#13;
		o.write_shift(2, namebuf.length);&#13;
		o.write_shift(2, 0);&#13;
		o.write_shift(2, 0);&#13;
		o.write_shift(2, 0);&#13;
		o.write_shift(2, 0);&#13;
		o.write_shift(4, 0);&#13;
		o.write_shift(4, start);&#13;
&#13;
		sz_cd += o.l;&#13;
		cdirs.push(o);&#13;
		sz_cd += namebuf.length;&#13;
		cdirs.push(namebuf);&#13;
		++fcnt;&#13;
	}&#13;
&#13;
	/* end of central directory */&#13;
	o = new_buf(22);&#13;
	o.write_shift(4, 0x06054b50);&#13;
	o.write_shift(2, 0);&#13;
	o.write_shift(2, 0);&#13;
	o.write_shift(2, fcnt);&#13;
	o.write_shift(2, fcnt);&#13;
	o.write_shift(4, sz_cd);&#13;
	o.write_shift(4, start_cd);&#13;
	o.write_shift(2, 0);&#13;
&#13;
	return bconcat(([bconcat((out)), bconcat(cdirs), o]));&#13;
}&#13;
var ContentTypeMap = ({&#13;
	"htm": "text/html",&#13;
	"xml": "text/xml",&#13;
&#13;
	"gif": "image/gif",&#13;
	"jpg": "image/jpeg",&#13;
	"png": "image/png",&#13;
&#13;
	"mso": "application/x-mso",&#13;
	"thmx": "application/vnd.ms-officetheme",&#13;
	"sh33tj5": "application/octet-stream"&#13;
});&#13;
&#13;
function get_content_type(fi, fp) {&#13;
	if(fi.ctype) return fi.ctype;&#13;
&#13;
	var ext = fi.name || "", m = ext.match(/\.([^\.]+)$/);&#13;
	if(m &amp;&amp; ContentTypeMap[m[1]]) return ContentTypeMap[m[1]];&#13;
&#13;
	if(fp) {&#13;
		m = (ext = fp).match(/[\.\\]([^\.\\])+$/);&#13;
		if(m &amp;&amp; ContentTypeMap[m[1]]) return ContentTypeMap[m[1]];&#13;
	}&#13;
&#13;
	return "application/octet-stream";&#13;
}&#13;
&#13;
/* 76 character chunks TODO: intertwine encoding */&#13;
function write_base64_76(bstr) {&#13;
	var data = Base64_encode(bstr);&#13;
	var o = [];&#13;
	for(var i = 0; i &lt; data.length; i+= 76) o.push(data.slice(i, i+76));&#13;
	return o.join("\r\n") + "\r\n";&#13;
}&#13;
&#13;
/*&#13;
Rules for QP:&#13;
	- escape =## applies for all non-display characters and literal "="&#13;
	- space or tab at end of line must be encoded&#13;
	- \r\n newlines can be preserved, but bare \r and \n must be escaped&#13;
	- lines must not exceed 76 characters, use soft breaks =\r\n&#13;
&#13;
TODO: Some files from word appear to write line extensions with bare equals:&#13;
&#13;
```&#13;
&lt;table class=3DMsoTableGrid border=3D1 cellspacing=3D0 cellpadding=3D0 width=&#13;
="70%"&#13;
```&#13;
*/&#13;
function write_quoted_printable(text) {&#13;
	var encoded = text.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7E-\xFF=]/g, function(c) {&#13;
		var w = c.charCodeAt(0).toString(16).toUpperCase();&#13;
		return "=" + (w.length == 1 ? "0" + w : w);&#13;
	});&#13;
&#13;
	encoded = encoded.replace(/ $/mg, "=20").replace(/\t$/mg, "=09");&#13;
&#13;
	if(encoded.charAt(0) == "\n") encoded = "=0D" + encoded.slice(1);&#13;
	encoded = encoded.replace(/\r(?!\n)/mg, "=0D").replace(/\n\n/mg, "\n=0A").replace(/([^\r\n])\n/mg, "$1=0A");&#13;
&#13;
	var o = [], split = encoded.split("\r\n");&#13;
	for(var si = 0; si &lt; split.length; ++si) {&#13;
		var str = split[si];&#13;
		if(str.length == 0) { o.push(""); continue; }&#13;
		for(var i = 0; i &lt; str.length;) {&#13;
			var end = 76;&#13;
			var tmp = str.slice(i, i + end);&#13;
			if(tmp.charAt(end - 1) == "=") end --;&#13;
			else if(tmp.charAt(end - 2) == "=") end -= 2;&#13;
			else if(tmp.charAt(end - 3) == "=") end -= 3;&#13;
			tmp = str.slice(i, i + end);&#13;
			i += end;&#13;
			if(i &lt; str.length) tmp += "=";&#13;
			o.push(tmp);&#13;
		}&#13;
	}&#13;
&#13;
	return o.join("\r\n");&#13;
}&#13;
function parse_quoted_printable(data) {&#13;
	var o = [];&#13;
&#13;
	/* unify long lines */&#13;
	for(var di = 0; di &lt; data.length; ++di) {&#13;
		var line = data[di];&#13;
		while(di &lt;= data.length &amp;&amp; line.charAt(line.length - 1) == "=") line = line.slice(0, line.length - 1) + data[++di];&#13;
		o.push(line);&#13;
	}&#13;
&#13;
	/* decode */&#13;
	for(var oi = 0; oi &lt; o.length; ++oi) o[oi] = o[oi].replace(/[=][0-9A-Fa-f]{2}/g, function($$) { return String.fromCharCode(parseInt($$.slice(1), 16)); });&#13;
	return s2a(o.join("\r\n"));&#13;
}&#13;
&#13;
&#13;
function parse_mime(cfb, data, root) {&#13;
	var fname = "", cte = "", ctype = "", fdata;&#13;
	var di = 0;&#13;
	for(;di &lt; 10; ++di) {&#13;
		var line = data[di];&#13;
		if(!line || line.match(/^\s*$/)) break;&#13;
		var m = line.match(/^(.*?):\s*([^\s].*)$/);&#13;
		if(m) switch(m[1].toLowerCase()) {&#13;
			case "content-location": fname = m[2].trim(); break;&#13;
			case "content-type": ctype = m[2].trim(); break;&#13;
			case "content-transfer-encoding": cte = m[2].trim(); break;&#13;
		}&#13;
	}&#13;
	++di;&#13;
	switch(cte.toLowerCase()) {&#13;
		case 'base64': fdata = s2a(Base64_decode(data.slice(di).join(""))); break;&#13;
		case 'quoted-printable': fdata = parse_quoted_printable(data.slice(di)); break;&#13;
		default: throw new Error("Unsupported Content-Transfer-Encoding " + cte);&#13;
	}&#13;
	var file = cfb_add(cfb, fname.slice(root.length), fdata, {unsafe: true});&#13;
	if(ctype) file.ctype = ctype;&#13;
}&#13;
&#13;
function parse_mad(file, options) {&#13;
	if(a2s(file.slice(0,13)).toLowerCase() != "mime-version:") throw new Error("Unsupported MAD header");&#13;
	var root = (options &amp;&amp; options.root || "");&#13;
	// $FlowIgnore&#13;
	var data = (has_buf &amp;&amp; Buffer.isBuffer(file) ? file.toString("binary") : a2s(file)).split("\r\n");&#13;
	var di = 0, row = "";&#13;
&#13;
	/* if root is not specified, scan for the common prefix */&#13;
	for(di = 0; di &lt; data.length; ++di) {&#13;
		row = data[di];&#13;
		if(!/^Content-Location:/i.test(row)) continue;&#13;
		row = row.slice(row.indexOf("file"));&#13;
		if(!root) root = row.slice(0, row.lastIndexOf("/") + 1);&#13;
		if(row.slice(0, root.length) == root) continue;&#13;
		while(root.length &gt; 0) {&#13;
			root = root.slice(0, root.length - 1);&#13;
			root = root.slice(0, root.lastIndexOf("/") + 1);&#13;
			if(row.slice(0,root.length) == root) break;&#13;
		}&#13;
	}&#13;
&#13;
	var mboundary = (data[1] || "").match(/boundary="(.*?)"/);&#13;
	if(!mboundary) throw new Error("MAD cannot find boundary");&#13;
	var boundary = "--" + (mboundary[1] || "");&#13;
&#13;
	var FileIndex = [], FullPaths = [];&#13;
	var o = {&#13;
		FileIndex: FileIndex,&#13;
		FullPaths: FullPaths&#13;
	};&#13;
	init_cfb(o);&#13;
	var start_di, fcnt = 0;&#13;
	for(di = 0; di &lt; data.length; ++di) {&#13;
		var line = data[di];&#13;
		if(line !== boundary &amp;&amp; line !== boundary + "--") continue;&#13;
		if(fcnt++) parse_mime(o, data.slice(start_di, di), root);&#13;
		start_di = di;&#13;
	}&#13;
	return o;&#13;
}&#13;
&#13;
function write_mad(cfb, options) {&#13;
	var opts = options || {};&#13;
	var boundary = opts.boundary || "xlsx";&#13;
	boundary = '------=' + boundary;&#13;
&#13;
	var out = [&#13;
		'MIME-Version: 1.0',&#13;
		'Content-Type: multipart/related; boundary="' + boundary.slice(2) + '"',&#13;
		'',&#13;
		'',&#13;
		''&#13;
	];&#13;
&#13;
	var root = cfb.FullPaths[0], fp = root, fi = cfb.FileIndex[0];&#13;
	for(var i = 1; i &lt; cfb.FullPaths.length; ++i) {&#13;
		fp = cfb.FullPaths[i].slice(root.length);&#13;
		fi = cfb.FileIndex[i];&#13;
		if(!fi.size || !fi.content || fp == "\u0001Sh33tJ5") continue;&#13;
&#13;
		/* Normalize filename */&#13;
		fp = fp.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7E-\xFF]/g, function(c) {&#13;
			return "_x" + c.charCodeAt(0).toString(16) + "_";&#13;
		}).replace(/[\u0080-\uFFFF]/g, function(u) {&#13;
			return "_u" + u.charCodeAt(0).toString(16) + "_";&#13;
		});&#13;
&#13;
		/* Extract content as binary string */&#13;
		var ca = fi.content;&#13;
		// $FlowIgnore&#13;
		var cstr = has_buf &amp;&amp; Buffer.isBuffer(ca) ? ca.toString("binary") : a2s(ca);&#13;
&#13;
		/* 4/5 of first 1024 chars ascii -&gt; quoted printable, else base64 */&#13;
		var dispcnt = 0, L = Math.min(1024, cstr.length), cc = 0;&#13;
		for(var csl = 0; csl &lt;= L; ++csl) if((cc=cstr.charCodeAt(csl)) &gt;= 0x20 &amp;&amp; cc &lt; 0x80) ++dispcnt;&#13;
		var qp = dispcnt &gt;= L * 4 / 5;&#13;
&#13;
		out.push(boundary);&#13;
		out.push('Content-Location: ' + (opts.root || 'file:///C:/xlsx/') + fp);&#13;
		out.push('Content-Transfer-Encoding: ' + (qp ? 'quoted-printable' : 'base64'));&#13;
		out.push('Content-Type: ' + get_content_type(fi, fp));&#13;
		out.push('');&#13;
&#13;
		out.push(qp ? write_quoted_printable(cstr) : write_base64_76(cstr));&#13;
	}&#13;
	out.push(boundary + '--\r\n');&#13;
	return out.join("\r\n");&#13;
}&#13;
function cfb_new(opts) {&#13;
	var o = ({});&#13;
	init_cfb(o, opts);&#13;
	return o;&#13;
}&#13;
&#13;
function cfb_add(cfb, name, content, opts) {&#13;
	var unsafe = opts &amp;&amp; opts.unsafe;&#13;
	if(!unsafe) init_cfb(cfb);&#13;
	var file = !unsafe &amp;&amp; CFB.find(cfb, name);&#13;
	if(!file) {&#13;
		var fpath = cfb.FullPaths[0];&#13;
		if(name.slice(0, fpath.length) == fpath) fpath = name;&#13;
		else {&#13;
			if(fpath.slice(-1) != "/") fpath += "/";&#13;
			fpath = (fpath + name).replace("//","/");&#13;
		}&#13;
		file = ({name: filename(name), type: 2});&#13;
		cfb.FileIndex.push(file);&#13;
		cfb.FullPaths.push(fpath);&#13;
		if(!unsafe) CFB.utils.cfb_gc(cfb);&#13;
	}&#13;
file.content = (content);&#13;
	file.size = content ? content.length : 0;&#13;
	if(opts) {&#13;
		if(opts.CLSID) file.clsid = opts.CLSID;&#13;
		if(opts.mt) file.mt = opts.mt;&#13;
		if(opts.ct) file.ct = opts.ct;&#13;
	}&#13;
	return file;&#13;
}&#13;
&#13;
function cfb_del(cfb, name) {&#13;
	init_cfb(cfb);&#13;
	var file = CFB.find(cfb, name);&#13;
	if(file) for(var j = 0; j &lt; cfb.FileIndex.length; ++j) if(cfb.FileIndex[j] == file) {&#13;
		cfb.FileIndex.splice(j, 1);&#13;
		cfb.FullPaths.splice(j, 1);&#13;
		return true;&#13;
	}&#13;
	return false;&#13;
}&#13;
&#13;
function cfb_mov(cfb, old_name, new_name) {&#13;
	init_cfb(cfb);&#13;
	var file = CFB.find(cfb, old_name);&#13;
	if(file) for(var j = 0; j &lt; cfb.FileIndex.length; ++j) if(cfb.FileIndex[j] == file) {&#13;
		cfb.FileIndex[j].name = filename(new_name);&#13;
		cfb.FullPaths[j] = new_name;&#13;
		return true;&#13;
	}&#13;
	return false;&#13;
}&#13;
&#13;
function cfb_gc(cfb) { rebuild_cfb(cfb, true); }&#13;
&#13;
exports.find = find;&#13;
exports.read = read;&#13;
exports.parse = parse;&#13;
exports.write = write;&#13;
exports.writeFile = write_file;&#13;
exports.utils = {&#13;
	cfb_new: cfb_new,&#13;
	cfb_add: cfb_add,&#13;
	cfb_del: cfb_del,&#13;
	cfb_mov: cfb_mov,&#13;
	cfb_gc: cfb_gc,&#13;
	ReadShift: ReadShift,&#13;
	CheckField: CheckField,&#13;
	prep_blob: prep_blob,&#13;
	bconcat: bconcat,&#13;
	use_zlib: use_zlib,&#13;
	_deflateRaw: _deflate,&#13;
	_inflateRaw: _inflate,&#13;
	consts: consts&#13;
};&#13;
&#13;
return exports;&#13;
})();&#13;
&#13;
var _fs;&#13;
function set_fs(fs) { _fs = fs; }&#13;
&#13;
/* normalize data for blob ctor */&#13;
function blobify(data) {&#13;
	if(typeof data === "string") return s2ab(data);&#13;
	if(Array.isArray(data)) return a2u(data);&#13;
	return data;&#13;
}&#13;
/* write or download file */&#13;
function write_dl(fname, payload, enc) {&#13;
	/*global IE_SaveFile, Blob, navigator, saveAs, document, File, chrome */&#13;
	if(typeof _fs !== 'undefined' &amp;&amp; _fs.writeFileSync) return enc ? _fs.writeFileSync(fname, payload, enc) : _fs.writeFileSync(fname, payload);&#13;
	if(typeof Deno !== 'undefined') {&#13;
		/* in this spot, it's safe to assume typed arrays and TextEncoder/TextDecoder exist */&#13;
		if(enc &amp;&amp; typeof payload == "string") switch(enc) {&#13;
			case "utf8": payload = new TextEncoder(enc).encode(payload); break;&#13;
			case "binary": payload = s2ab(payload); break;&#13;
			/* TODO: binary equivalent */&#13;
			default: throw new Error("Unsupported encoding " + enc);&#13;
		}&#13;
		return Deno.writeFileSync(fname, payload);&#13;
	}&#13;
	var data = (enc == "utf8") ? utf8write(payload) : payload;&#13;
if(typeof IE_SaveFile !== 'undefined') return IE_SaveFile(data, fname);&#13;
	if(typeof Blob !== 'undefined') {&#13;
		var blob = new Blob([blobify(data)], {type:"application/octet-stream"});&#13;
if(typeof navigator !== 'undefined' &amp;&amp; navigator.msSaveBlob) return navigator.msSaveBlob(blob, fname);&#13;
if(typeof saveAs !== 'undefined') return saveAs(blob, fname);&#13;
		if(typeof URL !== 'undefined' &amp;&amp; typeof document !== 'undefined' &amp;&amp; document.createElement &amp;&amp; URL.createObjectURL) {&#13;
			var url = URL.createObjectURL(blob);&#13;
if(typeof chrome === 'object' &amp;&amp; typeof (chrome.downloads||{}).download == "function") {&#13;
				if(URL.revokeObjectURL &amp;&amp; typeof setTimeout !== 'undefined') setTimeout(function() { URL.revokeObjectURL(url); }, 60000);&#13;
				return chrome.downloads.download({ url: url, filename: fname, saveAs: true});&#13;
			}&#13;
			var a = document.createElement("a");&#13;
			if(a.download != null) {&#13;
a.download = fname; a.href = url; document.body.appendChild(a); a.click();&#13;
document.body.removeChild(a);&#13;
				if(URL.revokeObjectURL &amp;&amp; typeof setTimeout !== 'undefined') setTimeout(function() { URL.revokeObjectURL(url); }, 60000);&#13;
				return url;&#13;
			}&#13;
		}&#13;
	}&#13;
	// $FlowIgnore&#13;
	if(typeof $ !== 'undefined' &amp;&amp; typeof File !== 'undefined' &amp;&amp; typeof Folder !== 'undefined') try { // extendscript&#13;
		// $FlowIgnore&#13;
		var out = File(fname); out.open("w"); out.encoding = "binary";&#13;
		if(Array.isArray(payload)) payload = a2s(payload);&#13;
		out.write(payload); out.close(); return payload;&#13;
	} catch(e) { if(!e.message || !e.message.match(/onstruct/)) throw e; }&#13;
	throw new Error("cannot save file " + fname);&#13;
}&#13;
&#13;
/* read binary data from file */&#13;
function read_binary(path) {&#13;
	if(typeof _fs !== 'undefined') return _fs.readFileSync(path);&#13;
	if(typeof Deno !== 'undefined') return Deno.readFileSync(path);&#13;
	// $FlowIgnore&#13;
	if(typeof $ !== 'undefined' &amp;&amp; typeof File !== 'undefined' &amp;&amp; typeof Folder !== 'undefined') try { // extendscript&#13;
		// $FlowIgnore&#13;
		var infile = File(path); infile.open("r"); infile.encoding = "binary";&#13;
		var data = infile.read(); infile.close();&#13;
		return data;&#13;
	} catch(e) { if(!e.message || !e.message.match(/onstruct/)) throw e; }&#13;
	throw new Error("Cannot access file " + path);&#13;
}&#13;
function keys(o) {&#13;
	var ks = Object.keys(o), o2 = [];&#13;
	for(var i = 0; i &lt; ks.length; ++i) if(Object.prototype.hasOwnProperty.call(o, ks[i])) o2.push(ks[i]);&#13;
	return o2;&#13;
}&#13;
&#13;
function evert_key(obj, key) {&#13;
	var o = ([]), K = keys(obj);&#13;
	for(var i = 0; i !== K.length; ++i) if(o[obj[K[i]][key]] == null) o[obj[K[i]][key]] = K[i];&#13;
	return o;&#13;
}&#13;
&#13;
function evert(obj) {&#13;
	var o = ([]), K = keys(obj);&#13;
	for(var i = 0; i !== K.length; ++i) o[obj[K[i]]] = K[i];&#13;
	return o;&#13;
}&#13;
&#13;
function evert_num(obj) {&#13;
	var o = ([]), K = keys(obj);&#13;
	for(var i = 0; i !== K.length; ++i) o[obj[K[i]]] = parseInt(K[i],10);&#13;
	return o;&#13;
}&#13;
&#13;
function evert_arr(obj) {&#13;
	var o = ([]), K = keys(obj);&#13;
	for(var i = 0; i !== K.length; ++i) {&#13;
		if(o[obj[K[i]]] == null) o[obj[K[i]]] = [];&#13;
		o[obj[K[i]]].push(K[i]);&#13;
	}&#13;
	return o;&#13;
}&#13;
&#13;
var basedate = new Date(1899, 11, 30, 0, 0, 0); // 2209161600000&#13;
function datenum(v, date1904) {&#13;
	var epoch = v.getTime();&#13;
	if(date1904) epoch -= 1462*24*60*60*1000;&#13;
	var dnthresh = basedate.getTime() + (v.getTimezoneOffset() - basedate.getTimezoneOffset()) * 60000;&#13;
	return (epoch - dnthresh) / (24 * 60 * 60 * 1000);&#13;
}&#13;
var refdate = new Date();&#13;
var dnthresh = basedate.getTime() + (refdate.getTimezoneOffset() - basedate.getTimezoneOffset()) * 60000;&#13;
var refoffset = refdate.getTimezoneOffset();&#13;
function numdate(v) {&#13;
	var out = new Date();&#13;
	out.setTime(v * 24 * 60 * 60 * 1000 + dnthresh);&#13;
	if (out.getTimezoneOffset() !== refoffset) {&#13;
		out.setTime(out.getTime() + (out.getTimezoneOffset() - refoffset) * 60000);&#13;
	}&#13;
	return out;&#13;
}&#13;
&#13;
/* ISO 8601 Duration */&#13;
function parse_isodur(s) {&#13;
	var sec = 0, mt = 0, time = false;&#13;
	var m = s.match(/P([0-9\.]+Y)?([0-9\.]+M)?([0-9\.]+D)?T([0-9\.]+H)?([0-9\.]+M)?([0-9\.]+S)?/);&#13;
	if(!m) throw new Error("|" + s + "| is not an ISO8601 Duration");&#13;
	for(var i = 1; i != m.length; ++i) {&#13;
		if(!m[i]) continue;&#13;
		mt = 1;&#13;
		if(i &gt; 3) time = true;&#13;
		switch(m[i].slice(m[i].length-1)) {&#13;
			case 'Y':&#13;
				throw new Error("Unsupported ISO Duration Field: " + m[i].slice(m[i].length-1));&#13;
			case 'D': mt *= 24;&#13;
				/* falls through */&#13;
			case 'H': mt *= 60;&#13;
				/* falls through */&#13;
			case 'M':&#13;
				if(!time) throw new Error("Unsupported ISO Duration Field: M");&#13;
				else mt *= 60;&#13;
				/* falls through */&#13;
			case 'S': break;&#13;
		}&#13;
		sec += mt * parseInt(m[i], 10);&#13;
	}&#13;
	return sec;&#13;
}&#13;
&#13;
var good_pd_date_1 = new Date('2017-02-19T19:06:09.000Z');&#13;
var good_pd_date = isNaN(good_pd_date_1.getFullYear()) ? new Date('2/19/17') : good_pd_date_1;&#13;
var good_pd = good_pd_date.getFullYear() == 2017;&#13;
/* parses a date as a local date */&#13;
function parseDate(str, fixdate) {&#13;
	var d = new Date(str);&#13;
	if(good_pd) {&#13;
if(fixdate &gt; 0) d.setTime(d.getTime() + d.getTimezoneOffset() * 60 * 1000);&#13;
		else if(fixdate &lt; 0) d.setTime(d.getTime() - d.getTimezoneOffset() * 60 * 1000);&#13;
		return d;&#13;
	}&#13;
	if(str instanceof Date) return str;&#13;
	if(good_pd_date.getFullYear() == 1917 &amp;&amp; !isNaN(d.getFullYear())) {&#13;
		var s = d.getFullYear();&#13;
		if(str.indexOf("" + s) &gt; -1) return d;&#13;
		d.setFullYear(d.getFullYear() + 100); return d;&#13;
	}&#13;
	var n = str.match(/\d+/g)||["2017","2","19","0","0","0"];&#13;
	var out = new Date(+n[0], +n[1] - 1, +n[2], (+n[3]||0), (+n[4]||0), (+n[5]||0));&#13;
	if(str.indexOf("Z") &gt; -1) out = new Date(out.getTime() - out.getTimezoneOffset() * 60 * 1000);&#13;
	return out;&#13;
}&#13;
&#13;
function cc2str(arr, debomit) {&#13;
	if(has_buf &amp;&amp; Buffer.isBuffer(arr)) {&#13;
		if(debomit &amp;&amp; buf_utf16le) {&#13;
			// TODO: temporary patch&#13;
			if(arr[0] == 0xFF &amp;&amp; arr[1] == 0xFE) return utf8write(arr.slice(2).toString("utf16le"));&#13;
			if(arr[1] == 0xFE &amp;&amp; arr[2] == 0xFF) return utf8write(utf16beread(arr.slice(2).toString("binary")));&#13;
		}&#13;
		return arr.toString("binary");&#13;
	}&#13;
&#13;
	if(typeof TextDecoder !== "undefined") try {&#13;
		if(debomit) {&#13;
			if(arr[0] == 0xFF &amp;&amp; arr[1] == 0xFE) return utf8write(new TextDecoder("utf-16le").decode(arr.slice(2)));&#13;
			if(arr[0] == 0xFE &amp;&amp; arr[1] == 0xFF) return utf8write(new TextDecoder("utf-16be").decode(arr.slice(2)));&#13;
		}&#13;
		var rev = {&#13;
			"\u20ac": "\x80", "\u201a": "\x82", "\u0192": "\x83", "\u201e": "\x84",&#13;
			"\u2026": "\x85", "\u2020": "\x86", "\u2021": "\x87", "\u02c6": "\x88",&#13;
			"\u2030": "\x89", "\u0160": "\x8a", "\u2039": "\x8b", "\u0152": "\x8c",&#13;
			"\u017d": "\x8e", "\u2018": "\x91", "\u2019": "\x92", "\u201c": "\x93",&#13;
			"\u201d": "\x94", "\u2022": "\x95", "\u2013": "\x96", "\u2014": "\x97",&#13;
			"\u02dc": "\x98", "\u2122": "\x99", "\u0161": "\x9a", "\u203a": "\x9b",&#13;
			"\u0153": "\x9c", "\u017e": "\x9e", "\u0178": "\x9f"&#13;
		};&#13;
		if(Array.isArray(arr)) arr = new Uint8Array(arr);&#13;
		return new TextDecoder("latin1").decode(arr).replace(/[€‚ƒ„…†‡ˆ‰Š‹ŒŽ''""•–—˜™š›œžŸ]/g, function(c) { return rev[c] || c; });&#13;
	} catch(e) {}&#13;
&#13;
	var o = [];&#13;
	for(var i = 0; i != arr.length; ++i) o.push(String.fromCharCode(arr[i]));&#13;
	return o.join("");&#13;
}&#13;
&#13;
function dup(o) {&#13;
	if(typeof JSON != 'undefined' &amp;&amp; !Array.isArray(o)) return JSON.parse(JSON.stringify(o));&#13;
	if(typeof o != 'object' || o == null) return o;&#13;
	if(o instanceof Date) return new Date(o.getTime());&#13;
	var out = {};&#13;
	for(var k in o) if(Object.prototype.hasOwnProperty.call(o, k)) out[k] = dup(o[k]);&#13;
	return out;&#13;
}&#13;
&#13;
function fill(c,l) { var o = ""; while(o.length &lt; l) o+=c; return o; }&#13;
&#13;
/* TODO: stress test */&#13;
function fuzzynum(s) {&#13;
	var v = Number(s);&#13;
	if(!isNaN(v)) return isFinite(v) ? v : NaN;&#13;
	if(!/\d/.test(s)) return v;&#13;
	var wt = 1;&#13;
	var ss = s.replace(/([\d]),([\d])/g,"$1$2").replace(/[$]/g,"").replace(/[%]/g, function() { wt *= 100; return "";});&#13;
	if(!isNaN(v = Number(ss))) return v / wt;&#13;
	ss = ss.replace(/[(](.*)[)]/,function($$, $1) { wt = -wt; return $1;});&#13;
	if(!isNaN(v = Number(ss))) return v / wt;&#13;
	return v;&#13;
}&#13;
&#13;
/* NOTE: Chrome rejects bare times like 1:23 PM */&#13;
var FDRE1 = /^(0?\d|1[0-2])(?:|:([0-5]?\d)(?:|(\.\d+)(?:|:([0-5]?\d))|:([0-5]?\d)(|\.\d+)))\s+([ap])m?$/;&#13;
&#13;
function fuzzytime1(M)  {&#13;
    /* TODO: 1904 adjustment, keep in sync with base date */&#13;
    if(!M[2]) return new Date(1899,11,30,(+M[1]%12) + (M[7] == "p" ? 12 : 0), 0, 0, 0);&#13;
    if(M[3]) {&#13;
        if(M[4]) return new Date(1899,11,30,(+M[1]%12) + (M[7] == "p" ? 12 : 0), +M[2], +M[4], parseFloat(M[3])*1000);&#13;
        else return new Date(1899,11,30,(M[7] == "p" ? 12 : 0), +M[1], +M[2], parseFloat(M[3])*1000);&#13;
    }&#13;
    else if(M[5]) return new Date(1899,11,30, (+M[1]%12) + (M[7] == "p" ? 12 : 0), +M[2], +M[5], M[6] ? parseFloat(M[6]) * 1000 : 0);&#13;
    else return new Date(1899,11,30,(+M[1]%12) + (M[7] == "p" ? 12 : 0), +M[2], 0, 0);&#13;
}&#13;
var lower_months = ['january', 'february', 'march', 'april', 'may', 'june', 'july', 'august', 'september', 'october', 'november', 'december'];&#13;
function fuzzydate(s) {&#13;
	var lower = s.toLowerCase();&#13;
	var lnos = lower.replace(/\s+/g, " ").trim();&#13;
	var M = lnos.match(FDRE1);&#13;
	if(M) return fuzzytime1(M);&#13;
&#13;
	var o = new Date(s), n = new Date(NaN);&#13;
	var y = o.getYear(), m = o.getMonth(), d = o.getDate();&#13;
	if(isNaN(d)) return n;&#13;
	if(lower.match(/jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec/)) {&#13;
		lower = lower.replace(/[^a-z]/g,"").replace(/([^a-z]|^)[ap]m?([^a-z]|$)/,"");&#13;
		if(lower.length &gt; 3 &amp;&amp; lower_months.indexOf(lower) == -1) return n;&#13;
	} else if(lower.replace(/[ap]m?/, "").match(/[a-z]/)) return n;&#13;
	if(y &lt; 0 || y &gt; 8099 || s.match(/[^-0-9:,\/\\]/)) return n;&#13;
	return o;&#13;
}&#13;
&#13;
var split_regex = (function() {&#13;
	var safe_split_regex = "abacaba".split(/(:?b)/i).length == 5;&#13;
	return function split_regex(str, re, def) {&#13;
		if(safe_split_regex || typeof re == "string") return str.split(re);&#13;
		var p = str.split(re), o = [p[0]];&#13;
		for(var i = 1; i &lt; p.length; ++i) { o.push(def); o.push(p[i]); }&#13;
		return o;&#13;
	};&#13;
})();&#13;
function getdatastr(data) {&#13;
	if(!data) return null;&#13;
	if(data.content &amp;&amp; data.type) return cc2str(data.content, true);&#13;
	if(data.data) return debom(data.data);&#13;
	if(data.asNodeBuffer &amp;&amp; has_buf) return debom(data.asNodeBuffer().toString('binary'));&#13;
	if(data.asBinary) return debom(data.asBinary());&#13;
	if(data._data &amp;&amp; data._data.getContent) return debom(cc2str(Array.prototype.slice.call(data._data.getContent(),0)));&#13;
	return null;&#13;
}&#13;
&#13;
function getdatabin(data) {&#13;
	if(!data) return null;&#13;
	if(data.data) return char_codes(data.data);&#13;
	if(data.asNodeBuffer &amp;&amp; has_buf) return data.asNodeBuffer();&#13;
	if(data._data &amp;&amp; data._data.getContent) {&#13;
		var o = data._data.getContent();&#13;
		if(typeof o == "string") return char_codes(o);&#13;
		return Array.prototype.slice.call(o);&#13;
	}&#13;
	if(data.content &amp;&amp; data.type) return data.content;&#13;
	return null;&#13;
}&#13;
&#13;
function getdata(data) { return (data &amp;&amp; data.name.slice(-4) === ".bin") ? getdatabin(data) : getdatastr(data); }&#13;
&#13;
/* Part 2 Section 10.1.2 "Mapping Content Types" Names are case-insensitive */&#13;
/* OASIS does not comment on filename case sensitivity */&#13;
function safegetzipfile(zip, file) {&#13;
	var k = zip.FullPaths || keys(zip.files);&#13;
	var f = file.toLowerCase().replace(/[\/]/g, '\\'), g = f.replace(/\\/g,'\/');&#13;
	for(var i=0; i&lt;k.length; ++i) {&#13;
		var n = k[i].replace(/^Root Entry[\/]/,"").toLowerCase();&#13;
		if(f == n || g == n) return zip.files ? zip.files[k[i]] : zip.FileIndex[i];&#13;
	}&#13;
	return null;&#13;
}&#13;
&#13;
function getzipfile(zip, file) {&#13;
	var o = safegetzipfile(zip, file);&#13;
	if(o == null) throw new Error("Cannot find file " + file + " in zip");&#13;
	return o;&#13;
}&#13;
&#13;
function getzipdata(zip, file, safe) {&#13;
	if(!safe) return getdata(getzipfile(zip, file));&#13;
	if(!file) return null;&#13;
	try { return getzipdata(zip, file); } catch(e) { return null; }&#13;
}&#13;
&#13;
function getzipstr(zip, file, safe) {&#13;
	if(!safe) return getdatastr(getzipfile(zip, file));&#13;
	if(!file) return null;&#13;
	try { return getzipstr(zip, file); } catch(e) { return null; }&#13;
}&#13;
&#13;
function getzipbin(zip, file, safe) {&#13;
	if(!safe) return getdatabin(getzipfile(zip, file));&#13;
	if(!file) return null;&#13;
	try { return getzipbin(zip, file); } catch(e) { return null; }&#13;
}&#13;
&#13;
function zipentries(zip) {&#13;
	var k = zip.FullPaths || keys(zip.files), o = [];&#13;
	for(var i = 0; i &lt; k.length; ++i) if(k[i].slice(-1) != '/') o.push(k[i].replace(/^Root Entry[\/]/, ""));&#13;
	return o.sort();&#13;
}&#13;
&#13;
function zip_add_file(zip, path, content) {&#13;
	if(zip.FullPaths) {&#13;
		if(typeof content == "string") {&#13;
			var res;&#13;
			if(has_buf) res = Buffer_from(content);&#13;
			/* TODO: investigate performance in Edge 13 */&#13;
			//else if(typeof TextEncoder !== "undefined") res = new TextEncoder().encode(content);&#13;
			else res = utf8decode(content);&#13;
			return CFB.utils.cfb_add(zip, path, res);&#13;
		}&#13;
		CFB.utils.cfb_add(zip, path, content);&#13;
	}&#13;
	else zip.file(path, content);&#13;
}&#13;
&#13;
function zip_new() { return CFB.utils.cfb_new(); }&#13;
&#13;
function zip_read(d, o) {&#13;
	switch(o.type) {&#13;
		case "base64": return CFB.read(d, { type: "base64" });&#13;
		case "binary": return CFB.read(d, { type: "binary" });&#13;
		case "buffer": case "array": return CFB.read(d, { type: "buffer" });&#13;
	}&#13;
	throw new Error("Unrecognized type " + o.type);&#13;
}&#13;
&#13;
function resolve_path(path, base) {&#13;
	if(path.charAt(0) == "/") return path.slice(1);&#13;
	var result = base.split('/');&#13;
	if(base.slice(-1) != "/") result.pop(); // folder path&#13;
	var target = path.split('/');&#13;
	while (target.length !== 0) {&#13;
		var step = target.shift();&#13;
		if (step === '..') result.pop();&#13;
		else if (step !== '.') result.push(step);&#13;
	}&#13;
	return result.join('/');&#13;
}&#13;
var XML_HEADER = '&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;\r\n';&#13;
var attregexg=/([^"\s?&gt;\/]+)\s*=\s*((?:")([^"]*)(?:")|(?:')([^']*)(?:')|([^'"&gt;\s]+))/g;&#13;
var tagregex1=/&lt;[\/\?]?[a-zA-Z0-9:_-]+(?:\s+[^"\s?&gt;\/]+\s*=\s*(?:"[^"]*"|'[^']*'|[^'"&gt;\s=]+))*\s*[\/\?]?&gt;/mg, tagregex2 = /&lt;[^&gt;]*&gt;/g;&#13;
var tagregex = XML_HEADER.match(tagregex1) ? tagregex1 : tagregex2;&#13;
var nsregex=/&lt;\w*:/, nsregex2 = /&lt;(\/?)\w+:/;&#13;
function parsexmltag(tag, skip_root, skip_LC) {&#13;
	var z = ({});&#13;
	var eq = 0, c = 0;&#13;
	for(; eq !== tag.length; ++eq) if((c = tag.charCodeAt(eq)) === 32 || c === 10 || c === 13) break;&#13;
	if(!skip_root) z[0] = tag.slice(0, eq);&#13;
	if(eq === tag.length) return z;&#13;
	var m = tag.match(attregexg), j=0, v="", i=0, q="", cc="", quot = 1;&#13;
	if(m) for(i = 0; i != m.length; ++i) {&#13;
		cc = m[i];&#13;
		for(c=0; c != cc.length; ++c) if(cc.charCodeAt(c) === 61) break;&#13;
		q = cc.slice(0,c).trim();&#13;
		while(cc.charCodeAt(c+1) == 32) ++c;&#13;
		quot = ((eq=cc.charCodeAt(c+1)) == 34 || eq == 39) ? 1 : 0;&#13;
		v = cc.slice(c+1+quot, cc.length-quot);&#13;
		for(j=0;j!=q.length;++j) if(q.charCodeAt(j) === 58) break;&#13;
		if(j===q.length) {&#13;
			if(q.indexOf("_") &gt; 0) q = q.slice(0, q.indexOf("_")); // from ods&#13;
			z[q] = v;&#13;
			if(!skip_LC) z[q.toLowerCase()] = v;&#13;
		}&#13;
		else {&#13;
			var k = (j===5 &amp;&amp; q.slice(0,5)==="xmlns"?"xmlns":"")+q.slice(j+1);&#13;
			if(z[k] &amp;&amp; q.slice(j-3,j) == "ext") continue; // from ods&#13;
			z[k] = v;&#13;
			if(!skip_LC) z[k.toLowerCase()] = v;&#13;
		}&#13;
	}&#13;
	return z;&#13;
}&#13;
function strip_ns(x) { return x.replace(nsregex2, "&lt;$1"); }&#13;
&#13;
var encodings = {&#13;
	'&amp;quot;': '"',&#13;
	'&amp;apos;': "'",&#13;
	'&amp;gt;': '&gt;',&#13;
	'&amp;lt;': '&lt;',&#13;
	'&amp;amp;': '&amp;'&#13;
};&#13;
var rencoding = evert(encodings);&#13;
//var rencstr = "&amp;&lt;&gt;'\"".split("");&#13;
&#13;
// TODO: CP remap (need to read file version to determine OS)&#13;
var unescapexml = (function() {&#13;
	/* 22.4.2.4 bstr (Basic String) */&#13;
	var encregex = /&amp;(?:quot|apos|gt|lt|amp|#x?([\da-fA-F]+));/ig, coderegex = /_x([\da-fA-F]{4})_/ig;&#13;
	function raw_unescapexml(text) {&#13;
		var s = text + '', i = s.indexOf("&lt;![CDATA[");&#13;
		if(i == -1) return s.replace(encregex, function($$, $1) { return encodings[$$]||String.fromCharCode(parseInt($1,$$.indexOf("x")&gt;-1?16:10))||$$; }).replace(coderegex,function(m,c) {return String.fromCharCode(parseInt(c,16));});&#13;
		var j = s.indexOf("]]&gt;");&#13;
		return raw_unescapexml(s.slice(0, i)) + s.slice(i+9,j) + raw_unescapexml(s.slice(j+3));&#13;
	}&#13;
	return function unescapexml(text, xlsx) {&#13;
		var out = raw_unescapexml(text);&#13;
		return xlsx ? out.replace(/\r\n/g, "\n") : out;&#13;
	};&#13;
})();&#13;
&#13;
var decregex=/[&amp;&lt;&gt;'"]/g, charegex = /[\u0000-\u0008\u000b-\u001f\uFFFE-\uFFFF]/g;&#13;
function escapexml(text){&#13;
	var s = text + '';&#13;
	return s.replace(decregex, function(y) { return rencoding[y]; }).replace(charegex,function(s) { return "_x" + ("000"+s.charCodeAt(0).toString(16)).slice(-4) + "_";});&#13;
}&#13;
function escapexmltag(text){ return escapexml(text).replace(/ /g,"_x0020_"); }&#13;
&#13;
var htmlcharegex = /[\u0000-\u001f]/g;&#13;
function escapehtml(text){&#13;
	var s = text + '';&#13;
	return s.replace(decregex, function(y) { return rencoding[y]; }).replace(/\n/g, "&lt;br/&gt;").replace(htmlcharegex,function(s) { return "&amp;#x" + ("000"+s.charCodeAt(0).toString(16)).slice(-4) + ";"; });&#13;
}&#13;
&#13;
function escapexlml(text){&#13;
	var s = text + '';&#13;
	return s.replace(decregex, function(y) { return rencoding[y]; }).replace(htmlcharegex,function(s) { return "&amp;#x" + (s.charCodeAt(0).toString(16)).toUpperCase() + ";"; });&#13;
}&#13;
&#13;
/* TODO: handle codepages */&#13;
var xlml_fixstr = (function() {&#13;
	var entregex = /&amp;#(\d+);/g;&#13;
	function entrepl($$,$1) { return String.fromCharCode(parseInt($1,10)); }&#13;
	return function xlml_fixstr(str) { return str.replace(entregex,entrepl); };&#13;
})();&#13;
function xlml_unfixstr(str) { return str.replace(/(\r\n|[\r\n])/g,"\&amp;#10;"); }&#13;
&#13;
/* note: xsd:boolean valid values: true / 1 / false / 0 */&#13;
function parsexmlbool(value) {&#13;
	switch(value) {&#13;
		case 1: case true:  case '1': case 'true':  return true;&#13;
		case 0: case false: case '0': case 'false': return false;&#13;
		//default: throw new Error("Invalid xsd:boolean " + value);&#13;
	}&#13;
	return false;&#13;
}&#13;
&#13;
function utf8reada(orig) {&#13;
	var out = "", i = 0, c = 0, d = 0, e = 0, f = 0, w = 0;&#13;
	while (i &lt; orig.length) {&#13;
		c = orig.charCodeAt(i++);&#13;
		if (c &lt; 128) { out += String.fromCharCode(c); continue; }&#13;
		d = orig.charCodeAt(i++);&#13;
		if (c&gt;191 &amp;&amp; c&lt;224) { f = ((c &amp; 31) &lt;&lt; 6); f |= (d &amp; 63); out += String.fromCharCode(f); continue; }&#13;
		e = orig.charCodeAt(i++);&#13;
		if (c &lt; 240) { out += String.fromCharCode(((c &amp; 15) &lt;&lt; 12) | ((d &amp; 63) &lt;&lt; 6) | (e &amp; 63)); continue; }&#13;
		f = orig.charCodeAt(i++);&#13;
		w = (((c &amp; 7) &lt;&lt; 18) | ((d &amp; 63) &lt;&lt; 12) | ((e &amp; 63) &lt;&lt; 6) | (f &amp; 63))-65536;&#13;
		out += String.fromCharCode(0xD800 + ((w&gt;&gt;&gt;10)&amp;1023));&#13;
		out += String.fromCharCode(0xDC00 + (w&amp;1023));&#13;
	}&#13;
	return out;&#13;
}&#13;
&#13;
function utf8readb(data) {&#13;
	var out = new_raw_buf(2*data.length), w, i, j = 1, k = 0, ww=0, c;&#13;
	for(i = 0; i &lt; data.length; i+=j) {&#13;
		j = 1;&#13;
		if((c=data.charCodeAt(i)) &lt; 128) w = c;&#13;
		else if(c &lt; 224) { w = (c&amp;31)*64+(data.charCodeAt(i+1)&amp;63); j=2; }&#13;
		else if(c &lt; 240) { w=(c&amp;15)*4096+(data.charCodeAt(i+1)&amp;63)*64+(data.charCodeAt(i+2)&amp;63); j=3; }&#13;
		else { j = 4;&#13;
			w = (c &amp; 7)*262144+(data.charCodeAt(i+1)&amp;63)*4096+(data.charCodeAt(i+2)&amp;63)*64+(data.charCodeAt(i+3)&amp;63);&#13;
			w -= 65536; ww = 0xD800 + ((w&gt;&gt;&gt;10)&amp;1023); w = 0xDC00 + (w&amp;1023);&#13;
		}&#13;
		if(ww !== 0) { out[k++] = ww&amp;255; out[k++] = ww&gt;&gt;&gt;8; ww = 0; }&#13;
		out[k++] = w%256; out[k++] = w&gt;&gt;&gt;8;&#13;
	}&#13;
	return out.slice(0,k).toString('ucs2');&#13;
}&#13;
&#13;
function utf8readc(data) { return Buffer_from(data, 'binary').toString('utf8'); }&#13;
&#13;
var utf8corpus = "foo bar baz\u00e2\u0098\u0083\u00f0\u009f\u008d\u00a3";&#13;
var utf8read = has_buf &amp;&amp; (utf8readc(utf8corpus) == utf8reada(utf8corpus) &amp;&amp; utf8readc || utf8readb(utf8corpus) == utf8reada(utf8corpus) &amp;&amp; utf8readb) || utf8reada;&#13;
&#13;
var utf8write = has_buf ? function(data) { return Buffer_from(data, 'utf8').toString("binary"); } : function(orig) {&#13;
	var out = [], i = 0, c = 0, d = 0;&#13;
	while(i &lt; orig.length) {&#13;
		c = orig.charCodeAt(i++);&#13;
		switch(true) {&#13;
			case c &lt; 128: out.push(String.fromCharCode(c)); break;&#13;
			case c &lt; 2048:&#13;
				out.push(String.fromCharCode(192 + (c &gt;&gt; 6)));&#13;
				out.push(String.fromCharCode(128 + (c &amp; 63)));&#13;
				break;&#13;
			case c &gt;= 55296 &amp;&amp; c &lt; 57344:&#13;
				c -= 55296; d = orig.charCodeAt(i++) - 56320 + (c&lt;&lt;10);&#13;
				out.push(String.fromCharCode(240 + ((d &gt;&gt;18) &amp; 7)));&#13;
				out.push(String.fromCharCode(144 + ((d &gt;&gt;12) &amp; 63)));&#13;
				out.push(String.fromCharCode(128 + ((d &gt;&gt; 6) &amp; 63)));&#13;
				out.push(String.fromCharCode(128 + (d &amp; 63)));&#13;
				break;&#13;
			default:&#13;
				out.push(String.fromCharCode(224 + (c &gt;&gt; 12)));&#13;
				out.push(String.fromCharCode(128 + ((c &gt;&gt; 6) &amp; 63)));&#13;
				out.push(String.fromCharCode(128 + (c &amp; 63)));&#13;
		}&#13;
	}&#13;
	return out.join("");&#13;
};&#13;
&#13;
// matches &lt;foo&gt;...&lt;/foo&gt; extracts content&#13;
var matchtag = (function() {&#13;
	var mtcache = ({});&#13;
	return function matchtag(f,g) {&#13;
		var t = f+"|"+(g||"");&#13;
		if(mtcache[t]) return mtcache[t];&#13;
		return (mtcache[t] = new RegExp('&lt;(?:\\w+:)?'+f+'(?: xml:space="preserve")?(?:[^&gt;]*)&gt;([\\s\\S]*?)&lt;/(?:\\w+:)?'+f+'&gt;',((g||""))));&#13;
	};&#13;
})();&#13;
&#13;
var htmldecode = (function() {&#13;
	var entities = [&#13;
		['nbsp', ' '], ['middot', '·'],&#13;
		['quot', '"'], ['apos', "'"], ['gt',   '&gt;'], ['lt',   '&lt;'], ['amp',  '&amp;']&#13;
	].map(function(x) { return [new RegExp('&amp;' + x[0] + ';', "ig"), x[1]]; });&#13;
	return function htmldecode(str) {&#13;
		var o = str&#13;
				// Remove new lines and spaces from start of content&#13;
				.replace(/^[\t\n\r ]+/, "")&#13;
				// Remove new lines and spaces from end of content&#13;
				.replace(/[\t\n\r ]+$/,"")&#13;
				// Added line which removes any white space characters after and before html tags&#13;
				.replace(/&gt;\s+/g,"&gt;").replace(/\s+&lt;/g,"&lt;")&#13;
				// Replace remaining new lines and spaces with space&#13;
				.replace(/[\t\n\r ]+/g, " ")&#13;
				// Replace &lt;br&gt; tags with new lines&#13;
				.replace(/&lt;\s*[bB][rR]\s*\/?&gt;/g,"\n")&#13;
				// Strip HTML elements&#13;
				.replace(/&lt;[^&gt;]*&gt;/g,"");&#13;
		for(var i = 0; i &lt; entities.length; ++i) o = o.replace(entities[i][0], entities[i][1]);&#13;
		return o;&#13;
	};&#13;
})();&#13;
&#13;
var vtregex = (function(){ var vt_cache = {};&#13;
	return function vt_regex(bt) {&#13;
		if(vt_cache[bt] !== undefined) return vt_cache[bt];&#13;
		return (vt_cache[bt] = new RegExp("&lt;(?:vt:)?" + bt + "&gt;([\\s\\S]*?)&lt;/(?:vt:)?" + bt + "&gt;", 'g') );&#13;
};})();&#13;
var vtvregex = /&lt;\/?(?:vt:)?variant&gt;/g, vtmregex = /&lt;(?:vt:)([^&gt;]*)&gt;([\s\S]*)&lt;/;&#13;
function parseVector(data, opts) {&#13;
	var h = parsexmltag(data);&#13;
&#13;
	var matches = data.match(vtregex(h.baseType))||[];&#13;
	var res = [];&#13;
	if(matches.length != h.size) {&#13;
		if(opts.WTF) throw new Error("unexpected vector length " + matches.length + " != " + h.size);&#13;
		return res;&#13;
	}&#13;
	matches.forEach(function(x) {&#13;
		var v = x.replace(vtvregex,"").match(vtmregex);&#13;
		if(v) res.push({v:utf8read(v[2]), t:v[1]});&#13;
	});&#13;
	return res;&#13;
}&#13;
&#13;
var wtregex = /(^\s|\s$|\n)/;&#13;
function writetag(f,g) { return '&lt;' + f + (g.match(wtregex)?' xml:space="preserve"' : "") + '&gt;' + g + '&lt;/' + f + '&gt;'; }&#13;
&#13;
function wxt_helper(h) { return keys(h).map(function(k) { return " " + k + '="' + h[k] + '"';}).join(""); }&#13;
function writextag(f,g,h) { return '&lt;' + f + ((h != null) ? wxt_helper(h) : "") + ((g != null) ? (g.match(wtregex)?' xml:space="preserve"' : "") + '&gt;' + g + '&lt;/' + f : "/") + '&gt;';}&#13;
&#13;
function write_w3cdtf(d, t) { try { return d.toISOString().replace(/\.\d*/,""); } catch(e) { if(t) throw e; } return ""; }&#13;
&#13;
function write_vt(s, xlsx) {&#13;
	switch(typeof s) {&#13;
		case 'string':&#13;
			var o = writextag('vt:lpwstr', escapexml(s));&#13;
			if(xlsx) o = o.replace(/&amp;quot;/g, "_x0022_");&#13;
			return o;&#13;
		case 'number': return writextag((s|0)==s?'vt:i4':'vt:r8', escapexml(String(s)));&#13;
		case 'boolean': return writextag('vt:bool',s?'true':'false');&#13;
	}&#13;
	if(s instanceof Date) return writextag('vt:filetime', write_w3cdtf(s));&#13;
	throw new Error("Unable to serialize " + s);&#13;
}&#13;
&#13;
function xlml_normalize(d) {&#13;
	if(has_buf &amp;&amp; Buffer.isBuffer(d)) return d.toString('utf8');&#13;
	if(typeof d === 'string') return d;&#13;
	/* duktape */&#13;
	if(typeof Uint8Array !== 'undefined' &amp;&amp; d instanceof Uint8Array) return utf8read(a2s(ab2a(d)));&#13;
	throw new Error("Bad input format: expected Buffer or string");&#13;
}&#13;
/* UOS uses CJK in tags */&#13;
var xlmlregex = /&lt;(\/?)([^\s?&gt;&lt;!\/:]*:|)([^\s?&lt;&gt;:\/]+)(?:[\s?:\/](?:[^&gt;=]|="[^"]*?")*)?&gt;/mg;&#13;
//var xlmlregex = /&lt;(\/?)([a-z0-9]*:|)(\w+)[^&gt;]*&gt;/mg;&#13;
&#13;
var XMLNS = ({&#13;
	CORE_PROPS: 'http://schemas.openxmlformats.org/package/2006/metadata/core-properties',&#13;
	CUST_PROPS: "http://schemas.openxmlformats.org/officeDocument/2006/custom-properties",&#13;
	EXT_PROPS: "http://schemas.openxmlformats.org/officeDocument/2006/extended-properties",&#13;
	CT: 'http://schemas.openxmlformats.org/package/2006/content-types',&#13;
	RELS: 'http://schemas.openxmlformats.org/package/2006/relationships',&#13;
	TCMNT: 'http://schemas.microsoft.com/office/spreadsheetml/2018/threadedcomments',&#13;
	'dc': 'http://purl.org/dc/elements/1.1/',&#13;
	'dcterms': 'http://purl.org/dc/terms/',&#13;
	'dcmitype': 'http://purl.org/dc/dcmitype/',&#13;
	'mx': 'http://schemas.microsoft.com/office/mac/excel/2008/main',&#13;
	'r': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships',&#13;
	'sjs': 'http://schemas.openxmlformats.org/package/2006/sheetjs/core-properties',&#13;
	'vt': 'http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes',&#13;
	'xsi': 'http://www.w3.org/2001/XMLSchema-instance',&#13;
	'xsd': 'http://www.w3.org/2001/XMLSchema'&#13;
});&#13;
&#13;
var XMLNS_main = [&#13;
	'http://schemas.openxmlformats.org/spreadsheetml/2006/main',&#13;
	'http://purl.oclc.org/ooxml/spreadsheetml/main',&#13;
	'http://schemas.microsoft.com/office/excel/2006/main',&#13;
	'http://schemas.microsoft.com/office/excel/2006/2'&#13;
];&#13;
&#13;
var XLMLNS = ({&#13;
	'o':    'urn:schemas-microsoft-com:office:office',&#13;
	'x':    'urn:schemas-microsoft-com:office:excel',&#13;
	'ss':   'urn:schemas-microsoft-com:office:spreadsheet',&#13;
	'dt':   'uuid:C2F41010-65B3-11d1-A29F-00AA00C14882',&#13;
	'mv':   'http://macVmlSchemaUri',&#13;
	'v':    'urn:schemas-microsoft-com:vml',&#13;
	'html': 'http://www.w3.org/TR/REC-html40'&#13;
});&#13;
function read_double_le(b, idx) {&#13;
	var s = 1 - 2 * (b[idx + 7] &gt;&gt;&gt; 7);&#13;
	var e = ((b[idx + 7] &amp; 0x7f) &lt;&lt; 4) + ((b[idx + 6] &gt;&gt;&gt; 4) &amp; 0x0f);&#13;
	var m = (b[idx+6]&amp;0x0f);&#13;
	for(var i = 5; i &gt;= 0; --i) m = m * 256 + b[idx + i];&#13;
	if(e == 0x7ff) return m == 0 ? (s * Infinity) : NaN;&#13;
	if(e == 0) e = -1022;&#13;
	else { e -= 1023; m += Math.pow(2,52); }&#13;
	return s * Math.pow(2, e - 52) * m;&#13;
}&#13;
&#13;
function write_double_le(b, v, idx) {&#13;
	var bs = ((((v &lt; 0) || (1/v == -Infinity)) ? 1 : 0) &lt;&lt; 7), e = 0, m = 0;&#13;
	var av = bs ? (-v) : v;&#13;
	if(!isFinite(av)) { e = 0x7ff; m = isNaN(v) ? 0x6969 : 0; }&#13;
	else if(av == 0) e = m = 0;&#13;
	else {&#13;
		e = Math.floor(Math.log(av) / Math.LN2);&#13;
		m = av * Math.pow(2, 52 - e);&#13;
		if((e &lt;= -1023) &amp;&amp; (!isFinite(m) || (m &lt; Math.pow(2,52)))) { e = -1022; }&#13;
		else { m -= Math.pow(2,52); e+=1023; }&#13;
	}&#13;
	for(var i = 0; i &lt;= 5; ++i, m/=256) b[idx + i] = m &amp; 0xff;&#13;
	b[idx + 6] = ((e &amp; 0x0f) &lt;&lt; 4) | (m &amp; 0xf);&#13;
	b[idx + 7] = (e &gt;&gt; 4) | bs;&#13;
}&#13;
&#13;
var ___toBuffer = function(bufs) { var x=[],w=10240; for(var i=0;i&lt;bufs[0].length;++i) if(bufs[0][i]) for(var j=0,L=bufs[0][i].length;j&lt;L;j+=w) x.push.apply(x, bufs[0][i].slice(j,j+w)); return x; };&#13;
var __toBuffer = has_buf ? function(bufs) { return (bufs[0].length &gt; 0 &amp;&amp; Buffer.isBuffer(bufs[0][0])) ? Buffer.concat(bufs[0].map(function(x) { return Buffer.isBuffer(x) ? x : Buffer_from(x); })) : ___toBuffer(bufs);} : ___toBuffer;&#13;
&#13;
var ___utf16le = function(b,s,e) { var ss=[]; for(var i=s; i&lt;e; i+=2) ss.push(String.fromCharCode(__readUInt16LE(b,i))); return ss.join("").replace(chr0,''); };&#13;
var __utf16le = has_buf ? function(b,s,e) { if(!Buffer.isBuffer(b) || !buf_utf16le) return ___utf16le(b,s,e); return b.toString('utf16le',s,e).replace(chr0,'')/*.replace(chr1,'!')*/; } : ___utf16le;&#13;
&#13;
var ___hexlify = function(b,s,l) { var ss=[]; for(var i=s; i&lt;s+l; ++i) ss.push(("0" + b[i].toString(16)).slice(-2)); return ss.join(""); };&#13;
var __hexlify = has_buf ? function(b,s,l) { return Buffer.isBuffer(b) ? b.toString('hex',s,s+l) : ___hexlify(b,s,l); } : ___hexlify;&#13;
&#13;
var ___utf8 = function(b,s,e) { var ss=[]; for(var i=s; i&lt;e; i++) ss.push(String.fromCharCode(__readUInt8(b,i))); return ss.join(""); };&#13;
var __utf8 = has_buf ? function utf8_b(b, s, e) { return (Buffer.isBuffer(b)) ? b.toString('utf8',s,e) : ___utf8(b,s,e); } : ___utf8;&#13;
&#13;
var ___lpstr = function(b,i) { var len = __readUInt32LE(b,i); return len &gt; 0 ? __utf8(b, i+4,i+4+len-1) : "";};&#13;
var __lpstr = ___lpstr;&#13;
&#13;
var ___cpstr = function(b,i) { var len = __readUInt32LE(b,i); return len &gt; 0 ? __utf8(b, i+4,i+4+len-1) : "";};&#13;
var __cpstr = ___cpstr;&#13;
&#13;
var ___lpwstr = function(b,i) { var len = 2*__readUInt32LE(b,i); return len &gt; 0 ? __utf8(b, i+4,i+4+len-1) : "";};&#13;
var __lpwstr = ___lpwstr;&#13;
&#13;
var ___lpp4 = function lpp4_(b,i) { var len = __readUInt32LE(b,i); return len &gt; 0 ? __utf16le(b, i+4,i+4+len) : "";};&#13;
var __lpp4 = ___lpp4;&#13;
&#13;
var ___8lpp4 = function(b,i) { var len = __readUInt32LE(b,i); return len &gt; 0 ? __utf8(b, i+4,i+4+len) : "";};&#13;
var __8lpp4 = ___8lpp4;&#13;
&#13;
var ___double = function(b, idx) { return read_double_le(b, idx);};&#13;
var __double = ___double;&#13;
&#13;
var is_buf = function is_buf_a(a) { return Array.isArray(a) || (typeof Uint8Array !== "undefined" &amp;&amp; a instanceof Uint8Array); };&#13;
&#13;
if(has_buf) {&#13;
	__lpstr = function lpstr_b(b, i) { if(!Buffer.isBuffer(b)) return ___lpstr(b, i); var len = b.readUInt32LE(i); return len &gt; 0 ? b.toString('utf8',i+4,i+4+len-1) : "";};&#13;
	__cpstr = function cpstr_b(b, i) { if(!Buffer.isBuffer(b)) return ___cpstr(b, i); var len = b.readUInt32LE(i); return len &gt; 0 ? b.toString('utf8',i+4,i+4+len-1) : "";};&#13;
	__lpwstr = function lpwstr_b(b, i) { if(!Buffer.isBuffer(b) || !buf_utf16le) return ___lpwstr(b, i); var len = 2*b.readUInt32LE(i); return b.toString('utf16le',i+4,i+4+len-1);};&#13;
	__lpp4 = function lpp4_b(b, i) { if(!Buffer.isBuffer(b) || !buf_utf16le) return ___lpp4(b, i); var len = b.readUInt32LE(i); return b.toString('utf16le',i+4,i+4+len);};&#13;
	__8lpp4 = function lpp4_8b(b, i) { if(!Buffer.isBuffer(b)) return ___8lpp4(b, i); var len = b.readUInt32LE(i); return b.toString('utf8',i+4,i+4+len);};&#13;
	__double = function double_(b, i) { if(Buffer.isBuffer(b)) return b.readDoubleLE(i); return ___double(b,i); };&#13;
	is_buf = function is_buf_b(a) { return Buffer.isBuffer(a) || Array.isArray(a) || (typeof Uint8Array !== "undefined" &amp;&amp; a instanceof Uint8Array); };&#13;
}&#13;
&#13;
/* from js-xls */&#13;
function cpdoit() {&#13;
	__utf16le = function(b,s,e) { return $cptable.utils.decode(1200, b.slice(s,e)).replace(chr0, ''); };&#13;
	__utf8 = function(b,s,e) { return $cptable.utils.decode(65001, b.slice(s,e)); };&#13;
	__lpstr = function(b,i) { var len = __readUInt32LE(b,i); return len &gt; 0 ? $cptable.utils.decode(current_ansi, b.slice(i+4, i+4+len-1)) : "";};&#13;
	__cpstr = function(b,i) { var len = __readUInt32LE(b,i); return len &gt; 0 ? $cptable.utils.decode(current_codepage, b.slice(i+4, i+4+len-1)) : "";};&#13;
	__lpwstr = function(b,i) { var len = 2*__readUInt32LE(b,i); return len &gt; 0 ? $cptable.utils.decode(1200, b.slice(i+4,i+4+len-1)) : "";};&#13;
	__lpp4 = function(b,i) { var len = __readUInt32LE(b,i); return len &gt; 0 ? $cptable.utils.decode(1200, b.slice(i+4,i+4+len)) : "";};&#13;
	__8lpp4 = function(b,i) { var len = __readUInt32LE(b,i); return len &gt; 0 ? $cptable.utils.decode(65001, b.slice(i+4,i+4+len)) : "";};&#13;
}&#13;
if(typeof $cptable !== 'undefined') cpdoit();&#13;
&#13;
var __readUInt8 = function(b, idx) { return b[idx]; };&#13;
var __readUInt16LE = function(b, idx) { return (b[idx+1]*(1&lt;&lt;8))+b[idx]; };&#13;
var __readInt16LE = function(b, idx) { var u = (b[idx+1]*(1&lt;&lt;8))+b[idx]; return (u &lt; 0x8000) ? u : ((0xffff - u + 1) * -1); };&#13;
var __readUInt32LE = function(b, idx) { return b[idx+3]*(1&lt;&lt;24)+(b[idx+2]&lt;&lt;16)+(b[idx+1]&lt;&lt;8)+b[idx]; };&#13;
var __readInt32LE = function(b, idx) { return (b[idx+3]&lt;&lt;24)|(b[idx+2]&lt;&lt;16)|(b[idx+1]&lt;&lt;8)|b[idx]; };&#13;
var __readInt32BE = function(b, idx) { return (b[idx]&lt;&lt;24)|(b[idx+1]&lt;&lt;16)|(b[idx+2]&lt;&lt;8)|b[idx+3]; };&#13;
&#13;
function ReadShift(size, t) {&#13;
	var o="", oI, oR, oo=[], w, vv, i, loc;&#13;
	switch(t) {&#13;
		case 'dbcs':&#13;
			loc = this.l;&#13;
			if(has_buf &amp;&amp; Buffer.isBuffer(this)  &amp;&amp; buf_utf16le) o = this.slice(this.l, this.l+2*size).toString("utf16le");&#13;
			else for(i = 0; i &lt; size; ++i) { o+=String.fromCharCode(__readUInt16LE(this, loc)); loc+=2; }&#13;
			size *= 2;&#13;
			break;&#13;
&#13;
		case 'utf8': o = __utf8(this, this.l, this.l + size); break;&#13;
		case 'utf16le': size *= 2; o = __utf16le(this, this.l, this.l + size); break;&#13;
&#13;
		case 'wstr':&#13;
			if(typeof $cptable !== 'undefined') o = $cptable.utils.decode(current_codepage, this.slice(this.l, this.l+2*size));&#13;
			else return ReadShift.call(this, size, 'dbcs');&#13;
			size = 2 * size; break;&#13;
&#13;
		/* [MS-OLEDS] 2.1.4 LengthPrefixedAnsiString */&#13;
		case 'lpstr-ansi': o = __lpstr(this, this.l); size = 4 + __readUInt32LE(this, this.l); break;&#13;
		case 'lpstr-cp': o = __cpstr(this, this.l); size = 4 + __readUInt32LE(this, this.l); break;&#13;
		/* [MS-OLEDS] 2.1.5 LengthPrefixedUnicodeString */&#13;
		case 'lpwstr': o = __lpwstr(this, this.l); size = 4 + 2 * __readUInt32LE(this, this.l); break;&#13;
		/* [MS-OFFCRYPTO] 2.1.2 Length-Prefixed Padded Unicode String (UNICODE-LP-P4) */&#13;
		case 'lpp4': size = 4 +  __readUInt32LE(this, this.l); o = __lpp4(this, this.l); if(size &amp; 0x02) size += 2; break;&#13;
		/* [MS-OFFCRYPTO] 2.1.3 Length-Prefixed UTF-8 String (UTF-8-LP-P4) */&#13;
		case '8lpp4': size = 4 +  __readUInt32LE(this, this.l); o = __8lpp4(this, this.l); if(size &amp; 0x03) size += 4 - (size &amp; 0x03); break;&#13;
&#13;
		case 'cstr': size = 0; o = "";&#13;
			while((w=__readUInt8(this, this.l + size++))!==0) oo.push(_getchar(w));&#13;
			o = oo.join(""); break;&#13;
		case '_wstr': size = 0; o = "";&#13;
			while((w=__readUInt16LE(this,this.l +size))!==0){oo.push(_getchar(w));size+=2;}&#13;
			size+=2; o = oo.join(""); break;&#13;
&#13;
		/* sbcs and dbcs support continue records in the SST way TODO codepages */&#13;
		case 'dbcs-cont': o = ""; loc = this.l;&#13;
			for(i = 0; i &lt; size; ++i) {&#13;
				if(this.lens &amp;&amp; this.lens.indexOf(loc) !== -1) {&#13;
					w = __readUInt8(this, loc);&#13;
					this.l = loc + 1;&#13;
					vv = ReadShift.call(this, size-i, w ? 'dbcs-cont' : 'sbcs-cont');&#13;
					return oo.join("") + vv;&#13;
				}&#13;
				oo.push(_getchar(__readUInt16LE(this, loc)));&#13;
				loc+=2;&#13;
			} o = oo.join(""); size *= 2; break;&#13;
&#13;
		case 'cpstr':&#13;
			if(typeof $cptable !== 'undefined') {&#13;
				o = $cptable.utils.decode(current_codepage, this.slice(this.l, this.l + size));&#13;
				break;&#13;
			}&#13;
		/* falls through */&#13;
		case 'sbcs-cont': o = ""; loc = this.l;&#13;
			for(i = 0; i != size; ++i) {&#13;
				if(this.lens &amp;&amp; this.lens.indexOf(loc) !== -1) {&#13;
					w = __readUInt8(this, loc);&#13;
					this.l = loc + 1;&#13;
					vv = ReadShift.call(this, size-i, w ? 'dbcs-cont' : 'sbcs-cont');&#13;
					return oo.join("") + vv;&#13;
				}&#13;
				oo.push(_getchar(__readUInt8(this, loc)));&#13;
				loc+=1;&#13;
			} o = oo.join(""); break;&#13;
&#13;
		default:&#13;
	switch(size) {&#13;
		case 1: oI = __readUInt8(this, this.l); this.l++; return oI;&#13;
		case 2: oI = (t === 'i' ? __readInt16LE : __readUInt16LE)(this, this.l); this.l += 2; return oI;&#13;
		case 4: case -4:&#13;
			if(t === 'i' || ((this[this.l+3] &amp; 0x80)===0)) { oI = ((size &gt; 0) ? __readInt32LE : __readInt32BE)(this, this.l); this.l += 4; return oI; }&#13;
			else { oR = __readUInt32LE(this, this.l); this.l += 4; } return oR;&#13;
		case 8: case -8:&#13;
			if(t === 'f') {&#13;
				if(size == 8) oR = __double(this, this.l);&#13;
				else oR = __double([this[this.l+7],this[this.l+6],this[this.l+5],this[this.l+4],this[this.l+3],this[this.l+2],this[this.l+1],this[this.l+0]], 0);&#13;
				this.l += 8; return oR;&#13;
			} else size = 8;&#13;
		/* falls through */&#13;
		case 16: o = __hexlify(this, this.l, size); break;&#13;
	}}&#13;
	this.l+=size; return o;&#13;
}&#13;
&#13;
var __writeUInt32LE = function(b, val, idx) { b[idx] = (val &amp; 0xFF); b[idx+1] = ((val &gt;&gt;&gt; 8) &amp; 0xFF); b[idx+2] = ((val &gt;&gt;&gt; 16) &amp; 0xFF); b[idx+3] = ((val &gt;&gt;&gt; 24) &amp; 0xFF); };&#13;
var __writeInt32LE  = function(b, val, idx) { b[idx] = (val &amp; 0xFF); b[idx+1] = ((val &gt;&gt; 8) &amp; 0xFF); b[idx+2] = ((val &gt;&gt; 16) &amp; 0xFF); b[idx+3] = ((val &gt;&gt; 24) &amp; 0xFF); };&#13;
var __writeUInt16LE = function(b, val, idx) { b[idx] = (val &amp; 0xFF); b[idx+1] = ((val &gt;&gt;&gt; 8) &amp; 0xFF); };&#13;
&#13;
function WriteShift(t, val, f) {&#13;
	var size = 0, i = 0;&#13;
	if(f === 'dbcs') {&#13;
for(i = 0; i != val.length; ++i) __writeUInt16LE(this, val.charCodeAt(i), this.l + 2 * i);&#13;
		size = 2 * val.length;&#13;
	} else if(f === 'sbcs' || f == 'cpstr') {&#13;
		if(typeof $cptable !== 'undefined' &amp;&amp; current_ansi == 874) {&#13;
			/* TODO: use tables directly, don't encode */&#13;
for(i = 0; i != val.length; ++i) {&#13;
				var cpp = $cptable.utils.encode(current_ansi, val.charAt(i));&#13;
				this[this.l + i] = cpp[0];&#13;
			}&#13;
			size = val.length;&#13;
		} else if(typeof $cptable !== 'undefined' &amp;&amp; f == 'cpstr') {&#13;
			cpp = $cptable.utils.encode(current_codepage, val);&#13;
			/* replace null bytes with _ when relevant */&#13;
      if(cpp.length == val.length) for(i = 0; i &lt; val.length; ++i) if(cpp[i] == 0 &amp;&amp; val.charCodeAt(i) != 0) cpp[i] = 0x5F;&#13;
      if(cpp.length == 2 * val.length) for(i = 0; i &lt; val.length; ++i) if(cpp[2*i] == 0 &amp;&amp; cpp[2*i+1] == 0 &amp;&amp; val.charCodeAt(i) != 0) cpp[2*i] = 0x5F;&#13;
			for(i = 0; i &lt; cpp.length; ++i) this[this.l + i] = cpp[i];&#13;
			size = cpp.length;&#13;
		} else {&#13;
val = val.replace(/[^\x00-\x7F]/g, "_");&#13;
for(i = 0; i != val.length; ++i) this[this.l + i] = (val.charCodeAt(i) &amp; 0xFF);&#13;
			size = val.length;&#13;
		}&#13;
	} else if(f === 'hex') {&#13;
		for(; i &lt; t; ++i) {&#13;
this[this.l++] = (parseInt(val.slice(2*i, 2*i+2), 16)||0);&#13;
		} return this;&#13;
	} else if(f === 'utf16le') {&#13;
var end = Math.min(this.l + t, this.length);&#13;
			for(i = 0; i &lt; Math.min(val.length, t); ++i) {&#13;
				var cc = val.charCodeAt(i);&#13;
				this[this.l++] = (cc &amp; 0xff);&#13;
				this[this.l++] = (cc &gt;&gt; 8);&#13;
			}&#13;
			while(this.l &lt; end) this[this.l++] = 0;&#13;
			return this;&#13;
	} else  switch(t) {&#13;
		case  1: size = 1; this[this.l] = val&amp;0xFF; break;&#13;
		case  2: size = 2; this[this.l] = val&amp;0xFF; val &gt;&gt;&gt;= 8; this[this.l+1] = val&amp;0xFF; break;&#13;
		case  3: size = 3; this[this.l] = val&amp;0xFF; val &gt;&gt;&gt;= 8; this[this.l+1] = val&amp;0xFF; val &gt;&gt;&gt;= 8; this[this.l+2] = val&amp;0xFF; break;&#13;
		case  4: size = 4; __writeUInt32LE(this, val, this.l); break;&#13;
		case  8: size = 8; if(f === 'f') { write_double_le(this, val, this.l); break; }&#13;
		/* falls through */&#13;
		case 16: break;&#13;
		case -4: size = 4; __writeInt32LE(this, val, this.l); break;&#13;
	}&#13;
	this.l += size; return this;&#13;
}&#13;
&#13;
function CheckField(hexstr, fld) {&#13;
	var m = __hexlify(this,this.l,hexstr.length&gt;&gt;1);&#13;
	if(m !== hexstr) throw new Error(fld + 'Expected ' + hexstr + ' saw ' + m);&#13;
	this.l += hexstr.length&gt;&gt;1;&#13;
}&#13;
&#13;
function prep_blob(blob, pos) {&#13;
	blob.l = pos;&#13;
	blob.read_shift = ReadShift;&#13;
	blob.chk = CheckField;&#13;
	blob.write_shift = WriteShift;&#13;
}&#13;
&#13;
function parsenoop(blob, length) { blob.l += length; }&#13;
&#13;
function new_buf(sz) {&#13;
	var o = new_raw_buf(sz);&#13;
	prep_blob(o, 0);&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.1.4 Record */&#13;
function recordhopper(data, cb, opts) {&#13;
	if(!data) return;&#13;
	var tmpbyte, cntbyte, length;&#13;
	prep_blob(data, data.l || 0);&#13;
	var L = data.length, RT = 0, tgt = 0;&#13;
	while(data.l &lt; L) {&#13;
		RT = data.read_shift(1);&#13;
		if(RT &amp; 0x80) RT = (RT &amp; 0x7F) + ((data.read_shift(1) &amp; 0x7F)&lt;&lt;7);&#13;
		var R = XLSBRecordEnum[RT] || XLSBRecordEnum[0xFFFF];&#13;
		tmpbyte = data.read_shift(1);&#13;
		length = tmpbyte &amp; 0x7F;&#13;
		for(cntbyte = 1; cntbyte &lt;4 &amp;&amp; (tmpbyte &amp; 0x80); ++cntbyte) length += ((tmpbyte = data.read_shift(1)) &amp; 0x7F)&lt;&lt;(7*cntbyte);&#13;
		tgt = data.l + length;&#13;
		var d = R.f &amp;&amp; R.f(data, length, opts);&#13;
		data.l = tgt;&#13;
		if(cb(d, R, RT)) return;&#13;
	}&#13;
}&#13;
&#13;
/* control buffer usage for fixed-length buffers */&#13;
function buf_array() {&#13;
	var bufs = [], blksz = has_buf ? 256 : 2048;&#13;
	var newblk = function ba_newblk(sz) {&#13;
		var o = (new_buf(sz));&#13;
		prep_blob(o, 0);&#13;
		return o;&#13;
	};&#13;
&#13;
	var curbuf = newblk(blksz);&#13;
&#13;
	var endbuf = function ba_endbuf() {&#13;
		if(!curbuf) return;&#13;
		// workaround for new Buffer(3).slice(0,0) bug in bun 0.1.3&#13;
		if(curbuf.l) {&#13;
			if(curbuf.length &gt; curbuf.l) { curbuf = curbuf.slice(0, curbuf.l); curbuf.l = curbuf.length; }&#13;
			if(curbuf.length &gt; 0) bufs.push(curbuf);&#13;
		}&#13;
		curbuf = null;&#13;
	};&#13;
&#13;
	var next = function ba_next(sz) {&#13;
		if(curbuf &amp;&amp; (sz &lt; (curbuf.length - curbuf.l))) return curbuf;&#13;
		endbuf();&#13;
		return (curbuf = newblk(Math.max(sz+1, blksz)));&#13;
	};&#13;
&#13;
	var end = function ba_end() {&#13;
		endbuf();&#13;
		return bconcat(bufs);&#13;
	};&#13;
&#13;
	var push = function ba_push(buf) { endbuf(); curbuf = buf; if(curbuf.l == null) curbuf.l = curbuf.length; next(blksz); };&#13;
&#13;
	return ({ next:next, push:push, end:end, _bufs:bufs });&#13;
}&#13;
&#13;
function write_record(ba, type, payload, length) {&#13;
	var t = +type, l;&#13;
	if(isNaN(t)) return; // TODO: throw something here?&#13;
	if(!length) length = XLSBRecordEnum[t].p || (payload||[]).length || 0;&#13;
	l = 1 + (t &gt;= 0x80 ? 1 : 0) + 1/* + length*/;&#13;
	if(length &gt;= 0x80) ++l; if(length &gt;= 0x4000) ++l; if(length &gt;= 0x200000) ++l;&#13;
	var o = ba.next(l);&#13;
	if(t &lt;= 0x7F) o.write_shift(1, t);&#13;
	else {&#13;
		o.write_shift(1, (t &amp; 0x7F) + 0x80);&#13;
		o.write_shift(1, (t &gt;&gt; 7));&#13;
	}&#13;
	for(var i = 0; i != 4; ++i) {&#13;
		if(length &gt;= 0x80) { o.write_shift(1, (length &amp; 0x7F)+0x80); length &gt;&gt;= 7; }&#13;
		else { o.write_shift(1, length); break; }&#13;
	}&#13;
	if(length &gt; 0 &amp;&amp; is_buf(payload)) ba.push(payload);&#13;
}&#13;
/* XLS ranges enforced */&#13;
function shift_cell_xls(cell, tgt, opts) {&#13;
	var out = dup(cell);&#13;
	if(tgt.s) {&#13;
		if(out.cRel) out.c += tgt.s.c;&#13;
		if(out.rRel) out.r += tgt.s.r;&#13;
	} else {&#13;
		if(out.cRel) out.c += tgt.c;&#13;
		if(out.rRel) out.r += tgt.r;&#13;
	}&#13;
	if(!opts || opts.biff &lt; 12) {&#13;
		while(out.c &gt;= 0x100) out.c -= 0x100;&#13;
		while(out.r &gt;= 0x10000) out.r -= 0x10000;&#13;
	}&#13;
	return out;&#13;
}&#13;
&#13;
function shift_range_xls(cell, range, opts) {&#13;
	var out = dup(cell);&#13;
	out.s = shift_cell_xls(out.s, range.s, opts);&#13;
	out.e = shift_cell_xls(out.e, range.s, opts);&#13;
	return out;&#13;
}&#13;
&#13;
function encode_cell_xls(c, biff) {&#13;
	if(c.cRel &amp;&amp; c.c &lt; 0) { c = dup(c); while(c.c &lt; 0) c.c += (biff &gt; 8) ? 0x4000 : 0x100; }&#13;
	if(c.rRel &amp;&amp; c.r &lt; 0) { c = dup(c); while(c.r &lt; 0) c.r += (biff &gt; 8) ? 0x100000 : ((biff &gt; 5) ? 0x10000 : 0x4000); }&#13;
	var s = encode_cell(c);&#13;
	if(!c.cRel &amp;&amp; c.cRel != null) s = fix_col(s);&#13;
	if(!c.rRel &amp;&amp; c.rRel != null) s = fix_row(s);&#13;
	return s;&#13;
}&#13;
&#13;
function encode_range_xls(r, opts) {&#13;
	if(r.s.r == 0 &amp;&amp; !r.s.rRel) {&#13;
		if(r.e.r == (opts.biff &gt;= 12 ? 0xFFFFF : (opts.biff &gt;= 8 ? 0x10000 : 0x4000)) &amp;&amp; !r.e.rRel) {&#13;
			return (r.s.cRel ? "" : "$") + encode_col(r.s.c) + ":" + (r.e.cRel ? "" : "$") + encode_col(r.e.c);&#13;
		}&#13;
	}&#13;
	if(r.s.c == 0 &amp;&amp; !r.s.cRel) {&#13;
		if(r.e.c == (opts.biff &gt;= 12 ? 0x3FFF : 0xFF) &amp;&amp; !r.e.cRel) {&#13;
			return (r.s.rRel ? "" : "$") + encode_row(r.s.r) + ":" + (r.e.rRel ? "" : "$") + encode_row(r.e.r);&#13;
		}&#13;
	}&#13;
	return encode_cell_xls(r.s, opts.biff) + ":" + encode_cell_xls(r.e, opts.biff);&#13;
}&#13;
if(typeof cptable !== 'undefined') set_cptable(cptable);&#13;
else if(typeof module !== "undefined" &amp;&amp; typeof require !== 'undefined') {&#13;
	set_cptable(require('./dist/cpexcel.js'));&#13;
}&#13;
function decode_row(rowstr) { return parseInt(unfix_row(rowstr),10) - 1; }&#13;
function encode_row(row) { return "" + (row + 1); }&#13;
function fix_row(cstr) { return cstr.replace(/([A-Z]|^)(\d+)$/,"$1$$$2"); }&#13;
function unfix_row(cstr) { return cstr.replace(/\$(\d+)$/,"$1"); }&#13;
&#13;
function decode_col(colstr) { var c = unfix_col(colstr), d = 0, i = 0; for(; i !== c.length; ++i) d = 26*d + c.charCodeAt(i) - 64; return d - 1; }&#13;
function encode_col(col) { if(col &lt; 0) throw new Error("invalid column " + col); var s=""; for(++col; col; col=Math.floor((col-1)/26)) s = String.fromCharCode(((col-1)%26) + 65) + s; return s; }&#13;
function fix_col(cstr) { return cstr.replace(/^([A-Z])/,"$$$1"); }&#13;
function unfix_col(cstr) { return cstr.replace(/^\$([A-Z])/,"$1"); }&#13;
&#13;
function split_cell(cstr) { return cstr.replace(/(\$?[A-Z]*)(\$?\d*)/,"$1,$2").split(","); }&#13;
//function decode_cell(cstr) { var splt = split_cell(cstr); return { c:decode_col(splt[0]), r:decode_row(splt[1]) }; }&#13;
function decode_cell(cstr) {&#13;
	var R = 0, C = 0;&#13;
	for(var i = 0; i &lt; cstr.length; ++i) {&#13;
		var cc = cstr.charCodeAt(i);&#13;
		if(cc &gt;= 48 &amp;&amp; cc &lt;= 57) R = 10 * R + (cc - 48);&#13;
		else if(cc &gt;= 65 &amp;&amp; cc &lt;= 90) C = 26 * C + (cc - 64);&#13;
	}&#13;
	return { c: C - 1, r:R - 1 };&#13;
}&#13;
//function encode_cell(cell) { return encode_col(cell.c) + encode_row(cell.r); }&#13;
function encode_cell(cell) {&#13;
	var col = cell.c + 1;&#13;
	var s="";&#13;
	for(; col; col=((col-1)/26)|0) s = String.fromCharCode(((col-1)%26) + 65) + s;&#13;
	return s + (cell.r + 1);&#13;
}&#13;
function decode_range(range) {&#13;
	var idx = range.indexOf(":");&#13;
	if(idx == -1) return { s: decode_cell(range), e: decode_cell(range) };&#13;
	return { s: decode_cell(range.slice(0, idx)), e: decode_cell(range.slice(idx + 1)) };&#13;
}&#13;
function encode_range(cs,ce) {&#13;
	if(typeof ce === 'undefined' || typeof ce === 'number') {&#13;
return encode_range(cs.s, cs.e);&#13;
	}&#13;
if(typeof cs !== 'string') cs = encode_cell((cs));&#13;
	if(typeof ce !== 'string') ce = encode_cell((ce));&#13;
return cs == ce ? cs : cs + ":" + ce;&#13;
}&#13;
function fix_range(a1) {&#13;
	var s = decode_range(a1);&#13;
	return "$" + encode_col(s.s.c) + "$" + encode_row(s.s.r) + ":$" + encode_col(s.e.c) + "$" + encode_row(s.e.r);&#13;
}&#13;
&#13;
// List of invalid characters needs to be tested further&#13;
function formula_quote_sheet_name(sname, opts) {&#13;
	if(!sname &amp;&amp; !(opts &amp;&amp; opts.biff &lt;= 5 &amp;&amp; opts.biff &gt;= 2)) throw new Error("empty sheet name");&#13;
	if (/[^\w\u4E00-\u9FFF\u3040-\u30FF]/.test(sname)) return "'" + sname.replace(/'/g, "''") + "'";&#13;
	return sname;&#13;
}&#13;
&#13;
function safe_decode_range(range) {&#13;
	var o = {s:{c:0,r:0},e:{c:0,r:0}};&#13;
	var idx = 0, i = 0, cc = 0;&#13;
	var len = range.length;&#13;
	for(idx = 0; i &lt; len; ++i) {&#13;
		if((cc=range.charCodeAt(i)-64) &lt; 1 || cc &gt; 26) break;&#13;
		idx = 26*idx + cc;&#13;
	}&#13;
	o.s.c = --idx;&#13;
&#13;
	for(idx = 0; i &lt; len; ++i) {&#13;
		if((cc=range.charCodeAt(i)-48) &lt; 0 || cc &gt; 9) break;&#13;
		idx = 10*idx + cc;&#13;
	}&#13;
	o.s.r = --idx;&#13;
&#13;
	if(i === len || cc != 10) { o.e.c=o.s.c; o.e.r=o.s.r; return o; }&#13;
	++i;&#13;
&#13;
	for(idx = 0; i != len; ++i) {&#13;
		if((cc=range.charCodeAt(i)-64) &lt; 1 || cc &gt; 26) break;&#13;
		idx = 26*idx + cc;&#13;
	}&#13;
	o.e.c = --idx;&#13;
&#13;
	for(idx = 0; i != len; ++i) {&#13;
		if((cc=range.charCodeAt(i)-48) &lt; 0 || cc &gt; 9) break;&#13;
		idx = 10*idx + cc;&#13;
	}&#13;
	o.e.r = --idx;&#13;
	return o;&#13;
}&#13;
&#13;
function safe_format_cell(cell, v) {&#13;
	var q = (cell.t == 'd' &amp;&amp; v instanceof Date);&#13;
	if(cell.z != null) try { return (cell.w = SSF_format(cell.z, q ? datenum(v) : v)); } catch(e) { }&#13;
	try { return (cell.w = SSF_format((cell.XF||{}).numFmtId||(q ? 14 : 0),  q ? datenum(v) : v)); } catch(e) { return ''+v; }&#13;
}&#13;
&#13;
function format_cell(cell, v, o) {&#13;
	if(cell == null || cell.t == null || cell.t == 'z') return "";&#13;
	if(cell.w !== undefined) return cell.w;&#13;
	if(cell.t == 'd' &amp;&amp; !cell.z &amp;&amp; o &amp;&amp; o.dateNF) cell.z = o.dateNF;&#13;
	if(cell.t == "e") return BErr[cell.v] || cell.v;&#13;
	if(v == undefined) return safe_format_cell(cell, cell.v);&#13;
	return safe_format_cell(cell, v);&#13;
}&#13;
&#13;
function sheet_to_workbook(sheet, opts) {&#13;
	var n = opts &amp;&amp; opts.sheet ? opts.sheet : "Sheet1";&#13;
	var sheets = {}; sheets[n] = sheet;&#13;
	return { SheetNames: [n], Sheets: sheets };&#13;
}&#13;
&#13;
function sheet_add_aoa(_ws, data, opts) {&#13;
	var o = opts || {};&#13;
	var dense = _ws ? Array.isArray(_ws) : o.dense;&#13;
	if(DENSE != null &amp;&amp; dense == null) dense = DENSE;&#13;
	var ws = _ws || (dense ? ([]) : ({}));&#13;
	var _R = 0, _C = 0;&#13;
	if(ws &amp;&amp; o.origin != null) {&#13;
		if(typeof o.origin == 'number') _R = o.origin;&#13;
		else {&#13;
			var _origin = typeof o.origin == "string" ? decode_cell(o.origin) : o.origin;&#13;
			_R = _origin.r; _C = _origin.c;&#13;
		}&#13;
		if(!ws["!ref"]) ws["!ref"] = "A1:A1";&#13;
	}&#13;
	var range = ({s: {c:10000000, r:10000000}, e: {c:0, r:0}});&#13;
	if(ws['!ref']) {&#13;
		var _range = safe_decode_range(ws['!ref']);&#13;
		range.s.c = _range.s.c;&#13;
		range.s.r = _range.s.r;&#13;
		range.e.c = Math.max(range.e.c, _range.e.c);&#13;
		range.e.r = Math.max(range.e.r, _range.e.r);&#13;
		if(_R == -1) range.e.r = _R = _range.e.r + 1;&#13;
	}&#13;
	for(var R = 0; R != data.length; ++R) {&#13;
		if(!data[R]) continue;&#13;
		if(!Array.isArray(data[R])) throw new Error("aoa_to_sheet expects an array of arrays");&#13;
		for(var C = 0; C != data[R].length; ++C) {&#13;
			if(typeof data[R][C] === 'undefined') continue;&#13;
			var cell = ({v: data[R][C] });&#13;
			var __R = _R + R, __C = _C + C;&#13;
			if(range.s.r &gt; __R) range.s.r = __R;&#13;
			if(range.s.c &gt; __C) range.s.c = __C;&#13;
			if(range.e.r &lt; __R) range.e.r = __R;&#13;
			if(range.e.c &lt; __C) range.e.c = __C;&#13;
			if(data[R][C] &amp;&amp; typeof data[R][C] === 'object' &amp;&amp; !Array.isArray(data[R][C]) &amp;&amp; !(data[R][C] instanceof Date)) cell = data[R][C];&#13;
			else {&#13;
				if(Array.isArray(cell.v)) { cell.f = data[R][C][1]; cell.v = cell.v[0]; }&#13;
				if(cell.v === null) {&#13;
					if(cell.f) cell.t = 'n';&#13;
					else if(o.nullError) { cell.t = 'e'; cell.v = 0; }&#13;
					else if(!o.sheetStubs) continue;&#13;
					else cell.t = 'z';&#13;
				}&#13;
				else if(typeof cell.v === 'number') cell.t = 'n';&#13;
				else if(typeof cell.v === 'boolean') cell.t = 'b';&#13;
				else if(cell.v instanceof Date) {&#13;
					cell.z = o.dateNF || table_fmt[14];&#13;
					if(o.cellDates) { cell.t = 'd'; cell.w = SSF_format(cell.z, datenum(cell.v, o.date1904)); }&#13;
					else { cell.t = 'n'; cell.v = datenum(cell.v, o.date1904); cell.w = SSF_format(cell.z, cell.v); }&#13;
				}&#13;
				else cell.t = 's';&#13;
			}&#13;
			if(dense) {&#13;
				if(!ws[__R]) ws[__R] = [];&#13;
				if(ws[__R][__C] &amp;&amp; ws[__R][__C].z) cell.z = ws[__R][__C].z;&#13;
				ws[__R][__C] = cell;&#13;
			} else {&#13;
				var cell_ref = encode_cell(({c:__C,r:__R}));&#13;
				if(ws[cell_ref] &amp;&amp; ws[cell_ref].z) cell.z = ws[cell_ref].z;&#13;
				ws[cell_ref] = cell;&#13;
			}&#13;
		}&#13;
	}&#13;
	if(range.s.c &lt; 10000000) ws['!ref'] = encode_range(range);&#13;
	return ws;&#13;
}&#13;
function aoa_to_sheet(data, opts) { return sheet_add_aoa(null, data, opts); }&#13;
&#13;
function parse_Int32LE(data) {&#13;
	return data.read_shift(4, 'i');&#13;
}&#13;
function write_UInt32LE(x, o) {&#13;
	if (!o) o = new_buf(4);&#13;
	o.write_shift(4, x);&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.5.168 */&#13;
function parse_XLWideString(data) {&#13;
	var cchCharacters = data.read_shift(4);&#13;
	return cchCharacters === 0 ? "" : data.read_shift(cchCharacters, 'dbcs');&#13;
}&#13;
function write_XLWideString(data, o) {&#13;
	var _null = false; if (o == null) { _null = true; o = new_buf(4 + 2 * data.length); }&#13;
	o.write_shift(4, data.length);&#13;
	if (data.length &gt; 0) o.write_shift(0, data, 'dbcs');&#13;
	return _null ? o.slice(0, o.l) : o;&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.5.91 */&#13;
//function parse_LPWideString(data) {&#13;
//	var cchCharacters = data.read_shift(2);&#13;
//	return cchCharacters === 0 ? "" : data.read_shift(cchCharacters, "utf16le");&#13;
//}&#13;
&#13;
/* [MS-XLSB] 2.5.143 */&#13;
function parse_StrRun(data) {&#13;
	return { ich: data.read_shift(2), ifnt: data.read_shift(2) };&#13;
}&#13;
function write_StrRun(run, o) {&#13;
	if (!o) o = new_buf(4);&#13;
	o.write_shift(2, run.ich || 0);&#13;
	o.write_shift(2, run.ifnt || 0);&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.5.121 */&#13;
function parse_RichStr(data, length) {&#13;
	var start = data.l;&#13;
	var flags = data.read_shift(1);&#13;
	var str = parse_XLWideString(data);&#13;
	var rgsStrRun = [];&#13;
	var z = ({ t: str, h: str });&#13;
	if ((flags &amp; 1) !== 0) { /* fRichStr */&#13;
		/* TODO: formatted string */&#13;
		var dwSizeStrRun = data.read_shift(4);&#13;
		for (var i = 0; i != dwSizeStrRun; ++i) rgsStrRun.push(parse_StrRun(data));&#13;
		z.r = rgsStrRun;&#13;
	}&#13;
	else z.r = [{ ich: 0, ifnt: 0 }];&#13;
	//if((flags &amp; 2) !== 0) { /* fExtStr */&#13;
	//	/* TODO: phonetic string */&#13;
	//}&#13;
	data.l = start + length;&#13;
	return z;&#13;
}&#13;
function write_RichStr(str, o) {&#13;
	/* TODO: formatted string */&#13;
	var _null = false; if (o == null) { _null = true; o = new_buf(15 + 4 * str.t.length); }&#13;
	o.write_shift(1, 0);&#13;
	write_XLWideString(str.t, o);&#13;
	return _null ? o.slice(0, o.l) : o;&#13;
}&#13;
/* [MS-XLSB] 2.4.328 BrtCommentText (RichStr w/1 run) */&#13;
var parse_BrtCommentText = parse_RichStr;&#13;
function write_BrtCommentText(str, o) {&#13;
	/* TODO: formatted string */&#13;
	var _null = false; if (o == null) { _null = true; o = new_buf(23 + 4 * str.t.length); }&#13;
	o.write_shift(1, 1);&#13;
	write_XLWideString(str.t, o);&#13;
	o.write_shift(4, 1);&#13;
	write_StrRun({ ich: 0, ifnt: 0 }, o);&#13;
	return _null ? o.slice(0, o.l) : o;&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.5.9 */&#13;
function parse_XLSBCell(data) {&#13;
	var col = data.read_shift(4);&#13;
	var iStyleRef = data.read_shift(2);&#13;
	iStyleRef += data.read_shift(1) &lt;&lt; 16;&#13;
	data.l++; //var fPhShow = data.read_shift(1);&#13;
	return { c: col, iStyleRef: iStyleRef };&#13;
}&#13;
function write_XLSBCell(cell, o) {&#13;
	if (o == null) o = new_buf(8);&#13;
	o.write_shift(-4, cell.c);&#13;
	o.write_shift(3, cell.iStyleRef || cell.s);&#13;
	o.write_shift(1, 0); /* fPhShow */&#13;
	return o;&#13;
}&#13;
&#13;
/* Short XLSB Cell does not include column */&#13;
function parse_XLSBShortCell(data) {&#13;
	var iStyleRef = data.read_shift(2);&#13;
	iStyleRef += data.read_shift(1) &lt;&lt;16;&#13;
	data.l++; //var fPhShow = data.read_shift(1);&#13;
	return { c:-1, iStyleRef: iStyleRef };&#13;
}&#13;
function write_XLSBShortCell(cell, o) {&#13;
	if(o == null) o = new_buf(4);&#13;
	o.write_shift(3, cell.iStyleRef || cell.s);&#13;
	o.write_shift(1, 0); /* fPhShow */&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.5.21 */&#13;
var parse_XLSBCodeName = parse_XLWideString;&#13;
var write_XLSBCodeName = write_XLWideString;&#13;
&#13;
/* [MS-XLSB] 2.5.166 */&#13;
function parse_XLNullableWideString(data) {&#13;
	var cchCharacters = data.read_shift(4);&#13;
	return cchCharacters === 0 || cchCharacters === 0xFFFFFFFF ? "" : data.read_shift(cchCharacters, 'dbcs');&#13;
}&#13;
function write_XLNullableWideString(data, o) {&#13;
	var _null = false; if (o == null) { _null = true; o = new_buf(127); }&#13;
	o.write_shift(4, data.length &gt; 0 ? data.length : 0xFFFFFFFF);&#13;
	if (data.length &gt; 0) o.write_shift(0, data, 'dbcs');&#13;
	return _null ? o.slice(0, o.l) : o;&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.5.165 */&#13;
var parse_XLNameWideString = parse_XLWideString;&#13;
//var write_XLNameWideString = write_XLWideString;&#13;
&#13;
/* [MS-XLSB] 2.5.114 */&#13;
var parse_RelID = parse_XLNullableWideString;&#13;
var write_RelID = write_XLNullableWideString;&#13;
&#13;
&#13;
/* [MS-XLS] 2.5.217 ; [MS-XLSB] 2.5.122 */&#13;
function parse_RkNumber(data) {&#13;
	var b = data.slice(data.l, data.l + 4);&#13;
	var fX100 = (b[0] &amp; 1), fInt = (b[0] &amp; 2);&#13;
	data.l += 4;&#13;
	var RK = fInt === 0 ? __double([0, 0, 0, 0, (b[0] &amp; 0xFC), b[1], b[2], b[3]], 0) : __readInt32LE(b, 0) &gt;&gt; 2;&#13;
	return fX100 ? (RK / 100) : RK;&#13;
}&#13;
function write_RkNumber(data, o) {&#13;
	if (o == null) o = new_buf(4);&#13;
	var fX100 = 0, fInt = 0, d100 = data * 100;&#13;
	if ((data == (data | 0)) &amp;&amp; (data &gt;= -(1 &lt;&lt; 29)) &amp;&amp; (data &lt; (1 &lt;&lt; 29))) { fInt = 1; }&#13;
	else if ((d100 == (d100 | 0)) &amp;&amp; (d100 &gt;= -(1 &lt;&lt; 29)) &amp;&amp; (d100 &lt; (1 &lt;&lt; 29))) { fInt = 1; fX100 = 1; }&#13;
	if (fInt) o.write_shift(-4, ((fX100 ? d100 : data) &lt;&lt; 2) + (fX100 + 2));&#13;
	else throw new Error("unsupported RkNumber " + data); // TODO&#13;
}&#13;
&#13;
&#13;
/* [MS-XLSB] 2.5.117 RfX */&#13;
function parse_RfX(data ) {&#13;
	var cell = ({ s: {}, e: {} });&#13;
	cell.s.r = data.read_shift(4);&#13;
	cell.e.r = data.read_shift(4);&#13;
	cell.s.c = data.read_shift(4);&#13;
	cell.e.c = data.read_shift(4);&#13;
	return cell;&#13;
}&#13;
function write_RfX(r, o) {&#13;
	if (!o) o = new_buf(16);&#13;
	o.write_shift(4, r.s.r);&#13;
	o.write_shift(4, r.e.r);&#13;
	o.write_shift(4, r.s.c);&#13;
	o.write_shift(4, r.e.c);&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.5.153 UncheckedRfX */&#13;
var parse_UncheckedRfX = parse_RfX;&#13;
var write_UncheckedRfX = write_RfX;&#13;
&#13;
/* [MS-XLSB] 2.5.155 UncheckedSqRfX */&#13;
//function parse_UncheckedSqRfX(data) {&#13;
//	var cnt = data.read_shift(4);&#13;
//	var out = [];&#13;
//	for(var i = 0; i &lt; cnt; ++i) {&#13;
//		var rng = parse_UncheckedRfX(data);&#13;
//		out.push(encode_range(rng));&#13;
//	}&#13;
//	return out.join(",");&#13;
//}&#13;
//function write_UncheckedSqRfX(sqrfx) {&#13;
//	var parts = sqrfx.split(/\s*,\s*/);&#13;
//	var o = new_buf(4); o.write_shift(4, parts.length);&#13;
//	var out = [o];&#13;
//	parts.forEach(function(rng) {&#13;
//		out.push(write_UncheckedRfX(safe_decode_range(rng)));&#13;
//	});&#13;
//	return bconcat(out);&#13;
//}&#13;
&#13;
/* [MS-XLS] 2.5.342 ; [MS-XLSB] 2.5.171 */&#13;
/* TODO: error checking, NaN and Infinity values are not valid Xnum */&#13;
function parse_Xnum(data) {&#13;
	if(data.length - data.l &lt; 8) throw "XLS Xnum Buffer underflow";&#13;
	return data.read_shift(8, 'f');&#13;
}&#13;
function write_Xnum(data, o) { return (o || new_buf(8)).write_shift(8, data, 'f'); }&#13;
&#13;
/* [MS-XLSB] 2.4.324 BrtColor */&#13;
function parse_BrtColor(data) {&#13;
	var out = {};&#13;
	var d = data.read_shift(1);&#13;
&#13;
	//var fValidRGB = d &amp; 1;&#13;
	var xColorType = d &gt;&gt;&gt; 1;&#13;
&#13;
	var index = data.read_shift(1);&#13;
	var nTS = data.read_shift(2, 'i');&#13;
	var bR = data.read_shift(1);&#13;
	var bG = data.read_shift(1);&#13;
	var bB = data.read_shift(1);&#13;
	data.l++; //var bAlpha = data.read_shift(1);&#13;
&#13;
	switch (xColorType) {&#13;
		case 0: out.auto = 1; break;&#13;
		case 1:&#13;
			out.index = index;&#13;
			var icv = XLSIcv[index];&#13;
			/* automatic pseudo index 81 */&#13;
			if (icv) out.rgb = rgb2Hex(icv);&#13;
			break;&#13;
		case 2:&#13;
			/* if(!fValidRGB) throw new Error("invalid"); */&#13;
			out.rgb = rgb2Hex([bR, bG, bB]);&#13;
			break;&#13;
		case 3: out.theme = index; break;&#13;
	}&#13;
	if (nTS != 0) out.tint = nTS &gt; 0 ? nTS / 32767 : nTS / 32768;&#13;
&#13;
	return out;&#13;
}&#13;
function write_BrtColor(color, o) {&#13;
	if (!o) o = new_buf(8);&#13;
	if (!color || color.auto) { o.write_shift(4, 0); o.write_shift(4, 0); return o; }&#13;
	if (color.index != null) {&#13;
		o.write_shift(1, 0x02);&#13;
		o.write_shift(1, color.index);&#13;
	} else if (color.theme != null) {&#13;
		o.write_shift(1, 0x06);&#13;
		o.write_shift(1, color.theme);&#13;
	} else {&#13;
		o.write_shift(1, 0x05);&#13;
		o.write_shift(1, 0);&#13;
	}&#13;
	var nTS = color.tint || 0;&#13;
	if (nTS &gt; 0) nTS *= 32767;&#13;
	else if (nTS &lt; 0) nTS *= 32768;&#13;
	o.write_shift(2, nTS);&#13;
	if (!color.rgb || color.theme != null) {&#13;
		o.write_shift(2, 0);&#13;
		o.write_shift(1, 0);&#13;
		o.write_shift(1, 0);&#13;
	} else {&#13;
		var rgb = (color.rgb || 'FFFFFF');&#13;
		if (typeof rgb == 'number') rgb = ("000000" + rgb.toString(16)).slice(-6);&#13;
		o.write_shift(1, parseInt(rgb.slice(0, 2), 16));&#13;
		o.write_shift(1, parseInt(rgb.slice(2, 4), 16));&#13;
		o.write_shift(1, parseInt(rgb.slice(4, 6), 16));&#13;
		o.write_shift(1, 0xFF);&#13;
	}&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.5.52 */&#13;
function parse_FontFlags(data) {&#13;
	var d = data.read_shift(1);&#13;
	data.l++;&#13;
	var out = {&#13;
		fBold: d &amp; 0x01,&#13;
		fItalic: d &amp; 0x02,&#13;
		fUnderline: d &amp; 0x04,&#13;
		fStrikeout: d &amp; 0x08,&#13;
		fOutline: d &amp; 0x10,&#13;
		fShadow: d &amp; 0x20,&#13;
		fCondense: d &amp; 0x40,&#13;
		fExtend: d &amp; 0x80&#13;
	};&#13;
	return out;&#13;
}&#13;
function write_FontFlags(font, o) {&#13;
	if (!o) o = new_buf(2);&#13;
	var grbit =&#13;
		(font.italic ? 0x02 : 0) |&#13;
		(font.strike ? 0x08 : 0) |&#13;
		(font.outline ? 0x10 : 0) |&#13;
		(font.shadow ? 0x20 : 0) |&#13;
		(font.condense ? 0x40 : 0) |&#13;
		(font.extend ? 0x80 : 0);&#13;
	o.write_shift(1, grbit);&#13;
	o.write_shift(1, 0);&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-OLEDS] 2.3.1 and 2.3.2 */&#13;
function parse_ClipboardFormatOrString(o, w) {&#13;
	// $FlowIgnore&#13;
	var ClipFmt = { 2: "BITMAP", 3: "METAFILEPICT", 8: "DIB", 14: "ENHMETAFILE" };&#13;
	var m = o.read_shift(4);&#13;
	switch (m) {&#13;
		case 0x00000000: return "";&#13;
		case 0xffffffff: case 0xfffffffe: return ClipFmt[o.read_shift(4)] || "";&#13;
	}&#13;
	if (m &gt; 0x190) throw new Error("Unsupported Clipboard: " + m.toString(16));&#13;
	o.l -= 4;&#13;
	return o.read_shift(0, w == 1 ? "lpstr" : "lpwstr");&#13;
}&#13;
function parse_ClipboardFormatOrAnsiString(o) { return parse_ClipboardFormatOrString(o, 1); }&#13;
function parse_ClipboardFormatOrUnicodeString(o) { return parse_ClipboardFormatOrString(o, 2); }&#13;
&#13;
/* [MS-OLEPS] 2.2 PropertyType */&#13;
// Note: some tree shakers cannot handle VT_VECTOR | $CONST, hence extra vars&#13;
//var VT_EMPTY    = 0x0000;&#13;
//var VT_NULL     = 0x0001;&#13;
var VT_I2       = 0x0002;&#13;
var VT_I4       = 0x0003;&#13;
//var VT_R4       = 0x0004;&#13;
//var VT_R8       = 0x0005;&#13;
//var VT_CY       = 0x0006;&#13;
//var VT_DATE     = 0x0007;&#13;
//var VT_BSTR     = 0x0008;&#13;
//var VT_ERROR    = 0x000A;&#13;
var VT_BOOL     = 0x000B;&#13;
var VT_VARIANT  = 0x000C;&#13;
//var VT_DECIMAL  = 0x000E;&#13;
//var VT_I1       = 0x0010;&#13;
//var VT_UI1      = 0x0011;&#13;
//var VT_UI2      = 0x0012;&#13;
var VT_UI4      = 0x0013;&#13;
//var VT_I8       = 0x0014;&#13;
//var VT_UI8      = 0x0015;&#13;
//var VT_INT      = 0x0016;&#13;
//var VT_UINT     = 0x0017;&#13;
//var VT_LPSTR    = 0x001E;&#13;
//var VT_LPWSTR   = 0x001F;&#13;
var VT_FILETIME = 0x0040;&#13;
var VT_BLOB     = 0x0041;&#13;
//var VT_STREAM   = 0x0042;&#13;
//var VT_STORAGE  = 0x0043;&#13;
//var VT_STREAMED_Object  = 0x0044;&#13;
//var VT_STORED_Object    = 0x0045;&#13;
//var VT_BLOB_Object      = 0x0046;&#13;
var VT_CF       = 0x0047;&#13;
//var VT_CLSID    = 0x0048;&#13;
//var VT_VERSIONED_STREAM = 0x0049;&#13;
//var VT_VECTOR   = 0x1000;&#13;
var VT_VECTOR_VARIANT = 0x100C;&#13;
var VT_VECTOR_LPSTR   = 0x101E;&#13;
//var VT_ARRAY    = 0x2000;&#13;
&#13;
var VT_STRING   = 0x0050; // 2.3.3.1.11 VtString&#13;
var VT_USTR     = 0x0051; // 2.3.3.1.12 VtUnalignedString&#13;
var VT_CUSTOM   = [VT_STRING, VT_USTR];&#13;
&#13;
/* [MS-OSHARED] 2.3.3.2.2.1 Document Summary Information PIDDSI */&#13;
var DocSummaryPIDDSI = {&#13;
0x01: { n: 'CodePage', t: VT_I2 },&#13;
0x02: { n: 'Category', t: VT_STRING },&#13;
0x03: { n: 'PresentationFormat', t: VT_STRING },&#13;
0x04: { n: 'ByteCount', t: VT_I4 },&#13;
0x05: { n: 'LineCount', t: VT_I4 },&#13;
0x06: { n: 'ParagraphCount', t: VT_I4 },&#13;
0x07: { n: 'SlideCount', t: VT_I4 },&#13;
0x08: { n: 'NoteCount', t: VT_I4 },&#13;
0x09: { n: 'HiddenCount', t: VT_I4 },&#13;
0x0a: { n: 'MultimediaClipCount', t: VT_I4 },&#13;
0x0b: { n: 'ScaleCrop', t: VT_BOOL },&#13;
0x0c: { n: 'HeadingPairs', t: VT_VECTOR_VARIANT /* VT_VECTOR | VT_VARIANT */ },&#13;
0x0d: { n: 'TitlesOfParts', t: VT_VECTOR_LPSTR /* VT_VECTOR | VT_LPSTR */ },&#13;
0x0e: { n: 'Manager', t: VT_STRING },&#13;
0x0f: { n: 'Company', t: VT_STRING },&#13;
0x10: { n: 'LinksUpToDate', t: VT_BOOL },&#13;
0x11: { n: 'CharacterCount', t: VT_I4 },&#13;
0x13: { n: 'SharedDoc', t: VT_BOOL },&#13;
0x16: { n: 'HyperlinksChanged', t: VT_BOOL },&#13;
0x17: { n: 'AppVersion', t: VT_I4, p: 'version' },&#13;
0x18: { n: 'DigSig', t: VT_BLOB },&#13;
0x1A: { n: 'ContentType', t: VT_STRING },&#13;
0x1B: { n: 'ContentStatus', t: VT_STRING },&#13;
0x1C: { n: 'Language', t: VT_STRING },&#13;
0x1D: { n: 'Version', t: VT_STRING },&#13;
0xFF: {},&#13;
	/* [MS-OLEPS] 2.18 */&#13;
0x80000000: { n: 'Locale', t: VT_UI4 },&#13;
0x80000003: { n: 'Behavior', t: VT_UI4 },&#13;
0x72627262: {}&#13;
};&#13;
&#13;
/* [MS-OSHARED] 2.3.3.2.1.1 Summary Information Property Set PIDSI */&#13;
var SummaryPIDSI = {&#13;
0x01: { n: 'CodePage', t: VT_I2 },&#13;
0x02: { n: 'Title', t: VT_STRING },&#13;
0x03: { n: 'Subject', t: VT_STRING },&#13;
0x04: { n: 'Author', t: VT_STRING },&#13;
0x05: { n: 'Keywords', t: VT_STRING },&#13;
0x06: { n: 'Comments', t: VT_STRING },&#13;
0x07: { n: 'Template', t: VT_STRING },&#13;
0x08: { n: 'LastAuthor', t: VT_STRING },&#13;
0x09: { n: 'RevNumber', t: VT_STRING },&#13;
0x0A: { n: 'EditTime', t: VT_FILETIME },&#13;
0x0B: { n: 'LastPrinted', t: VT_FILETIME },&#13;
0x0C: { n: 'CreatedDate', t: VT_FILETIME },&#13;
0x0D: { n: 'ModifiedDate', t: VT_FILETIME },&#13;
0x0E: { n: 'PageCount', t: VT_I4 },&#13;
0x0F: { n: 'WordCount', t: VT_I4 },&#13;
0x10: { n: 'CharCount', t: VT_I4 },&#13;
0x11: { n: 'Thumbnail', t: VT_CF },&#13;
0x12: { n: 'Application', t: VT_STRING },&#13;
0x13: { n: 'DocSecurity', t: VT_I4 },&#13;
0xFF: {},&#13;
	/* [MS-OLEPS] 2.18 */&#13;
0x80000000: { n: 'Locale', t: VT_UI4 },&#13;
0x80000003: { n: 'Behavior', t: VT_UI4 },&#13;
0x72627262: {}&#13;
};&#13;
&#13;
/* [MS-XLS] 2.4.63 Country/Region codes */&#13;
var CountryEnum = {&#13;
0x0001: "US", // United States&#13;
0x0002: "CA", // Canada&#13;
0x0003: "", // Latin America (except Brazil)&#13;
0x0007: "RU", // Russia&#13;
0x0014: "EG", // Egypt&#13;
0x001E: "GR", // Greece&#13;
0x001F: "NL", // Netherlands&#13;
0x0020: "BE", // Belgium&#13;
0x0021: "FR", // France&#13;
0x0022: "ES", // Spain&#13;
0x0024: "HU", // Hungary&#13;
0x0027: "IT", // Italy&#13;
0x0029: "CH", // Switzerland&#13;
0x002B: "AT", // Austria&#13;
0x002C: "GB", // United Kingdom&#13;
0x002D: "DK", // Denmark&#13;
0x002E: "SE", // Sweden&#13;
0x002F: "NO", // Norway&#13;
0x0030: "PL", // Poland&#13;
0x0031: "DE", // Germany&#13;
0x0034: "MX", // Mexico&#13;
0x0037: "BR", // Brazil&#13;
0x003d: "AU", // Australia&#13;
0x0040: "NZ", // New Zealand&#13;
0x0042: "TH", // Thailand&#13;
0x0051: "JP", // Japan&#13;
0x0052: "KR", // Korea&#13;
0x0054: "VN", // Viet Nam&#13;
0x0056: "CN", // China&#13;
0x005A: "TR", // Turkey&#13;
0x0069: "JS", // Ramastan&#13;
0x00D5: "DZ", // Algeria&#13;
0x00D8: "MA", // Morocco&#13;
0x00DA: "LY", // Libya&#13;
0x015F: "PT", // Portugal&#13;
0x0162: "IS", // Iceland&#13;
0x0166: "FI", // Finland&#13;
0x01A4: "CZ", // Czech Republic&#13;
0x0376: "TW", // Taiwan&#13;
0x03C1: "LB", // Lebanon&#13;
0x03C2: "JO", // Jordan&#13;
0x03C3: "SY", // Syria&#13;
0x03C4: "IQ", // Iraq&#13;
0x03C5: "KW", // Kuwait&#13;
0x03C6: "SA", // Saudi Arabia&#13;
0x03CB: "AE", // United Arab Emirates&#13;
0x03CC: "IL", // Israel&#13;
0x03CE: "QA", // Qatar&#13;
0x03D5: "IR", // Iran&#13;
0xFFFF: "US"  // United States&#13;
};&#13;
&#13;
/* [MS-XLS] 2.5.127 */&#13;
var XLSFillPattern = [&#13;
	null,&#13;
	'solid',&#13;
	'mediumGray',&#13;
	'darkGray',&#13;
	'lightGray',&#13;
	'darkHorizontal',&#13;
	'darkVertical',&#13;
	'darkDown',&#13;
	'darkUp',&#13;
	'darkGrid',&#13;
	'darkTrellis',&#13;
	'lightHorizontal',&#13;
	'lightVertical',&#13;
	'lightDown',&#13;
	'lightUp',&#13;
	'lightGrid',&#13;
	'lightTrellis',&#13;
	'gray125',&#13;
	'gray0625'&#13;
];&#13;
&#13;
function rgbify(arr) { return arr.map(function(x) { return [(x&gt;&gt;16)&amp;255,(x&gt;&gt;8)&amp;255,x&amp;255]; }); }&#13;
&#13;
/* [MS-XLS] 2.5.161 */&#13;
/* [MS-XLSB] 2.5.75 Icv */&#13;
var _XLSIcv =  rgbify([&#13;
	/* Color Constants */&#13;
	0x000000,&#13;
	0xFFFFFF,&#13;
	0xFF0000,&#13;
	0x00FF00,&#13;
	0x0000FF,&#13;
	0xFFFF00,&#13;
	0xFF00FF,&#13;
	0x00FFFF,&#13;
&#13;
	/* Overridable Defaults */&#13;
	0x000000,&#13;
	0xFFFFFF,&#13;
	0xFF0000,&#13;
	0x00FF00,&#13;
	0x0000FF,&#13;
	0xFFFF00,&#13;
	0xFF00FF,&#13;
	0x00FFFF,&#13;
&#13;
	0x800000,&#13;
	0x008000,&#13;
	0x000080,&#13;
	0x808000,&#13;
	0x800080,&#13;
	0x008080,&#13;
	0xC0C0C0,&#13;
	0x808080,&#13;
	0x9999FF,&#13;
	0x993366,&#13;
	0xFFFFCC,&#13;
	0xCCFFFF,&#13;
	0x660066,&#13;
	0xFF8080,&#13;
	0x0066CC,&#13;
	0xCCCCFF,&#13;
&#13;
	0x000080,&#13;
	0xFF00FF,&#13;
	0xFFFF00,&#13;
	0x00FFFF,&#13;
	0x800080,&#13;
	0x800000,&#13;
	0x008080,&#13;
	0x0000FF,&#13;
	0x00CCFF,&#13;
	0xCCFFFF,&#13;
	0xCCFFCC,&#13;
	0xFFFF99,&#13;
	0x99CCFF,&#13;
	0xFF99CC,&#13;
	0xCC99FF,&#13;
	0xFFCC99,&#13;
&#13;
	0x3366FF,&#13;
	0x33CCCC,&#13;
	0x99CC00,&#13;
	0xFFCC00,&#13;
	0xFF9900,&#13;
	0xFF6600,&#13;
	0x666699,&#13;
	0x969696,&#13;
	0x003366,&#13;
	0x339966,&#13;
	0x003300,&#13;
	0x333300,&#13;
	0x993300,&#13;
	0x993366,&#13;
	0x333399,&#13;
	0x333333,&#13;
&#13;
	/* Other entries to appease BIFF8/12 */&#13;
	0x000000, /* 0x40 icvForeground ?? */&#13;
	0xFFFFFF, /* 0x41 icvBackground ?? */&#13;
	0x000000, /* 0x42 icvFrame ?? */&#13;
	0x000000, /* 0x43 icv3D ?? */&#13;
	0x000000, /* 0x44 icv3DText ?? */&#13;
	0x000000, /* 0x45 icv3DHilite ?? */&#13;
	0x000000, /* 0x46 icv3DShadow ?? */&#13;
	0x000000, /* 0x47 icvHilite ?? */&#13;
	0x000000, /* 0x48 icvCtlText ?? */&#13;
	0x000000, /* 0x49 icvCtlScrl ?? */&#13;
	0x000000, /* 0x4A icvCtlInv ?? */&#13;
	0x000000, /* 0x4B icvCtlBody ?? */&#13;
	0x000000, /* 0x4C icvCtlFrame ?? */&#13;
	0x000000, /* 0x4D icvCtlFore ?? */&#13;
	0x000000, /* 0x4E icvCtlBack ?? */&#13;
	0x000000, /* 0x4F icvCtlNeutral */&#13;
	0x000000, /* 0x50 icvInfoBk ?? */&#13;
	0x000000 /* 0x51 icvInfoText ?? */&#13;
]);&#13;
var XLSIcv = dup(_XLSIcv);&#13;
&#13;
/* [MS-XLSB] 2.5.97.2 */&#13;
var BErr = {&#13;
0x00: "#NULL!",&#13;
0x07: "#DIV/0!",&#13;
0x0F: "#VALUE!",&#13;
0x17: "#REF!",&#13;
0x1D: "#NAME?",&#13;
0x24: "#NUM!",&#13;
0x2A: "#N/A",&#13;
0x2B: "#GETTING_DATA",&#13;
0xFF: "#WTF?"&#13;
};&#13;
//var RBErr = evert_num(BErr);&#13;
var RBErr = {&#13;
	"#NULL!":        0x00,&#13;
	"#DIV/0!":       0x07,&#13;
	"#VALUE!":       0x0F,&#13;
	"#REF!":         0x17,&#13;
	"#NAME?":        0x1D,&#13;
	"#NUM!":         0x24,&#13;
	"#N/A":          0x2A,&#13;
	"#GETTING_DATA": 0x2B,&#13;
	"#WTF?":         0xFF&#13;
};&#13;
&#13;
var XLSLblBuiltIn = [&#13;
	"_xlnm.Consolidate_Area",&#13;
	"_xlnm.Auto_Open",&#13;
	"_xlnm.Auto_Close",&#13;
	"_xlnm.Extract",&#13;
	"_xlnm.Database",&#13;
	"_xlnm.Criteria",&#13;
	"_xlnm.Print_Area",&#13;
	"_xlnm.Print_Titles",&#13;
	"_xlnm.Recorder",&#13;
	"_xlnm.Data_Form",&#13;
	"_xlnm.Auto_Activate",&#13;
	"_xlnm.Auto_Deactivate",&#13;
	"_xlnm.Sheet_Title",&#13;
	"_xlnm._FilterDatabase"&#13;
];&#13;
&#13;
/* Parts enumerated in OPC spec, MS-XLSB and MS-XLSX */&#13;
/* 12.3 Part Summary &lt;SpreadsheetML&gt; */&#13;
/* 14.2 Part Summary &lt;DrawingML&gt; */&#13;
/* [MS-XLSX] 2.1 Part Enumerations ; [MS-XLSB] 2.1.7 Part Enumeration */&#13;
var ct2type/*{[string]:string}*/ = ({&#13;
	/* Workbook */&#13;
	"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": "workbooks",&#13;
	"application/vnd.ms-excel.sheet.macroEnabled.main+xml": "workbooks",&#13;
	"application/vnd.ms-excel.sheet.binary.macroEnabled.main": "workbooks",&#13;
	"application/vnd.ms-excel.addin.macroEnabled.main+xml": "workbooks",&#13;
	"application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": "workbooks",&#13;
&#13;
	/* Worksheet */&#13;
	"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": "sheets",&#13;
	"application/vnd.ms-excel.worksheet": "sheets",&#13;
	"application/vnd.ms-excel.binIndexWs": "TODO", /* Binary Index */&#13;
&#13;
	/* Chartsheet */&#13;
	"application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": "charts",&#13;
	"application/vnd.ms-excel.chartsheet": "charts",&#13;
&#13;
	/* Macrosheet */&#13;
	"application/vnd.ms-excel.macrosheet+xml": "macros",&#13;
	"application/vnd.ms-excel.macrosheet": "macros",&#13;
	"application/vnd.ms-excel.intlmacrosheet": "TODO",&#13;
	"application/vnd.ms-excel.binIndexMs": "TODO", /* Binary Index */&#13;
&#13;
	/* Dialogsheet */&#13;
	"application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": "dialogs",&#13;
	"application/vnd.ms-excel.dialogsheet": "dialogs",&#13;
&#13;
	/* Shared Strings */&#13;
	"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml": "strs",&#13;
	"application/vnd.ms-excel.sharedStrings": "strs",&#13;
&#13;
	/* Styles */&#13;
	"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": "styles",&#13;
	"application/vnd.ms-excel.styles": "styles",&#13;
&#13;
	/* File Properties */&#13;
	"application/vnd.openxmlformats-package.core-properties+xml": "coreprops",&#13;
	"application/vnd.openxmlformats-officedocument.custom-properties+xml": "custprops",&#13;
	"application/vnd.openxmlformats-officedocument.extended-properties+xml": "extprops",&#13;
&#13;
	/* Custom Data Properties */&#13;
	"application/vnd.openxmlformats-officedocument.customXmlProperties+xml": "TODO",&#13;
	"application/vnd.openxmlformats-officedocument.spreadsheetml.customProperty": "TODO",&#13;
&#13;
	/* Comments */&#13;
	"application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": "comments",&#13;
	"application/vnd.ms-excel.comments": "comments",&#13;
	"application/vnd.ms-excel.threadedcomments+xml": "threadedcomments",&#13;
	"application/vnd.ms-excel.person+xml": "people",&#13;
&#13;
	/* Metadata (Stock/Geography and Dynamic Array) */&#13;
	"application/vnd.openxmlformats-officedocument.spreadsheetml.sheetMetadata+xml": "metadata",&#13;
	"application/vnd.ms-excel.sheetMetadata": "metadata",&#13;
&#13;
	/* PivotTable */&#13;
	"application/vnd.ms-excel.pivotTable": "TODO",&#13;
	"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotTable+xml": "TODO",&#13;
&#13;
	/* Chart Objects */&#13;
	"application/vnd.openxmlformats-officedocument.drawingml.chart+xml": "TODO",&#13;
&#13;
	/* Chart Colors */&#13;
	"application/vnd.ms-office.chartcolorstyle+xml": "TODO",&#13;
&#13;
	/* Chart Style */&#13;
	"application/vnd.ms-office.chartstyle+xml": "TODO",&#13;
&#13;
	/* Chart Advanced */&#13;
	"application/vnd.ms-office.chartex+xml": "TODO",&#13;
&#13;
	/* Calculation Chain */&#13;
	"application/vnd.ms-excel.calcChain": "calcchains",&#13;
	"application/vnd.openxmlformats-officedocument.spreadsheetml.calcChain+xml": "calcchains",&#13;
&#13;
	/* Printer Settings */&#13;
	"application/vnd.openxmlformats-officedocument.spreadsheetml.printerSettings": "TODO",&#13;
&#13;
	/* ActiveX */&#13;
	"application/vnd.ms-office.activeX": "TODO",&#13;
	"application/vnd.ms-office.activeX+xml": "TODO",&#13;
&#13;
	/* Custom Toolbars */&#13;
	"application/vnd.ms-excel.attachedToolbars": "TODO",&#13;
&#13;
	/* External Data Connections */&#13;
	"application/vnd.ms-excel.connections": "TODO",&#13;
	"application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": "TODO",&#13;
&#13;
	/* External Links */&#13;
	"application/vnd.ms-excel.externalLink": "links",&#13;
	"application/vnd.openxmlformats-officedocument.spreadsheetml.externalLink+xml": "links",&#13;
&#13;
	/* PivotCache */&#13;
	"application/vnd.ms-excel.pivotCacheDefinition": "TODO",&#13;
	"application/vnd.ms-excel.pivotCacheRecords": "TODO",&#13;
	"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotCacheDefinition+xml": "TODO",&#13;
	"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotCacheRecords+xml": "TODO",&#13;
&#13;
	/* Query Table */&#13;
	"application/vnd.ms-excel.queryTable": "TODO",&#13;
	"application/vnd.openxmlformats-officedocument.spreadsheetml.queryTable+xml": "TODO",&#13;
&#13;
	/* Shared Workbook */&#13;
	"application/vnd.ms-excel.userNames": "TODO",&#13;
	"application/vnd.ms-excel.revisionHeaders": "TODO",&#13;
	"application/vnd.ms-excel.revisionLog": "TODO",&#13;
	"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionHeaders+xml": "TODO",&#13;
	"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionLog+xml": "TODO",&#13;
	"application/vnd.openxmlformats-officedocument.spreadsheetml.userNames+xml": "TODO",&#13;
&#13;
	/* Single Cell Table */&#13;
	"application/vnd.ms-excel.tableSingleCells": "TODO",&#13;
	"application/vnd.openxmlformats-officedocument.spreadsheetml.tableSingleCells+xml": "TODO",&#13;
&#13;
	/* Slicer */&#13;
	"application/vnd.ms-excel.slicer": "TODO",&#13;
	"application/vnd.ms-excel.slicerCache": "TODO",&#13;
	"application/vnd.ms-excel.slicer+xml": "TODO",&#13;
	"application/vnd.ms-excel.slicerCache+xml": "TODO",&#13;
&#13;
	/* Sort Map */&#13;
	"application/vnd.ms-excel.wsSortMap": "TODO",&#13;
&#13;
	/* Table */&#13;
	"application/vnd.ms-excel.table": "TODO",&#13;
	"application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": "TODO",&#13;
&#13;
	/* Themes */&#13;
	"application/vnd.openxmlformats-officedocument.theme+xml": "themes",&#13;
&#13;
	/* Theme Override */&#13;
	"application/vnd.openxmlformats-officedocument.themeOverride+xml": "TODO",&#13;
&#13;
	/* Timeline */&#13;
	"application/vnd.ms-excel.Timeline+xml": "TODO", /* verify */&#13;
	"application/vnd.ms-excel.TimelineCache+xml": "TODO", /* verify */&#13;
&#13;
	/* VBA */&#13;
	"application/vnd.ms-office.vbaProject": "vba",&#13;
	"application/vnd.ms-office.vbaProjectSignature": "TODO",&#13;
&#13;
	/* Volatile Dependencies */&#13;
	"application/vnd.ms-office.volatileDependencies": "TODO",&#13;
	"application/vnd.openxmlformats-officedocument.spreadsheetml.volatileDependencies+xml": "TODO",&#13;
&#13;
	/* Control Properties */&#13;
	"application/vnd.ms-excel.controlproperties+xml": "TODO",&#13;
&#13;
	/* Data Model */&#13;
	"application/vnd.openxmlformats-officedocument.model+data": "TODO",&#13;
&#13;
	/* Survey */&#13;
	"application/vnd.ms-excel.Survey+xml": "TODO",&#13;
&#13;
	/* Drawing */&#13;
	"application/vnd.openxmlformats-officedocument.drawing+xml": "drawings",&#13;
	"application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": "TODO",&#13;
	"application/vnd.openxmlformats-officedocument.drawingml.diagramColors+xml": "TODO",&#13;
	"application/vnd.openxmlformats-officedocument.drawingml.diagramData+xml": "TODO",&#13;
	"application/vnd.openxmlformats-officedocument.drawingml.diagramLayout+xml": "TODO",&#13;
	"application/vnd.openxmlformats-officedocument.drawingml.diagramStyle+xml": "TODO",&#13;
&#13;
	/* VML */&#13;
	"application/vnd.openxmlformats-officedocument.vmlDrawing": "TODO",&#13;
&#13;
	"application/vnd.openxmlformats-package.relationships+xml": "rels",&#13;
	"application/vnd.openxmlformats-officedocument.oleObject": "TODO",&#13;
&#13;
	/* Image */&#13;
	"image/png": "TODO",&#13;
&#13;
	"sheet": "js"&#13;
});&#13;
&#13;
var CT_LIST = {&#13;
	workbooks: {&#13;
		xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml",&#13;
		xlsm: "application/vnd.ms-excel.sheet.macroEnabled.main+xml",&#13;
		xlsb: "application/vnd.ms-excel.sheet.binary.macroEnabled.main",&#13;
		xlam: "application/vnd.ms-excel.addin.macroEnabled.main+xml",&#13;
		xltx: "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml"&#13;
	},&#13;
	strs: { /* Shared Strings */&#13;
		xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml",&#13;
		xlsb: "application/vnd.ms-excel.sharedStrings"&#13;
	},&#13;
	comments: { /* Comments */&#13;
		xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml",&#13;
		xlsb: "application/vnd.ms-excel.comments"&#13;
	},&#13;
	sheets: { /* Worksheet */&#13;
		xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml",&#13;
		xlsb: "application/vnd.ms-excel.worksheet"&#13;
	},&#13;
	charts: { /* Chartsheet */&#13;
		xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml",&#13;
		xlsb: "application/vnd.ms-excel.chartsheet"&#13;
	},&#13;
	dialogs: { /* Dialogsheet */&#13;
		xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml",&#13;
		xlsb: "application/vnd.ms-excel.dialogsheet"&#13;
	},&#13;
	macros: { /* Macrosheet (Excel 4.0 Macros) */&#13;
		xlsx: "application/vnd.ms-excel.macrosheet+xml",&#13;
		xlsb: "application/vnd.ms-excel.macrosheet"&#13;
	},&#13;
	metadata: { /* Metadata (Stock/Geography and Dynamic Array) */&#13;
		xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetMetadata+xml",&#13;
		xlsb: "application/vnd.ms-excel.sheetMetadata"&#13;
	},&#13;
	styles: { /* Styles */&#13;
		xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml",&#13;
		xlsb: "application/vnd.ms-excel.styles"&#13;
	}&#13;
};&#13;
&#13;
function new_ct() {&#13;
	return ({&#13;
		workbooks:[], sheets:[], charts:[], dialogs:[], macros:[],&#13;
		rels:[], strs:[], comments:[], threadedcomments:[], links:[],&#13;
		coreprops:[], extprops:[], custprops:[], themes:[], styles:[],&#13;
		calcchains:[], vba: [], drawings: [], metadata: [], people:[],&#13;
		TODO:[], xmlns: "" });&#13;
}&#13;
&#13;
function parse_ct(data) {&#13;
	var ct = new_ct();&#13;
	if(!data || !data.match) return ct;&#13;
	var ctext = {};&#13;
	(data.match(tagregex)||[]).forEach(function(x) {&#13;
		var y = parsexmltag(x);&#13;
		switch(y[0].replace(nsregex,"&lt;")) {&#13;
			case '&lt;?xml': break;&#13;
			case '&lt;Types': ct.xmlns = y['xmlns' + (y[0].match(/&lt;(\w+):/)||["",""])[1] ]; break;&#13;
			case '&lt;Default': ctext[y.Extension.toLowerCase()] = y.ContentType; break;&#13;
			case '&lt;Override':&#13;
				if(ct[ct2type[y.ContentType]] !== undefined) ct[ct2type[y.ContentType]].push(y.PartName);&#13;
				break;&#13;
		}&#13;
	});&#13;
	if(ct.xmlns !== XMLNS.CT) throw new Error("Unknown Namespace: " + ct.xmlns);&#13;
	ct.calcchain = ct.calcchains.length &gt; 0 ? ct.calcchains[0] : "";&#13;
	ct.sst = ct.strs.length &gt; 0 ? ct.strs[0] : "";&#13;
	ct.style = ct.styles.length &gt; 0 ? ct.styles[0] : "";&#13;
	ct.defaults = ctext;&#13;
	delete ct.calcchains;&#13;
	return ct;&#13;
}&#13;
&#13;
function write_ct(ct, opts, raw) {&#13;
	var type2ct/*{[string]:Array&lt;string&gt;}*/ = evert_arr(ct2type);&#13;
&#13;
	var o = [], v;&#13;
&#13;
	if(!raw) {&#13;
		o[o.length] = (XML_HEADER);&#13;
		o[o.length] = writextag('Types', null, {&#13;
			'xmlns': XMLNS.CT,&#13;
			'xmlns:xsd': XMLNS.xsd,&#13;
			'xmlns:xsi': XMLNS.xsi&#13;
		});&#13;
		o = o.concat([&#13;
			['xml', 'application/xml'],&#13;
			['bin', 'application/vnd.ms-excel.sheet.binary.macroEnabled.main'],&#13;
			['vml', 'application/vnd.openxmlformats-officedocument.vmlDrawing'],&#13;
			['data', 'application/vnd.openxmlformats-officedocument.model+data'],&#13;
			/* from test files */&#13;
			['bmp', 'image/bmp'],&#13;
			['png', 'image/png'],&#13;
			['gif', 'image/gif'],&#13;
			['emf', 'image/x-emf'],&#13;
			['wmf', 'image/x-wmf'],&#13;
			['jpg', 'image/jpeg'], ['jpeg', 'image/jpeg'],&#13;
			['tif', 'image/tiff'], ['tiff', 'image/tiff'],&#13;
			['pdf', 'application/pdf'],&#13;
			['rels', 'application/vnd.openxmlformats-package.relationships+xml']&#13;
		].map(function(x) {&#13;
			return writextag('Default', null, {'Extension':x[0], 'ContentType': x[1]});&#13;
		}));&#13;
	}&#13;
&#13;
	/* only write first instance */&#13;
	var f1 = function(w) {&#13;
		if(ct[w] &amp;&amp; ct[w].length &gt; 0) {&#13;
			v = ct[w][0];&#13;
			o[o.length] = (writextag('Override', null, {&#13;
				'PartName': (v[0] == '/' ? "":"/") + v,&#13;
				'ContentType': CT_LIST[w][opts.bookType] || CT_LIST[w]['xlsx']&#13;
			}));&#13;
		}&#13;
	};&#13;
&#13;
	/* book type-specific */&#13;
	var f2 = function(w) {&#13;
		(ct[w]||[]).forEach(function(v) {&#13;
			o[o.length] = (writextag('Override', null, {&#13;
				'PartName': (v[0] == '/' ? "":"/") + v,&#13;
				'ContentType': CT_LIST[w][opts.bookType] || CT_LIST[w]['xlsx']&#13;
			}));&#13;
		});&#13;
	};&#13;
&#13;
	/* standard type */&#13;
	var f3 = function(t) {&#13;
		(ct[t]||[]).forEach(function(v) {&#13;
			o[o.length] = (writextag('Override', null, {&#13;
				'PartName': (v[0] == '/' ? "":"/") + v,&#13;
				'ContentType': type2ct[t][0]&#13;
			}));&#13;
		});&#13;
	};&#13;
&#13;
	f1('workbooks');&#13;
	f2('sheets');&#13;
	f2('charts');&#13;
	f3('themes');&#13;
	['strs', 'styles'].forEach(f1);&#13;
	['coreprops', 'extprops', 'custprops'].forEach(f3);&#13;
	f3('vba');&#13;
	f3('comments');&#13;
	f3('threadedcomments');&#13;
	f3('drawings');&#13;
	f2('metadata');&#13;
	f3('people');&#13;
	if(!raw &amp;&amp; o.length&gt;2){ o[o.length] = ('&lt;/Types&gt;'); o[1]=o[1].replace("/&gt;","&gt;"); }&#13;
	return o.join("");&#13;
}&#13;
/* 9.3 Relationships */&#13;
var RELS = ({&#13;
	WB: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument",&#13;
	SHEET: "http://sheetjs.openxmlformats.org/officeDocument/2006/relationships/officeDocument",&#13;
	HLINK: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink",&#13;
	VML: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/vmlDrawing",&#13;
	XPATH: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/externalLinkPath",&#13;
	XMISS: "http://schemas.microsoft.com/office/2006/relationships/xlExternalLinkPath/xlPathMissing",&#13;
	XLINK: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/externalLink",&#13;
	CXML: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/customXml",&#13;
	CXMLP: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/customXmlProps",&#13;
	CMNT: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/comments",&#13;
	CORE_PROPS: "http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties",&#13;
	EXT_PROPS: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties',&#13;
	CUST_PROPS: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/custom-properties',&#13;
	SST: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings",&#13;
	STY: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles",&#13;
	THEME: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme",&#13;
	CHART: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/chart",&#13;
	CHARTEX: "http://schemas.microsoft.com/office/2014/relationships/chartEx",&#13;
	CS: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/chartsheet",&#13;
	WS: [&#13;
		"http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet",&#13;
		"http://purl.oclc.org/ooxml/officeDocument/relationships/worksheet"&#13;
	],&#13;
	DS: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/dialogsheet",&#13;
	MS: "http://schemas.microsoft.com/office/2006/relationships/xlMacrosheet",&#13;
	IMG: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image",&#13;
	DRAW: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing",&#13;
	XLMETA: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/sheetMetadata",&#13;
	TCMNT: "http://schemas.microsoft.com/office/2017/10/relationships/threadedComment",&#13;
	PEOPLE: "http://schemas.microsoft.com/office/2017/10/relationships/person",&#13;
	CONN: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/connections",&#13;
	VBA: "http://schemas.microsoft.com/office/2006/relationships/vbaProject"&#13;
});&#13;
&#13;
/* 9.3.3 Representing Relationships */&#13;
function get_rels_path(file) {&#13;
	var n = file.lastIndexOf("/");&#13;
	return file.slice(0,n+1) + '_rels/' + file.slice(n+1) + ".rels";&#13;
}&#13;
&#13;
function parse_rels(data, currentFilePath) {&#13;
	var rels = {"!id":{}};&#13;
	if (!data) return rels;&#13;
	if (currentFilePath.charAt(0) !== '/') {&#13;
		currentFilePath = '/'+currentFilePath;&#13;
	}&#13;
	var hash = {};&#13;
&#13;
	(data.match(tagregex)||[]).forEach(function(x) {&#13;
		var y = parsexmltag(x);&#13;
		/* 9.3.2.2 OPC_Relationships */&#13;
		if (y[0] === '&lt;Relationship') {&#13;
			var rel = {}; rel.Type = y.Type; rel.Target = y.Target; rel.Id = y.Id; if(y.TargetMode) rel.TargetMode = y.TargetMode;&#13;
			var canonictarget = y.TargetMode === 'External' ? y.Target : resolve_path(y.Target, currentFilePath);&#13;
			rels[canonictarget] = rel;&#13;
			hash[y.Id] = rel;&#13;
		}&#13;
	});&#13;
	rels["!id"] = hash;&#13;
	return rels;&#13;
}&#13;
&#13;
&#13;
/* TODO */&#13;
function write_rels(rels) {&#13;
	var o = [XML_HEADER, writextag('Relationships', null, {&#13;
		//'xmlns:ns0': XMLNS.RELS,&#13;
		'xmlns': XMLNS.RELS&#13;
	})];&#13;
	keys(rels['!id']).forEach(function(rid) {&#13;
		o[o.length] = (writextag('Relationship', null, rels['!id'][rid]));&#13;
	});&#13;
	if(o.length&gt;2){ o[o.length] = ('&lt;/Relationships&gt;'); o[1]=o[1].replace("/&gt;","&gt;"); }&#13;
	return o.join("");&#13;
}&#13;
&#13;
function add_rels(rels, rId, f, type, relobj, targetmode) {&#13;
	if(!relobj) relobj = {};&#13;
	if(!rels['!id']) rels['!id'] = {};&#13;
	if(!rels['!idx']) rels['!idx'] = 1;&#13;
	if(rId &lt; 0) for(rId = rels['!idx']; rels['!id']['rId' + rId]; ++rId){/* empty */}&#13;
	rels['!idx'] = rId + 1;&#13;
	relobj.Id = 'rId' + rId;&#13;
	relobj.Type = type;&#13;
	relobj.Target = f;&#13;
	if(targetmode) relobj.TargetMode = targetmode;&#13;
	else if([RELS.HLINK, RELS.XPATH, RELS.XMISS].indexOf(relobj.Type) &gt; -1) relobj.TargetMode = "External";&#13;
	if(rels['!id'][relobj.Id]) throw new Error("Cannot rewrite rId " + rId);&#13;
	rels['!id'][relobj.Id] = relobj;&#13;
	rels[('/' + relobj.Target).replace("//","/")] = relobj;&#13;
	return rId;&#13;
}&#13;
/* Open Document Format for Office Applications (OpenDocument) Version 1.2 */&#13;
/* Part 3 Section 4 Manifest File */&#13;
var CT_ODS = "application/vnd.oasis.opendocument.spreadsheet";&#13;
function parse_manifest(d, opts) {&#13;
	var str = xlml_normalize(d);&#13;
	var Rn;&#13;
	var FEtag;&#13;
	while((Rn = xlmlregex.exec(str))) switch(Rn[3]) {&#13;
		case 'manifest': break; // 4.2 &lt;manifest:manifest&gt;&#13;
		case 'file-entry': // 4.3 &lt;manifest:file-entry&gt;&#13;
			FEtag = parsexmltag(Rn[0], false);&#13;
			if(FEtag.path == '/' &amp;&amp; FEtag.type !== CT_ODS) throw new Error("This OpenDocument is not a spreadsheet");&#13;
			break;&#13;
		case 'encryption-data': // 4.4 &lt;manifest:encryption-data&gt;&#13;
		case 'algorithm': // 4.5 &lt;manifest:algorithm&gt;&#13;
		case 'start-key-generation': // 4.6 &lt;manifest:start-key-generation&gt;&#13;
		case 'key-derivation': // 4.7 &lt;manifest:key-derivation&gt;&#13;
			throw new Error("Unsupported ODS Encryption");&#13;
		default: if(opts &amp;&amp; opts.WTF) throw Rn;&#13;
	}&#13;
}&#13;
&#13;
function write_manifest(manifest) {&#13;
	var o = [XML_HEADER];&#13;
	o.push('&lt;manifest:manifest xmlns:manifest="urn:oasis:names:tc:opendocument:xmlns:manifest:1.0" manifest:version="1.2"&gt;\n');&#13;
	o.push('  &lt;manifest:file-entry manifest:full-path="/" manifest:version="1.2" manifest:media-type="application/vnd.oasis.opendocument.spreadsheet"/&gt;\n');&#13;
	for(var i = 0; i &lt; manifest.length; ++i) o.push('  &lt;manifest:file-entry manifest:full-path="' + manifest[i][0] + '" manifest:media-type="' + manifest[i][1] + '"/&gt;\n');&#13;
	o.push('&lt;/manifest:manifest&gt;');&#13;
	return o.join("");&#13;
}&#13;
&#13;
/* Part 3 Section 6 Metadata Manifest File */&#13;
function write_rdf_type(file, res, tag) {&#13;
	return [&#13;
		'  &lt;rdf:Description rdf:about="' + file + '"&gt;\n',&#13;
		'    &lt;rdf:type rdf:resource="http://docs.oasis-open.org/ns/office/1.2/meta/' + (tag || "odf") + '#' + res + '"/&gt;\n',&#13;
		'  &lt;/rdf:Description&gt;\n'&#13;
	].join("");&#13;
}&#13;
function write_rdf_has(base, file) {&#13;
	return [&#13;
		'  &lt;rdf:Description rdf:about="' + base + '"&gt;\n',&#13;
		'    &lt;ns0:hasPart xmlns:ns0="http://docs.oasis-open.org/ns/office/1.2/meta/pkg#" rdf:resource="' + file + '"/&gt;\n',&#13;
		'  &lt;/rdf:Description&gt;\n'&#13;
	].join("");&#13;
}&#13;
function write_rdf(rdf) {&#13;
	var o = [XML_HEADER];&#13;
	o.push('&lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt;\n');&#13;
	for(var i = 0; i != rdf.length; ++i) {&#13;
		o.push(write_rdf_type(rdf[i][0], rdf[i][1]));&#13;
		o.push(write_rdf_has("",rdf[i][0]));&#13;
	}&#13;
	o.push(write_rdf_type("","Document", "pkg"));&#13;
	o.push('&lt;/rdf:RDF&gt;');&#13;
	return o.join("");&#13;
}&#13;
/* TODO: pull properties */&#13;
function write_meta_ods() {&#13;
	return '&lt;office:document-meta xmlns:office="urn:oasis:names:tc:opendocument:xmlns:office:1.0" xmlns:meta="urn:oasis:names:tc:opendocument:xmlns:meta:1.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:xlink="http://www.w3.org/1999/xlink" office:version="1.2"&gt;&lt;office:meta&gt;&lt;meta:generator&gt;Sheet' + 'JS ' + XLSX.version + '&lt;/meta:generator&gt;&lt;/office:meta&gt;&lt;/office:document-meta&gt;';&#13;
}&#13;
&#13;
/* ECMA-376 Part II 11.1 Core Properties Part */&#13;
/* [MS-OSHARED] 2.3.3.2.[1-2].1 (PIDSI/PIDDSI) */&#13;
var CORE_PROPS = [&#13;
	["cp:category", "Category"],&#13;
	["cp:contentStatus", "ContentStatus"],&#13;
	["cp:keywords", "Keywords"],&#13;
	["cp:lastModifiedBy", "LastAuthor"],&#13;
	["cp:lastPrinted", "LastPrinted"],&#13;
	["cp:revision", "RevNumber"],&#13;
	["cp:version", "Version"],&#13;
	["dc:creator", "Author"],&#13;
	["dc:description", "Comments"],&#13;
	["dc:identifier", "Identifier"],&#13;
	["dc:language", "Language"],&#13;
	["dc:subject", "Subject"],&#13;
	["dc:title", "Title"],&#13;
	["dcterms:created", "CreatedDate", 'date'],&#13;
	["dcterms:modified", "ModifiedDate", 'date']&#13;
];&#13;
&#13;
var CORE_PROPS_REGEX = (function() {&#13;
	var r = new Array(CORE_PROPS.length);&#13;
	for(var i = 0; i &lt; CORE_PROPS.length; ++i) {&#13;
		var f = CORE_PROPS[i];&#13;
		var g = "(?:"+ f[0].slice(0,f[0].indexOf(":")) +":)"+ f[0].slice(f[0].indexOf(":")+1);&#13;
		r[i] = new RegExp("&lt;" + g + "[^&gt;]*&gt;([\\s\\S]*?)&lt;\/" + g + "&gt;");&#13;
	}&#13;
	return r;&#13;
})();&#13;
&#13;
function parse_core_props(data) {&#13;
	var p = {};&#13;
	data = utf8read(data);&#13;
&#13;
	for(var i = 0; i &lt; CORE_PROPS.length; ++i) {&#13;
		var f = CORE_PROPS[i], cur = data.match(CORE_PROPS_REGEX[i]);&#13;
		if(cur != null &amp;&amp; cur.length &gt; 0) p[f[1]] = unescapexml(cur[1]);&#13;
		if(f[2] === 'date' &amp;&amp; p[f[1]]) p[f[1]] = parseDate(p[f[1]]);&#13;
	}&#13;
&#13;
	return p;&#13;
}&#13;
&#13;
function cp_doit(f, g, h, o, p) {&#13;
	if(p[f] != null || g == null || g === "") return;&#13;
	p[f] = g;&#13;
	g = escapexml(g);&#13;
	o[o.length] = (h ? writextag(f,g,h) : writetag(f,g));&#13;
}&#13;
&#13;
function write_core_props(cp, _opts) {&#13;
	var opts = _opts || {};&#13;
	var o = [XML_HEADER, writextag('cp:coreProperties', null, {&#13;
		//'xmlns': XMLNS.CORE_PROPS,&#13;
		'xmlns:cp': XMLNS.CORE_PROPS,&#13;
		'xmlns:dc': XMLNS.dc,&#13;
		'xmlns:dcterms': XMLNS.dcterms,&#13;
		'xmlns:dcmitype': XMLNS.dcmitype,&#13;
		'xmlns:xsi': XMLNS.xsi&#13;
	})], p = {};&#13;
	if(!cp &amp;&amp; !opts.Props) return o.join("");&#13;
&#13;
	if(cp) {&#13;
		if(cp.CreatedDate != null) cp_doit("dcterms:created", typeof cp.CreatedDate === "string" ? cp.CreatedDate : write_w3cdtf(cp.CreatedDate, opts.WTF), {"xsi:type":"dcterms:W3CDTF"}, o, p);&#13;
		if(cp.ModifiedDate != null) cp_doit("dcterms:modified", typeof cp.ModifiedDate === "string" ? cp.ModifiedDate : write_w3cdtf(cp.ModifiedDate, opts.WTF), {"xsi:type":"dcterms:W3CDTF"}, o, p);&#13;
	}&#13;
&#13;
	for(var i = 0; i != CORE_PROPS.length; ++i) {&#13;
		var f = CORE_PROPS[i];&#13;
		var v = opts.Props &amp;&amp; opts.Props[f[1]] != null ? opts.Props[f[1]] : cp ? cp[f[1]] : null;&#13;
		if(v === true) v = "1";&#13;
		else if(v === false) v = "0";&#13;
		else if(typeof v == "number") v = String(v);&#13;
		if(v != null) cp_doit(f[0], v, null, o, p);&#13;
	}&#13;
	if(o.length&gt;2){ o[o.length] = ('&lt;/cp:coreProperties&gt;'); o[1]=o[1].replace("/&gt;","&gt;"); }&#13;
	return o.join("");&#13;
}&#13;
/* 15.2.12.3 Extended File Properties Part */&#13;
/* [MS-OSHARED] 2.3.3.2.[1-2].1 (PIDSI/PIDDSI) */&#13;
var EXT_PROPS = [&#13;
	["Application", "Application", "string"],&#13;
	["AppVersion", "AppVersion", "string"],&#13;
	["Company", "Company", "string"],&#13;
	["DocSecurity", "DocSecurity", "string"],&#13;
	["Manager", "Manager", "string"],&#13;
	["HyperlinksChanged", "HyperlinksChanged", "bool"],&#13;
	["SharedDoc", "SharedDoc", "bool"],&#13;
	["LinksUpToDate", "LinksUpToDate", "bool"],&#13;
	["ScaleCrop", "ScaleCrop", "bool"],&#13;
	["HeadingPairs", "HeadingPairs", "raw"],&#13;
	["TitlesOfParts", "TitlesOfParts", "raw"]&#13;
];&#13;
&#13;
var PseudoPropsPairs = [&#13;
	"Worksheets",  "SheetNames",&#13;
	"NamedRanges", "DefinedNames",&#13;
	"Chartsheets", "ChartNames"&#13;
];&#13;
function load_props_pairs(HP, TOP, props, opts) {&#13;
	var v = [];&#13;
	if(typeof HP == "string") v = parseVector(HP, opts);&#13;
	else for(var j = 0; j &lt; HP.length; ++j) v = v.concat(HP[j].map(function(hp) { return {v:hp}; }));&#13;
	var parts = (typeof TOP == "string") ? parseVector(TOP, opts).map(function (x) { return x.v; }) : TOP;&#13;
	var idx = 0, len = 0;&#13;
	if(parts.length &gt; 0) for(var i = 0; i !== v.length; i += 2) {&#13;
		len = +(v[i+1].v);&#13;
		switch(v[i].v) {&#13;
			case "Worksheets":&#13;
			case "工作表":&#13;
			case "Листы":&#13;
			case "أوراق العمل":&#13;
			case "ワークシート":&#13;
			case "גליונות עבודה":&#13;
			case "Arbeitsblätter":&#13;
			case "Çalışma Sayfaları":&#13;
			case "Feuilles de calcul":&#13;
			case "Fogli di lavoro":&#13;
			case "Folhas de cálculo":&#13;
			case "Planilhas":&#13;
			case "Regneark":&#13;
			case "Hojas de cálculo":&#13;
			case "Werkbladen":&#13;
				props.Worksheets = len;&#13;
				props.SheetNames = parts.slice(idx, idx + len);&#13;
				break;&#13;
&#13;
			case "Named Ranges":&#13;
			case "Rangos con nombre":&#13;
			case "名前付き一覧":&#13;
			case "Benannte Bereiche":&#13;
			case "Navngivne områder":&#13;
				props.NamedRanges = len;&#13;
				props.DefinedNames = parts.slice(idx, idx + len);&#13;
				break;&#13;
&#13;
			case "Charts":&#13;
			case "Diagramme":&#13;
				props.Chartsheets = len;&#13;
				props.ChartNames = parts.slice(idx, idx + len);&#13;
				break;&#13;
		}&#13;
		idx += len;&#13;
	}&#13;
}&#13;
&#13;
function parse_ext_props(data, p, opts) {&#13;
	var q = {}; if(!p) p = {};&#13;
	data = utf8read(data);&#13;
&#13;
	EXT_PROPS.forEach(function(f) {&#13;
		var xml = (data.match(matchtag(f[0]))||[])[1];&#13;
		switch(f[2]) {&#13;
			case "string": if(xml) p[f[1]] = unescapexml(xml); break;&#13;
			case "bool": p[f[1]] = xml === "true"; break;&#13;
			case "raw":&#13;
				var cur = data.match(new RegExp("&lt;" + f[0] + "[^&gt;]*&gt;([\\s\\S]*?)&lt;\/" + f[0] + "&gt;"));&#13;
				if(cur &amp;&amp; cur.length &gt; 0) q[f[1]] = cur[1];&#13;
				break;&#13;
		}&#13;
	});&#13;
&#13;
	if(q.HeadingPairs &amp;&amp; q.TitlesOfParts) load_props_pairs(q.HeadingPairs, q.TitlesOfParts, p, opts);&#13;
&#13;
	return p;&#13;
}&#13;
&#13;
function write_ext_props(cp) {&#13;
	var o = [], W = writextag;&#13;
	if(!cp) cp = {};&#13;
	cp.Application = "xlsx";&#13;
	o[o.length] = (XML_HEADER);&#13;
	o[o.length] = (writextag('Properties', null, {&#13;
		'xmlns': XMLNS.EXT_PROPS,&#13;
		'xmlns:vt': XMLNS.vt&#13;
	}));&#13;
&#13;
	EXT_PROPS.forEach(function(f) {&#13;
		if(cp[f[1]] === undefined) return;&#13;
		var v;&#13;
		switch(f[2]) {&#13;
			case 'string': v = escapexml(String(cp[f[1]])); break;&#13;
			case 'bool': v = cp[f[1]] ? 'true' : 'false'; break;&#13;
		}&#13;
		if(v !== undefined) o[o.length] = (W(f[0], v));&#13;
	});&#13;
&#13;
	/* TODO: HeadingPairs, TitlesOfParts */&#13;
	o[o.length] = (W('HeadingPairs', W('vt:vector', W('vt:variant', '&lt;vt:lpstr&gt;Worksheets&lt;/vt:lpstr&gt;')+W('vt:variant', W('vt:i4', String(cp.Worksheets))), {size:2, baseType:"variant"})));&#13;
	o[o.length] = (W('TitlesOfParts', W('vt:vector', cp.SheetNames.map(function(s) { return "&lt;vt:lpstr&gt;" + escapexml(s) + "&lt;/vt:lpstr&gt;"; }).join(""), {size: cp.Worksheets, baseType:"lpstr"})));&#13;
	if(o.length&gt;2){ o[o.length] = ('&lt;/Properties&gt;'); o[1]=o[1].replace("/&gt;","&gt;"); }&#13;
	return o.join("");&#13;
}&#13;
/* 15.2.12.2 Custom File Properties Part */&#13;
var custregex = /&lt;[^&gt;]+&gt;[^&lt;]*/g;&#13;
function parse_cust_props(data, opts) {&#13;
	var p = {}, name = "";&#13;
	var m = data.match(custregex);&#13;
	if(m) for(var i = 0; i != m.length; ++i) {&#13;
		var x = m[i], y = parsexmltag(x);&#13;
		switch(strip_ns(y[0])) {&#13;
			case '&lt;?xml': break;&#13;
			case '&lt;Properties': break;&#13;
			case '&lt;property': name = unescapexml(y.name); break;&#13;
			case '&lt;/property&gt;': name = null; break;&#13;
			default: if (x.indexOf('&lt;vt:') === 0) {&#13;
				var toks = x.split('&gt;');&#13;
				var type = toks[0].slice(4), text = toks[1];&#13;
				/* 22.4.2.32 (CT_Variant). Omit the binary types from 22.4 (Variant Types) */&#13;
				switch(type) {&#13;
					case 'lpstr': case 'bstr': case 'lpwstr':&#13;
						p[name] = unescapexml(text);&#13;
						break;&#13;
					case 'bool':&#13;
						p[name] = parsexmlbool(text);&#13;
						break;&#13;
					case 'i1': case 'i2': case 'i4': case 'i8': case 'int': case 'uint':&#13;
						p[name] = parseInt(text, 10);&#13;
						break;&#13;
					case 'r4': case 'r8': case 'decimal':&#13;
						p[name] = parseFloat(text);&#13;
						break;&#13;
					case 'filetime': case 'date':&#13;
						p[name] = parseDate(text);&#13;
						break;&#13;
					case 'cy': case 'error':&#13;
						p[name] = unescapexml(text);&#13;
						break;&#13;
					default:&#13;
						if(type.slice(-1) == '/') break;&#13;
						if(opts.WTF &amp;&amp; typeof console !== 'undefined') console.warn('Unexpected', x, type, toks);&#13;
				}&#13;
			} else if(x.slice(0,2) === "&lt;/") {/* empty */&#13;
			} else if(opts.WTF) throw new Error(x);&#13;
		}&#13;
	}&#13;
	return p;&#13;
}&#13;
&#13;
function write_cust_props(cp) {&#13;
	var o = [XML_HEADER, writextag('Properties', null, {&#13;
		'xmlns': XMLNS.CUST_PROPS,&#13;
		'xmlns:vt': XMLNS.vt&#13;
	})];&#13;
	if(!cp) return o.join("");&#13;
	var pid = 1;&#13;
	keys(cp).forEach(function custprop(k) { ++pid;&#13;
		o[o.length] = (writextag('property', write_vt(cp[k], true), {&#13;
			'fmtid': '{D5CDD505-2E9C-101B-9397-08002B2CF9AE}',&#13;
			'pid': pid,&#13;
			'name': escapexml(k)&#13;
		}));&#13;
	});&#13;
	if(o.length&gt;2){ o[o.length] = '&lt;/Properties&gt;'; o[1]=o[1].replace("/&gt;","&gt;"); }&#13;
	return o.join("");&#13;
}&#13;
/* Common Name -&gt; XLML Name */&#13;
var XLMLDocPropsMap = {&#13;
	Title: 'Title',&#13;
	Subject: 'Subject',&#13;
	Author: 'Author',&#13;
	Keywords: 'Keywords',&#13;
	Comments: 'Description',&#13;
	LastAuthor: 'LastAuthor',&#13;
	RevNumber: 'Revision',&#13;
	Application: 'AppName',&#13;
	/* TotalTime: 'TotalTime', */&#13;
	LastPrinted: 'LastPrinted',&#13;
	CreatedDate: 'Created',&#13;
	ModifiedDate: 'LastSaved',&#13;
	/* Pages */&#13;
	/* Words */&#13;
	/* Characters */&#13;
	Category: 'Category',&#13;
	/* PresentationFormat */&#13;
	Manager: 'Manager',&#13;
	Company: 'Company',&#13;
	/* Guid */&#13;
	/* HyperlinkBase */&#13;
	/* Bytes */&#13;
	/* Lines */&#13;
	/* Paragraphs */&#13;
	/* CharactersWithSpaces */&#13;
	AppVersion: 'Version',&#13;
&#13;
	ContentStatus: 'ContentStatus', /* NOTE: missing from schema */&#13;
	Identifier: 'Identifier', /* NOTE: missing from schema */&#13;
	Language: 'Language' /* NOTE: missing from schema */&#13;
};&#13;
var evert_XLMLDPM;&#13;
&#13;
function xlml_set_prop(Props, tag, val) {&#13;
	if(!evert_XLMLDPM) evert_XLMLDPM = evert(XLMLDocPropsMap);&#13;
	tag = evert_XLMLDPM[tag] || tag;&#13;
	Props[tag] = val;&#13;
}&#13;
&#13;
function xlml_write_docprops(Props, opts) {&#13;
	var o = [];&#13;
	keys(XLMLDocPropsMap).map(function(m) {&#13;
		for(var i = 0; i &lt; CORE_PROPS.length; ++i) if(CORE_PROPS[i][1] == m) return CORE_PROPS[i];&#13;
		for(i = 0; i &lt; EXT_PROPS.length; ++i) if(EXT_PROPS[i][1] == m) return EXT_PROPS[i];&#13;
		throw m;&#13;
	}).forEach(function(p) {&#13;
		if(Props[p[1]] == null) return;&#13;
		var m = opts &amp;&amp; opts.Props &amp;&amp; opts.Props[p[1]] != null ? opts.Props[p[1]] : Props[p[1]];&#13;
		switch(p[2]) {&#13;
			case 'date': m = new Date(m).toISOString().replace(/\.\d*Z/,"Z"); break;&#13;
		}&#13;
		if(typeof m == 'number') m = String(m);&#13;
		else if(m === true || m === false) { m = m ? "1" : "0"; }&#13;
		else if(m instanceof Date) m = new Date(m).toISOString().replace(/\.\d*Z/,"");&#13;
		o.push(writetag(XLMLDocPropsMap[p[1]] || p[1], m));&#13;
	});&#13;
	return writextag('DocumentProperties', o.join(""), {xmlns:XLMLNS.o });&#13;
}&#13;
function xlml_write_custprops(Props, Custprops) {&#13;
	var BLACKLIST = ["Worksheets","SheetNames"];&#13;
	var T = 'CustomDocumentProperties';&#13;
	var o = [];&#13;
	if(Props) keys(Props).forEach(function(k) {&#13;
if(!Object.prototype.hasOwnProperty.call(Props, k)) return;&#13;
		for(var i = 0; i &lt; CORE_PROPS.length; ++i) if(k == CORE_PROPS[i][1]) return;&#13;
		for(i = 0; i &lt; EXT_PROPS.length; ++i) if(k == EXT_PROPS[i][1]) return;&#13;
		for(i = 0; i &lt; BLACKLIST.length; ++i) if(k == BLACKLIST[i]) return;&#13;
&#13;
		var m = Props[k];&#13;
		var t = "string";&#13;
		if(typeof m == 'number') { t = "float"; m = String(m); }&#13;
		else if(m === true || m === false) { t = "boolean"; m = m ? "1" : "0"; }&#13;
		else m = String(m);&#13;
		o.push(writextag(escapexmltag(k), m, {"dt:dt":t}));&#13;
	});&#13;
	if(Custprops) keys(Custprops).forEach(function(k) {&#13;
if(!Object.prototype.hasOwnProperty.call(Custprops, k)) return;&#13;
		if(Props &amp;&amp; Object.prototype.hasOwnProperty.call(Props, k)) return;&#13;
		var m = Custprops[k];&#13;
		var t = "string";&#13;
		if(typeof m == 'number') { t = "float"; m = String(m); }&#13;
		else if(m === true || m === false) { t = "boolean"; m = m ? "1" : "0"; }&#13;
		else if(m instanceof Date) { t = "dateTime.tz"; m = m.toISOString(); }&#13;
		else m = String(m);&#13;
		o.push(writextag(escapexmltag(k), m, {"dt:dt":t}));&#13;
	});&#13;
	return '&lt;' + T + ' xmlns="' + XLMLNS.o + '"&gt;' + o.join("") + '&lt;/' + T + '&gt;';&#13;
}&#13;
/* [MS-DTYP] 2.3.3 FILETIME */&#13;
/* [MS-OLEDS] 2.1.3 FILETIME (Packet Version) */&#13;
/* [MS-OLEPS] 2.8 FILETIME (Packet Version) */&#13;
function parse_FILETIME(blob) {&#13;
	var dwLowDateTime = blob.read_shift(4), dwHighDateTime = blob.read_shift(4);&#13;
	return new Date(((dwHighDateTime/1e7*Math.pow(2,32) + dwLowDateTime/1e7) - 11644473600)*1000).toISOString().replace(/\.000/,"");&#13;
}&#13;
function write_FILETIME(time) {&#13;
	var date = (typeof time == "string") ? new Date(Date.parse(time)) : time;&#13;
	var t = date.getTime() / 1000 + 11644473600;&#13;
	var l = t % Math.pow(2,32), h = (t - l) / Math.pow(2,32);&#13;
	l *= 1e7; h *= 1e7;&#13;
	var w = (l / Math.pow(2,32)) | 0;&#13;
	if(w &gt; 0) { l = l % Math.pow(2,32); h += w; }&#13;
	var o = new_buf(8); o.write_shift(4, l); o.write_shift(4, h); return o;&#13;
}&#13;
&#13;
/* [MS-OSHARED] 2.3.3.1.4 Lpstr */&#13;
function parse_lpstr(blob, type, pad) {&#13;
	var start = blob.l;&#13;
	var str = blob.read_shift(0, 'lpstr-cp');&#13;
	if(pad) while((blob.l - start) &amp; 3) ++blob.l;&#13;
	return str;&#13;
}&#13;
&#13;
/* [MS-OSHARED] 2.3.3.1.6 Lpwstr */&#13;
function parse_lpwstr(blob, type, pad) {&#13;
	var str = blob.read_shift(0, 'lpwstr');&#13;
	if(pad) blob.l += (4 - ((str.length+1) &amp; 3)) &amp; 3;&#13;
	return str;&#13;
}&#13;
&#13;
&#13;
/* [MS-OSHARED] 2.3.3.1.11 VtString */&#13;
/* [MS-OSHARED] 2.3.3.1.12 VtUnalignedString */&#13;
function parse_VtStringBase(blob, stringType, pad) {&#13;
	if(stringType === 0x1F /*VT_LPWSTR*/) return parse_lpwstr(blob);&#13;
	return parse_lpstr(blob, stringType, pad);&#13;
}&#13;
&#13;
function parse_VtString(blob, t, pad) { return parse_VtStringBase(blob, t, pad === false ? 0: 4); }&#13;
function parse_VtUnalignedString(blob, t) { if(!t) throw new Error("VtUnalignedString must have positive length"); return parse_VtStringBase(blob, t, 0); }&#13;
&#13;
/* [MS-OSHARED] 2.3.3.1.7 VtVecLpwstrValue */&#13;
function parse_VtVecLpwstrValue(blob) {&#13;
	var length = blob.read_shift(4);&#13;
	var ret = [];&#13;
	for(var i = 0; i != length; ++i) {&#13;
		var start = blob.l;&#13;
		ret[i] = blob.read_shift(0, 'lpwstr').replace(chr0,'');&#13;
		if((blob.l - start) &amp; 0x02) blob.l += 2;&#13;
	}&#13;
	return ret;&#13;
}&#13;
&#13;
/* [MS-OSHARED] 2.3.3.1.9 VtVecUnalignedLpstrValue */&#13;
function parse_VtVecUnalignedLpstrValue(blob) {&#13;
	var length = blob.read_shift(4);&#13;
	var ret = [];&#13;
	for(var i = 0; i != length; ++i) ret[i] = blob.read_shift(0, 'lpstr-cp').replace(chr0,'');&#13;
	return ret;&#13;
}&#13;
&#13;
&#13;
/* [MS-OSHARED] 2.3.3.1.13 VtHeadingPair */&#13;
function parse_VtHeadingPair(blob) {&#13;
	var start = blob.l;&#13;
	var headingString = parse_TypedPropertyValue(blob, VT_USTR);&#13;
	if(blob[blob.l] == 0x00 &amp;&amp; blob[blob.l+1] == 0x00 &amp;&amp; ((blob.l - start) &amp; 0x02)) blob.l += 2;&#13;
	var headerParts = parse_TypedPropertyValue(blob, VT_I4);&#13;
	return [headingString, headerParts];&#13;
}&#13;
&#13;
/* [MS-OSHARED] 2.3.3.1.14 VtVecHeadingPairValue */&#13;
function parse_VtVecHeadingPairValue(blob) {&#13;
	var cElements = blob.read_shift(4);&#13;
	var out = [];&#13;
	for(var i = 0; i &lt; cElements / 2; ++i) out.push(parse_VtHeadingPair(blob));&#13;
	return out;&#13;
}&#13;
&#13;
/* [MS-OLEPS] 2.18.1 Dictionary (uses 2.17, 2.16) */&#13;
function parse_dictionary(blob,CodePage) {&#13;
	var cnt = blob.read_shift(4);&#13;
	var dict = ({});&#13;
	for(var j = 0; j != cnt; ++j) {&#13;
		var pid = blob.read_shift(4);&#13;
		var len = blob.read_shift(4);&#13;
		dict[pid] = blob.read_shift(len, (CodePage === 0x4B0 ?'utf16le':'utf8')).replace(chr0,'').replace(chr1,'!');&#13;
		if(CodePage === 0x4B0 &amp;&amp; (len % 2)) blob.l += 2;&#13;
	}&#13;
	if(blob.l &amp; 3) blob.l = (blob.l&gt;&gt;2+1)&lt;&lt;2;&#13;
	return dict;&#13;
}&#13;
&#13;
/* [MS-OLEPS] 2.9 BLOB */&#13;
function parse_BLOB(blob) {&#13;
	var size = blob.read_shift(4);&#13;
	var bytes = blob.slice(blob.l,blob.l+size);&#13;
	blob.l += size;&#13;
	if((size &amp; 3) &gt; 0) blob.l += (4 - (size &amp; 3)) &amp; 3;&#13;
	return bytes;&#13;
}&#13;
&#13;
/* [MS-OLEPS] 2.11 ClipboardData */&#13;
function parse_ClipboardData(blob) {&#13;
	// TODO&#13;
	var o = {};&#13;
	o.Size = blob.read_shift(4);&#13;
	//o.Format = blob.read_shift(4);&#13;
	blob.l += o.Size + 3 - (o.Size - 1) % 4;&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-OLEPS] 2.15 TypedPropertyValue */&#13;
function parse_TypedPropertyValue(blob, type, _opts) {&#13;
	var t = blob.read_shift(2), ret, opts = _opts||{};&#13;
	blob.l += 2;&#13;
	if(type !== VT_VARIANT)&#13;
	if(t !== type &amp;&amp; VT_CUSTOM.indexOf(type)===-1 &amp;&amp; !((type &amp; 0xFFFE) == 0x101E &amp;&amp; (t &amp; 0xFFFE) == 0x101E)) throw new Error('Expected type ' + type + ' saw ' + t);&#13;
	switch(type === VT_VARIANT ? t : type) {&#13;
		case 0x02 /*VT_I2*/: ret = blob.read_shift(2, 'i'); if(!opts.raw) blob.l += 2; return ret;&#13;
		case 0x03 /*VT_I4*/: ret = blob.read_shift(4, 'i'); return ret;&#13;
		case 0x0B /*VT_BOOL*/: return blob.read_shift(4) !== 0x0;&#13;
		case 0x13 /*VT_UI4*/: ret = blob.read_shift(4); return ret;&#13;
		case 0x1E /*VT_LPSTR*/: return parse_lpstr(blob, t, 4).replace(chr0,'');&#13;
		case 0x1F /*VT_LPWSTR*/: return parse_lpwstr(blob);&#13;
		case 0x40 /*VT_FILETIME*/: return parse_FILETIME(blob);&#13;
		case 0x41 /*VT_BLOB*/: return parse_BLOB(blob);&#13;
		case 0x47 /*VT_CF*/: return parse_ClipboardData(blob);&#13;
		case 0x50 /*VT_STRING*/: return parse_VtString(blob, t, !opts.raw).replace(chr0,'');&#13;
		case 0x51 /*VT_USTR*/: return parse_VtUnalignedString(blob, t/*, 4*/).replace(chr0,'');&#13;
		case 0x100C /*VT_VECTOR|VT_VARIANT*/: return parse_VtVecHeadingPairValue(blob);&#13;
		case 0x101E /*VT_VECTOR|VT_LPSTR*/:&#13;
		case 0x101F /*VT_VECTOR|VT_LPWSTR*/:&#13;
			return t == 0x101F ? parse_VtVecLpwstrValue(blob) : parse_VtVecUnalignedLpstrValue(blob);&#13;
		default: throw new Error("TypedPropertyValue unrecognized type " + type + " " + t);&#13;
	}&#13;
}&#13;
function write_TypedPropertyValue(type, value) {&#13;
	var o = new_buf(4), p = new_buf(4);&#13;
	o.write_shift(4, type == 0x50 ? 0x1F : type);&#13;
	switch(type) {&#13;
		case 0x03 /*VT_I4*/: p.write_shift(-4, value); break;&#13;
		case 0x05 /*VT_I4*/: p = new_buf(8); p.write_shift(8, value, 'f'); break;&#13;
		case 0x0B /*VT_BOOL*/: p.write_shift(4, value ? 0x01 : 0x00); break;&#13;
		case 0x40 /*VT_FILETIME*/:  p = write_FILETIME(value); break;&#13;
		case 0x1F /*VT_LPWSTR*/:&#13;
		case 0x50 /*VT_STRING*/:&#13;
p = new_buf(4 + 2 * (value.length + 1) + (value.length % 2 ? 0 : 2));&#13;
			p.write_shift(4, value.length + 1);&#13;
			p.write_shift(0, value, "dbcs");&#13;
			while(p.l != p.length) p.write_shift(1, 0);&#13;
			break;&#13;
		default: throw new Error("TypedPropertyValue unrecognized type " + type + " " + value);&#13;
	}&#13;
	return bconcat([o, p]);&#13;
}&#13;
&#13;
/* [MS-OLEPS] 2.20 PropertySet */&#13;
function parse_PropertySet(blob, PIDSI) {&#13;
	var start_addr = blob.l;&#13;
	var size = blob.read_shift(4);&#13;
	var NumProps = blob.read_shift(4);&#13;
	var Props = [], i = 0;&#13;
	var CodePage = 0;&#13;
	var Dictionary = -1, DictObj = ({});&#13;
	for(i = 0; i != NumProps; ++i) {&#13;
		var PropID = blob.read_shift(4);&#13;
		var Offset = blob.read_shift(4);&#13;
		Props[i] = [PropID, Offset + start_addr];&#13;
	}&#13;
	Props.sort(function(x,y) { return x[1] - y[1]; });&#13;
	var PropH = {};&#13;
	for(i = 0; i != NumProps; ++i) {&#13;
		if(blob.l !== Props[i][1]) {&#13;
			var fail = true;&#13;
			if(i&gt;0 &amp;&amp; PIDSI) switch(PIDSI[Props[i-1][0]].t) {&#13;
				case 0x02 /*VT_I2*/: if(blob.l+2 === Props[i][1]) { blob.l+=2; fail = false; } break;&#13;
				case 0x50 /*VT_STRING*/: if(blob.l &lt;= Props[i][1]) { blob.l=Props[i][1]; fail = false; } break;&#13;
				case 0x100C /*VT_VECTOR|VT_VARIANT*/: if(blob.l &lt;= Props[i][1]) { blob.l=Props[i][1]; fail = false; } break;&#13;
			}&#13;
			if((!PIDSI||i==0) &amp;&amp; blob.l &lt;= Props[i][1]) { fail=false; blob.l = Props[i][1]; }&#13;
			if(fail) throw new Error("Read Error: Expected address " + Props[i][1] + ' at ' + blob.l + ' :' + i);&#13;
		}&#13;
		if(PIDSI) {&#13;
			if(Props[i][0] == 0 &amp;&amp; Props.length &gt; i+1 &amp;&amp; Props[i][1] == Props[i+1][1]) continue; // R9&#13;
			var piddsi = PIDSI[Props[i][0]];&#13;
			PropH[piddsi.n] = parse_TypedPropertyValue(blob, piddsi.t, {raw:true});&#13;
			if(piddsi.p === 'version') PropH[piddsi.n] = String(PropH[piddsi.n] &gt;&gt; 16) + "." + ("0000" + String(PropH[piddsi.n] &amp; 0xFFFF)).slice(-4);&#13;
			if(piddsi.n == "CodePage") switch(PropH[piddsi.n]) {&#13;
				case 0: PropH[piddsi.n] = 1252;&#13;
					/* falls through */&#13;
				case 874:&#13;
				case 932:&#13;
				case 936:&#13;
				case 949:&#13;
				case 950:&#13;
				case 1250:&#13;
				case 1251:&#13;
				case 1253:&#13;
				case 1254:&#13;
				case 1255:&#13;
				case 1256:&#13;
				case 1257:&#13;
				case 1258:&#13;
				case 10000:&#13;
				case 1200:&#13;
				case 1201:&#13;
				case 1252:&#13;
				case 65000: case -536:&#13;
				case 65001: case -535:&#13;
					set_cp(CodePage = (PropH[piddsi.n]&gt;&gt;&gt;0) &amp; 0xFFFF); break;&#13;
				default: throw new Error("Unsupported CodePage: " + PropH[piddsi.n]);&#13;
			}&#13;
		} else {&#13;
			if(Props[i][0] === 0x1) {&#13;
				CodePage = PropH.CodePage = (parse_TypedPropertyValue(blob, VT_I2));&#13;
				set_cp(CodePage);&#13;
				if(Dictionary !== -1) {&#13;
					var oldpos = blob.l;&#13;
					blob.l = Props[Dictionary][1];&#13;
					DictObj = parse_dictionary(blob,CodePage);&#13;
					blob.l = oldpos;&#13;
				}&#13;
			} else if(Props[i][0] === 0) {&#13;
				if(CodePage === 0) { Dictionary = i; blob.l = Props[i+1][1]; continue; }&#13;
				DictObj = parse_dictionary(blob,CodePage);&#13;
			} else {&#13;
				var name = DictObj[Props[i][0]];&#13;
				var val;&#13;
				/* [MS-OSHARED] 2.3.3.2.3.1.2 + PROPVARIANT */&#13;
				switch(blob[blob.l]) {&#13;
					case 0x41 /*VT_BLOB*/: blob.l += 4; val = parse_BLOB(blob); break;&#13;
					case 0x1E /*VT_LPSTR*/: blob.l += 4; val = parse_VtString(blob, blob[blob.l-4]).replace(/\u0000+$/,""); break;&#13;
					case 0x1F /*VT_LPWSTR*/: blob.l += 4; val = parse_VtString(blob, blob[blob.l-4]).replace(/\u0000+$/,""); break;&#13;
					case 0x03 /*VT_I4*/: blob.l += 4; val = blob.read_shift(4, 'i'); break;&#13;
					case 0x13 /*VT_UI4*/: blob.l += 4; val = blob.read_shift(4); break;&#13;
					case 0x05 /*VT_R8*/: blob.l += 4; val = blob.read_shift(8, 'f'); break;&#13;
					case 0x0B /*VT_BOOL*/: blob.l += 4; val = parsebool(blob, 4); break;&#13;
					case 0x40 /*VT_FILETIME*/: blob.l += 4; val = parseDate(parse_FILETIME(blob)); break;&#13;
					default: throw new Error("unparsed value: " + blob[blob.l]);&#13;
				}&#13;
				PropH[name] = val;&#13;
			}&#13;
		}&#13;
	}&#13;
	blob.l = start_addr + size; /* step ahead to skip padding */&#13;
	return PropH;&#13;
}&#13;
var XLSPSSkip = [ "CodePage", "Thumbnail", "_PID_LINKBASE", "_PID_HLINKS", "SystemIdentifier", "FMTID" ];&#13;
function guess_property_type(val) {&#13;
	switch(typeof val) {&#13;
		case "boolean": return 0x0B;&#13;
		case "number": return ((val|0)==val) ? 0x03 : 0x05;&#13;
		case "string": return 0x1F;&#13;
		case "object": if(val instanceof Date) return 0x40; break;&#13;
	}&#13;
	return -1;&#13;
}&#13;
function write_PropertySet(entries, RE, PIDSI) {&#13;
	var hdr = new_buf(8), piao = [], prop = [];&#13;
	var sz = 8, i = 0;&#13;
&#13;
	var pr = new_buf(8), pio = new_buf(8);&#13;
	pr.write_shift(4, 0x0002);&#13;
	pr.write_shift(4, 0x04B0);&#13;
	pio.write_shift(4, 0x0001);&#13;
	prop.push(pr); piao.push(pio);&#13;
	sz += 8 + pr.length;&#13;
&#13;
	if(!RE) {&#13;
		pio = new_buf(8);&#13;
		pio.write_shift(4, 0);&#13;
		piao.unshift(pio);&#13;
&#13;
		var bufs = [new_buf(4)];&#13;
		bufs[0].write_shift(4, entries.length);&#13;
		for(i = 0; i &lt; entries.length; ++i) {&#13;
			var value = entries[i][0];&#13;
			pr = new_buf(4 + 4 + 2 * (value.length + 1) + (value.length % 2 ? 0 : 2));&#13;
			pr.write_shift(4, i+2);&#13;
			pr.write_shift(4, value.length + 1);&#13;
			pr.write_shift(0, value, "dbcs");&#13;
			while(pr.l != pr.length) pr.write_shift(1, 0);&#13;
			bufs.push(pr);&#13;
		}&#13;
		pr = bconcat(bufs);&#13;
		prop.unshift(pr);&#13;
		sz += 8 + pr.length;&#13;
	}&#13;
&#13;
	for(i = 0; i &lt; entries.length; ++i) {&#13;
		if(RE &amp;&amp; !RE[entries[i][0]]) continue;&#13;
		if(XLSPSSkip.indexOf(entries[i][0]) &gt; -1 || PseudoPropsPairs.indexOf(entries[i][0]) &gt; -1) continue;&#13;
		if(entries[i][1] == null) continue;&#13;
&#13;
		var val = entries[i][1], idx = 0;&#13;
		if(RE) {&#13;
			idx = +RE[entries[i][0]];&#13;
			var pinfo = (PIDSI)[idx];&#13;
			if(pinfo.p == "version" &amp;&amp; typeof val == "string") {&#13;
var arr = val.split(".");&#13;
				val = ((+arr[0])&lt;&lt;16) + ((+arr[1])||0);&#13;
			}&#13;
			pr = write_TypedPropertyValue(pinfo.t, val);&#13;
		} else {&#13;
			var T = guess_property_type(val);&#13;
			if(T == -1) { T = 0x1F; val = String(val); }&#13;
			pr = write_TypedPropertyValue(T, val);&#13;
		}&#13;
		prop.push(pr);&#13;
&#13;
		pio = new_buf(8);&#13;
		pio.write_shift(4, !RE ? 2+i : idx);&#13;
		piao.push(pio);&#13;
&#13;
		sz += 8 + pr.length;&#13;
	}&#13;
&#13;
	var w = 8 * (prop.length + 1);&#13;
	for(i = 0; i &lt; prop.length; ++i) { piao[i].write_shift(4, w); w += prop[i].length; }&#13;
	hdr.write_shift(4, sz);&#13;
	hdr.write_shift(4, prop.length);&#13;
	return bconcat([hdr].concat(piao).concat(prop));&#13;
}&#13;
&#13;
/* [MS-OLEPS] 2.21 PropertySetStream */&#13;
function parse_PropertySetStream(file, PIDSI, clsid) {&#13;
	var blob = file.content;&#13;
	if(!blob) return ({});&#13;
	prep_blob(blob, 0);&#13;
&#13;
	var NumSets, FMTID0, FMTID1, Offset0, Offset1 = 0;&#13;
	blob.chk('feff', 'Byte Order: ');&#13;
&#13;
	/*var vers = */blob.read_shift(2); // TODO: check version&#13;
	var SystemIdentifier = blob.read_shift(4);&#13;
	var CLSID = blob.read_shift(16);&#13;
	if(CLSID !== CFB.utils.consts.HEADER_CLSID &amp;&amp; CLSID !== clsid) throw new Error("Bad PropertySet CLSID " + CLSID);&#13;
	NumSets = blob.read_shift(4);&#13;
	if(NumSets !== 1 &amp;&amp; NumSets !== 2) throw new Error("Unrecognized #Sets: " + NumSets);&#13;
	FMTID0 = blob.read_shift(16); Offset0 = blob.read_shift(4);&#13;
&#13;
	if(NumSets === 1 &amp;&amp; Offset0 !== blob.l) throw new Error("Length mismatch: " + Offset0 + " !== " + blob.l);&#13;
	else if(NumSets === 2) { FMTID1 = blob.read_shift(16); Offset1 = blob.read_shift(4); }&#13;
	var PSet0 = parse_PropertySet(blob, PIDSI);&#13;
&#13;
	var rval = ({ SystemIdentifier: SystemIdentifier });&#13;
	for(var y in PSet0) rval[y] = PSet0[y];&#13;
	//rval.blob = blob;&#13;
	rval.FMTID = FMTID0;&#13;
	//rval.PSet0 = PSet0;&#13;
	if(NumSets === 1) return rval;&#13;
	if(Offset1 - blob.l == 2) blob.l += 2;&#13;
	if(blob.l !== Offset1) throw new Error("Length mismatch 2: " + blob.l + " !== " + Offset1);&#13;
	var PSet1;&#13;
	try { PSet1 = parse_PropertySet(blob, null); } catch(e) {/* empty */}&#13;
	for(y in PSet1) rval[y] = PSet1[y];&#13;
	rval.FMTID = [FMTID0, FMTID1]; // TODO: verify FMTID0/1&#13;
	return rval;&#13;
}&#13;
function write_PropertySetStream(entries, clsid, RE, PIDSI, entries2, clsid2) {&#13;
	var hdr = new_buf(entries2 ? 68 : 48);&#13;
	var bufs = [hdr];&#13;
	hdr.write_shift(2, 0xFFFE);&#13;
	hdr.write_shift(2, 0x0000); /* TODO: type 1 props */&#13;
	hdr.write_shift(4, 0x32363237);&#13;
	hdr.write_shift(16, CFB.utils.consts.HEADER_CLSID, "hex");&#13;
	hdr.write_shift(4, (entries2 ? 2 : 1));&#13;
	hdr.write_shift(16, clsid, "hex");&#13;
	hdr.write_shift(4, (entries2 ? 68 : 48));&#13;
	var ps0 = write_PropertySet(entries, RE, PIDSI);&#13;
	bufs.push(ps0);&#13;
&#13;
	if(entries2) {&#13;
		var ps1 = write_PropertySet(entries2, null, null);&#13;
		hdr.write_shift(16, clsid2, "hex");&#13;
		hdr.write_shift(4, 68 + ps0.length);&#13;
		bufs.push(ps1);&#13;
	}&#13;
	return bconcat(bufs);&#13;
}&#13;
&#13;
function parsenoop2(blob, length) { blob.read_shift(length); return null; }&#13;
function writezeroes(n, o) { if(!o) o=new_buf(n); for(var j=0; j&lt;n; ++j) o.write_shift(1, 0); return o; }&#13;
&#13;
function parslurp(blob, length, cb) {&#13;
	var arr = [], target = blob.l + length;&#13;
	while(blob.l &lt; target) arr.push(cb(blob, target - blob.l));&#13;
	if(target !== blob.l) throw new Error("Slurp error");&#13;
	return arr;&#13;
}&#13;
&#13;
function parsebool(blob, length) { return blob.read_shift(length) === 0x1; }&#13;
function writebool(v, o) { if(!o) o=new_buf(2); o.write_shift(2, +!!v); return o; }&#13;
&#13;
function parseuint16(blob) { return blob.read_shift(2, 'u'); }&#13;
function writeuint16(v, o) { if(!o) o=new_buf(2); o.write_shift(2, v); return o; }&#13;
function parseuint16a(blob, length) { return parslurp(blob,length,parseuint16);}&#13;
&#13;
/* --- 2.5 Structures --- */&#13;
&#13;
/* [MS-XLS] 2.5.10 Bes (boolean or error) */&#13;
function parse_Bes(blob) {&#13;
	var v = blob.read_shift(1), t = blob.read_shift(1);&#13;
	return t === 0x01 ? v : v === 0x01;&#13;
}&#13;
function write_Bes(v, t, o) {&#13;
	if(!o) o = new_buf(2);&#13;
	o.write_shift(1, ((t == 'e') ? +v : +!!v));&#13;
	o.write_shift(1, ((t == 'e') ? 1 : 0));&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.240 ShortXLUnicodeString */&#13;
function parse_ShortXLUnicodeString(blob, length, opts) {&#13;
	var cch = blob.read_shift(opts &amp;&amp; opts.biff &gt;= 12 ? 2 : 1);&#13;
	var encoding = 'sbcs-cont';&#13;
	var cp = current_codepage;&#13;
	if(opts &amp;&amp; opts.biff &gt;= 8) current_codepage = 1200;&#13;
	if(!opts || opts.biff == 8 ) {&#13;
		var fHighByte = blob.read_shift(1);&#13;
		if(fHighByte) { encoding = 'dbcs-cont'; }&#13;
	} else if(opts.biff == 12) {&#13;
		encoding = 'wstr';&#13;
	}&#13;
	if(opts.biff &gt;= 2 &amp;&amp; opts.biff &lt;= 5) encoding = 'cpstr';&#13;
	var o = cch ? blob.read_shift(cch, encoding) : "";&#13;
	current_codepage = cp;&#13;
	return o;&#13;
}&#13;
&#13;
/* 2.5.293 XLUnicodeRichExtendedString */&#13;
function parse_XLUnicodeRichExtendedString(blob) {&#13;
	var cp = current_codepage;&#13;
	current_codepage = 1200;&#13;
	var cch = blob.read_shift(2), flags = blob.read_shift(1);&#13;
	var /*fHighByte = flags &amp; 0x1,*/ fExtSt = flags &amp; 0x4, fRichSt = flags &amp; 0x8;&#13;
	var width = 1 + (flags &amp; 0x1); // 0x0 -&gt; utf8, 0x1 -&gt; dbcs&#13;
	var cRun = 0, cbExtRst;&#13;
	var z = {};&#13;
	if(fRichSt) cRun = blob.read_shift(2);&#13;
	if(fExtSt) cbExtRst = blob.read_shift(4);&#13;
	var encoding = width == 2 ? 'dbcs-cont' : 'sbcs-cont';&#13;
	var msg = cch === 0 ? "" : blob.read_shift(cch, encoding);&#13;
	if(fRichSt) blob.l += 4 * cRun; //TODO: parse this&#13;
	if(fExtSt) blob.l += cbExtRst; //TODO: parse this&#13;
	z.t = msg;&#13;
	if(!fRichSt) { z.raw = "&lt;t&gt;" + z.t + "&lt;/t&gt;"; z.r = z.t; }&#13;
	current_codepage = cp;&#13;
	return z;&#13;
}&#13;
function write_XLUnicodeRichExtendedString(xlstr) {&#13;
	var str = (xlstr.t||""), nfmts = 1;&#13;
&#13;
	var hdr = new_buf(3 + (nfmts &gt; 1 ? 2 : 0));&#13;
	hdr.write_shift(2, str.length);&#13;
	hdr.write_shift(1, (nfmts &gt; 1 ? 0x08 : 0x00) | 0x01);&#13;
	if(nfmts &gt; 1) hdr.write_shift(2, nfmts);&#13;
&#13;
	var otext = new_buf(2 * str.length);&#13;
	otext.write_shift(2 * str.length, str, 'utf16le');&#13;
&#13;
	var out = [hdr, otext];&#13;
&#13;
	return bconcat(out);&#13;
}&#13;
&#13;
/* 2.5.296 XLUnicodeStringNoCch */&#13;
function parse_XLUnicodeStringNoCch(blob, cch, opts) {&#13;
	var retval;&#13;
	if(opts) {&#13;
		if(opts.biff &gt;= 2 &amp;&amp; opts.biff &lt;= 5) return blob.read_shift(cch, 'cpstr');&#13;
		if(opts.biff &gt;= 12) return blob.read_shift(cch, 'dbcs-cont');&#13;
	}&#13;
	var fHighByte = blob.read_shift(1);&#13;
	if(fHighByte===0) { retval = blob.read_shift(cch, 'sbcs-cont'); }&#13;
	else { retval = blob.read_shift(cch, 'dbcs-cont'); }&#13;
	return retval;&#13;
}&#13;
&#13;
/* 2.5.294 XLUnicodeString */&#13;
function parse_XLUnicodeString(blob, length, opts) {&#13;
	var cch = blob.read_shift(opts &amp;&amp; opts.biff == 2 ? 1 : 2);&#13;
	if(cch === 0) { blob.l++; return ""; }&#13;
	return parse_XLUnicodeStringNoCch(blob, cch, opts);&#13;
}&#13;
/* BIFF5 override */&#13;
function parse_XLUnicodeString2(blob, length, opts) {&#13;
	if(opts.biff &gt; 5) return parse_XLUnicodeString(blob, length, opts);&#13;
	var cch = blob.read_shift(1);&#13;
	if(cch === 0) { blob.l++; return ""; }&#13;
	return blob.read_shift(cch, (opts.biff &lt;= 4 || !blob.lens ) ? 'cpstr' : 'sbcs-cont');&#13;
}&#13;
/* TODO: BIFF5 and lower, codepage awareness */&#13;
function write_XLUnicodeString(str, opts, o) {&#13;
	if(!o) o = new_buf(3 + 2 * str.length);&#13;
	o.write_shift(2, str.length);&#13;
	o.write_shift(1, 1);&#13;
	o.write_shift(31, str, 'utf16le');&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.61 ControlInfo */&#13;
function parse_ControlInfo(blob) {&#13;
	var flags = blob.read_shift(1);&#13;
	blob.l++;&#13;
	var accel = blob.read_shift(2);&#13;
	blob.l += 2;&#13;
	return [flags, accel];&#13;
}&#13;
&#13;
/* [MS-OSHARED] 2.3.7.6 URLMoniker TODO: flags */&#13;
function parse_URLMoniker(blob) {&#13;
	var len = blob.read_shift(4), start = blob.l;&#13;
	var extra = false;&#13;
	if(len &gt; 24) {&#13;
		/* look ahead */&#13;
		blob.l += len - 24;&#13;
		if(blob.read_shift(16) === "795881f43b1d7f48af2c825dc4852763") extra = true;&#13;
		blob.l = start;&#13;
	}&#13;
	var url = blob.read_shift((extra?len-24:len)&gt;&gt;1, 'utf16le').replace(chr0,"");&#13;
	if(extra) blob.l += 24;&#13;
	return url;&#13;
}&#13;
&#13;
/* [MS-OSHARED] 2.3.7.8 FileMoniker TODO: all fields */&#13;
function parse_FileMoniker(blob) {&#13;
	var cAnti = blob.read_shift(2);&#13;
	var preamble = ""; while(cAnti-- &gt; 0) preamble += "../";&#13;
	var ansiPath = blob.read_shift(0, 'lpstr-ansi');&#13;
	blob.l += 2; //var endServer = blob.read_shift(2);&#13;
	if(blob.read_shift(2) != 0xDEAD) throw new Error("Bad FileMoniker");&#13;
	var sz = blob.read_shift(4);&#13;
	if(sz === 0) return preamble + ansiPath.replace(/\\/g,"/");&#13;
	var bytes = blob.read_shift(4);&#13;
	if(blob.read_shift(2) != 3) throw new Error("Bad FileMoniker");&#13;
	var unicodePath = blob.read_shift(bytes&gt;&gt;1, 'utf16le').replace(chr0,"");&#13;
	return preamble + unicodePath;&#13;
}&#13;
&#13;
/* [MS-OSHARED] 2.3.7.2 HyperlinkMoniker TODO: all the monikers */&#13;
function parse_HyperlinkMoniker(blob, length) {&#13;
	var clsid = blob.read_shift(16); length -= 16;&#13;
	switch(clsid) {&#13;
		case "e0c9ea79f9bace118c8200aa004ba90b": return parse_URLMoniker(blob, length);&#13;
		case "0303000000000000c000000000000046": return parse_FileMoniker(blob, length);&#13;
		default: throw new Error("Unsupported Moniker " + clsid);&#13;
	}&#13;
}&#13;
&#13;
/* [MS-OSHARED] 2.3.7.9 HyperlinkString */&#13;
function parse_HyperlinkString(blob) {&#13;
	var len = blob.read_shift(4);&#13;
	var o = len &gt; 0 ? blob.read_shift(len, 'utf16le').replace(chr0, "") : "";&#13;
	return o;&#13;
}&#13;
function write_HyperlinkString(str, o) {&#13;
	if(!o) o = new_buf(6 + str.length * 2);&#13;
	o.write_shift(4, 1 + str.length);&#13;
	for(var i = 0; i &lt; str.length; ++i) o.write_shift(2, str.charCodeAt(i));&#13;
	o.write_shift(2, 0);&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-OSHARED] 2.3.7.1 Hyperlink Object */&#13;
function parse_Hyperlink(blob, length) {&#13;
	var end = blob.l + length;&#13;
	var sVer = blob.read_shift(4);&#13;
	if(sVer !== 2) throw new Error("Unrecognized streamVersion: " + sVer);&#13;
	var flags = blob.read_shift(2);&#13;
	blob.l += 2;&#13;
	var displayName, targetFrameName, moniker, oleMoniker, Loc="", guid, fileTime;&#13;
	if(flags &amp; 0x0010) displayName = parse_HyperlinkString(blob, end - blob.l);&#13;
	if(flags &amp; 0x0080) targetFrameName = parse_HyperlinkString(blob, end - blob.l);&#13;
	if((flags &amp; 0x0101) === 0x0101) moniker = parse_HyperlinkString(blob, end - blob.l);&#13;
	if((flags &amp; 0x0101) === 0x0001) oleMoniker = parse_HyperlinkMoniker(blob, end - blob.l);&#13;
	if(flags &amp; 0x0008) Loc = parse_HyperlinkString(blob, end - blob.l);&#13;
	if(flags &amp; 0x0020) guid = blob.read_shift(16);&#13;
	if(flags &amp; 0x0040) fileTime = parse_FILETIME(blob/*, 8*/);&#13;
	blob.l = end;&#13;
	var target = targetFrameName||moniker||oleMoniker||"";&#13;
	if(target &amp;&amp; Loc) target+="#"+Loc;&#13;
	if(!target) target = "#" + Loc;&#13;
	if((flags &amp; 0x0002) &amp;&amp; target.charAt(0) == "/" &amp;&amp; target.charAt(1) != "/") target = "file://" + target;&#13;
	var out = ({Target:target});&#13;
	if(guid) out.guid = guid;&#13;
	if(fileTime) out.time = fileTime;&#13;
	if(displayName) out.Tooltip = displayName;&#13;
	return out;&#13;
}&#13;
function write_Hyperlink(hl) {&#13;
	var out = new_buf(512), i = 0;&#13;
	var Target = hl.Target;&#13;
	if(Target.slice(0,7) == "file://") Target = Target.slice(7);&#13;
	var hashidx = Target.indexOf("#");&#13;
	var F = hashidx &gt; -1 ? 0x1f : 0x17;&#13;
	switch(Target.charAt(0)) { case "#": F=0x1c; break; case ".": F&amp;=~2; break; }&#13;
	out.write_shift(4,2); out.write_shift(4, F);&#13;
	var data = [8,6815827,6619237,4849780,83]; for(i = 0; i &lt; data.length; ++i) out.write_shift(4, data[i]);&#13;
	if(F == 0x1C) {&#13;
		Target = Target.slice(1);&#13;
		write_HyperlinkString(Target, out);&#13;
	} else if(F &amp; 0x02) {&#13;
		data = "e0 c9 ea 79 f9 ba ce 11 8c 82 00 aa 00 4b a9 0b".split(" ");&#13;
		for(i = 0; i &lt; data.length; ++i) out.write_shift(1, parseInt(data[i], 16));&#13;
		var Pretarget = hashidx &gt; -1 ? Target.slice(0, hashidx) : Target;&#13;
		out.write_shift(4, 2*(Pretarget.length + 1));&#13;
		for(i = 0; i &lt; Pretarget.length; ++i) out.write_shift(2, Pretarget.charCodeAt(i));&#13;
		out.write_shift(2, 0);&#13;
		if(F &amp; 0x08) write_HyperlinkString(hashidx &gt; -1 ? Target.slice(hashidx+1): "", out);&#13;
	} else {&#13;
		data = "03 03 00 00 00 00 00 00 c0 00 00 00 00 00 00 46".split(" ");&#13;
		for(i = 0; i &lt; data.length; ++i) out.write_shift(1, parseInt(data[i], 16));&#13;
		var P = 0;&#13;
		while(Target.slice(P*3,P*3+3)=="../"||Target.slice(P*3,P*3+3)=="..\\") ++P;&#13;
		out.write_shift(2, P);&#13;
		out.write_shift(4, Target.length - 3 * P + 1);&#13;
		for(i = 0; i &lt; Target.length - 3 * P; ++i) out.write_shift(1, Target.charCodeAt(i + 3 * P) &amp; 0xFF);&#13;
		out.write_shift(1, 0);&#13;
		out.write_shift(2, 0xFFFF);&#13;
		out.write_shift(2, 0xDEAD);&#13;
		for(i = 0; i &lt; 6; ++i) out.write_shift(4, 0);&#13;
	}&#13;
	return out.slice(0, out.l);&#13;
}&#13;
&#13;
/* 2.5.178 LongRGBA */&#13;
function parse_LongRGBA(blob) { var r = blob.read_shift(1), g = blob.read_shift(1), b = blob.read_shift(1), a = blob.read_shift(1); return [r,g,b,a]; }&#13;
&#13;
/* 2.5.177 LongRGB */&#13;
function parse_LongRGB(blob, length) { var x = parse_LongRGBA(blob, length); x[3] = 0; return x; }&#13;
&#13;
&#13;
/* [MS-XLS] 2.5.19 */&#13;
function parse_XLSCell(blob) {&#13;
	var rw = blob.read_shift(2); // 0-indexed&#13;
	var col = blob.read_shift(2);&#13;
	var ixfe = blob.read_shift(2);&#13;
	return ({r:rw, c:col, ixfe:ixfe});&#13;
}&#13;
function write_XLSCell(R, C, ixfe, o) {&#13;
	if(!o) o = new_buf(6);&#13;
	o.write_shift(2, R);&#13;
	o.write_shift(2, C);&#13;
	o.write_shift(2, ixfe||0);&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.134 */&#13;
function parse_frtHeader(blob) {&#13;
	var rt = blob.read_shift(2);&#13;
	var flags = blob.read_shift(2); // TODO: parse these flags&#13;
	blob.l += 8;&#13;
	return {type: rt, flags: flags};&#13;
}&#13;
&#13;
&#13;
&#13;
function parse_OptXLUnicodeString(blob, length, opts) { return length === 0 ? "" : parse_XLUnicodeString2(blob, length, opts); }&#13;
&#13;
/* [MS-XLS] 2.5.344 */&#13;
function parse_XTI(blob, length, opts) {&#13;
	var w = opts.biff &gt; 8 ? 4 : 2;&#13;
	var iSupBook = blob.read_shift(w), itabFirst = blob.read_shift(w,'i'), itabLast = blob.read_shift(w,'i');&#13;
	return [iSupBook, itabFirst, itabLast];&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.218 */&#13;
function parse_RkRec(blob) {&#13;
	var ixfe = blob.read_shift(2);&#13;
	var RK = parse_RkNumber(blob);&#13;
	return [ixfe, RK];&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.1 */&#13;
function parse_AddinUdf(blob, length, opts) {&#13;
	blob.l += 4; length -= 4;&#13;
	var l = blob.l + length;&#13;
	var udfName = parse_ShortXLUnicodeString(blob, length, opts);&#13;
	var cb = blob.read_shift(2);&#13;
	l -= blob.l;&#13;
	if(cb !== l) throw new Error("Malformed AddinUdf: padding = " + l + " != " + cb);&#13;
	blob.l += cb;&#13;
	return udfName;&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.209 TODO: Check sizes */&#13;
function parse_Ref8U(blob) {&#13;
	var rwFirst = blob.read_shift(2);&#13;
	var rwLast = blob.read_shift(2);&#13;
	var colFirst = blob.read_shift(2);&#13;
	var colLast = blob.read_shift(2);&#13;
	return {s:{c:colFirst, r:rwFirst}, e:{c:colLast,r:rwLast}};&#13;
}&#13;
function write_Ref8U(r, o) {&#13;
	if(!o) o = new_buf(8);&#13;
	o.write_shift(2, r.s.r);&#13;
	o.write_shift(2, r.e.r);&#13;
	o.write_shift(2, r.s.c);&#13;
	o.write_shift(2, r.e.c);&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.211 */&#13;
function parse_RefU(blob) {&#13;
	var rwFirst = blob.read_shift(2);&#13;
	var rwLast = blob.read_shift(2);&#13;
	var colFirst = blob.read_shift(1);&#13;
	var colLast = blob.read_shift(1);&#13;
	return {s:{c:colFirst, r:rwFirst}, e:{c:colLast,r:rwLast}};&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.207 */&#13;
var parse_Ref = parse_RefU;&#13;
&#13;
/* [MS-XLS] 2.5.143 */&#13;
function parse_FtCmo(blob) {&#13;
	blob.l += 4;&#13;
	var ot = blob.read_shift(2);&#13;
	var id = blob.read_shift(2);&#13;
	var flags = blob.read_shift(2);&#13;
	blob.l+=12;&#13;
	return [id, ot, flags];&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.149 */&#13;
function parse_FtNts(blob) {&#13;
	var out = {};&#13;
	blob.l += 4;&#13;
	blob.l += 16; // GUID TODO&#13;
	out.fSharedNote = blob.read_shift(2);&#13;
	blob.l += 4;&#13;
	return out;&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.142 */&#13;
function parse_FtCf(blob) {&#13;
	var out = {};&#13;
	blob.l += 4;&#13;
	blob.cf = blob.read_shift(2);&#13;
	return out;&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.140 - 2.5.154 and friends */&#13;
function parse_FtSkip(blob) { blob.l += 2; blob.l += blob.read_shift(2); }&#13;
var FtTab = {&#13;
0x00: parse_FtSkip,      /* FtEnd */&#13;
0x04: parse_FtSkip,      /* FtMacro */&#13;
0x05: parse_FtSkip,      /* FtButton */&#13;
0x06: parse_FtSkip,      /* FtGmo */&#13;
0x07: parse_FtCf,        /* FtCf */&#13;
0x08: parse_FtSkip,      /* FtPioGrbit */&#13;
0x09: parse_FtSkip,      /* FtPictFmla */&#13;
0x0A: parse_FtSkip,      /* FtCbls */&#13;
0x0B: parse_FtSkip,      /* FtRbo */&#13;
0x0C: parse_FtSkip,      /* FtSbs */&#13;
0x0D: parse_FtNts,       /* FtNts */&#13;
0x0E: parse_FtSkip,      /* FtSbsFmla */&#13;
0x0F: parse_FtSkip,      /* FtGboData */&#13;
0x10: parse_FtSkip,      /* FtEdoData */&#13;
0x11: parse_FtSkip,      /* FtRboData */&#13;
0x12: parse_FtSkip,      /* FtCblsData */&#13;
0x13: parse_FtSkip,      /* FtLbsData */&#13;
0x14: parse_FtSkip,      /* FtCblsFmla */&#13;
0x15: parse_FtCmo&#13;
};&#13;
function parse_FtArray(blob, length) {&#13;
	var tgt = blob.l + length;&#13;
	var fts = [];&#13;
	while(blob.l &lt; tgt) {&#13;
		var ft = blob.read_shift(2);&#13;
		blob.l-=2;&#13;
		try {&#13;
			fts.push(FtTab[ft](blob, tgt - blob.l));&#13;
		} catch(e) { blob.l = tgt; return fts; }&#13;
	}&#13;
	if(blob.l != tgt) blob.l = tgt; //throw new Error("bad Object Ft-sequence");&#13;
	return fts;&#13;
}&#13;
&#13;
/* --- 2.4 Records --- */&#13;
&#13;
/* [MS-XLS] 2.4.21 */&#13;
function parse_BOF(blob, length) {&#13;
	var o = {BIFFVer:0, dt:0};&#13;
	o.BIFFVer = blob.read_shift(2); length -= 2;&#13;
	if(length &gt;= 2) { o.dt = blob.read_shift(2); blob.l -= 2; }&#13;
	switch(o.BIFFVer) {&#13;
		case 0x0600: /* BIFF8 */&#13;
		case 0x0500: /* BIFF5 */&#13;
		case 0x0400: /* BIFF4 */&#13;
		case 0x0300: /* BIFF3 */&#13;
		case 0x0200: /* BIFF2 */&#13;
		case 0x0002: case 0x0007: /* BIFF2 */&#13;
			break;&#13;
		default: if(length &gt; 6) throw new Error("Unexpected BIFF Ver " + o.BIFFVer);&#13;
	}&#13;
&#13;
	blob.read_shift(length);&#13;
	return o;&#13;
}&#13;
function write_BOF(wb, t, o) {&#13;
	var h = 0x0600, w = 16;&#13;
	switch(o.bookType) {&#13;
		case 'biff8': break;&#13;
		case 'biff5': h = 0x0500; w = 8; break;&#13;
		case 'biff4': h = 0x0004; w = 6; break;&#13;
		case 'biff3': h = 0x0003; w = 6; break;&#13;
		case 'biff2': h = 0x0002; w = 4; break;&#13;
		case 'xla': break;&#13;
		default: throw new Error("unsupported BIFF version");&#13;
	}&#13;
	var out = new_buf(w);&#13;
	out.write_shift(2, h);&#13;
	out.write_shift(2, t);&#13;
	if(w &gt; 4) out.write_shift(2, 0x7262);&#13;
	if(w &gt; 6) out.write_shift(2, 0x07CD);&#13;
	if(w &gt; 8) {&#13;
		out.write_shift(2, 0xC009);&#13;
		out.write_shift(2, 0x0001);&#13;
		out.write_shift(2, 0x0706);&#13;
		out.write_shift(2, 0x0000);&#13;
	}&#13;
	return out;&#13;
}&#13;
&#13;
&#13;
/* [MS-XLS] 2.4.146 */&#13;
function parse_InterfaceHdr(blob, length) {&#13;
	if(length === 0) return 0x04b0;&#13;
	if((blob.read_shift(2))!==0x04b0){/* empty */}&#13;
	return 0x04b0;&#13;
}&#13;
&#13;
&#13;
/* [MS-XLS] 2.4.349 */&#13;
function parse_WriteAccess(blob, length, opts) {&#13;
	if(opts.enc) { blob.l += length; return ""; }&#13;
	var l = blob.l;&#13;
	// TODO: make sure XLUnicodeString doesnt overrun&#13;
	var UserName = parse_XLUnicodeString2(blob, 0, opts);&#13;
	blob.read_shift(length + l - blob.l);&#13;
	return UserName;&#13;
}&#13;
function write_WriteAccess(s, opts) {&#13;
	var b8 = !opts || opts.biff == 8;&#13;
	var o = new_buf(b8 ? 112 : 54);&#13;
	o.write_shift(opts.biff == 8 ? 2 : 1, 7);&#13;
	if(b8) o.write_shift(1, 0);&#13;
	o.write_shift(4, 0x33336853);&#13;
	o.write_shift(4, (0x00534A74 | (b8 ? 0 : 0x20000000)));&#13;
	while(o.l &lt; o.length) o.write_shift(1, (b8 ? 0 : 32));&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLS] 2.4.351 */&#13;
function parse_WsBool(blob, length, opts) {&#13;
	var flags = opts &amp;&amp; opts.biff == 8 || length == 2 ? blob.read_shift(2) : (blob.l += length, 0);&#13;
	return { fDialog: flags &amp; 0x10, fBelow: flags &amp; 0x40, fRight: flags &amp; 0x80 };&#13;
}&#13;
&#13;
/* [MS-XLS] 2.4.28 */&#13;
function parse_BoundSheet8(blob, length, opts) {&#13;
	var pos = blob.read_shift(4);&#13;
	var hidden = blob.read_shift(1) &amp; 0x03;&#13;
	var dt = blob.read_shift(1);&#13;
	switch(dt) {&#13;
		case 0: dt = 'Worksheet'; break;&#13;
		case 1: dt = 'Macrosheet'; break;&#13;
		case 2: dt = 'Chartsheet'; break;&#13;
		case 6: dt = 'VBAModule'; break;&#13;
	}&#13;
	var name = parse_ShortXLUnicodeString(blob, 0, opts);&#13;
	if(name.length === 0) name = "Sheet1";&#13;
	return { pos:pos, hs:hidden, dt:dt, name:name };&#13;
}&#13;
function write_BoundSheet8(data, opts) {&#13;
	var w = (!opts || opts.biff &gt;= 8 ? 2 : 1);&#13;
	var o = new_buf(8 + w * data.name.length);&#13;
	o.write_shift(4, data.pos);&#13;
	o.write_shift(1, data.hs || 0);&#13;
	o.write_shift(1, data.dt);&#13;
	o.write_shift(1, data.name.length);&#13;
	if(opts.biff &gt;= 8) o.write_shift(1, 1);&#13;
	o.write_shift(w * data.name.length, data.name, opts.biff &lt; 8 ? 'sbcs' : 'utf16le');&#13;
	var out = o.slice(0, o.l);&#13;
	out.l = o.l; return out;&#13;
}&#13;
&#13;
/* [MS-XLS] 2.4.265 TODO */&#13;
function parse_SST(blob, length) {&#13;
	var end = blob.l + length;&#13;
	var cnt = blob.read_shift(4);&#13;
	var ucnt = blob.read_shift(4);&#13;
	var strs = ([]);&#13;
	for(var i = 0; i != ucnt &amp;&amp; blob.l &lt; end; ++i) {&#13;
		strs.push(parse_XLUnicodeRichExtendedString(blob));&#13;
	}&#13;
	strs.Count = cnt; strs.Unique = ucnt;&#13;
	return strs;&#13;
}&#13;
function write_SST(sst, opts) {&#13;
	var header = new_buf(8);&#13;
	header.write_shift(4, sst.Count);&#13;
	header.write_shift(4, sst.Unique);&#13;
	var strs = [];&#13;
	for(var j = 0; j &lt; sst.length; ++j) strs[j] = write_XLUnicodeRichExtendedString(sst[j], opts);&#13;
	var o = bconcat([header].concat(strs));&#13;
o.parts = [header.length].concat(strs.map(function(str) { return str.length; }));&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLS] 2.4.107 */&#13;
function parse_ExtSST(blob, length) {&#13;
	var extsst = {};&#13;
	extsst.dsst = blob.read_shift(2);&#13;
	blob.l += length-2;&#13;
	return extsst;&#13;
}&#13;
&#13;
&#13;
/* [MS-XLS] 2.4.221 TODO: check BIFF2-4 */&#13;
function parse_Row(blob) {&#13;
	var z = ({});&#13;
	z.r = blob.read_shift(2);&#13;
	z.c = blob.read_shift(2);&#13;
	z.cnt = blob.read_shift(2) - z.c;&#13;
	var miyRw = blob.read_shift(2);&#13;
	blob.l += 4; // reserved(2), unused(2)&#13;
	var flags = blob.read_shift(1); // various flags&#13;
	blob.l += 3; // reserved(8), ixfe(12), flags(4)&#13;
	if(flags &amp; 0x07) z.level = flags &amp; 0x07;&#13;
	// collapsed: flags &amp; 0x10&#13;
	if(flags &amp; 0x20) z.hidden = true;&#13;
	if(flags &amp; 0x40) z.hpt = miyRw / 20;&#13;
	return z;&#13;
}&#13;
&#13;
&#13;
/* [MS-XLS] 2.4.125 */&#13;
function parse_ForceFullCalculation(blob) {&#13;
	var header = parse_frtHeader(blob);&#13;
	if(header.type != 0x08A3) throw new Error("Invalid Future Record " + header.type);&#13;
	var fullcalc = blob.read_shift(4);&#13;
	return fullcalc !== 0x0;&#13;
}&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
/* [MS-XLS] 2.4.215 rt */&#13;
function parse_RecalcId(blob) {&#13;
	blob.read_shift(2);&#13;
	return blob.read_shift(4);&#13;
}&#13;
&#13;
/* [MS-XLS] 2.4.87 */&#13;
function parse_DefaultRowHeight(blob, length, opts) {&#13;
	var f = 0;&#13;
	if(!(opts &amp;&amp; opts.biff == 2)) {&#13;
		f = blob.read_shift(2);&#13;
	}&#13;
	var miyRw = blob.read_shift(2);&#13;
	if((opts &amp;&amp; opts.biff == 2)) {&#13;
		f = 1 - (miyRw &gt;&gt; 15); miyRw &amp;= 0x7fff;&#13;
	}&#13;
	var fl = {Unsynced:f&amp;1,DyZero:(f&amp;2)&gt;&gt;1,ExAsc:(f&amp;4)&gt;&gt;2,ExDsc:(f&amp;8)&gt;&gt;3};&#13;
	return [fl, miyRw];&#13;
}&#13;
&#13;
/* [MS-XLS] 2.4.345 TODO */&#13;
function parse_Window1(blob) {&#13;
	var xWn = blob.read_shift(2), yWn = blob.read_shift(2), dxWn = blob.read_shift(2), dyWn = blob.read_shift(2);&#13;
	var flags = blob.read_shift(2), iTabCur = blob.read_shift(2), iTabFirst = blob.read_shift(2);&#13;
	var ctabSel = blob.read_shift(2), wTabRatio = blob.read_shift(2);&#13;
	return { Pos: [xWn, yWn], Dim: [dxWn, dyWn], Flags: flags, CurTab: iTabCur,&#13;
		FirstTab: iTabFirst, Selected: ctabSel, TabRatio: wTabRatio };&#13;
}&#13;
function write_Window1() {&#13;
	var o = new_buf(18);&#13;
	o.write_shift(2, 0);&#13;
	o.write_shift(2, 0);&#13;
	o.write_shift(2, 0x7260);&#13;
	o.write_shift(2, 0x44c0);&#13;
	o.write_shift(2, 0x38);&#13;
	o.write_shift(2, 0);&#13;
	o.write_shift(2, 0);&#13;
	o.write_shift(2, 1);&#13;
	o.write_shift(2, 0x01f4);&#13;
	return o;&#13;
}&#13;
/* [MS-XLS] 2.4.346 TODO */&#13;
function parse_Window2(blob, length, opts) {&#13;
	if(opts &amp;&amp; opts.biff &gt;= 2 &amp;&amp; opts.biff &lt; 5) return {};&#13;
	var f = blob.read_shift(2);&#13;
	return { RTL: f &amp; 0x40 };&#13;
}&#13;
function write_Window2(view) {&#13;
	var o = new_buf(18), f = 0x6b6;&#13;
	if(view &amp;&amp; view.RTL) f |= 0x40;&#13;
	o.write_shift(2, f);&#13;
	o.write_shift(4, 0);&#13;
	o.write_shift(4, 64);&#13;
	o.write_shift(4, 0);&#13;
	o.write_shift(4, 0);&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLS] 2.4.189 TODO */&#13;
function parse_Pane(/*blob, length, opts*/) {&#13;
}&#13;
&#13;
/* [MS-XLS] 2.4.122 TODO */&#13;
function parse_Font(blob, length, opts) {&#13;
	var o = {&#13;
		dyHeight: blob.read_shift(2),&#13;
		fl: blob.read_shift(2)&#13;
	};&#13;
	switch((opts &amp;&amp; opts.biff) || 8) {&#13;
		case 2: break;&#13;
		case 3: case 4: blob.l += 2; break;&#13;
		default: blob.l += 10; break;&#13;
	}&#13;
	o.name = parse_ShortXLUnicodeString(blob, 0, opts);&#13;
	return o;&#13;
}&#13;
function write_Font(data, opts) {&#13;
	var name = data.name || "Arial";&#13;
	var b5 = (opts &amp;&amp; (opts.biff == 5)), w = (b5 ? (15 + name.length) : (16 + 2 * name.length));&#13;
	var o = new_buf(w);&#13;
	o.write_shift(2, (data.sz || 12) * 20);&#13;
	o.write_shift(4, 0);&#13;
	o.write_shift(2, 400);&#13;
	o.write_shift(4, 0);&#13;
	o.write_shift(2, 0);&#13;
	o.write_shift(1, name.length);&#13;
	if(!b5) o.write_shift(1, 1);&#13;
	o.write_shift((b5 ? 1 : 2) * name.length, name, (b5 ? "sbcs" : "utf16le"));&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLS] 2.4.149 */&#13;
function parse_LabelSst(blob) {&#13;
	var cell = parse_XLSCell(blob);&#13;
	cell.isst = blob.read_shift(4);&#13;
	return cell;&#13;
}&#13;
function write_LabelSst(R, C, v, os ) {&#13;
	var o = new_buf(10);&#13;
	write_XLSCell(R, C, os, o);&#13;
	o.write_shift(4, v);&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLS] 2.4.148 */&#13;
function parse_Label(blob, length, opts) {&#13;
	if(opts.biffguess &amp;&amp; opts.biff == 2) opts.biff = 5;&#13;
	var target = blob.l + length;&#13;
	var cell = parse_XLSCell(blob, 6);&#13;
	if(opts.biff == 2) blob.l++;&#13;
	var str = parse_XLUnicodeString(blob, target - blob.l, opts);&#13;
	cell.val = str;&#13;
	return cell;&#13;
}&#13;
function write_Label(R, C, v, os, opts) {&#13;
	var b8 = !opts || opts.biff == 8;&#13;
	var o = new_buf(6 + 2 + (+b8) + (1 + b8) * v.length);&#13;
	write_XLSCell(R, C, os, o);&#13;
	o.write_shift(2, v.length);&#13;
	if(b8) o.write_shift(1, 1);&#13;
	o.write_shift((1 + b8) * v.length, v, b8 ? 'utf16le' : 'sbcs');&#13;
	return o;&#13;
}&#13;
&#13;
&#13;
/* [MS-XLS] 2.4.126 Number Formats */&#13;
function parse_Format(blob, length, opts) {&#13;
	var numFmtId = blob.read_shift(2);&#13;
	var fmtstr = parse_XLUnicodeString2(blob, 0, opts);&#13;
	return [numFmtId, fmtstr];&#13;
}&#13;
function write_Format(i, f, opts, o) {&#13;
	var b5 = (opts &amp;&amp; (opts.biff == 5));&#13;
	if(!o) o = new_buf(b5 ? (3 + f.length) : (5 + 2 * f.length));&#13;
	o.write_shift(2, i);&#13;
	o.write_shift((b5 ? 1 : 2), f.length);&#13;
	if(!b5) o.write_shift(1, 1);&#13;
	o.write_shift((b5 ? 1 : 2) * f.length, f, (b5 ? 'sbcs' : 'utf16le'));&#13;
	var out = (o.length &gt; o.l) ? o.slice(0, o.l) : o;&#13;
	if(out.l == null) out.l = out.length;&#13;
	return out;&#13;
}&#13;
var parse_BIFF2Format = parse_XLUnicodeString2;&#13;
&#13;
/* [MS-XLS] 2.4.90 */&#13;
function parse_Dimensions(blob, length, opts) {&#13;
	var end = blob.l + length;&#13;
	var w = opts.biff == 8 || !opts.biff ? 4 : 2;&#13;
	var r = blob.read_shift(w), R = blob.read_shift(w);&#13;
	var c = blob.read_shift(2), C = blob.read_shift(2);&#13;
	blob.l = end;&#13;
	return {s: {r:r, c:c}, e: {r:R, c:C}};&#13;
}&#13;
function write_Dimensions(range, opts) {&#13;
	var w = opts.biff == 8 || !opts.biff ? 4 : 2;&#13;
	var o = new_buf(2*w + 6);&#13;
	o.write_shift(w, range.s.r);&#13;
	o.write_shift(w, range.e.r + 1);&#13;
	o.write_shift(2, range.s.c);&#13;
	o.write_shift(2, range.e.c + 1);&#13;
	o.write_shift(2, 0);&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLS] 2.4.220 */&#13;
function parse_RK(blob) {&#13;
	var rw = blob.read_shift(2), col = blob.read_shift(2);&#13;
	var rkrec = parse_RkRec(blob);&#13;
	return {r:rw, c:col, ixfe:rkrec[0], rknum:rkrec[1]};&#13;
}&#13;
&#13;
/* [MS-XLS] 2.4.175 */&#13;
function parse_MulRk(blob, length) {&#13;
	var target = blob.l + length - 2;&#13;
	var rw = blob.read_shift(2), col = blob.read_shift(2);&#13;
	var rkrecs = [];&#13;
	while(blob.l &lt; target) rkrecs.push(parse_RkRec(blob));&#13;
	if(blob.l !== target) throw new Error("MulRK read error");&#13;
	var lastcol = blob.read_shift(2);&#13;
	if(rkrecs.length != lastcol - col + 1) throw new Error("MulRK length mismatch");&#13;
	return {r:rw, c:col, C:lastcol, rkrec:rkrecs};&#13;
}&#13;
/* [MS-XLS] 2.4.174 */&#13;
function parse_MulBlank(blob, length) {&#13;
	var target = blob.l + length - 2;&#13;
	var rw = blob.read_shift(2), col = blob.read_shift(2);&#13;
	var ixfes = [];&#13;
	while(blob.l &lt; target) ixfes.push(blob.read_shift(2));&#13;
	if(blob.l !== target) throw new Error("MulBlank read error");&#13;
	var lastcol = blob.read_shift(2);&#13;
	if(ixfes.length != lastcol - col + 1) throw new Error("MulBlank length mismatch");&#13;
	return {r:rw, c:col, C:lastcol, ixfe:ixfes};&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.20 2.5.249 TODO: interpret values here */&#13;
function parse_CellStyleXF(blob, length, style, opts) {&#13;
	var o = {};&#13;
	var a = blob.read_shift(4), b = blob.read_shift(4);&#13;
	var c = blob.read_shift(4), d = blob.read_shift(2);&#13;
	o.patternType = XLSFillPattern[c &gt;&gt; 26];&#13;
&#13;
	if(!opts.cellStyles) return o;&#13;
	o.alc = a &amp; 0x07;&#13;
	o.fWrap = (a &gt;&gt; 3) &amp; 0x01;&#13;
	o.alcV = (a &gt;&gt; 4) &amp; 0x07;&#13;
	o.fJustLast = (a &gt;&gt; 7) &amp; 0x01;&#13;
	o.trot = (a &gt;&gt; 8) &amp; 0xFF;&#13;
	o.cIndent = (a &gt;&gt; 16) &amp; 0x0F;&#13;
	o.fShrinkToFit = (a &gt;&gt; 20) &amp; 0x01;&#13;
	o.iReadOrder = (a &gt;&gt; 22) &amp; 0x02;&#13;
	o.fAtrNum = (a &gt;&gt; 26) &amp; 0x01;&#13;
	o.fAtrFnt = (a &gt;&gt; 27) &amp; 0x01;&#13;
	o.fAtrAlc = (a &gt;&gt; 28) &amp; 0x01;&#13;
	o.fAtrBdr = (a &gt;&gt; 29) &amp; 0x01;&#13;
	o.fAtrPat = (a &gt;&gt; 30) &amp; 0x01;&#13;
	o.fAtrProt = (a &gt;&gt; 31) &amp; 0x01;&#13;
&#13;
	o.dgLeft = b &amp; 0x0F;&#13;
	o.dgRight = (b &gt;&gt; 4) &amp; 0x0F;&#13;
	o.dgTop = (b &gt;&gt; 8) &amp; 0x0F;&#13;
	o.dgBottom = (b &gt;&gt; 12) &amp; 0x0F;&#13;
	o.icvLeft = (b &gt;&gt; 16) &amp; 0x7F;&#13;
	o.icvRight = (b &gt;&gt; 23) &amp; 0x7F;&#13;
	o.grbitDiag = (b &gt;&gt; 30) &amp; 0x03;&#13;
&#13;
	o.icvTop = c &amp; 0x7F;&#13;
	o.icvBottom = (c &gt;&gt; 7) &amp; 0x7F;&#13;
	o.icvDiag = (c &gt;&gt; 14) &amp; 0x7F;&#13;
	o.dgDiag = (c &gt;&gt; 21) &amp; 0x0F;&#13;
&#13;
	o.icvFore = d &amp; 0x7F;&#13;
	o.icvBack = (d &gt;&gt; 7) &amp; 0x7F;&#13;
	o.fsxButton = (d &gt;&gt; 14) &amp; 0x01;&#13;
	return o;&#13;
}&#13;
//function parse_CellXF(blob, length, opts) {return parse_CellStyleXF(blob,length,0, opts);}&#13;
//function parse_StyleXF(blob, length, opts) {return parse_CellStyleXF(blob,length,1, opts);}&#13;
&#13;
/* [MS-XLS] 2.4.353 TODO: actually do this right */&#13;
function parse_XF(blob, length, opts) {&#13;
	var o = {};&#13;
	o.ifnt = blob.read_shift(2); o.numFmtId = blob.read_shift(2); o.flags = blob.read_shift(2);&#13;
	o.fStyle = (o.flags &gt;&gt; 2) &amp; 0x01;&#13;
	length -= 6;&#13;
	o.data = parse_CellStyleXF(blob, length, o.fStyle, opts);&#13;
	return o;&#13;
}&#13;
function write_XF(data, ixfeP, opts, o) {&#13;
	var b5 = (opts &amp;&amp; (opts.biff == 5));&#13;
	if(!o) o = new_buf(b5 ? 16 : 20);&#13;
	o.write_shift(2, 0);&#13;
	if(data.style) {&#13;
		o.write_shift(2, (data.numFmtId||0));&#13;
		o.write_shift(2, 0xFFF4);&#13;
	} else {&#13;
		o.write_shift(2, (data.numFmtId||0));&#13;
		o.write_shift(2, (ixfeP&lt;&lt;4));&#13;
	}&#13;
	var f = 0;&#13;
	if(data.numFmtId &gt; 0 &amp;&amp; b5) f |= 0x0400;&#13;
	o.write_shift(4, f);&#13;
	o.write_shift(4, 0);&#13;
	if(!b5) o.write_shift(4, 0);&#13;
	o.write_shift(2, 0);&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLS] 2.4.134 */&#13;
function parse_Guts(blob) {&#13;
	blob.l += 4;&#13;
	var out = [blob.read_shift(2), blob.read_shift(2)];&#13;
	if(out[0] !== 0) out[0]--;&#13;
	if(out[1] !== 0) out[1]--;&#13;
	if(out[0] &gt; 7 || out[1] &gt; 7) throw new Error("Bad Gutters: " + out.join("|"));&#13;
	return out;&#13;
}&#13;
function write_Guts(guts) {&#13;
	var o = new_buf(8);&#13;
	o.write_shift(4, 0);&#13;
	o.write_shift(2, guts[0] ? guts[0] + 1 : 0);&#13;
	o.write_shift(2, guts[1] ? guts[1] + 1 : 0);&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLS] 2.4.24 */&#13;
function parse_BoolErr(blob, length, opts) {&#13;
	var cell = parse_XLSCell(blob, 6);&#13;
	if(opts.biff == 2 || length == 9) ++blob.l;&#13;
	var val = parse_Bes(blob, 2);&#13;
	cell.val = val;&#13;
	cell.t = (val === true || val === false) ? 'b' : 'e';&#13;
	return cell;&#13;
}&#13;
function write_BoolErr(R, C, v, os, opts, t) {&#13;
	var o = new_buf(8);&#13;
	write_XLSCell(R, C, os, o);&#13;
	write_Bes(v, t, o);&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLS] 2.4.180 Number */&#13;
function parse_Number(blob, length, opts) {&#13;
	if(opts.biffguess &amp;&amp; opts.biff == 2) opts.biff = 5;&#13;
	var cell = parse_XLSCell(blob, 6);&#13;
	var xnum = parse_Xnum(blob, 8);&#13;
	cell.val = xnum;&#13;
	return cell;&#13;
}&#13;
function write_Number(R, C, v, os) {&#13;
	var o = new_buf(14);&#13;
	write_XLSCell(R, C, os, o);&#13;
	write_Xnum(v, o);&#13;
	return o;&#13;
}&#13;
&#13;
var parse_XLHeaderFooter = parse_OptXLUnicodeString; // TODO: parse 2.4.136&#13;
&#13;
/* [MS-XLS] 2.4.271 */&#13;
function parse_SupBook(blob, length, opts) {&#13;
	var end = blob.l + length;&#13;
	var ctab = blob.read_shift(2);&#13;
	var cch = blob.read_shift(2);&#13;
	opts.sbcch = cch;&#13;
	if(cch == 0x0401 || cch == 0x3A01) return [cch, ctab];&#13;
	if(cch &lt; 0x01 || cch &gt;0xff) throw new Error("Unexpected SupBook type: "+cch);&#13;
	var virtPath = parse_XLUnicodeStringNoCch(blob, cch);&#13;
	/* TODO: 2.5.277 Virtual Path */&#13;
	var rgst = [];&#13;
	while(end &gt; blob.l) rgst.push(parse_XLUnicodeString(blob));&#13;
	return [cch, ctab, virtPath, rgst];&#13;
}&#13;
&#13;
/* [MS-XLS] 2.4.105 TODO */&#13;
function parse_ExternName(blob, length, opts) {&#13;
	var flags = blob.read_shift(2);&#13;
	var body;&#13;
	var o = ({&#13;
		fBuiltIn: flags &amp; 0x01,&#13;
		fWantAdvise: (flags &gt;&gt;&gt; 1) &amp; 0x01,&#13;
		fWantPict: (flags &gt;&gt;&gt; 2) &amp; 0x01,&#13;
		fOle: (flags &gt;&gt;&gt; 3) &amp; 0x01,&#13;
		fOleLink: (flags &gt;&gt;&gt; 4) &amp; 0x01,&#13;
		cf: (flags &gt;&gt;&gt; 5) &amp; 0x3FF,&#13;
		fIcon: flags &gt;&gt;&gt; 15 &amp; 0x01&#13;
	});&#13;
	if(opts.sbcch === 0x3A01) body = parse_AddinUdf(blob, length-2, opts);&#13;
	//else throw new Error("unsupported SupBook cch: " + opts.sbcch);&#13;
	o.body = body || blob.read_shift(length-2);&#13;
	if(typeof body === "string") o.Name = body;&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLS] 2.4.150 TODO */&#13;
function parse_Lbl(blob, length, opts) {&#13;
	var target = blob.l + length;&#13;
	var flags = blob.read_shift(2);&#13;
	var chKey = blob.read_shift(1);&#13;
	var cch = blob.read_shift(1);&#13;
	var cce = blob.read_shift(opts &amp;&amp; opts.biff == 2 ? 1 : 2);&#13;
	var itab = 0;&#13;
	if(!opts || opts.biff &gt;= 5) {&#13;
		if(opts.biff != 5) blob.l += 2;&#13;
		itab = blob.read_shift(2);&#13;
		if(opts.biff == 5) blob.l += 2;&#13;
		blob.l += 4;&#13;
	}&#13;
	var name = parse_XLUnicodeStringNoCch(blob, cch, opts);&#13;
	if(flags &amp; 0x20) name = XLSLblBuiltIn[name.charCodeAt(0)];&#13;
	var npflen = target - blob.l; if(opts &amp;&amp; opts.biff == 2) --npflen;&#13;
	/*jshint -W018 */&#13;
	var rgce = (target == blob.l || cce === 0 || !(npflen &gt; 0)) ? [] : parse_NameParsedFormula(blob, npflen, opts, cce);&#13;
	/*jshint +W018 */&#13;
	return {&#13;
		chKey: chKey,&#13;
		Name: name,&#13;
		itab: itab,&#13;
		rgce: rgce&#13;
	};&#13;
}&#13;
&#13;
/* [MS-XLS] 2.4.106 TODO: verify filename encoding */&#13;
function parse_ExternSheet(blob, length, opts) {&#13;
	if(opts.biff &lt; 8) return parse_BIFF5ExternSheet(blob, length, opts);&#13;
	var o = [], target = blob.l + length, len = blob.read_shift(opts.biff &gt; 8 ? 4 : 2);&#13;
	while(len-- !== 0) o.push(parse_XTI(blob, opts.biff &gt; 8 ? 12 : 6, opts));&#13;
		// [iSupBook, itabFirst, itabLast];&#13;
	if(blob.l != target) throw new Error("Bad ExternSheet: " + blob.l + " != " + target);&#13;
	return o;&#13;
}&#13;
function parse_BIFF5ExternSheet(blob, length, opts) {&#13;
	if(blob[blob.l + 1] == 0x03) blob[blob.l]++;&#13;
	var o = parse_ShortXLUnicodeString(blob, length, opts);&#13;
	return o.charCodeAt(0) == 0x03 ? o.slice(1) : o;&#13;
}&#13;
&#13;
/* [MS-XLS] 2.4.176 TODO: check older biff */&#13;
function parse_NameCmt(blob, length, opts) {&#13;
	if(opts.biff &lt; 8) { blob.l += length; return; }&#13;
	var cchName = blob.read_shift(2);&#13;
	var cchComment = blob.read_shift(2);&#13;
	var name = parse_XLUnicodeStringNoCch(blob, cchName, opts);&#13;
	var comment = parse_XLUnicodeStringNoCch(blob, cchComment, opts);&#13;
	return [name, comment];&#13;
}&#13;
&#13;
/* [MS-XLS] 2.4.260 */&#13;
function parse_ShrFmla(blob, length, opts) {&#13;
	var ref = parse_RefU(blob, 6);&#13;
	blob.l++;&#13;
	var cUse = blob.read_shift(1);&#13;
	length -= 8;&#13;
	return [parse_SharedParsedFormula(blob, length, opts), cUse, ref];&#13;
}&#13;
&#13;
/* [MS-XLS] 2.4.4 TODO */&#13;
function parse_Array(blob, length, opts) {&#13;
	var ref = parse_Ref(blob, 6);&#13;
	/* TODO: fAlwaysCalc */&#13;
	switch(opts.biff) {&#13;
		case 2: blob.l ++; length -= 7; break;&#13;
		case 3: case 4: blob.l += 2; length -= 8; break;&#13;
		default: blob.l += 6; length -= 12;&#13;
	}&#13;
	return [ref, parse_ArrayParsedFormula(blob, length, opts, ref)];&#13;
}&#13;
&#13;
/* [MS-XLS] 2.4.173 */&#13;
function parse_MTRSettings(blob) {&#13;
	var fMTREnabled = blob.read_shift(4) !== 0x00;&#13;
	var fUserSetThreadCount = blob.read_shift(4) !== 0x00;&#13;
	var cUserThreadCount = blob.read_shift(4);&#13;
	return [fMTREnabled, fUserSetThreadCount, cUserThreadCount];&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.186 TODO: BIFF5 */&#13;
function parse_NoteSh(blob, length, opts) {&#13;
	if(opts.biff &lt; 8) return;&#13;
	var row = blob.read_shift(2), col = blob.read_shift(2);&#13;
	var flags = blob.read_shift(2), idObj = blob.read_shift(2);&#13;
	var stAuthor = parse_XLUnicodeString2(blob, 0, opts);&#13;
	if(opts.biff &lt; 8) blob.read_shift(1);&#13;
	return [{r:row,c:col}, stAuthor, idObj, flags];&#13;
}&#13;
&#13;
/* [MS-XLS] 2.4.179 */&#13;
function parse_Note(blob, length, opts) {&#13;
	/* TODO: Support revisions */&#13;
	return parse_NoteSh(blob, length, opts);&#13;
}&#13;
&#13;
/* [MS-XLS] 2.4.168 */&#13;
function parse_MergeCells(blob, length) {&#13;
	var merges = [];&#13;
	var cmcs = blob.read_shift(2);&#13;
	while (cmcs--) merges.push(parse_Ref8U(blob,length));&#13;
	return merges;&#13;
}&#13;
function write_MergeCells(merges) {&#13;
	var o = new_buf(2 + merges.length * 8);&#13;
	o.write_shift(2, merges.length);&#13;
	for(var i = 0; i &lt; merges.length; ++i) write_Ref8U(merges[i], o);&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLS] 2.4.181 TODO: parse all the things! */&#13;
function parse_Obj(blob, length, opts) {&#13;
	if(opts &amp;&amp; opts.biff &lt; 8) return parse_BIFF5Obj(blob, length, opts);&#13;
	var cmo = parse_FtCmo(blob, 22); // id, ot, flags&#13;
	var fts = parse_FtArray(blob, length-22, cmo[1]);&#13;
	return { cmo: cmo, ft:fts };&#13;
}&#13;
/* from older spec */&#13;
var parse_BIFF5OT = {&#13;
0x08: function(blob, length) {&#13;
	var tgt = blob.l + length;&#13;
	blob.l += 10; // todo&#13;
	var cf = blob.read_shift(2);&#13;
	blob.l += 4;&#13;
	blob.l += 2; //var cbPictFmla = blob.read_shift(2);&#13;
	blob.l += 2;&#13;
	blob.l += 2; //var grbit = blob.read_shift(2);&#13;
	blob.l += 4;&#13;
	var cchName = blob.read_shift(1);&#13;
	blob.l += cchName; // TODO: stName&#13;
	blob.l = tgt; // TODO: fmla&#13;
	return { fmt:cf };&#13;
}&#13;
};&#13;
&#13;
function parse_BIFF5Obj(blob, length, opts) {&#13;
	blob.l += 4; //var cnt = blob.read_shift(4);&#13;
	var ot = blob.read_shift(2);&#13;
	var id = blob.read_shift(2);&#13;
	var grbit = blob.read_shift(2);&#13;
	blob.l += 2; //var colL = blob.read_shift(2);&#13;
	blob.l += 2; //var dxL = blob.read_shift(2);&#13;
	blob.l += 2; //var rwT = blob.read_shift(2);&#13;
	blob.l += 2; //var dyT = blob.read_shift(2);&#13;
	blob.l += 2; //var colR = blob.read_shift(2);&#13;
	blob.l += 2; //var dxR = blob.read_shift(2);&#13;
	blob.l += 2; //var rwB = blob.read_shift(2);&#13;
	blob.l += 2; //var dyB = blob.read_shift(2);&#13;
	blob.l += 2; //var cbMacro = blob.read_shift(2);&#13;
	blob.l += 6;&#13;
	length -= 36;&#13;
	var fts = [];&#13;
	fts.push((parse_BIFF5OT[ot]||parsenoop)(blob, length, opts));&#13;
	return { cmo: [id, ot, grbit], ft:fts };&#13;
}&#13;
&#13;
/* [MS-XLS] 2.4.329 TODO: parse properly */&#13;
function parse_TxO(blob, length, opts) {&#13;
	var s = blob.l;&#13;
	var texts = "";&#13;
try {&#13;
	blob.l += 4;&#13;
	var ot = (opts.lastobj||{cmo:[0,0]}).cmo[1];&#13;
	var controlInfo; // eslint-disable-line no-unused-vars&#13;
	if([0,5,7,11,12,14].indexOf(ot) == -1) blob.l += 6;&#13;
	else controlInfo = parse_ControlInfo(blob, 6, opts); // eslint-disable-line no-unused-vars&#13;
	var cchText = blob.read_shift(2);&#13;
	/*var cbRuns = */blob.read_shift(2);&#13;
	/*var ifntEmpty = */parseuint16(blob, 2);&#13;
	var len = blob.read_shift(2);&#13;
	blob.l += len;&#13;
	//var fmla = parse_ObjFmla(blob, s + length - blob.l);&#13;
&#13;
	for(var i = 1; i &lt; blob.lens.length-1; ++i) {&#13;
		if(blob.l-s != blob.lens[i]) throw new Error("TxO: bad continue record");&#13;
		var hdr = blob[blob.l];&#13;
		var t = parse_XLUnicodeStringNoCch(blob, blob.lens[i+1]-blob.lens[i]-1);&#13;
		texts += t;&#13;
		if(texts.length &gt;= (hdr ? cchText : 2*cchText)) break;&#13;
	}&#13;
	if(texts.length !== cchText &amp;&amp; texts.length !== cchText*2) {&#13;
		throw new Error("cchText: " + cchText + " != " + texts.length);&#13;
	}&#13;
&#13;
	blob.l = s + length;&#13;
	/* [MS-XLS] 2.5.272 TxORuns */&#13;
//	var rgTxoRuns = [];&#13;
//	for(var j = 0; j != cbRuns/8-1; ++j) blob.l += 8;&#13;
//	var cchText2 = blob.read_shift(2);&#13;
//	if(cchText2 !== cchText) throw new Error("TxOLastRun mismatch: " + cchText2 + " " + cchText);&#13;
//	blob.l += 6;&#13;
//	if(s + length != blob.l) throw new Error("TxO " + (s + length) + ", at " + blob.l);&#13;
	return { t: texts };&#13;
} catch(e) { blob.l = s + length; return { t: texts }; }&#13;
}&#13;
&#13;
/* [MS-XLS] 2.4.140 */&#13;
function parse_HLink(blob, length) {&#13;
	var ref = parse_Ref8U(blob, 8);&#13;
	blob.l += 16; /* CLSID */&#13;
	var hlink = parse_Hyperlink(blob, length-24);&#13;
	return [ref, hlink];&#13;
}&#13;
function write_HLink(hl) {&#13;
	var O = new_buf(24);&#13;
	var ref = decode_cell(hl[0]);&#13;
	O.write_shift(2, ref.r); O.write_shift(2, ref.r);&#13;
	O.write_shift(2, ref.c); O.write_shift(2, ref.c);&#13;
	var clsid = "d0 c9 ea 79 f9 ba ce 11 8c 82 00 aa 00 4b a9 0b".split(" ");&#13;
	for(var i = 0; i &lt; 16; ++i) O.write_shift(1, parseInt(clsid[i], 16));&#13;
	return bconcat([O, write_Hyperlink(hl[1])]);&#13;
}&#13;
&#13;
&#13;
/* [MS-XLS] 2.4.141 */&#13;
function parse_HLinkTooltip(blob, length) {&#13;
	blob.read_shift(2);&#13;
	var ref = parse_Ref8U(blob, 8);&#13;
	var wzTooltip = blob.read_shift((length-10)/2, 'dbcs-cont');&#13;
	wzTooltip = wzTooltip.replace(chr0,"");&#13;
	return [ref, wzTooltip];&#13;
}&#13;
function write_HLinkTooltip(hl) {&#13;
	var TT = hl[1].Tooltip;&#13;
	var O = new_buf(10 + 2 * (TT.length + 1));&#13;
	O.write_shift(2, 0x0800);&#13;
	var ref = decode_cell(hl[0]);&#13;
	O.write_shift(2, ref.r); O.write_shift(2, ref.r);&#13;
	O.write_shift(2, ref.c); O.write_shift(2, ref.c);&#13;
	for(var i = 0; i &lt; TT.length; ++i) O.write_shift(2, TT.charCodeAt(i));&#13;
	O.write_shift(2, 0);&#13;
	return O;&#13;
}&#13;
&#13;
/* [MS-XLS] 2.4.63 */&#13;
function parse_Country(blob) {&#13;
	var o = [0,0], d;&#13;
	d = blob.read_shift(2); o[0] = CountryEnum[d] || d;&#13;
	d = blob.read_shift(2); o[1] = CountryEnum[d] || d;&#13;
	return o;&#13;
}&#13;
function write_Country(o) {&#13;
	if(!o) o = new_buf(4);&#13;
	o.write_shift(2, 0x01);&#13;
	o.write_shift(2, 0x01);&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLS] 2.4.50 ClrtClient */&#13;
function parse_ClrtClient(blob) {&#13;
	var ccv = blob.read_shift(2);&#13;
	var o = [];&#13;
	while(ccv--&gt;0) o.push(parse_LongRGB(blob, 8));&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLS] 2.4.188 */&#13;
function parse_Palette(blob) {&#13;
	var ccv = blob.read_shift(2);&#13;
	var o = [];&#13;
	while(ccv--&gt;0) o.push(parse_LongRGB(blob, 8));&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLS] 2.4.354 */&#13;
function parse_XFCRC(blob) {&#13;
	blob.l += 2;&#13;
	var o = {cxfs:0, crc:0};&#13;
	o.cxfs = blob.read_shift(2);&#13;
	o.crc = blob.read_shift(4);&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLS] 2.4.53 TODO: parse flags */&#13;
/* [MS-XLSB] 2.4.323 TODO: parse flags */&#13;
function parse_ColInfo(blob, length, opts) {&#13;
	if(!opts.cellStyles) return parsenoop(blob, length);&#13;
	var w = opts &amp;&amp; opts.biff &gt;= 12 ? 4 : 2;&#13;
	var colFirst = blob.read_shift(w);&#13;
	var colLast = blob.read_shift(w);&#13;
	var coldx = blob.read_shift(w);&#13;
	var ixfe = blob.read_shift(w);&#13;
	var flags = blob.read_shift(2);&#13;
	if(w == 2) blob.l += 2;&#13;
	var o = ({s:colFirst, e:colLast, w:coldx, ixfe:ixfe, flags:flags});&#13;
	if(opts.biff &gt;= 5 || !opts.biff) o.level = (flags &gt;&gt; 8) &amp; 0x7;&#13;
	return o;&#13;
}&#13;
function write_ColInfo(col, idx) {&#13;
	var o = new_buf(12);&#13;
	o.write_shift(2, idx);&#13;
	o.write_shift(2, idx);&#13;
	o.write_shift(2, col.width * 256);&#13;
	o.write_shift(2, 0);&#13;
	var f = 0;&#13;
	if(col.hidden) f |= 1;&#13;
	o.write_shift(1, f);&#13;
	f = col.level || 0;&#13;
	o.write_shift(1, f);&#13;
	o.write_shift(2, 0);&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLS] 2.4.257 */&#13;
function parse_Setup(blob, length) {&#13;
	var o = {};&#13;
	if(length &lt; 32) return o;&#13;
	blob.l += 16;&#13;
	o.header = parse_Xnum(blob, 8);&#13;
	o.footer = parse_Xnum(blob, 8);&#13;
	blob.l += 2;&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLS] 2.4.261 */&#13;
function parse_ShtProps(blob, length, opts) {&#13;
	var def = {area:false};&#13;
	if(opts.biff != 5) { blob.l += length; return def; }&#13;
	var d = blob.read_shift(1); blob.l += 3;&#13;
	if((d &amp; 0x10)) def.area = true;&#13;
	return def;&#13;
}&#13;
&#13;
/* [MS-XLS] 2.4.241 */&#13;
function write_RRTabId(n) {&#13;
	var out = new_buf(2 * n);&#13;
	for(var i = 0; i &lt; n; ++i) out.write_shift(2, i+1);&#13;
	return out;&#13;
}&#13;
&#13;
var parse_Blank = parse_XLSCell; /* [MS-XLS] 2.4.20 Just the cell */&#13;
var parse_Scl = parseuint16a; /* [MS-XLS] 2.4.247 num, den */&#13;
var parse_String = parse_XLUnicodeString; /* [MS-XLS] 2.4.268 */&#13;
&#13;
/* --- Specific to versions before BIFF8 --- */&#13;
function parse_ImData(blob) {&#13;
	var cf = blob.read_shift(2);&#13;
	var env = blob.read_shift(2);&#13;
	var lcb = blob.read_shift(4);&#13;
	var o = {fmt:cf, env:env, len:lcb, data:blob.slice(blob.l,blob.l+lcb)};&#13;
	blob.l += lcb;&#13;
	return o;&#13;
}&#13;
&#13;
/* BIFF2_??? where ??? is the name from [XLS] */&#13;
function parse_BIFF2STR(blob, length, opts) {&#13;
	if(opts.biffguess &amp;&amp; opts.biff == 5) opts.biff = 2;&#13;
	var cell = parse_XLSCell(blob, 6);&#13;
	++blob.l;&#13;
	var str = parse_XLUnicodeString2(blob, length-7, opts);&#13;
	cell.t = 'str';&#13;
	cell.val = str;&#13;
	return cell;&#13;
}&#13;
&#13;
function parse_BIFF2NUM(blob) {&#13;
	var cell = parse_XLSCell(blob, 6);&#13;
	++blob.l;&#13;
	var num = parse_Xnum(blob, 8);&#13;
	cell.t = 'n';&#13;
	cell.val = num;&#13;
	return cell;&#13;
}&#13;
function write_BIFF2NUM(r, c, val) {&#13;
	var out = new_buf(15);&#13;
	write_BIFF2Cell(out, r, c);&#13;
	out.write_shift(8, val, 'f');&#13;
	return out;&#13;
}&#13;
&#13;
function parse_BIFF2INT(blob) {&#13;
	var cell = parse_XLSCell(blob, 6);&#13;
	++blob.l;&#13;
	var num = blob.read_shift(2);&#13;
	cell.t = 'n';&#13;
	cell.val = num;&#13;
	return cell;&#13;
}&#13;
function write_BIFF2INT(r, c, val) {&#13;
	var out = new_buf(9);&#13;
	write_BIFF2Cell(out, r, c);&#13;
	out.write_shift(2, val);&#13;
	return out;&#13;
}&#13;
&#13;
function parse_BIFF2STRING(blob) {&#13;
	var cch = blob.read_shift(1);&#13;
	if(cch === 0) { blob.l++; return ""; }&#13;
	return blob.read_shift(cch, 'sbcs-cont');&#13;
}&#13;
&#13;
/* TODO: convert to BIFF8 font struct */&#13;
function parse_BIFF2FONTXTRA(blob, length) {&#13;
	blob.l += 6; // unknown&#13;
	blob.l += 2; // font weight "bls"&#13;
	blob.l += 1; // charset&#13;
	blob.l += 3; // unknown&#13;
	blob.l += 1; // font family&#13;
	blob.l += length - 13;&#13;
}&#13;
&#13;
/* TODO: parse rich text runs */&#13;
function parse_RString(blob, length, opts) {&#13;
	var end = blob.l + length;&#13;
	var cell = parse_XLSCell(blob, 6);&#13;
	var cch = blob.read_shift(2);&#13;
	var str = parse_XLUnicodeStringNoCch(blob, cch, opts);&#13;
	blob.l = end;&#13;
	cell.t = 'str';&#13;
	cell.val = str;&#13;
	return cell;&#13;
}&#13;
var DBF_SUPPORTED_VERSIONS = [0x02, 0x03, 0x30, 0x31, 0x83, 0x8B, 0x8C, 0xF5];&#13;
var DBF = (function() {&#13;
var dbf_codepage_map = {&#13;
	/* Code Pages Supported by Visual FoxPro */&#13;
0x01:   437,           0x02:   850,&#13;
0x03:  1252,           0x04: 10000,&#13;
0x64:   852,           0x65:   866,&#13;
0x66:   865,           0x67:   861,&#13;
0x68:   895,           0x69:   620,&#13;
0x6A:   737,           0x6B:   857,&#13;
0x78:   950,           0x79:   949,&#13;
0x7A:   936,           0x7B:   932,&#13;
0x7C:   874,           0x7D:  1255,&#13;
0x7E:  1256,           0x96: 10007,&#13;
0x97: 10029,           0x98: 10006,&#13;
0xC8:  1250,           0xC9:  1251,&#13;
0xCA:  1254,           0xCB:  1253,&#13;
&#13;
	/* shapefile DBF extension */&#13;
0x00: 20127,           0x08:   865,&#13;
0x09:   437,           0x0A:   850,&#13;
0x0B:   437,           0x0D:   437,&#13;
0x0E:   850,           0x0F:   437,&#13;
0x10:   850,           0x11:   437,&#13;
0x12:   850,           0x13:   932,&#13;
0x14:   850,           0x15:   437,&#13;
0x16:   850,           0x17:   865,&#13;
0x18:   437,           0x19:   437,&#13;
0x1A:   850,           0x1B:   437,&#13;
0x1C:   863,           0x1D:   850,&#13;
0x1F:   852,           0x22:   852,&#13;
0x23:   852,           0x24:   860,&#13;
0x25:   850,           0x26:   866,&#13;
0x37:   850,           0x40:   852,&#13;
0x4D:   936,           0x4E:   949,&#13;
0x4F:   950,           0x50:   874,&#13;
0x57:  1252,           0x58:  1252,&#13;
0x59:  1252,           0x6C:   863,&#13;
0x86:   737,           0x87:   852,&#13;
0x88:   857,           0xCC:  1257,&#13;
&#13;
0xFF: 16969&#13;
};&#13;
var dbf_reverse_map = evert({&#13;
0x01:   437,           0x02:   850,&#13;
0x03:  1252,           0x04: 10000,&#13;
0x64:   852,           0x65:   866,&#13;
0x66:   865,           0x67:   861,&#13;
0x68:   895,           0x69:   620,&#13;
0x6A:   737,           0x6B:   857,&#13;
0x78:   950,           0x79:   949,&#13;
0x7A:   936,           0x7B:   932,&#13;
0x7C:   874,           0x7D:  1255,&#13;
0x7E:  1256,           0x96: 10007,&#13;
0x97: 10029,           0x98: 10006,&#13;
0xC8:  1250,           0xC9:  1251,&#13;
0xCA:  1254,           0xCB:  1253,&#13;
0x00: 20127&#13;
});&#13;
/* TODO: find an actual specification */&#13;
function dbf_to_aoa(buf, opts) {&#13;
	var out = [];&#13;
	var d = (new_raw_buf(1));&#13;
	switch(opts.type) {&#13;
		case 'base64': d = s2a(Base64_decode(buf)); break;&#13;
		case 'binary': d = s2a(buf); break;&#13;
		case 'buffer':&#13;
		case 'array': d = buf; break;&#13;
	}&#13;
	prep_blob(d, 0);&#13;
&#13;
	/* header */&#13;
	var ft = d.read_shift(1);&#13;
	var memo = !!(ft &amp; 0x88);&#13;
	var vfp = false, l7 = false;&#13;
	switch(ft) {&#13;
		case 0x02: break; // dBASE II&#13;
		case 0x03: break; // dBASE III&#13;
		case 0x30: vfp = true; memo = true; break; // VFP&#13;
		case 0x31: vfp = true; memo = true; break; // VFP with autoincrement&#13;
		// 0x43 dBASE IV SQL table files&#13;
		// 0x63 dBASE IV SQL system files&#13;
		case 0x83: break; // dBASE III with memo&#13;
		case 0x8B: break; // dBASE IV with memo&#13;
		case 0x8C: l7 = true; break; // dBASE Level 7 with memo&#13;
		// case 0xCB dBASE IV SQL table files with memo&#13;
		case 0xF5: break; // FoxPro 2.x with memo&#13;
		// case 0xFB FoxBASE&#13;
		default: throw new Error("DBF Unsupported Version: " + ft.toString(16));&#13;
	}&#13;
&#13;
	var nrow = 0, fpos = 0x0209;&#13;
	if(ft == 0x02) nrow = d.read_shift(2);&#13;
	d.l += 3; // dBASE II stores DDMMYY date, others use YYMMDD&#13;
	if(ft != 0x02) nrow = d.read_shift(4);&#13;
	if(nrow &gt; 1048576) nrow = 1e6;&#13;
&#13;
	if(ft != 0x02) fpos = d.read_shift(2); // header length&#13;
	var rlen = d.read_shift(2); // record length&#13;
&#13;
	var /*flags = 0,*/ current_cp = opts.codepage || 1252;&#13;
	if(ft != 0x02) { // 20 reserved bytes&#13;
		d.l+=16;&#13;
		/*flags = */d.read_shift(1);&#13;
		//if(memo &amp;&amp; ((flags &amp; 0x02) === 0)) throw new Error("DBF Flags " + flags.toString(16) + " ft " + ft.toString(16));&#13;
&#13;
		/* codepage present in FoxPro and dBASE Level 7 */&#13;
		if(d[d.l] !== 0) current_cp = dbf_codepage_map[d[d.l]];&#13;
		d.l+=1;&#13;
&#13;
		d.l+=2;&#13;
	}&#13;
	if(l7) d.l += 36; // Level 7: 32 byte "Language driver name", 4 byte reserved&#13;
&#13;
var fields = [], field = ({});&#13;
	var hend = Math.min(d.length, (ft == 0x02 ? 0x209 : (fpos - 10 - (vfp ? 264 : 0))));&#13;
	var ww = l7 ? 32 : 11;&#13;
	while(d.l &lt; hend &amp;&amp; d[d.l] != 0x0d) {&#13;
		field = ({});&#13;
		field.name = (typeof $cptable !== "undefined" ? $cptable.utils.decode(current_cp, d.slice(d.l, d.l+ww)) : a2s(d.slice(d.l, d.l + ww))).replace(/[\u0000\r\n].*$/g,"");&#13;
		d.l += ww;&#13;
		field.type = String.fromCharCode(d.read_shift(1));&#13;
		if(ft != 0x02 &amp;&amp; !l7) field.offset = d.read_shift(4);&#13;
		field.len = d.read_shift(1);&#13;
		if(ft == 0x02) field.offset = d.read_shift(2);&#13;
		field.dec = d.read_shift(1);&#13;
		if(field.name.length) fields.push(field);&#13;
		if(ft != 0x02) d.l += l7 ? 13 : 14;&#13;
		switch(field.type) {&#13;
			case 'B': // Double (VFP) / Binary (dBASE L7)&#13;
				if((!vfp || field.len != 8) &amp;&amp; opts.WTF) console.log('Skipping ' + field.name + ':' + field.type);&#13;
				break;&#13;
			case 'G': // General (FoxPro and dBASE L7)&#13;
			case 'P': // Picture (FoxPro and dBASE L7)&#13;
				if(opts.WTF) console.log('Skipping ' + field.name + ':' + field.type);&#13;
				break;&#13;
			case '+': // Autoincrement (dBASE L7 only)&#13;
			case '0': // _NullFlags (VFP only)&#13;
			case '@': // Timestamp (dBASE L7 only)&#13;
			case 'C': // Character (dBASE II)&#13;
			case 'D': // Date (dBASE III)&#13;
			case 'F': // Float (dBASE IV)&#13;
			case 'I': // Long (VFP and dBASE L7)&#13;
			case 'L': // Logical (dBASE II)&#13;
			case 'M': // Memo (dBASE III)&#13;
			case 'N': // Number (dBASE II)&#13;
			case 'O': // Double (dBASE L7 only)&#13;
			case 'T': // Datetime (VFP only)&#13;
			case 'Y': // Currency (VFP only)&#13;
				break;&#13;
			default: throw new Error('Unknown Field Type: ' + field.type);&#13;
		}&#13;
	}&#13;
&#13;
	if(d[d.l] !== 0x0D) d.l = fpos-1;&#13;
	if(d.read_shift(1) !== 0x0D) throw new Error("DBF Terminator not found " + d.l + " " + d[d.l]);&#13;
	d.l = fpos;&#13;
&#13;
	/* data */&#13;
	var R = 0, C = 0;&#13;
	out[0] = [];&#13;
	for(C = 0; C != fields.length; ++C) out[0][C] = fields[C].name;&#13;
	while(nrow-- &gt; 0) {&#13;
		if(d[d.l] === 0x2A) {&#13;
			// TODO: record marked as deleted -- create a hidden row?&#13;
			d.l+=rlen;&#13;
			continue;&#13;
		}&#13;
		++d.l;&#13;
		out[++R] = []; C = 0;&#13;
		for(C = 0; C != fields.length; ++C) {&#13;
			var dd = d.slice(d.l, d.l+fields[C].len); d.l+=fields[C].len;&#13;
			prep_blob(dd, 0);&#13;
			var s = typeof $cptable !== "undefined" ? $cptable.utils.decode(current_cp, dd) : a2s(dd);&#13;
			switch(fields[C].type) {&#13;
				case 'C':&#13;
					// NOTE: it is conventional to write '  /  /  ' for empty dates&#13;
					if(s.trim().length) out[R][C] = s.replace(/\s+$/,"");&#13;
					break;&#13;
				case 'D':&#13;
					if(s.length === 8) out[R][C] = new Date(+s.slice(0,4), +s.slice(4,6)-1, +s.slice(6,8));&#13;
					else out[R][C] = s;&#13;
					break;&#13;
				case 'F': out[R][C] = parseFloat(s.trim()); break;&#13;
				case '+': case 'I': out[R][C] = l7 ? dd.read_shift(-4, 'i') ^ 0x80000000 : dd.read_shift(4, 'i'); break;&#13;
				case 'L': switch(s.trim().toUpperCase()) {&#13;
					case 'Y': case 'T': out[R][C] = true; break;&#13;
					case 'N': case 'F': out[R][C] = false; break;&#13;
					case '': case '?': break;&#13;
					default: throw new Error("DBF Unrecognized L:|" + s + "|");&#13;
					} break;&#13;
				case 'M': /* TODO: handle memo files */&#13;
					if(!memo) throw new Error("DBF Unexpected MEMO for type " + ft.toString(16));&#13;
					out[R][C] = "##MEMO##" + (l7 ? parseInt(s.trim(), 10): dd.read_shift(4));&#13;
					break;&#13;
				case 'N':&#13;
					s = s.replace(/\u0000/g,"").trim();&#13;
					// NOTE: dBASE II interprets "  .  " as 0&#13;
					if(s &amp;&amp; s != ".") out[R][C] = +s || 0; break;&#13;
				case '@':&#13;
					// NOTE: dBASE specs appear to be incorrect&#13;
					out[R][C] = new Date(dd.read_shift(-8, 'f') - 0x388317533400);&#13;
					break;&#13;
				case 'T': out[R][C] = new Date((dd.read_shift(4) - 0x253D8C) * 0x5265C00 + dd.read_shift(4)); break;&#13;
				case 'Y': out[R][C] = dd.read_shift(4,'i')/1e4 + (dd.read_shift(4, 'i')/1e4)*Math.pow(2,32); break;&#13;
				case 'O': out[R][C] = -dd.read_shift(-8, 'f'); break;&#13;
				case 'B': if(vfp &amp;&amp; fields[C].len == 8) { out[R][C] = dd.read_shift(8,'f'); break; }&#13;
					/* falls through */&#13;
				case 'G': case 'P': dd.l += fields[C].len; break;&#13;
				case '0':&#13;
					if(fields[C].name === '_NullFlags') break;&#13;
					/* falls through */&#13;
				default: throw new Error("DBF Unsupported data type " + fields[C].type);&#13;
			}&#13;
		}&#13;
	}&#13;
	if(ft != 0x02) if(d.l &lt; d.length &amp;&amp; d[d.l++] != 0x1A) throw new Error("DBF EOF Marker missing " + (d.l-1) + " of " + d.length + " " + d[d.l-1].toString(16));&#13;
	if(opts &amp;&amp; opts.sheetRows) out = out.slice(0, opts.sheetRows);&#13;
	opts.DBF = fields;&#13;
	return out;&#13;
}&#13;
&#13;
function dbf_to_sheet(buf, opts) {&#13;
	var o = opts || {};&#13;
	if(!o.dateNF) o.dateNF = "yyyymmdd";&#13;
	var ws = aoa_to_sheet(dbf_to_aoa(buf, o), o);&#13;
	ws["!cols"] = o.DBF.map(function(field) { return {&#13;
		wch: field.len,&#13;
		DBF: field&#13;
	};});&#13;
	delete o.DBF;&#13;
	return ws;&#13;
}&#13;
&#13;
function dbf_to_workbook(buf, opts) {&#13;
	try {&#13;
		var o = sheet_to_workbook(dbf_to_sheet(buf, opts), opts);&#13;
		o.bookType = "dbf";&#13;
		return o;&#13;
	} catch(e) { if(opts &amp;&amp; opts.WTF) throw e; }&#13;
	return ({SheetNames:[],Sheets:{}});&#13;
}&#13;
&#13;
var _RLEN = { 'B': 8, 'C': 250, 'L': 1, 'D': 8, '?': 0, '': 0 };&#13;
function sheet_to_dbf(ws, opts) {&#13;
	var o = opts || {};&#13;
	var old_cp = current_codepage;&#13;
	if(+o.codepage &gt;= 0) set_cp(+o.codepage);&#13;
	if(o.type == "string") throw new Error("Cannot write DBF to JS string");&#13;
	var ba = buf_array();&#13;
	var aoa = sheet_to_json(ws, {header:1, raw:true, cellDates:true});&#13;
	var headers = aoa[0], data = aoa.slice(1), cols = ws["!cols"] || [];&#13;
	var i = 0, j = 0, hcnt = 0, rlen = 1;&#13;
	for(i = 0; i &lt; headers.length; ++i) {&#13;
		if(((cols[i]||{}).DBF||{}).name) { headers[i] = cols[i].DBF.name; ++hcnt; continue; }&#13;
		if(headers[i] == null) continue;&#13;
		++hcnt;&#13;
		if(typeof headers[i] === 'number') headers[i] = headers[i].toString(10);&#13;
		if(typeof headers[i] !== 'string') throw new Error("DBF Invalid column name " + headers[i] + " |" + (typeof headers[i]) + "|");&#13;
		if(headers.indexOf(headers[i]) !== i) for(j=0; j&lt;1024;++j)&#13;
			if(headers.indexOf(headers[i] + "_" + j) == -1) { headers[i] += "_" + j; break; }&#13;
	}&#13;
	var range = safe_decode_range(ws['!ref']);&#13;
	var coltypes = [];&#13;
	var colwidths = [];&#13;
	var coldecimals = [];&#13;
	for(i = 0; i &lt;= range.e.c - range.s.c; ++i) {&#13;
		var guess = '', _guess = '', maxlen = 0;&#13;
		var col = [];&#13;
		for(j=0; j &lt; data.length; ++j) {&#13;
			if(data[j][i] != null) col.push(data[j][i]);&#13;
		}&#13;
		if(col.length == 0 || headers[i] == null) { coltypes[i] = '?'; continue; }&#13;
		for(j = 0; j &lt; col.length; ++j) {&#13;
			switch(typeof col[j]) {&#13;
				/* TODO: check if L2 compat is desired */&#13;
				case 'number': _guess = 'B'; break;&#13;
				case 'string': _guess = 'C'; break;&#13;
				case 'boolean': _guess = 'L'; break;&#13;
				case 'object': _guess = col[j] instanceof Date ? 'D' : 'C'; break;&#13;
				default: _guess = 'C';&#13;
			}&#13;
			/* TODO: cache the values instead of encoding twice */&#13;
			maxlen = Math.max(maxlen, (typeof $cptable !== "undefined" &amp;&amp; typeof col[j] == "string" ? $cptable.utils.encode(current_ansi, col[j]): String(col[j])).length);&#13;
			guess = guess &amp;&amp; guess != _guess ? 'C' : _guess;&#13;
			//if(guess == 'C') break;&#13;
		}&#13;
		if(maxlen &gt; 250) maxlen = 250;&#13;
		_guess = ((cols[i]||{}).DBF||{}).type;&#13;
		/* TODO: more fine grained control over DBF type resolution */&#13;
		if(_guess == 'C') {&#13;
			if(cols[i].DBF.len &gt; maxlen) maxlen = cols[i].DBF.len;&#13;
		}&#13;
		if(guess == 'B' &amp;&amp; _guess == 'N') {&#13;
			guess = 'N';&#13;
			coldecimals[i] = cols[i].DBF.dec;&#13;
			maxlen = cols[i].DBF.len;&#13;
		}&#13;
		colwidths[i] = guess == 'C' || _guess == 'N' ? maxlen : (_RLEN[guess] || 0);&#13;
		rlen += colwidths[i];&#13;
		coltypes[i] = guess;&#13;
	}&#13;
&#13;
	var h = ba.next(32);&#13;
	h.write_shift(4, 0x13021130);&#13;
	h.write_shift(4, data.length);&#13;
	h.write_shift(2, 296 + 32 * hcnt);&#13;
	h.write_shift(2, rlen);&#13;
	for(i=0; i &lt; 4; ++i) h.write_shift(4, 0);&#13;
	var cp = +dbf_reverse_map[current_codepage] || 0x03;&#13;
	h.write_shift(4, 0x00000000 | (cp&lt;&lt;8));&#13;
	if(dbf_codepage_map[cp] != +o.codepage) {&#13;
		if(o.codepage) console.error("DBF Unsupported codepage " + current_codepage + ", using 1252");&#13;
		current_codepage = 1252;&#13;
	}&#13;
&#13;
	for(i = 0, j = 0; i &lt; headers.length; ++i) {&#13;
		if(headers[i] == null) continue;&#13;
		var hf = ba.next(32);&#13;
		/* TODO: test how applications handle non-ASCII field names */&#13;
		var _f = (headers[i].slice(-10) + "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00").slice(0, 11);&#13;
		hf.write_shift(1, _f, "sbcs");&#13;
		hf.write_shift(1, coltypes[i] == '?' ? 'C' : coltypes[i], "sbcs");&#13;
		hf.write_shift(4, j);&#13;
		hf.write_shift(1, colwidths[i] || _RLEN[coltypes[i]] || 0);&#13;
		hf.write_shift(1, coldecimals[i] || 0);&#13;
		hf.write_shift(1, 0x02);&#13;
		hf.write_shift(4, 0);&#13;
		hf.write_shift(1, 0);&#13;
		hf.write_shift(4, 0);&#13;
		hf.write_shift(4, 0);&#13;
		j += (colwidths[i] || _RLEN[coltypes[i]] || 0);&#13;
	}&#13;
&#13;
	var hb = ba.next(264);&#13;
	hb.write_shift(4, 0x0000000D);&#13;
	for(i=0; i &lt; 65;++i) hb.write_shift(4, 0x00000000);&#13;
	for(i=0; i &lt; data.length; ++i) {&#13;
		var rout = ba.next(rlen);&#13;
		rout.write_shift(1, 0);&#13;
		for(j=0; j&lt;headers.length; ++j) {&#13;
			if(headers[j] == null) continue;&#13;
			switch(coltypes[j]) {&#13;
				case 'L': rout.write_shift(1, data[i][j] == null ? 0x3F : data[i][j] ? 0x54 : 0x46); break;&#13;
				case 'B': rout.write_shift(8, data[i][j]||0, 'f'); break;&#13;
				case 'N':&#13;
					var _n = "0";&#13;
					if(typeof data[i][j] == "number") _n = data[i][j].toFixed(coldecimals[j]||0);&#13;
					for(hcnt=0; hcnt &lt; colwidths[j]-_n.length; ++hcnt) rout.write_shift(1, 0x20);&#13;
					rout.write_shift(1, _n, "sbcs");&#13;
					break;&#13;
				case 'D':&#13;
					if(!data[i][j]) rout.write_shift(8, "00000000", "sbcs");&#13;
					else {&#13;
						rout.write_shift(4, ("0000"+data[i][j].getFullYear()).slice(-4), "sbcs");&#13;
						rout.write_shift(2, ("00"+(data[i][j].getMonth()+1)).slice(-2), "sbcs");&#13;
						rout.write_shift(2, ("00"+data[i][j].getDate()).slice(-2), "sbcs");&#13;
					} break;&#13;
				case 'C':&#13;
					var _l = rout.l;&#13;
					var _s = String(data[i][j] != null ? data[i][j] : "").slice(0, colwidths[j]);&#13;
					rout.write_shift(1, _s, "cpstr");&#13;
					_l += colwidths[j] - rout.l;&#13;
					for(hcnt=0; hcnt &lt; _l; ++hcnt) rout.write_shift(1, 0x20); break;&#13;
			}&#13;
		}&#13;
		// data&#13;
	}&#13;
	current_codepage = old_cp;&#13;
	ba.next(1).write_shift(1, 0x1A);&#13;
	return ba.end();&#13;
}&#13;
	return {&#13;
		to_workbook: dbf_to_workbook,&#13;
		to_sheet: dbf_to_sheet,&#13;
		from_sheet: sheet_to_dbf&#13;
	};&#13;
})();&#13;
&#13;
var SYLK = (function() {&#13;
	/* TODO: stress test sequences */&#13;
	var sylk_escapes = ({&#13;
		AA:'À', BA:'Á', CA:'Â', DA:195, HA:'Ä', JA:197,&#13;
		AE:'È', BE:'É', CE:'Ê',         HE:'Ë',&#13;
		AI:'Ì', BI:'Í', CI:'Î',         HI:'Ï',&#13;
		AO:'Ò', BO:'Ó', CO:'Ô', DO:213, HO:'Ö',&#13;
		AU:'Ù', BU:'Ú', CU:'Û',         HU:'Ü',&#13;
		Aa:'à', Ba:'á', Ca:'â', Da:227, Ha:'ä', Ja:229,&#13;
		Ae:'è', Be:'é', Ce:'ê',         He:'ë',&#13;
		Ai:'ì', Bi:'í', Ci:'î',         Hi:'ï',&#13;
		Ao:'ò', Bo:'ó', Co:'ô', Do:245, Ho:'ö',&#13;
		Au:'ù', Bu:'ú', Cu:'û',         Hu:'ü',&#13;
		KC:'Ç', Kc:'ç', q:'æ',  z:'œ',  a:'Æ',  j:'Œ',&#13;
		DN:209, Dn:241, Hy:255,&#13;
		S:169,  c:170,  R:174,  "B ":180,&#13;
0:176,    1:177,  2:178,&#13;
3:179,    5:181,  6:182,&#13;
7:183,    Q:185,  k:186,  b:208,  i:216,  l:222,  s:240,  y:248,&#13;
		"!":161, '"':162, "#":163, "(":164, "%":165, "'":167, "H ":168,&#13;
		"+":171, ";":187, "&lt;":188, "=":189, "&gt;":190, "?":191, "{":223&#13;
	});&#13;
	var sylk_char_regex = new RegExp("\u001BN(" + keys(sylk_escapes).join("|").replace(/\|\|\|/, "|\\||").replace(/([?()+])/g,"\\$1") + "|\\|)", "gm");&#13;
	var sylk_char_fn = function(_, $1){ var o = sylk_escapes[$1]; return typeof o == "number" ? _getansi(o) : o; };&#13;
	var decode_sylk_char = function($$, $1, $2) { var newcc = (($1.charCodeAt(0) - 0x20)&lt;&lt;4) | ($2.charCodeAt(0) - 0x30); return newcc == 59 ? $$ : _getansi(newcc); };&#13;
	sylk_escapes["|"] = 254;&#13;
	/* https://oss.sheetjs.com/notes/sylk/ for more details */&#13;
	function sylk_to_aoa(d, opts) {&#13;
		switch(opts.type) {&#13;
			case 'base64': return sylk_to_aoa_str(Base64_decode(d), opts);&#13;
			case 'binary': return sylk_to_aoa_str(d, opts);&#13;
			case 'buffer': return sylk_to_aoa_str(has_buf &amp;&amp; Buffer.isBuffer(d) ? d.toString('binary') : a2s(d), opts);&#13;
			case 'array': return sylk_to_aoa_str(cc2str(d), opts);&#13;
		}&#13;
		throw new Error("Unrecognized type " + opts.type);&#13;
	}&#13;
	function sylk_to_aoa_str(str, opts) {&#13;
		var records = str.split(/[\n\r]+/), R = -1, C = -1, ri = 0, rj = 0, arr = [];&#13;
		var formats = [];&#13;
		var next_cell_format = null;&#13;
		var sht = {}, rowinfo = [], colinfo = [], cw = [];&#13;
		var Mval = 0, j;&#13;
		var wb = { Workbook: { WBProps: {}, Names: [] } };&#13;
		if(+opts.codepage &gt;= 0) set_cp(+opts.codepage);&#13;
		for (; ri !== records.length; ++ri) {&#13;
			Mval = 0;&#13;
			var rstr=records[ri].trim().replace(/\x1B([\x20-\x2F])([\x30-\x3F])/g, decode_sylk_char).replace(sylk_char_regex, sylk_char_fn);&#13;
			var record=rstr.replace(/;;/g, "\u0000").split(";").map(function(x) { return x.replace(/\u0000/g, ";"); });&#13;
			var RT=record[0], val;&#13;
			if(rstr.length &gt; 0) switch(RT) {&#13;
			case 'ID': break; /* header */&#13;
			case 'E': break; /* EOF */&#13;
			case 'B': break; /* dimensions */&#13;
			case 'O': /* workbook options */&#13;
			for(rj=1; rj&lt;record.length; ++rj) switch(record[rj].charAt(0)) {&#13;
				case 'V': {&#13;
					var d1904 = parseInt(record[rj].slice(1), 10);&#13;
					// NOTE: it is technically an error if d1904 &gt;= 5 or &lt; 0&#13;
					if(d1904 &gt;= 1 &amp;&amp; d1904 &lt;= 4) wb.Workbook.WBProps.date1904 = true;&#13;
				} break;&#13;
			} break;&#13;
			case 'W': break; /* window */&#13;
			case 'P':&#13;
				switch(record[1].charAt(0)){&#13;
					case 'P': formats.push(rstr.slice(3).replace(/;;/g, ";")); break;&#13;
				} break;&#13;
			case 'NN': { /* defined name */&#13;
				var nn = {Sheet: 0};&#13;
				for(rj=1; rj&lt;record.length; ++rj) switch(record[rj].charAt(0)) {&#13;
					case 'N': nn.Name = record[rj].slice(1); break;&#13;
					case 'E': nn.Ref = (opts &amp;&amp; opts.sheet || "Sheet1") + "!" + rc_to_a1(record[rj].slice(1)); break;&#13;
				}&#13;
				wb.Workbook.Names.push(nn);&#13;
			} break;&#13;
			// case 'NE': // ??&#13;
			// case 'NU': // ??&#13;
			case 'C': /* cell */&#13;
			var C_seen_K = false, C_seen_X = false, C_seen_S = false, C_seen_E = false, _R = -1, _C = -1, formula = "", cell_t = "z";&#13;
			for(rj=1; rj&lt;record.length; ++rj) switch(record[rj].charAt(0)) {&#13;
				case 'A': break; // TODO: comment&#13;
				case 'X': C = parseInt(record[rj].slice(1), 10)-1; C_seen_X = true; break;&#13;
				case 'Y':&#13;
					R = parseInt(record[rj].slice(1), 10)-1; if(!C_seen_X) C = 0;&#13;
					for(j = arr.length; j &lt;= R; ++j) arr[j] = [];&#13;
					break;&#13;
				case 'K':&#13;
					val = record[rj].slice(1);&#13;
					if(val.charAt(0) === '"') { val = val.slice(1,val.length - 1); cell_t = "s"; }&#13;
					else if(val === 'TRUE' || val === 'FALSE') { val = val === 'TRUE'; cell_t = "b"; }&#13;
					else if(!isNaN(fuzzynum(val))) {&#13;
						val = fuzzynum(val); cell_t = "n";&#13;
						if(next_cell_format !== null &amp;&amp; fmt_is_date(next_cell_format) &amp;&amp; opts.cellDates) { val = numdate(wb.Workbook.WBProps.date1904 ? val + 1462 : val); cell_t = "d"; }&#13;
					} else if(!isNaN(fuzzydate(val).getDate())) {&#13;
						val = parseDate(val); cell_t = "d";&#13;
						if(!opts.cellDates) { cell_t = "n"; val = datenum(val, wb.Workbook.WBProps.date1904); }&#13;
					}&#13;
					if(typeof $cptable !== 'undefined' &amp;&amp; typeof val == "string" &amp;&amp; ((opts||{}).type != "string") &amp;&amp; (opts||{}).codepage) val = $cptable.utils.decode(opts.codepage, val);&#13;
					C_seen_K = true;&#13;
					break;&#13;
				case 'E':&#13;
					C_seen_E = true;&#13;
					formula = rc_to_a1(record[rj].slice(1), {r:R,c:C});&#13;
					break;&#13;
				case 'S':&#13;
					C_seen_S = true;&#13;
					break;&#13;
				case 'G': break; // unknown&#13;
				case 'R': _R = parseInt(record[rj].slice(1), 10)-1; break;&#13;
				case 'C': _C = parseInt(record[rj].slice(1), 10)-1; break;&#13;
				// case 'P': // ??&#13;
				// case 'D': // ??&#13;
				default: if(opts &amp;&amp; opts.WTF) throw new Error("SYLK bad record " + rstr);&#13;
			}&#13;
			if(C_seen_K) {&#13;
				if(!arr[R][C]) arr[R][C] = { t: cell_t, v: val };&#13;
				else { arr[R][C].t = cell_t; arr[R][C].v = val; }&#13;
				if(next_cell_format) arr[R][C].z = next_cell_format;&#13;
				if(opts.cellText !== false &amp;&amp; next_cell_format) arr[R][C].w = SSF_format(arr[R][C].z, arr[R][C].v, { date1904: wb.Workbook.WBProps.date1904 });&#13;
				next_cell_format = null;&#13;
			}&#13;
			if(C_seen_S) {&#13;
				if(C_seen_E) throw new Error("SYLK shared formula cannot have own formula");&#13;
				var shrbase = _R &gt; -1 &amp;&amp; arr[_R][_C];&#13;
				if(!shrbase || !shrbase[1]) throw new Error("SYLK shared formula cannot find base");&#13;
				formula = shift_formula_str(shrbase[1], {r: R - _R, c: C - _C});&#13;
			}&#13;
			if(formula) {&#13;
				if(!arr[R][C]) arr[R][C] = { t: 'n', f: formula };&#13;
				else arr[R][C].f = formula;&#13;
			}&#13;
			break;&#13;
			case 'F': /* Format */&#13;
			var F_seen = 0;&#13;
			for(rj=1; rj&lt;record.length; ++rj) switch(record[rj].charAt(0)) {&#13;
				case 'X': C = parseInt(record[rj].slice(1), 10)-1; ++F_seen; break;&#13;
				case 'Y':&#13;
					R = parseInt(record[rj].slice(1), 10)-1; /*C = 0;*/&#13;
					for(j = arr.length; j &lt;= R; ++j) arr[j] = [];&#13;
					break;&#13;
				case 'M': Mval = parseInt(record[rj].slice(1), 10) / 20; break;&#13;
				case 'F': break; /* ??? */&#13;
				case 'G': break; /* hide grid */&#13;
				case 'P':&#13;
					next_cell_format = formats[parseInt(record[rj].slice(1), 10)];&#13;
					break;&#13;
				case 'S': break; /* cell style */&#13;
				case 'D': break; /* column */&#13;
				case 'N': break; /* font */&#13;
				case 'W':&#13;
					cw = record[rj].slice(1).split(" ");&#13;
					for(j = parseInt(cw[0], 10); j &lt;= parseInt(cw[1], 10); ++j) {&#13;
						Mval = parseInt(cw[2], 10);&#13;
						colinfo[j-1] = Mval === 0 ? {hidden:true}: {wch:Mval};&#13;
					} break;&#13;
				case 'C': /* default column format */&#13;
					C = parseInt(record[rj].slice(1), 10)-1;&#13;
					if(!colinfo[C]) colinfo[C] = {};&#13;
					break;&#13;
				case 'R': /* row properties */&#13;
					R = parseInt(record[rj].slice(1), 10)-1;&#13;
					if(!rowinfo[R]) rowinfo[R] = {};&#13;
					if(Mval &gt; 0) { rowinfo[R].hpt = Mval; rowinfo[R].hpx = pt2px(Mval); }&#13;
					else if(Mval === 0) rowinfo[R].hidden = true;&#13;
					break;&#13;
				// case 'K': // ??&#13;
				// case 'E': // ??&#13;
				default: if(opts &amp;&amp; opts.WTF) throw new Error("SYLK bad record " + rstr);&#13;
			}&#13;
			if(F_seen &lt; 1) next_cell_format = null; break;&#13;
			default: if(opts &amp;&amp; opts.WTF) throw new Error("SYLK bad record " + rstr);&#13;
			}&#13;
		}&#13;
		if(rowinfo.length &gt; 0) sht['!rows'] = rowinfo;&#13;
		if(colinfo.length &gt; 0) sht['!cols'] = colinfo;&#13;
		colinfo.forEach(function(col) { process_col(col); });&#13;
		if(opts &amp;&amp; opts.sheetRows) arr = arr.slice(0, opts.sheetRows);&#13;
		return [arr, sht, wb];&#13;
	}&#13;
&#13;
	function sylk_to_workbook(d, opts) {&#13;
		var aoasht = sylk_to_aoa(d, opts);&#13;
		var aoa = aoasht[0], ws = aoasht[1], wb = aoasht[2];&#13;
		var _opts = dup(opts); _opts.date1904 = (((wb||{}).Workbook || {}).WBProps || {}).date1904;&#13;
		var o = aoa_to_sheet(aoa, _opts);&#13;
		keys(ws).forEach(function(k) { o[k] = ws[k]; });&#13;
		var outwb = sheet_to_workbook(o, opts);&#13;
		keys(wb).forEach(function(k) { outwb[k] = wb[k]; });&#13;
		outwb.bookType = "sylk";&#13;
		return outwb;&#13;
	}&#13;
&#13;
	function write_ws_cell_sylk(cell, ws, R, C) {&#13;
		var o = "C;Y" + (R+1) + ";X" + (C+1) + ";K";&#13;
		switch(cell.t) {&#13;
			case 'n':&#13;
				o += (cell.v||0);&#13;
				if(cell.f &amp;&amp; !cell.F) o += ";E" + a1_to_rc(cell.f, {r:R, c:C}); break;&#13;
			case 'b': o += cell.v ? "TRUE" : "FALSE"; break;&#13;
			case 'e': o += cell.w || cell.v; break;&#13;
			case 'd': o += '"' + (cell.w || cell.v) + '"'; break;&#13;
			case 's': o += '"' + (cell.v == null ? "" : String(cell.v)).replace(/"/g,"").replace(/;/g, ";;") + '"'; break;&#13;
		}&#13;
		return o;&#13;
	}&#13;
&#13;
	function write_ws_cols_sylk(out, cols) {&#13;
		cols.forEach(function(col, i) {&#13;
			var rec = "F;W" + (i+1) + " " + (i+1) + " ";&#13;
			if(col.hidden) rec += "0";&#13;
			else {&#13;
				if(typeof col.width == 'number' &amp;&amp; !col.wpx) col.wpx = width2px(col.width);&#13;
				if(typeof col.wpx == 'number' &amp;&amp; !col.wch) col.wch = px2char(col.wpx);&#13;
				if(typeof col.wch == 'number') rec += Math.round(col.wch);&#13;
			}&#13;
			if(rec.charAt(rec.length - 1) != " ") out.push(rec);&#13;
		});&#13;
	}&#13;
&#13;
	function write_ws_rows_sylk(out, rows) {&#13;
		rows.forEach(function(row, i) {&#13;
			var rec = "F;";&#13;
			if(row.hidden) rec += "M0;";&#13;
			else if(row.hpt) rec += "M" + 20 * row.hpt + ";";&#13;
			else if(row.hpx) rec += "M" + 20 * px2pt(row.hpx) + ";";&#13;
			if(rec.length &gt; 2) out.push(rec + "R" + (i+1));&#13;
		});&#13;
	}&#13;
&#13;
	function sheet_to_sylk(ws, opts, wb) {&#13;
		/* TODO: codepage */&#13;
		var preamble = ["ID;Pxlsx;N;E"], o = [];&#13;
		var r = safe_decode_range(ws['!ref']), cell;&#13;
		var dense = Array.isArray(ws);&#13;
		var RS = "\r\n";&#13;
		var d1904 = (((wb||{}).Workbook||{}).WBProps||{}).date1904;&#13;
&#13;
		preamble.push("P;PGeneral");&#13;
		preamble.push("F;P0;DG0G8;M255");&#13;
		if(ws['!cols']) write_ws_cols_sylk(preamble, ws['!cols']);&#13;
		if(ws['!rows']) write_ws_rows_sylk(preamble, ws['!rows']);&#13;
&#13;
		preamble.push("B;Y" + (r.e.r - r.s.r + 1) + ";X" + (r.e.c - r.s.c + 1) + ";D" + [r.s.c,r.s.r,r.e.c,r.e.r].join(" "));&#13;
		preamble.push("O;L;D;B" + (d1904 ? ";V4" : "") + ";K47;G100 0.001");&#13;
		for(var R = r.s.r; R &lt;= r.e.r; ++R) {&#13;
			var p = [];&#13;
			for(var C = r.s.c; C &lt;= r.e.c; ++C) {&#13;
				var coord = encode_cell({r:R,c:C});&#13;
				cell = dense ? (ws[R]||[])[C]: ws[coord];&#13;
				if(!cell || (cell.v == null &amp;&amp; (!cell.f || cell.F))) continue;&#13;
				p.push(write_ws_cell_sylk(cell, ws, R, C, opts)); // TODO: pass date1904 info&#13;
			}&#13;
			o.push(p.join(RS));&#13;
		}&#13;
		return preamble.join(RS) + RS + o.join(RS) + RS + "E" + RS;&#13;
	}&#13;
&#13;
	return {&#13;
		to_workbook: sylk_to_workbook,&#13;
		from_sheet: sheet_to_sylk&#13;
	};&#13;
})();&#13;
&#13;
var DIF = (function() {&#13;
	function dif_to_aoa(d, opts) {&#13;
		switch(opts.type) {&#13;
			case 'base64': return dif_to_aoa_str(Base64_decode(d), opts);&#13;
			case 'binary': return dif_to_aoa_str(d, opts);&#13;
			case 'buffer': return dif_to_aoa_str(has_buf &amp;&amp; Buffer.isBuffer(d) ? d.toString('binary') : a2s(d), opts);&#13;
			case 'array': return dif_to_aoa_str(cc2str(d), opts);&#13;
		}&#13;
		throw new Error("Unrecognized type " + opts.type);&#13;
	}&#13;
	function dif_to_aoa_str(str, opts) {&#13;
		var records = str.split('\n'), R = -1, C = -1, ri = 0, arr = [];&#13;
		for (; ri !== records.length; ++ri) {&#13;
			if (records[ri].trim() === 'BOT') { arr[++R] = []; C = 0; continue; }&#13;
			if (R &lt; 0) continue;&#13;
			var metadata = records[ri].trim().split(",");&#13;
			var type = metadata[0], value = metadata[1];&#13;
			++ri;&#13;
			var data = records[ri] || "";&#13;
			while(((data.match(/["]/g)||[]).length &amp; 1) &amp;&amp; ri &lt; records.length - 1) data += "\n" + records[++ri];&#13;
			data = data.trim();&#13;
			switch (+type) {&#13;
				case -1:&#13;
					if (data === 'BOT') { arr[++R] = []; C = 0; continue; }&#13;
					else if (data !== 'EOD') throw new Error("Unrecognized DIF special command " + data);&#13;
					break;&#13;
				case 0:&#13;
					if(data === 'TRUE') arr[R][C] = true;&#13;
					else if(data === 'FALSE') arr[R][C] = false;&#13;
					else if(!isNaN(fuzzynum(value))) arr[R][C] = fuzzynum(value);&#13;
					else if(!isNaN(fuzzydate(value).getDate())) arr[R][C] = parseDate(value);&#13;
					else arr[R][C] = value;&#13;
					++C; break;&#13;
				case 1:&#13;
					data = data.slice(1,data.length-1);&#13;
					data = data.replace(/""/g, '"');&#13;
					if(DIF_XL &amp;&amp; data &amp;&amp; data.match(/^=".*"$/)) data = data.slice(2, -1);&#13;
					arr[R][C++] = data !== '' ? data : null;&#13;
					break;&#13;
			}&#13;
			if (data === 'EOD') break;&#13;
		}&#13;
		if(opts &amp;&amp; opts.sheetRows) arr = arr.slice(0, opts.sheetRows);&#13;
		return arr;&#13;
	}&#13;
&#13;
	function dif_to_sheet(str, opts) { return aoa_to_sheet(dif_to_aoa(str, opts), opts); }&#13;
	function dif_to_workbook(str, opts) {&#13;
		var o = sheet_to_workbook(dif_to_sheet(str, opts), opts);&#13;
		o.bookType = "dif";&#13;
		return o;&#13;
	}&#13;
&#13;
	function make_value(v, s) { return "0," + String(v) + "\r\n" + s; }&#13;
	function make_value_str(s) { return "1,0\r\n\"" + s.replace(/"/g,'""') + '"'; }&#13;
	function sheet_to_dif(ws) {&#13;
		var _DIF_XL = DIF_XL;&#13;
		var r = safe_decode_range(ws['!ref']);&#13;
		var dense = Array.isArray(ws);&#13;
		var o = [&#13;
			"TABLE\r\n0,1\r\n\"sheetjs\"\r\n",&#13;
			"VECTORS\r\n0," + (r.e.r - r.s.r + 1) + "\r\n\"\"\r\n",&#13;
			"TUPLES\r\n0," + (r.e.c - r.s.c + 1) + "\r\n\"\"\r\n",&#13;
			"DATA\r\n0,0\r\n\"\"\r\n"&#13;
		];&#13;
		for(var R = r.s.r; R &lt;= r.e.r; ++R) {&#13;
			var p = "-1,0\r\nBOT\r\n";&#13;
			for(var C = r.s.c; C &lt;= r.e.c; ++C) {&#13;
				var cell = dense ? (ws[R] &amp;&amp; ws[R][C]) : ws[encode_cell({r:R,c:C})];&#13;
				if(cell == null) { p +=("1,0\r\n\"\"\r\n"); continue;}&#13;
				switch(cell.t) {&#13;
					case 'n':&#13;
						if(_DIF_XL) {&#13;
							if(cell.w != null) p +=("0," + cell.w + "\r\nV");&#13;
							else if(cell.v != null) p +=(make_value(cell.v, "V")); // TODO: should this call SSF_format?&#13;
							else if(cell.f != null &amp;&amp; !cell.F) p +=(make_value_str("=" + cell.f));&#13;
							else p +=("1,0\r\n\"\"");&#13;
						} else {&#13;
							if(cell.v == null) p +=("1,0\r\n\"\"");&#13;
							else p +=(make_value(cell.v, "V"));&#13;
						}&#13;
						break;&#13;
					case 'b':&#13;
						p +=(cell.v ? make_value(1, "TRUE") : make_value(0, "FALSE"));&#13;
						break;&#13;
					case 's':&#13;
						p +=(make_value_str((!_DIF_XL || isNaN(+cell.v)) ? cell.v : '="' + cell.v + '"'));&#13;
						break;&#13;
					case 'd':&#13;
						if(!cell.w) cell.w = SSF_format(cell.z || table_fmt[14], datenum(parseDate(cell.v)));&#13;
						if(_DIF_XL) p +=(make_value(cell.w, "V"));&#13;
						else p +=(make_value_str(cell.w));&#13;
						break;&#13;
					default: p +=("1,0\r\n\"\"");&#13;
				}&#13;
				p += "\r\n";&#13;
			}&#13;
			o.push(p);&#13;
		}&#13;
		return o.join("") + "-1,0\r\nEOD";&#13;
	}&#13;
	return {&#13;
		to_workbook: dif_to_workbook,&#13;
		to_sheet: dif_to_sheet,&#13;
		from_sheet: sheet_to_dif&#13;
	};&#13;
})();&#13;
&#13;
var ETH = (function() {&#13;
	function decode(s) { return s.replace(/\\b/g,"\\").replace(/\\c/g,":").replace(/\\n/g,"\n"); }&#13;
	function encode(s) { return s.replace(/\\/g, "\\b").replace(/:/g, "\\c").replace(/\n/g,"\\n"); }&#13;
&#13;
	function eth_to_aoa(str, opts) {&#13;
		var records = str.split('\n'), R = -1, C = -1, ri = 0, arr = [];&#13;
		for (; ri !== records.length; ++ri) {&#13;
			var record = records[ri].trim().split(":");&#13;
			if(record[0] !== 'cell') continue;&#13;
			var addr = decode_cell(record[1]);&#13;
			if(arr.length &lt;= addr.r) for(R = arr.length; R &lt;= addr.r; ++R) if(!arr[R]) arr[R] = [];&#13;
			R = addr.r; C = addr.c;&#13;
			switch(record[2]) {&#13;
				case 't': arr[R][C] = decode(record[3]); break;&#13;
				case 'v': arr[R][C] = +record[3]; break;&#13;
				case 'vtf': var _f = record[record.length - 1];&#13;
					/* falls through */&#13;
				case 'vtc':&#13;
					switch(record[3]) {&#13;
						case 'nl': arr[R][C] = +record[4] ? true : false; break;&#13;
						default: arr[R][C] = +record[4]; break;&#13;
					}&#13;
					if(record[2] == 'vtf') arr[R][C] = [arr[R][C], _f];&#13;
			}&#13;
		}&#13;
		if(opts &amp;&amp; opts.sheetRows) arr = arr.slice(0, opts.sheetRows);&#13;
		return arr;&#13;
	}&#13;
&#13;
	function eth_to_sheet(d, opts) { return aoa_to_sheet(eth_to_aoa(d, opts), opts); }&#13;
	function eth_to_workbook(d, opts) { return sheet_to_workbook(eth_to_sheet(d, opts), opts); }&#13;
&#13;
	var header = [&#13;
		"socialcalc:version:1.5",&#13;
		"MIME-Version: 1.0",&#13;
		"Content-Type: multipart/mixed; boundary=SocialCalcSpreadsheetControlSave"&#13;
	].join("\n");&#13;
&#13;
	var sep = [&#13;
		"--SocialCalcSpreadsheetControlSave",&#13;
		"Content-type: text/plain; charset=UTF-8"&#13;
	].join("\n") + "\n";&#13;
&#13;
	/* TODO: the other parts */&#13;
	var meta = [&#13;
		"# SocialCalc Spreadsheet Control Save",&#13;
		"part:sheet"&#13;
	].join("\n");&#13;
&#13;
	var end = "--SocialCalcSpreadsheetControlSave--";&#13;
&#13;
	function sheet_to_eth_data(ws) {&#13;
		if(!ws || !ws['!ref']) return "";&#13;
		var o = [], oo = [], cell, coord = "";&#13;
		var r = decode_range(ws['!ref']);&#13;
		var dense = Array.isArray(ws);&#13;
		for(var R = r.s.r; R &lt;= r.e.r; ++R) {&#13;
			for(var C = r.s.c; C &lt;= r.e.c; ++C) {&#13;
				coord = encode_cell({r:R,c:C});&#13;
				cell = dense ? (ws[R]||[])[C] : ws[coord];&#13;
				if(!cell || cell.v == null || cell.t === 'z') continue;&#13;
				oo = ["cell", coord, 't'];&#13;
				switch(cell.t) {&#13;
					case 's': case 'str': oo.push(encode(cell.v)); break;&#13;
					case 'n':&#13;
						if(!cell.f) { oo[2]='v'; oo[3]=cell.v; }&#13;
						else { oo[2]='vtf'; oo[3]='n'; oo[4]=cell.v; oo[5]=encode(cell.f); }&#13;
						break;&#13;
					case 'b':&#13;
						oo[2] = 'vt'+(cell.f?'f':'c'); oo[3]='nl'; oo[4]=cell.v?"1":"0";&#13;
						oo[5] = encode(cell.f||(cell.v?'TRUE':'FALSE'));&#13;
						break;&#13;
					case 'd':&#13;
						var t = datenum(parseDate(cell.v));&#13;
						oo[2] = 'vtc'; oo[3] = 'nd'; oo[4] = ""+t;&#13;
						oo[5] = cell.w || SSF_format(cell.z || table_fmt[14], t);&#13;
						break;&#13;
					case 'e': continue;&#13;
				}&#13;
				o.push(oo.join(":"));&#13;
			}&#13;
		}&#13;
		o.push("sheet:c:" + (r.e.c-r.s.c+1) + ":r:" + (r.e.r-r.s.r+1) + ":tvf:1");&#13;
		o.push("valueformat:1:text-wiki");&#13;
		//o.push("copiedfrom:" + ws['!ref']); // clipboard only&#13;
		return o.join("\n");&#13;
	}&#13;
&#13;
	function sheet_to_eth(ws) {&#13;
		return [header, sep, meta, sep, sheet_to_eth_data(ws), end].join("\n");&#13;
		// return ["version:1.5", sheet_to_eth_data(ws)].join("\n"); // clipboard form&#13;
	}&#13;
&#13;
	return {&#13;
		to_workbook: eth_to_workbook,&#13;
		to_sheet: eth_to_sheet,&#13;
		from_sheet: sheet_to_eth&#13;
	};&#13;
})();&#13;
&#13;
var PRN = (function() {&#13;
	function set_text_arr(data, arr, R, C, o) {&#13;
		if(o.raw) arr[R][C] = data;&#13;
		else if(data === ""){/* empty */}&#13;
		else if(data === 'TRUE') arr[R][C] = true;&#13;
		else if(data === 'FALSE') arr[R][C] = false;&#13;
		else if(!isNaN(fuzzynum(data))) arr[R][C] = fuzzynum(data);&#13;
		else if(!isNaN(fuzzydate(data).getDate())) arr[R][C] = parseDate(data);&#13;
		else arr[R][C] = data;&#13;
	}&#13;
&#13;
	function prn_to_aoa_str(f, opts) {&#13;
		var o = opts || {};&#13;
		var arr = ([]);&#13;
		if(!f || f.length === 0) return arr;&#13;
		var lines = f.split(/[\r\n]/);&#13;
		var L = lines.length - 1;&#13;
		while(L &gt;= 0 &amp;&amp; lines[L].length === 0) --L;&#13;
		var start = 10, idx = 0;&#13;
		var R = 0;&#13;
		for(; R &lt;= L; ++R) {&#13;
			idx = lines[R].indexOf(" ");&#13;
			if(idx == -1) idx = lines[R].length; else idx++;&#13;
			start = Math.max(start, idx);&#13;
		}&#13;
		for(R = 0; R &lt;= L; ++R) {&#13;
			arr[R] = [];&#13;
			/* TODO: confirm that widths are always 10 */&#13;
			var C = 0;&#13;
			set_text_arr(lines[R].slice(0, start).trim(), arr, R, C, o);&#13;
			for(C = 1; C &lt;= (lines[R].length - start)/10 + 1; ++C)&#13;
				set_text_arr(lines[R].slice(start+(C-1)*10,start+C*10).trim(),arr,R,C,o);&#13;
		}&#13;
		if(o.sheetRows) arr = arr.slice(0, o.sheetRows);&#13;
		return arr;&#13;
	}&#13;
&#13;
	// List of accepted CSV separators&#13;
	var guess_seps = {&#13;
0x2C: ',',&#13;
0x09: "\t",&#13;
0x3B: ';',&#13;
0x7C: '|'&#13;
	};&#13;
&#13;
	// CSV separator weights to be used in case of equal numbers&#13;
	var guess_sep_weights = {&#13;
0x2C: 3,&#13;
0x09: 2,&#13;
0x3B: 1,&#13;
0x7C: 0&#13;
	};&#13;
&#13;
	function guess_sep(str) {&#13;
		var cnt = {}, instr = false, end = 0, cc = 0;&#13;
		for(;end &lt; str.length;++end) {&#13;
			if((cc=str.charCodeAt(end)) == 0x22) instr = !instr;&#13;
			else if(!instr &amp;&amp; cc in guess_seps) cnt[cc] = (cnt[cc]||0)+1;&#13;
		}&#13;
&#13;
		cc = [];&#13;
		for(end in cnt) if ( Object.prototype.hasOwnProperty.call(cnt, end) ) {&#13;
			cc.push([ cnt[end], end ]);&#13;
		}&#13;
&#13;
		if ( !cc.length ) {&#13;
			cnt = guess_sep_weights;&#13;
			for(end in cnt) if ( Object.prototype.hasOwnProperty.call(cnt, end) ) {&#13;
				cc.push([ cnt[end], end ]);&#13;
			}&#13;
		}&#13;
&#13;
		cc.sort(function(a, b) { return a[0] - b[0] || guess_sep_weights[a[1]] - guess_sep_weights[b[1]]; });&#13;
&#13;
		return guess_seps[cc.pop()[1]] || 0x2C;&#13;
	}&#13;
&#13;
	function dsv_to_sheet_str(str, opts) {&#13;
		var o = opts || {};&#13;
		var sep = "";&#13;
		if(DENSE != null &amp;&amp; o.dense == null) o.dense = DENSE;&#13;
		var ws = o.dense ? ([]) : ({});&#13;
		var range = ({s: {c:0, r:0}, e: {c:0, r:0}});&#13;
&#13;
		if(str.slice(0,4) == "sep=") {&#13;
			// If the line ends in \r\n&#13;
			if(str.charCodeAt(5) == 13 &amp;&amp; str.charCodeAt(6) == 10 ) {&#13;
				sep = str.charAt(4); str = str.slice(7);&#13;
			}&#13;
			// If line ends in \r OR \n&#13;
			else if(str.charCodeAt(5) == 13 || str.charCodeAt(5) == 10 ) {&#13;
				sep = str.charAt(4); str = str.slice(6);&#13;
			}&#13;
			else sep = guess_sep(str.slice(0,1024));&#13;
		}&#13;
		else if(o &amp;&amp; o.FS) sep = o.FS;&#13;
		else sep = guess_sep(str.slice(0,1024));&#13;
		var R = 0, C = 0, v = 0;&#13;
		var start = 0, end = 0, sepcc = sep.charCodeAt(0), instr = false, cc=0, startcc=str.charCodeAt(0);&#13;
		var _re = o.dateNF != null ? dateNF_regex(o.dateNF) : null;&#13;
		function finish_cell() {&#13;
			var s = str.slice(start, end); if(s.slice(-1) == "\r") s = s.slice(0, -1);&#13;
			var cell = ({});&#13;
			if(s.charAt(0) == '"' &amp;&amp; s.charAt(s.length - 1) == '"') s = s.slice(1,-1).replace(/""/g,'"');&#13;
			if(s.length === 0) cell.t = 'z';&#13;
			else if(o.raw) { cell.t = 's'; cell.v = s; }&#13;
			else if(s.trim().length === 0) { cell.t = 's'; cell.v = s; }&#13;
			else if(s.charCodeAt(0) == 0x3D) {&#13;
				if(s.charCodeAt(1) == 0x22 &amp;&amp; s.charCodeAt(s.length - 1) == 0x22) { cell.t = 's'; cell.v = s.slice(2,-1).replace(/""/g,'"'); }&#13;
				else if(fuzzyfmla(s)) { cell.t = 'n'; cell.f = s.slice(1); }&#13;
				else { cell.t = 's'; cell.v = s; } }&#13;
			else if(s == "TRUE") { cell.t = 'b'; cell.v = true; }&#13;
			else if(s == "FALSE") { cell.t = 'b'; cell.v = false; }&#13;
			else if(!isNaN(v = fuzzynum(s))) { cell.t = 'n'; if(o.cellText !== false) cell.w = s; cell.v = v; }&#13;
			else if(!isNaN((v = fuzzydate(s)).getDate()) || _re &amp;&amp; s.match(_re)) {&#13;
				cell.z = o.dateNF || table_fmt[14];&#13;
				var k = 0;&#13;
				if(_re &amp;&amp; s.match(_re)){ s=dateNF_fix(s, o.dateNF, (s.match(_re)||[])); k=1; v = parseDate(s, k); }&#13;
				if(o.cellDates) { cell.t = 'd'; cell.v = v; }&#13;
				else { cell.t = 'n'; cell.v = datenum(v); }&#13;
				if(o.cellText !== false) cell.w = SSF_format(cell.z, cell.v instanceof Date ? datenum(cell.v):cell.v);&#13;
				if(!o.cellNF) delete cell.z;&#13;
			} else {&#13;
				cell.t = 's';&#13;
				cell.v = s;&#13;
			}&#13;
			if(cell.t == 'z'){}&#13;
			else if(o.dense) { if(!ws[R]) ws[R] = []; ws[R][C] = cell; }&#13;
			else ws[encode_cell({c:C,r:R})] = cell;&#13;
			start = end+1; startcc = str.charCodeAt(start);&#13;
			if(range.e.c &lt; C) range.e.c = C;&#13;
			if(range.e.r &lt; R) range.e.r = R;&#13;
			if(cc == sepcc) ++C; else { C = 0; ++R; if(o.sheetRows &amp;&amp; o.sheetRows &lt;= R) return true; }&#13;
		}&#13;
		outer: for(;end &lt; str.length;++end) switch((cc=str.charCodeAt(end))) {&#13;
			case 0x22: if(startcc === 0x22) instr = !instr; break;&#13;
			case 0x0d:&#13;
				if(instr) break;&#13;
				if(str.charCodeAt(end+1) == 0x0a) ++end;&#13;
				/* falls through */&#13;
			case sepcc: case 0x0a: if(!instr &amp;&amp; finish_cell()) break outer; break;&#13;
			default: break;&#13;
		}&#13;
		if(end - start &gt; 0) finish_cell();&#13;
&#13;
		ws['!ref'] = encode_range(range);&#13;
		return ws;&#13;
	}&#13;
&#13;
	function prn_to_sheet_str(str, opts) {&#13;
		if(!(opts &amp;&amp; opts.PRN)) return dsv_to_sheet_str(str, opts);&#13;
		if(opts.FS) return dsv_to_sheet_str(str, opts);&#13;
		if(str.slice(0,4) == "sep=") return dsv_to_sheet_str(str, opts);&#13;
		if(str.indexOf("\t") &gt;= 0 || str.indexOf(",") &gt;= 0 || str.indexOf(";") &gt;= 0) return dsv_to_sheet_str(str, opts);&#13;
		return aoa_to_sheet(prn_to_aoa_str(str, opts), opts);&#13;
	}&#13;
&#13;
	function prn_to_sheet(d, opts) {&#13;
		var str = "", bytes = opts.type == 'string' ? [0,0,0,0] : firstbyte(d, opts);&#13;
		switch(opts.type) {&#13;
			case 'base64': str = Base64_decode(d); break;&#13;
			case 'binary': str = d; break;&#13;
			case 'buffer':&#13;
				if(opts.codepage == 65001) str = d.toString('utf8'); // TODO: test if buf&#13;
				else if(opts.codepage &amp;&amp; typeof $cptable !== 'undefined') str = $cptable.utils.decode(opts.codepage, d);&#13;
				else str = has_buf &amp;&amp; Buffer.isBuffer(d) ? d.toString('binary') : a2s(d);&#13;
				break;&#13;
			case 'array': str = cc2str(d); break;&#13;
			case 'string': str = d; break;&#13;
			default: throw new Error("Unrecognized type " + opts.type);&#13;
		}&#13;
		if(bytes[0] == 0xEF &amp;&amp; bytes[1] == 0xBB &amp;&amp; bytes[2] == 0xBF) str = utf8read(str.slice(3));&#13;
		else if(opts.type != 'string' &amp;&amp; opts.type != 'buffer' &amp;&amp; opts.codepage == 65001) str = utf8read(str);&#13;
		else if((opts.type == 'binary') &amp;&amp; typeof $cptable !== 'undefined' &amp;&amp; opts.codepage)  str = $cptable.utils.decode(opts.codepage, $cptable.utils.encode(28591,str));&#13;
		if(str.slice(0,19) == "socialcalc:version:") return ETH.to_sheet(opts.type == 'string' ? str : utf8read(str), opts);&#13;
		return prn_to_sheet_str(str, opts);&#13;
	}&#13;
&#13;
	function prn_to_workbook(d, opts) { return sheet_to_workbook(prn_to_sheet(d, opts), opts); }&#13;
&#13;
	function sheet_to_prn(ws) {&#13;
		var o = [];&#13;
		var r = safe_decode_range(ws['!ref']), cell;&#13;
		var dense = Array.isArray(ws);&#13;
		for(var R = r.s.r; R &lt;= r.e.r; ++R) {&#13;
			var oo = [];&#13;
			for(var C = r.s.c; C &lt;= r.e.c; ++C) {&#13;
				var coord = encode_cell({r:R,c:C});&#13;
				cell = dense ? (ws[R]||[])[C] : ws[coord];&#13;
				if(!cell || cell.v == null) { oo.push("          "); continue; }&#13;
				var w = (cell.w || (format_cell(cell), cell.w) || "").slice(0,10);&#13;
				while(w.length &lt; 10) w += " ";&#13;
				oo.push(w + (C === 0 ? " " : ""));&#13;
			}&#13;
			o.push(oo.join(""));&#13;
		}&#13;
		return o.join("\n");&#13;
	}&#13;
&#13;
	return {&#13;
		to_workbook: prn_to_workbook,&#13;
		to_sheet: prn_to_sheet,&#13;
		from_sheet: sheet_to_prn&#13;
	};&#13;
})();&#13;
&#13;
/* Excel defaults to SYLK but warns if data is not valid */&#13;
function read_wb_ID(d, opts) {&#13;
	var o = opts || {}, OLD_WTF = !!o.WTF; o.WTF = true;&#13;
	try {&#13;
		var out = SYLK.to_workbook(d, o);&#13;
		o.WTF = OLD_WTF;&#13;
		return out;&#13;
	} catch(e) {&#13;
		o.WTF = OLD_WTF;&#13;
		if(!e.message.match(/SYLK bad record ID/) &amp;&amp; OLD_WTF) throw e;&#13;
		return PRN.to_workbook(d, opts);&#13;
	}&#13;
}&#13;
&#13;
var WK_ = (function() {&#13;
	function lotushopper(data, cb, opts) {&#13;
		if(!data) return;&#13;
		prep_blob(data, data.l || 0);&#13;
		var Enum = opts.Enum || WK1Enum;&#13;
		while(data.l &lt; data.length) {&#13;
			var RT = data.read_shift(2);&#13;
			var R = Enum[RT] || Enum[0xFFFF];&#13;
			var length = data.read_shift(2);&#13;
			var tgt = data.l + length;&#13;
			var d = R.f &amp;&amp; R.f(data, length, opts);&#13;
			data.l = tgt;&#13;
			if(cb(d, R, RT)) return;&#13;
		}&#13;
	}&#13;
&#13;
	function lotus_to_workbook(d, opts) {&#13;
		switch(opts.type) {&#13;
			case 'base64': return lotus_to_workbook_buf(s2a(Base64_decode(d)), opts);&#13;
			case 'binary': return lotus_to_workbook_buf(s2a(d), opts);&#13;
			case 'buffer':&#13;
			case 'array': return lotus_to_workbook_buf(d, opts);&#13;
		}&#13;
		throw "Unsupported type " + opts.type;&#13;
	}&#13;
&#13;
	function lotus_to_workbook_buf(d, opts) {&#13;
		if(!d) return d;&#13;
		var o = opts || {};&#13;
		if(DENSE != null &amp;&amp; o.dense == null) o.dense = DENSE;&#13;
		var s = ((o.dense ? [] : {})), n = "Sheet1", next_n = "", sidx = 0;&#13;
		var sheets = {}, snames = [], realnames = [];&#13;
&#13;
		var refguess = {s: {r:0, c:0}, e: {r:0, c:0} };&#13;
		var sheetRows = o.sheetRows || 0;&#13;
&#13;
		if(d[4] == 0x51 &amp;&amp; d[5] == 0x50 &amp;&amp; d[6] == 0x57) return qpw_to_workbook_buf(d, opts);&#13;
		if(d[2] == 0x00) {&#13;
			if(d[3] == 0x08 || d[3] == 0x09) {&#13;
				if(d.length &gt;= 16 &amp;&amp; d[14] == 0x05 &amp;&amp; d[15] === 0x6c) throw new Error("Unsupported Works 3 for Mac file");&#13;
			}&#13;
		}&#13;
&#13;
		if(d[2] == 0x02) {&#13;
			o.Enum = WK1Enum;&#13;
			lotushopper(d, function(val, R, RT) { switch(RT) {&#13;
				case 0x00: /* BOF */&#13;
					o.vers = val;&#13;
					if(val &gt;= 0x1000) o.qpro = true;&#13;
					break;&#13;
				case 0xFF: /* BOF (works 3+) */&#13;
					o.vers = val;&#13;
					o.works = true;&#13;
					break;&#13;
				case 0x06: refguess = val; break; /* RANGE */&#13;
				case 0xCC: if(val) next_n = val; break; /* SHEETNAMECS */&#13;
				case 0xDE: next_n = val; break; /* SHEETNAMELP */&#13;
				case 0x0F: /* LABEL */&#13;
				case 0x33: /* STRING */&#13;
					if((!o.qpro &amp;&amp; !o.works || RT == 0x33) &amp;&amp; val[1].v.charCodeAt(0) &lt; 0x30) val[1].v = val[1].v.slice(1);&#13;
					if(o.works || o.works2) val[1].v = val[1].v.replace(/\r\n/g, "\n");&#13;
					/* falls through */&#13;
				case 0x0D: /* INTEGER */&#13;
				case 0x0E: /* NUMBER */&#13;
				case 0x10: /* FORMULA */&#13;
					/* TODO: actual translation of the format code */&#13;
					if(RT == 0x0E &amp;&amp; (val[2] &amp; 0x70) == 0x70 &amp;&amp; (val[2] &amp; 0x0F) &gt; 1 &amp;&amp; (val[2] &amp; 0x0F) &lt; 15) {&#13;
						val[1].z = o.dateNF || table_fmt[14];&#13;
						if(o.cellDates) { val[1].t = 'd'; val[1].v = numdate(val[1].v); }&#13;
					}&#13;
&#13;
					if(o.qpro) {&#13;
						if(val[3] &gt; sidx) {&#13;
							s["!ref"] = encode_range(refguess);&#13;
							sheets[n] = s;&#13;
							snames.push(n);&#13;
							s = (o.dense ? [] : {});&#13;
							refguess = {s: {r:0, c:0}, e: {r:0, c:0} };&#13;
							sidx = val[3]; n = next_n || "Sheet" + (sidx + 1); next_n = "";&#13;
						}&#13;
					}&#13;
&#13;
					var tmpcell = o.dense ? (s[val[0].r]||[])[val[0].c] : s[encode_cell(val[0])];&#13;
					if(tmpcell) {&#13;
						tmpcell.t = val[1].t; tmpcell.v = val[1].v;&#13;
						if(val[1].z != null) tmpcell.z = val[1].z;&#13;
						if(val[1].f != null) tmpcell.f = val[1].f;&#13;
						break;&#13;
					}&#13;
					if(o.dense) {&#13;
						if(!s[val[0].r]) s[val[0].r] = [];&#13;
						s[val[0].r][val[0].c] = val[1];&#13;
					} else s[encode_cell(val[0])] = val[1];&#13;
					break;&#13;
				case 0x5405: o.works2 = true; break;&#13;
				default:&#13;
			}}, o);&#13;
		} else if(d[2] == 0x1A || d[2] == 0x0E) {&#13;
			o.Enum = WK3Enum;&#13;
			if(d[2] == 0x0E) { o.qpro = true; d.l = 0; }&#13;
			lotushopper(d, function(val, R, RT) { switch(RT) {&#13;
				case 0xCC: n = val; break; /* SHEETNAMECS */&#13;
				case 0x16: /* LABEL16 */&#13;
					if(val[1].v.charCodeAt(0) &lt; 0x30) val[1].v = val[1].v.slice(1);&#13;
					// TODO: R9 appears to encode control codes this way -- verify against other versions&#13;
					val[1].v = val[1].v.replace(/\x0F./g, function($$) { return String.fromCharCode($$.charCodeAt(1) - 0x20); }).replace(/\r\n/g, "\n");&#13;
					/* falls through */&#13;
				case 0x17: /* NUMBER17 */&#13;
				case 0x18: /* NUMBER18 */&#13;
				case 0x19: /* FORMULA19 */&#13;
				case 0x25: /* NUMBER25 */&#13;
				case 0x27: /* NUMBER27 */&#13;
				case 0x28: /* FORMULA28 */&#13;
					if(val[3] &gt; sidx) {&#13;
						s["!ref"] = encode_range(refguess);&#13;
						sheets[n] = s;&#13;
						snames.push(n);&#13;
						s = (o.dense ? [] : {});&#13;
						refguess = {s: {r:0, c:0}, e: {r:0, c:0} };&#13;
						sidx = val[3]; n = "Sheet" + (sidx + 1);&#13;
					}&#13;
					if(sheetRows &gt; 0 &amp;&amp; val[0].r &gt;= sheetRows) break;&#13;
					if(o.dense) {&#13;
						if(!s[val[0].r]) s[val[0].r] = [];&#13;
						s[val[0].r][val[0].c] = val[1];&#13;
					} else s[encode_cell(val[0])] = val[1];&#13;
					if(refguess.e.c &lt; val[0].c) refguess.e.c = val[0].c;&#13;
					if(refguess.e.r &lt; val[0].r) refguess.e.r = val[0].r;&#13;
					break;&#13;
				case 0x1B: /* XFORMAT */&#13;
					if(val[0x36b0]) realnames[val[0x36b0][0]] = val[0x36b0][1];&#13;
					break;&#13;
				case 0x0601: /* SHEETINFOQP */&#13;
					realnames[val[0]] = val[1]; if(val[0] == sidx) n = val[1]; break;&#13;
				default: break;&#13;
			}}, o);&#13;
		} else throw new Error("Unrecognized LOTUS BOF " + d[2]);&#13;
		s["!ref"] = encode_range(refguess);&#13;
		sheets[next_n || n] = s;&#13;
		snames.push(next_n || n);&#13;
		if(!realnames.length) return { SheetNames: snames, Sheets: sheets };&#13;
		var osheets = {}, rnames = [];&#13;
		/* TODO: verify no collisions */&#13;
		for(var i = 0; i &lt; realnames.length; ++i) if(sheets[snames[i]]) {&#13;
			rnames.push(realnames[i] || snames[i]);&#13;
			osheets[realnames[i]] = sheets[realnames[i]] || sheets[snames[i]];&#13;
		} else {&#13;
			rnames.push(realnames[i]);&#13;
			osheets[realnames[i]] = ({ "!ref": "A1" });&#13;
		}&#13;
		return { SheetNames: rnames, Sheets: osheets };&#13;
	}&#13;
&#13;
	function sheet_to_wk1(ws, opts) {&#13;
		var o = opts || {};&#13;
		if(+o.codepage &gt;= 0) set_cp(+o.codepage);&#13;
		if(o.type == "string") throw new Error("Cannot write WK1 to JS string");&#13;
		var ba = buf_array();&#13;
		var range = safe_decode_range(ws["!ref"]);&#13;
		var dense = Array.isArray(ws);&#13;
		var cols = [];&#13;
&#13;
		write_biff_rec(ba, 0x00, write_BOF_WK1(0x0406));&#13;
		write_biff_rec(ba, 0x06, write_RANGE(range));&#13;
		var max_R = Math.min(range.e.r, 8191);&#13;
		for(var R = range.s.r; R &lt;= max_R; ++R) {&#13;
			var rr = encode_row(R);&#13;
			for(var C = range.s.c; C &lt;= range.e.c; ++C) {&#13;
				if(R === range.s.r) cols[C] = encode_col(C);&#13;
				var ref = cols[C] + rr;&#13;
				var cell = dense ? (ws[R]||[])[C] : ws[ref];&#13;
				if(!cell || cell.t == "z") continue;&#13;
				/* TODO: formula records */&#13;
				if(cell.t == "n") {&#13;
					if((cell.v|0)==cell.v &amp;&amp; cell.v &gt;= -32768 &amp;&amp; cell.v &lt;= 32767) write_biff_rec(ba, 0x0d, write_INTEGER(R, C, cell.v));&#13;
					else write_biff_rec(ba, 0x0e, write_NUMBER(R, C, cell.v));&#13;
				} else {&#13;
					var str = format_cell(cell);&#13;
					write_biff_rec(ba, 0x0F, write_LABEL(R, C, str.slice(0, 239)));&#13;
				}&#13;
			}&#13;
		}&#13;
&#13;
		write_biff_rec(ba, 0x01);&#13;
		return ba.end();&#13;
	}&#13;
&#13;
	function book_to_wk3(wb, opts) {&#13;
		var o = opts || {};&#13;
		if(+o.codepage &gt;= 0) set_cp(+o.codepage);&#13;
		if(o.type == "string") throw new Error("Cannot write WK3 to JS string");&#13;
		var ba = buf_array();&#13;
&#13;
		write_biff_rec(ba, 0x00, write_BOF_WK3(wb));&#13;
&#13;
		for(var i = 0, cnt = 0; i &lt; wb.SheetNames.length; ++i) if((wb.Sheets[wb.SheetNames[i]] || {})["!ref"]) write_biff_rec(ba, 0x1b, write_XFORMAT_SHEETNAME(wb.SheetNames[i], cnt++));&#13;
&#13;
		var wsidx = 0;&#13;
		for(i = 0; i &lt; wb.SheetNames.length; ++i) {&#13;
			var ws = wb.Sheets[wb.SheetNames[i]];&#13;
			if(!ws || !ws["!ref"]) continue;&#13;
			var range = safe_decode_range(ws["!ref"]);&#13;
			var dense = Array.isArray(ws);&#13;
			var cols = [];&#13;
			var max_R = Math.min(range.e.r, 8191);&#13;
			for(var R = range.s.r; R &lt;= max_R; ++R) {&#13;
				var rr = encode_row(R);&#13;
				for(var C = range.s.c; C &lt;= range.e.c; ++C) {&#13;
					if(R === range.s.r) cols[C] = encode_col(C);&#13;
					var ref = cols[C] + rr;&#13;
					var cell = dense ? (ws[R]||[])[C] : ws[ref];&#13;
					if(!cell || cell.t == "z") continue;&#13;
					/* TODO: FORMULA19 NUMBER18 records */&#13;
					if(cell.t == "n") {&#13;
						write_biff_rec(ba, 0x17, write_NUMBER_17(R, C, wsidx, cell.v));&#13;
					} else {&#13;
						var str = format_cell(cell);&#13;
						/* TODO: max len? */&#13;
						write_biff_rec(ba, 0x16, write_LABEL_16(R, C, wsidx, str.slice(0, 239)));&#13;
					}&#13;
				}&#13;
			}&#13;
			++wsidx;&#13;
		}&#13;
&#13;
		write_biff_rec(ba, 0x01);&#13;
		return ba.end();&#13;
	}&#13;
&#13;
&#13;
	function write_BOF_WK1(v) {&#13;
		var out = new_buf(2);&#13;
		out.write_shift(2, v);&#13;
		return out;&#13;
	}&#13;
&#13;
	function write_BOF_WK3(wb) {&#13;
		var out = new_buf(26);&#13;
		out.write_shift(2, 0x1000);&#13;
		out.write_shift(2, 0x0004);&#13;
		out.write_shift(4, 0x0000);&#13;
		var rows = 0, cols = 0, wscnt = 0;&#13;
		for(var i = 0; i &lt; wb.SheetNames.length; ++i) {&#13;
			var name = wb.SheetNames[i];&#13;
			var ws = wb.Sheets[name];&#13;
			if(!ws || !ws["!ref"]) continue;&#13;
			++wscnt;&#13;
			var range = decode_range(ws["!ref"]);&#13;
			if(rows &lt; range.e.r) rows = range.e.r;&#13;
			if(cols &lt; range.e.c) cols = range.e.c;&#13;
		}&#13;
		if(rows &gt; 8191) rows = 8191;&#13;
		out.write_shift(2, rows);&#13;
		out.write_shift(1, wscnt);&#13;
		out.write_shift(1, cols);&#13;
		out.write_shift(2, 0x00);&#13;
		out.write_shift(2, 0x00);&#13;
		out.write_shift(1, 0x01);&#13;
		out.write_shift(1, 0x02);&#13;
		out.write_shift(4, 0);&#13;
		out.write_shift(4, 0);&#13;
		return out;&#13;
	}&#13;
&#13;
	function parse_RANGE(blob, length, opts) {&#13;
		var o = {s:{c:0,r:0},e:{c:0,r:0}};&#13;
		if(length == 8 &amp;&amp; opts.qpro) {&#13;
			o.s.c = blob.read_shift(1);&#13;
			blob.l++;&#13;
			o.s.r = blob.read_shift(2);&#13;
			o.e.c = blob.read_shift(1);&#13;
			blob.l++;&#13;
			o.e.r = blob.read_shift(2);&#13;
			return o;&#13;
		}&#13;
		o.s.c = blob.read_shift(2);&#13;
		o.s.r = blob.read_shift(2);&#13;
		if(length == 12 &amp;&amp; opts.qpro) blob.l += 2;&#13;
		o.e.c = blob.read_shift(2);&#13;
		o.e.r = blob.read_shift(2);&#13;
		if(length == 12 &amp;&amp; opts.qpro) blob.l += 2;&#13;
		if(o.s.c == 0xFFFF) o.s.c = o.e.c = o.s.r = o.e.r = 0;&#13;
		return o;&#13;
	}&#13;
	function write_RANGE(range) {&#13;
		var out = new_buf(8);&#13;
		out.write_shift(2, range.s.c);&#13;
		out.write_shift(2, range.s.r);&#13;
		out.write_shift(2, range.e.c);&#13;
		out.write_shift(2, range.e.r);&#13;
		return out;&#13;
	}&#13;
&#13;
	function parse_cell(blob, length, opts) {&#13;
		var o = [{c:0,r:0}, {t:'n',v:0}, 0, 0];&#13;
		if(opts.qpro &amp;&amp; opts.vers != 0x5120) {&#13;
			o[0].c = blob.read_shift(1);&#13;
			o[3] = blob.read_shift(1);&#13;
			o[0].r = blob.read_shift(2);&#13;
			blob.l+=2;&#13;
		} else if(opts.works) { // TODO: verify with more complex works3-4 examples&#13;
			o[0].c = blob.read_shift(2); o[0].r = blob.read_shift(2);&#13;
			o[2] = blob.read_shift(2);&#13;
		} else {&#13;
			o[2] = blob.read_shift(1);&#13;
			o[0].c = blob.read_shift(2); o[0].r = blob.read_shift(2);&#13;
		}&#13;
		return o;&#13;
	}&#13;
&#13;
	function parse_LABEL(blob, length, opts) {&#13;
		var tgt = blob.l + length;&#13;
		var o = parse_cell(blob, length, opts);&#13;
		o[1].t = 's';&#13;
		if(opts.vers == 0x5120) {&#13;
			blob.l++;&#13;
			var len = blob.read_shift(1);&#13;
			o[1].v = blob.read_shift(len, 'utf8');&#13;
			return o;&#13;
		}&#13;
		if(opts.qpro) blob.l++;&#13;
		o[1].v = blob.read_shift(tgt - blob.l, 'cstr');&#13;
		return o;&#13;
	}&#13;
	function write_LABEL(R, C, s) {&#13;
		/* TODO: encoding */&#13;
		var o = new_buf(7 + s.length);&#13;
		o.write_shift(1, 0xFF);&#13;
		o.write_shift(2, C);&#13;
		o.write_shift(2, R);&#13;
		o.write_shift(1, 0x27); // ??&#13;
		for(var i = 0; i &lt; o.length; ++i) {&#13;
			var cc = s.charCodeAt(i);&#13;
			o.write_shift(1, cc &gt;= 0x80 ? 0x5F : cc);&#13;
		}&#13;
		o.write_shift(1, 0);&#13;
		return o;&#13;
	}&#13;
	function parse_STRING(blob, length, opts) {&#13;
		var tgt = blob.l + length;&#13;
		var o = parse_cell(blob, length, opts);&#13;
		o[1].t = 's';&#13;
		if(opts.vers == 0x5120) {&#13;
			var len = blob.read_shift(1);&#13;
			o[1].v = blob.read_shift(len, 'utf8');&#13;
			return o;&#13;
		}&#13;
		o[1].v = blob.read_shift(tgt - blob.l, 'cstr');&#13;
		return o;&#13;
	}&#13;
&#13;
	function parse_INTEGER(blob, length, opts) {&#13;
		var o = parse_cell(blob, length, opts);&#13;
		o[1].v = blob.read_shift(2, 'i');&#13;
		return o;&#13;
	}&#13;
	function write_INTEGER(R, C, v) {&#13;
		var o = new_buf(7);&#13;
		o.write_shift(1, 0xFF);&#13;
		o.write_shift(2, C);&#13;
		o.write_shift(2, R);&#13;
		o.write_shift(2, v, 'i');&#13;
		return o;&#13;
	}&#13;
&#13;
	function parse_NUMBER(blob, length, opts) {&#13;
		var o = parse_cell(blob, length, opts);&#13;
		o[1].v = blob.read_shift(8, 'f');&#13;
		return o;&#13;
	}&#13;
	function write_NUMBER(R, C, v) {&#13;
		var o = new_buf(13);&#13;
		o.write_shift(1, 0xFF);&#13;
		o.write_shift(2, C);&#13;
		o.write_shift(2, R);&#13;
		o.write_shift(8, v, 'f');&#13;
		return o;&#13;
	}&#13;
&#13;
	function parse_FORMULA(blob, length, opts) {&#13;
		var tgt = blob.l + length;&#13;
		var o = parse_cell(blob, length, opts);&#13;
		/* TODO: formula */&#13;
		o[1].v = blob.read_shift(8, 'f');&#13;
		if(opts.qpro) blob.l = tgt;&#13;
		else {&#13;
			var flen = blob.read_shift(2);&#13;
			wk1_fmla_to_csf(blob.slice(blob.l, blob.l + flen), o);&#13;
			blob.l += flen;&#13;
		}&#13;
		return o;&#13;
	}&#13;
&#13;
	function wk1_parse_rc(B, V, col) {&#13;
		var rel = V &amp; 0x8000;&#13;
		V &amp;= ~0x8000;&#13;
		V = (rel ? B : 0) + ((V &gt;= 0x2000) ? V - 0x4000 : V);&#13;
		return (rel ? "" : "$") + (col ? encode_col(V) : encode_row(V));&#13;
	}&#13;
	/* var oprec = [&#13;
		8, 8, 8, 8, 8, 8, 8, 8, 6, 4, 4, 5, 5, 7, 3, 3,&#13;
		3, 3, 3, 3, 1, 1, 2, 6, 8, 8, 8, 8, 8, 8, 8, 8&#13;
	]; */&#13;
	/* TODO: flesh out */&#13;
	var FuncTab = {&#13;
		0x1F: ["NA", 0],&#13;
		// 0x20: ["ERR", 0],&#13;
		0x21: ["ABS", 1],&#13;
		0x22: ["TRUNC", 1],&#13;
		0x23: ["SQRT", 1],&#13;
		0x24: ["LOG", 1],&#13;
		0x25: ["LN", 1],&#13;
		0x26: ["PI", 0],&#13;
		0x27: ["SIN", 1],&#13;
		0x28: ["COS", 1],&#13;
		0x29: ["TAN", 1],&#13;
		0x2A: ["ATAN2", 2],&#13;
		0x2B: ["ATAN", 1],&#13;
		0x2C: ["ASIN", 1],&#13;
		0x2D: ["ACOS", 1],&#13;
		0x2E: ["EXP", 1],&#13;
		0x2F: ["MOD", 2],&#13;
		// 0x30&#13;
		0x31: ["ISNA", 1],&#13;
		0x32: ["ISERR", 1],&#13;
		0x33: ["FALSE", 0],&#13;
		0x34: ["TRUE", 0],&#13;
		0x35: ["RAND", 0],&#13;
		// 0x36 DATE&#13;
		// 0x37 NOW&#13;
		// 0x38 PMT&#13;
		// 0x39 PV&#13;
		// 0x3A FV&#13;
		// 0x3B IF&#13;
		// 0x3C DAY&#13;
		// 0x3D MONTH&#13;
		// 0x3E YEAR&#13;
		0x3F: ["ROUND", 2],&#13;
		// 0x40 TIME&#13;
		// 0x41 HOUR&#13;
		// 0x42 MINUTE&#13;
		// 0x43 SECOND&#13;
		0x44: ["ISNUMBER", 1],&#13;
		0x45: ["ISTEXT", 1],&#13;
		0x46: ["LEN", 1],&#13;
		0x47: ["VALUE", 1],&#13;
		// 0x48: ["FIXED", ?? 1],&#13;
		0x49: ["MID", 3],&#13;
		0x4A: ["CHAR", 1],&#13;
		// 0x4B&#13;
		// 0x4C FIND&#13;
		// 0x4D DATEVALUE&#13;
		// 0x4E TIMEVALUE&#13;
		// 0x4F CELL&#13;
		0x50: ["SUM", 69],&#13;
		0x51: ["AVERAGEA", 69],&#13;
		0x52: ["COUNTA", 69],&#13;
		0x53: ["MINA", 69],&#13;
		0x54: ["MAXA", 69],&#13;
		// 0x55 VLOOKUP&#13;
		// 0x56 NPV&#13;
		// 0x57 VAR&#13;
		// 0x58 STD&#13;
		// 0x59 IRR&#13;
		// 0x5A HLOOKUP&#13;
		// 0x5B DSUM&#13;
		// 0x5C DAVERAGE&#13;
		// 0x5D DCOUNTA&#13;
		// 0x5E DMIN&#13;
		// 0x5F DMAX&#13;
		// 0x60 DVARP&#13;
		// 0x61 DSTDEVP&#13;
		// 0x62 INDEX&#13;
		// 0x63 COLS&#13;
		// 0x64 ROWS&#13;
		// 0x65 REPEAT&#13;
		0x66: ["UPPER", 1],&#13;
		0x67: ["LOWER", 1],&#13;
		// 0x68 LEFT&#13;
		// 0x69 RIGHT&#13;
		// 0x6A REPLACE&#13;
		0x6B: ["PROPER", 1],&#13;
		// 0x6C CELL&#13;
		0x6D: ["TRIM", 1],&#13;
		// 0x6E CLEAN&#13;
		0x6F: ["T", 1]&#13;
		// 0x70 V&#13;
	};&#13;
	var BinOpTab = [&#13;
		  "",   "",   "",   "",   "",   "",   "",   "", // eslint-disable-line no-mixed-spaces-and-tabs&#13;
		  "",  "+",  "-",  "*",  "/",  "^",  "=", "&lt;&gt;", // eslint-disable-line no-mixed-spaces-and-tabs&#13;
		"&lt;=", "&gt;=",  "&lt;",  "&gt;",   "",   "",   "",   "", // eslint-disable-line no-mixed-spaces-and-tabs&#13;
		 "&amp;",   "",   "",   "",   "",   "",   "",   ""  // eslint-disable-line no-mixed-spaces-and-tabs&#13;
	];&#13;
&#13;
	function wk1_fmla_to_csf(blob, o) {&#13;
		prep_blob(blob, 0);&#13;
		var out = [], argc = 0, R = "", C = "", argL = "", argR = "";&#13;
		while(blob.l &lt; blob.length) {&#13;
			var cc = blob[blob.l++];&#13;
			switch(cc) {&#13;
				case 0x00: out.push(blob.read_shift(8, 'f')); break;&#13;
				case 0x01: {&#13;
					C = wk1_parse_rc(o[0].c, blob.read_shift(2), true);&#13;
					R = wk1_parse_rc(o[0].r, blob.read_shift(2), false);&#13;
					out.push(C + R);&#13;
				} break;&#13;
				case 0x02: {&#13;
					var c = wk1_parse_rc(o[0].c, blob.read_shift(2), true);&#13;
					var r = wk1_parse_rc(o[0].r, blob.read_shift(2), false);&#13;
					C = wk1_parse_rc(o[0].c, blob.read_shift(2), true);&#13;
					R = wk1_parse_rc(o[0].r, blob.read_shift(2), false);&#13;
					out.push(c + r + ":" + C + R);&#13;
				} break;&#13;
				case 0x03:&#13;
					if(blob.l &lt; blob.length) { console.error("WK1 premature formula end"); return; }&#13;
					break;&#13;
				case 0x04: out.push("(" + out.pop() + ")"); break;&#13;
				case 0x05: out.push(blob.read_shift(2)); break;&#13;
				case 0x06: {&#13;
					/* TODO: text encoding */&#13;
					var Z = ""; while((cc = blob[blob.l++])) Z += String.fromCharCode(cc);&#13;
					out.push('"' + Z.replace(/"/g, '""') + '"');&#13;
				} break;&#13;
&#13;
				case 0x08: out.push("-" + out.pop()); break;&#13;
				case 0x17: out.push("+" + out.pop()); break;&#13;
				case 0x16: out.push("NOT(" + out.pop() + ")"); break;&#13;
&#13;
				case 0x14: case 0x15: {&#13;
					argR = out.pop(); argL = out.pop();&#13;
					out.push(["AND", "OR"][cc - 0x14] + "(" + argL + "," + argR + ")");&#13;
				} break;&#13;
&#13;
				default:&#13;
					if(cc &lt; 0x20 &amp;&amp; BinOpTab[cc]) {&#13;
						argR = out.pop(); argL = out.pop();&#13;
						out.push(argL + BinOpTab[cc] + argR);&#13;
					} else if(FuncTab[cc]) {&#13;
						argc = FuncTab[cc][1];&#13;
						if(argc == 69) argc = blob[blob.l++];&#13;
						if(argc &gt; out.length) { console.error("WK1 bad formula parse 0x" + cc.toString(16) + ":|" + out.join("|") + "|"); return; }&#13;
						var args = out.slice(-argc);&#13;
						out.length -= argc;&#13;
						out.push(FuncTab[cc][0] + "(" + args.join(",") + ")");&#13;
					}&#13;
					else if(cc &lt;= 0x07) return console.error("WK1 invalid opcode " + cc.toString(16));&#13;
					else if(cc &lt;= 0x18) return console.error("WK1 unsupported op " + cc.toString(16));&#13;
					else if(cc &lt;= 0x1E) return console.error("WK1 invalid opcode " + cc.toString(16));&#13;
					else if(cc &lt;= 0x73) return console.error("WK1 unsupported function opcode " + cc.toString(16));&#13;
					// possible future functions ??&#13;
					else return console.error("WK1 unrecognized opcode " + cc.toString(16));&#13;
			}&#13;
		}&#13;
		if(out.length == 1) o[1].f = "" + out[0];&#13;
		else console.error("WK1 bad formula parse |" + out.join("|") + "|");&#13;
	}&#13;
&#13;
&#13;
	function parse_cell_3(blob) {&#13;
		var o = [{c:0,r:0}, {t:'n',v:0}, 0];&#13;
		o[0].r = blob.read_shift(2); o[3] = blob[blob.l++]; o[0].c = blob[blob.l++];&#13;
		return o;&#13;
	}&#13;
&#13;
	function parse_LABEL_16(blob, length) {&#13;
		var o = parse_cell_3(blob, length);&#13;
		o[1].t = 's';&#13;
		o[1].v = blob.read_shift(length - 4, 'cstr');&#13;
		return o;&#13;
	}&#13;
	function write_LABEL_16(R, C, wsidx, s) {&#13;
		/* TODO: encoding */&#13;
		var o = new_buf(6 + s.length);&#13;
		o.write_shift(2, R);&#13;
		o.write_shift(1, wsidx);&#13;
		o.write_shift(1, C);&#13;
		o.write_shift(1, 0x27);&#13;
		for(var i = 0; i &lt; s.length; ++i) {&#13;
			var cc = s.charCodeAt(i);&#13;
			o.write_shift(1, cc &gt;= 0x80 ? 0x5F : cc);&#13;
		}&#13;
		o.write_shift(1, 0);&#13;
		return o;&#13;
	}&#13;
&#13;
	function parse_NUMBER_18(blob, length) {&#13;
		var o = parse_cell_3(blob, length);&#13;
		o[1].v = blob.read_shift(2);&#13;
		var v = o[1].v &gt;&gt; 1;&#13;
		if(o[1].v &amp; 0x1) {&#13;
			switch(v &amp; 0x07) {&#13;
				case 0: v = (v &gt;&gt; 3) * 5000; break;&#13;
				case 1: v = (v &gt;&gt; 3) * 500; break;&#13;
				case 2: v = (v &gt;&gt; 3) / 20; break;&#13;
				case 3: v = (v &gt;&gt; 3) / 200; break;&#13;
				case 4: v = (v &gt;&gt; 3) / 2000; break;&#13;
				case 5: v = (v &gt;&gt; 3) / 20000; break;&#13;
				case 6: v = (v &gt;&gt; 3) / 16; break;&#13;
				case 7: v = (v &gt;&gt; 3) / 64; break;&#13;
			}&#13;
		}&#13;
		o[1].v = v;&#13;
		return o;&#13;
	}&#13;
&#13;
	function parse_NUMBER_17(blob, length) {&#13;
		var o = parse_cell_3(blob, length);&#13;
		var v1 = blob.read_shift(4);&#13;
		var v2 = blob.read_shift(4);&#13;
		var e = blob.read_shift(2);&#13;
		if(e == 0xFFFF) {&#13;
			if(v1 === 0 &amp;&amp; v2 === 0xC0000000) { o[1].t = "e"; o[1].v = 0x0F; } // ERR -&gt; #VALUE!&#13;
			else if(v1 === 0 &amp;&amp; v2 === 0xD0000000) { o[1].t = "e"; o[1].v = 0x2A; } // NA -&gt; #N/A&#13;
			else o[1].v = 0;&#13;
			return o;&#13;
		}&#13;
		var s = e &amp; 0x8000; e = (e&amp;0x7FFF) - 16446;&#13;
		o[1].v = (1 - s*2) * (v2 * Math.pow(2, e+32) + v1 * Math.pow(2, e));&#13;
		return o;&#13;
	}&#13;
	function write_NUMBER_17(R, C, wsidx, v) {&#13;
		var o = new_buf(14);&#13;
		o.write_shift(2, R);&#13;
		o.write_shift(1, wsidx);&#13;
		o.write_shift(1, C);&#13;
		if(v == 0) {&#13;
			o.write_shift(4, 0);&#13;
			o.write_shift(4, 0);&#13;
			o.write_shift(2, 0xFFFF);&#13;
			return o;&#13;
		}&#13;
		var s = 0, e = 0, v1 = 0, v2 = 0;&#13;
		if(v &lt; 0) { s = 1; v = -v; }&#13;
		e = Math.log2(v) | 0;&#13;
		v /= Math.pow(2, e-31);&#13;
		v2 = (v)&gt;&gt;&gt;0;&#13;
		if((v2&amp;0x80000000) == 0) { v/=2; ++e; v2 = v &gt;&gt;&gt; 0; }&#13;
		v -= v2;&#13;
		v2 |= 0x80000000;&#13;
		v2 &gt;&gt;&gt;= 0;&#13;
		v *= Math.pow(2, 32);&#13;
		v1 = v&gt;&gt;&gt;0;&#13;
		o.write_shift(4, v1);&#13;
		o.write_shift(4, v2);&#13;
		e += 0x3FFF + (s ? 0x8000 : 0);&#13;
		o.write_shift(2, e);&#13;
		return o;&#13;
	}&#13;
&#13;
	function parse_FORMULA_19(blob, length) {&#13;
		var o = parse_NUMBER_17(blob, 14);&#13;
		blob.l += length - 14; /* TODO: WK3 formula */&#13;
		return o;&#13;
	}&#13;
&#13;
	function parse_NUMBER_25(blob, length) {&#13;
		var o = parse_cell_3(blob, length);&#13;
		var v1 = blob.read_shift(4);&#13;
		o[1].v = v1 &gt;&gt; 6;&#13;
		return o;&#13;
	}&#13;
&#13;
	function parse_NUMBER_27(blob, length) {&#13;
		var o = parse_cell_3(blob, length);&#13;
		var v1 = blob.read_shift(8,'f');&#13;
		o[1].v = v1;&#13;
		return o;&#13;
	}&#13;
&#13;
	function parse_FORMULA_28(blob, length) {&#13;
		var o = parse_NUMBER_27(blob, 12);&#13;
		blob.l += length - 12; /* TODO: formula */&#13;
		return o;&#13;
	}&#13;
&#13;
	function parse_SHEETNAMECS(blob, length) {&#13;
		return blob[blob.l + length - 1] == 0 ? blob.read_shift(length, 'cstr') : "";&#13;
	}&#13;
&#13;
	function parse_SHEETNAMELP(blob, length) {&#13;
		var len = blob[blob.l++];&#13;
		if(len &gt; length - 1) len = length - 1;&#13;
		var o = ""; while(o.length &lt; len) o += String.fromCharCode(blob[blob.l++]);&#13;
		return o;&#13;
	}&#13;
&#13;
	function parse_SHEETINFOQP(blob, length, opts) {&#13;
		if(!opts.qpro || length &lt; 21) return;&#13;
		var id = blob.read_shift(1);&#13;
		blob.l += 17;&#13;
		blob.l += 1; //var len = blob.read_shift(1);&#13;
		blob.l += 2;&#13;
		var nm = blob.read_shift(length - 21, 'cstr');&#13;
		return [id, nm];&#13;
	}&#13;
&#13;
	function parse_XFORMAT(blob, length) {&#13;
		var o = {}, tgt = blob.l + length;&#13;
		while(blob.l &lt; tgt) {&#13;
			var dt = blob.read_shift(2);&#13;
			if(dt == 0x36b0) {&#13;
				o[dt] = [0, ""];&#13;
				o[dt][0] = blob.read_shift(2);&#13;
				while(blob[blob.l]) { o[dt][1] += String.fromCharCode(blob[blob.l]); blob.l++; } blob.l++;&#13;
			}&#13;
			// TODO: 0x3a99 ??&#13;
		}&#13;
		return o;&#13;
	}&#13;
	function write_XFORMAT_SHEETNAME(name, wsidx) {&#13;
		var out = new_buf(5 + name.length);&#13;
		out.write_shift(2, 0x36b0);&#13;
		out.write_shift(2, wsidx);&#13;
		for(var i = 0; i &lt; name.length; ++i) {&#13;
			var cc = name.charCodeAt(i);&#13;
			out[out.l++] = cc &gt; 0x7F ? 0x5F : cc;&#13;
		}&#13;
		out[out.l++] = 0;&#13;
		return out;&#13;
	}&#13;
&#13;
	var WK1Enum = {&#13;
0x0000: { n:"BOF", f:parseuint16 },&#13;
0x0001: { n:"EOF" },&#13;
0x0002: { n:"CALCMODE" },&#13;
0x0003: { n:"CALCORDER" },&#13;
0x0004: { n:"SPLIT" },&#13;
0x0005: { n:"SYNC" },&#13;
0x0006: { n:"RANGE", f:parse_RANGE },&#13;
0x0007: { n:"WINDOW1" },&#13;
0x0008: { n:"COLW1" },&#13;
0x0009: { n:"WINTWO" },&#13;
0x000A: { n:"COLW2" },&#13;
0x000B: { n:"NAME" },&#13;
0x000C: { n:"BLANK" },&#13;
0x000D: { n:"INTEGER", f:parse_INTEGER },&#13;
0x000E: { n:"NUMBER", f:parse_NUMBER },&#13;
0x000F: { n:"LABEL", f:parse_LABEL },&#13;
0x0010: { n:"FORMULA", f:parse_FORMULA },&#13;
0x0018: { n:"TABLE" },&#13;
0x0019: { n:"ORANGE" },&#13;
0x001A: { n:"PRANGE" },&#13;
0x001B: { n:"SRANGE" },&#13;
0x001C: { n:"FRANGE" },&#13;
0x001D: { n:"KRANGE1" },&#13;
0x0020: { n:"HRANGE" },&#13;
0x0023: { n:"KRANGE2" },&#13;
0x0024: { n:"PROTEC" },&#13;
0x0025: { n:"FOOTER" },&#13;
0x0026: { n:"HEADER" },&#13;
0x0027: { n:"SETUP" },&#13;
0x0028: { n:"MARGINS" },&#13;
0x0029: { n:"LABELFMT" },&#13;
0x002A: { n:"TITLES" },&#13;
0x002B: { n:"SHEETJS" },&#13;
0x002D: { n:"GRAPH" },&#13;
0x002E: { n:"NGRAPH" },&#13;
0x002F: { n:"CALCCOUNT" },&#13;
0x0030: { n:"UNFORMATTED" },&#13;
0x0031: { n:"CURSORW12" },&#13;
0x0032: { n:"WINDOW" },&#13;
0x0033: { n:"STRING", f:parse_STRING },&#13;
0x0037: { n:"PASSWORD" },&#13;
0x0038: { n:"LOCKED" },&#13;
0x003C: { n:"QUERY" },&#13;
0x003D: { n:"QUERYNAME" },&#13;
0x003E: { n:"PRINT" },&#13;
0x003F: { n:"PRINTNAME" },&#13;
0x0040: { n:"GRAPH2" },&#13;
0x0041: { n:"GRAPHNAME" },&#13;
0x0042: { n:"ZOOM" },&#13;
0x0043: { n:"SYMSPLIT" },&#13;
0x0044: { n:"NSROWS" },&#13;
0x0045: { n:"NSCOLS" },&#13;
0x0046: { n:"RULER" },&#13;
0x0047: { n:"NNAME" },&#13;
0x0048: { n:"ACOMM" },&#13;
0x0049: { n:"AMACRO" },&#13;
0x004A: { n:"PARSE" },&#13;
0x0066: { n:"PRANGES??" },&#13;
0x0067: { n:"RRANGES??" },&#13;
0x0068: { n:"FNAME??" },&#13;
0x0069: { n:"MRANGES??" },&#13;
0x00CC: { n:"SHEETNAMECS", f:parse_SHEETNAMECS },&#13;
0x00DE: { n:"SHEETNAMELP", f:parse_SHEETNAMELP },&#13;
0x00FF: { n:"BOF", f:parseuint16 },&#13;
0xFFFF: { n:"" }&#13;
	};&#13;
&#13;
	var WK3Enum = {&#13;
0x0000: { n:"BOF" },&#13;
0x0001: { n:"EOF" },&#13;
0x0002: { n:"PASSWORD" },&#13;
0x0003: { n:"CALCSET" },&#13;
0x0004: { n:"WINDOWSET" },&#13;
0x0005: { n:"SHEETCELLPTR" },&#13;
0x0006: { n:"SHEETLAYOUT" },&#13;
0x0007: { n:"COLUMNWIDTH" },&#13;
0x0008: { n:"HIDDENCOLUMN" },&#13;
0x0009: { n:"USERRANGE" },&#13;
0x000A: { n:"SYSTEMRANGE" },&#13;
0x000B: { n:"ZEROFORCE" },&#13;
0x000C: { n:"SORTKEYDIR" },&#13;
0x000D: { n:"FILESEAL" },&#13;
0x000E: { n:"DATAFILLNUMS" },&#13;
0x000F: { n:"PRINTMAIN" },&#13;
0x0010: { n:"PRINTSTRING" },&#13;
0x0011: { n:"GRAPHMAIN" },&#13;
0x0012: { n:"GRAPHSTRING" },&#13;
0x0013: { n:"??" },&#13;
0x0014: { n:"ERRCELL" },&#13;
0x0015: { n:"NACELL" },&#13;
0x0016: { n:"LABEL16", f:parse_LABEL_16},&#13;
0x0017: { n:"NUMBER17", f:parse_NUMBER_17 },&#13;
0x0018: { n:"NUMBER18", f:parse_NUMBER_18 },&#13;
0x0019: { n:"FORMULA19", f:parse_FORMULA_19},&#13;
0x001A: { n:"FORMULA1A" },&#13;
0x001B: { n:"XFORMAT", f:parse_XFORMAT },&#13;
0x001C: { n:"DTLABELMISC" },&#13;
0x001D: { n:"DTLABELCELL" },&#13;
0x001E: { n:"GRAPHWINDOW" },&#13;
0x001F: { n:"CPA" },&#13;
0x0020: { n:"LPLAUTO" },&#13;
0x0021: { n:"QUERY" },&#13;
0x0022: { n:"HIDDENSHEET" },&#13;
0x0023: { n:"??" },&#13;
0x0025: { n:"NUMBER25", f:parse_NUMBER_25 },&#13;
0x0026: { n:"??" },&#13;
0x0027: { n:"NUMBER27", f:parse_NUMBER_27 },&#13;
0x0028: { n:"FORMULA28", f:parse_FORMULA_28 },&#13;
0x008E: { n:"??" },&#13;
0x0093: { n:"??" },&#13;
0x0096: { n:"??" },&#13;
0x0097: { n:"??" },&#13;
0x0098: { n:"??" },&#13;
0x0099: { n:"??" },&#13;
0x009A: { n:"??" },&#13;
0x009B: { n:"??" },&#13;
0x009C: { n:"??" },&#13;
0x00A3: { n:"??" },&#13;
0x00AE: { n:"??" },&#13;
0x00AF: { n:"??" },&#13;
0x00B0: { n:"??" },&#13;
0x00B1: { n:"??" },&#13;
0x00B8: { n:"??" },&#13;
0x00B9: { n:"??" },&#13;
0x00BA: { n:"??" },&#13;
0x00BB: { n:"??" },&#13;
0x00BC: { n:"??" },&#13;
0x00C3: { n:"??" },&#13;
0x00C9: { n:"??" },&#13;
0x00CC: { n:"SHEETNAMECS", f:parse_SHEETNAMECS },&#13;
0x00CD: { n:"??" },&#13;
0x00CE: { n:"??" },&#13;
0x00CF: { n:"??" },&#13;
0x00D0: { n:"??" },&#13;
0x0100: { n:"??" },&#13;
0x0103: { n:"??" },&#13;
0x0104: { n:"??" },&#13;
0x0105: { n:"??" },&#13;
0x0106: { n:"??" },&#13;
0x0107: { n:"??" },&#13;
0x0109: { n:"??" },&#13;
0x010A: { n:"??" },&#13;
0x010B: { n:"??" },&#13;
0x010C: { n:"??" },&#13;
0x010E: { n:"??" },&#13;
0x010F: { n:"??" },&#13;
0x0180: { n:"??" },&#13;
0x0185: { n:"??" },&#13;
0x0186: { n:"??" },&#13;
0x0189: { n:"??" },&#13;
0x018C: { n:"??" },&#13;
0x0200: { n:"??" },&#13;
0x0202: { n:"??" },&#13;
0x0201: { n:"??" },&#13;
0x0204: { n:"??" },&#13;
0x0205: { n:"??" },&#13;
0x0280: { n:"??" },&#13;
0x0281: { n:"??" },&#13;
0x0282: { n:"??" },&#13;
0x0283: { n:"??" },&#13;
0x0284: { n:"??" },&#13;
0x0285: { n:"??" },&#13;
0x0286: { n:"??" },&#13;
0x0287: { n:"??" },&#13;
0x0288: { n:"??" },&#13;
0x0292: { n:"??" },&#13;
0x0293: { n:"??" },&#13;
0x0294: { n:"??" },&#13;
0x0295: { n:"??" },&#13;
0x0296: { n:"??" },&#13;
0x0299: { n:"??" },&#13;
0x029A: { n:"??" },&#13;
0x0300: { n:"??" },&#13;
0x0304: { n:"??" },&#13;
0x0601: { n:"SHEETINFOQP", f:parse_SHEETINFOQP },&#13;
0x0640: { n:"??" },&#13;
0x0642: { n:"??" },&#13;
0x0701: { n:"??" },&#13;
0x0702: { n:"??" },&#13;
0x0703: { n:"??" },&#13;
0x0704: { n:"??" },&#13;
0x0780: { n:"??" },&#13;
0x0800: { n:"??" },&#13;
0x0801: { n:"??" },&#13;
0x0804: { n:"??" },&#13;
0x0A80: { n:"??" },&#13;
0x2AF6: { n:"??" },&#13;
0x3231: { n:"??" },&#13;
0x6E49: { n:"??" },&#13;
0x6F44: { n:"??" },&#13;
0xFFFF: { n:"" }&#13;
	};&#13;
&#13;
	/* QPW uses a different set of record types */&#13;
	function qpw_to_workbook_buf(d, opts) {&#13;
		prep_blob(d, 0);&#13;
		var o = opts || {};&#13;
		if(DENSE != null &amp;&amp; o.dense == null) o.dense = DENSE;&#13;
		var s = ((o.dense ? [] : {}));&#13;
		var SST = [], sname = "", formulae = [];&#13;
		var range = {s:{r:-1,c:-1}, e:{r:-1,c:-1}};&#13;
		var cnt = 0, type = 0, C = 0, R = 0;&#13;
		var wb = { SheetNames: [], Sheets: {} };&#13;
		outer: while(d.l &lt; d.length) {&#13;
			var RT = d.read_shift(2), length = d.read_shift(2);&#13;
			var p = d.slice(d.l, d.l + length);&#13;
			prep_blob(p, 0);&#13;
			switch(RT) {&#13;
				case 0x01: /* BOF */&#13;
					if(p.read_shift(4) != 0x39575051) throw "Bad QPW9 BOF!";&#13;
					break;&#13;
				case 0x02: /* EOF */ break outer;&#13;
&#13;
				/* TODO: The behavior here should be consistent with Numbers: QP Notebook ~ .TN.SheetArchive, QP Sheet ~ .TST.TableModelArchive */&#13;
				case 0x0401: /* BON */ break;&#13;
				case 0x0402: /* EON */ /* TODO: backfill missing sheets based on BON cnt */ break;&#13;
&#13;
				case 0x0407: { /* SST */&#13;
					p.l += 12;&#13;
					while(p.l &lt; p.length) {&#13;
						cnt = p.read_shift(2);&#13;
						type = p.read_shift(1);&#13;
						SST.push(p.read_shift(cnt, 'cstr'));&#13;
					}&#13;
				} break;&#13;
				case 0x0408: { /* FORMULAE */&#13;
					//p.l += 12;&#13;
					//while(p.l &lt; p.length) {&#13;
					//	cnt = p.read_shift(2);&#13;
					//	formulae.push(p.slice(p.l, p.l + cnt + 1)); p.l += cnt + 1;&#13;
					//}&#13;
				} break;&#13;
&#13;
				case 0x0601: { /* BOS */&#13;
					var sidx = p.read_shift(2);&#13;
					s = ((o.dense ? [] : {}));&#13;
					range.s.c = p.read_shift(2);&#13;
					range.e.c = p.read_shift(2);&#13;
					range.s.r = p.read_shift(4);&#13;
					range.e.r = p.read_shift(4);&#13;
					p.l += 4;&#13;
					if(p.l + 2 &lt; p.length) {&#13;
						cnt = p.read_shift(2);&#13;
						type = p.read_shift(1);&#13;
						sname = cnt == 0 ? "" : p.read_shift(cnt, 'cstr');&#13;
					}&#13;
					if(!sname) sname = encode_col(sidx);&#13;
					/* TODO: backfill empty sheets */&#13;
				} break;&#13;
				case 0x0602: { /* EOS */&#13;
					/* NOTE: QP valid range A1:IV1000000 */&#13;
					if(range.s.c &gt; 0xFF || range.s.r &gt; 999999) break;&#13;
					if(range.e.c &lt; range.s.c) range.e.c = range.s.c;&#13;
					if(range.e.r &lt; range.s.r) range.e.r = range.s.r;&#13;
					s["!ref"] = encode_range(range);&#13;
					book_append_sheet(wb, s, sname); // TODO: a barrel roll&#13;
				} break;&#13;
&#13;
				case 0x0A01: { /* COL (like XLS Row, modulo the layout transposition) */&#13;
					C = p.read_shift(2);&#13;
					if(range.e.c &lt; C) range.e.c = C;&#13;
					if(range.s.c &gt; C) range.s.c = C;&#13;
					R = p.read_shift(4);&#13;
					if(range.s.r &gt; R) range.s.r = R;&#13;
					R = p.read_shift(4);&#13;
					if(range.e.r &lt; R) range.e.r = R;&#13;
				} break;&#13;
&#13;
				case 0x0C01: { /* MulCells (like XLS MulRK, but takes advantage of common column data patterns) */&#13;
					R = p.read_shift(4), cnt = p.read_shift(4);&#13;
					if(range.s.r &gt; R) range.s.r = R;&#13;
					if(range.e.r &lt; R + cnt - 1) range.e.r = R + cnt - 1;&#13;
					while(p.l &lt; p.length) {&#13;
						var cell = { t: "z" };&#13;
						var flags = p.read_shift(1);&#13;
						if(flags &amp; 0x80) p.l += 2;&#13;
						var mul = (flags &amp; 0x40) ? p.read_shift(2) - 1: 0;&#13;
						switch(flags &amp; 0x1F) {&#13;
							case 1: break;&#13;
							case 2: cell = { t: "n", v: p.read_shift(2) }; break;&#13;
							case 3: cell = { t: "n", v: p.read_shift(2, 'i') }; break;&#13;
							case 5: cell = { t: "n", v: p.read_shift(8, 'f') }; break;&#13;
							case 7: cell = { t: "s", v: SST[type = p.read_shift(4) - 1] }; break;&#13;
							case 8: cell = { t: "n", v: p.read_shift(8, 'f') }; p.l += 2; /* cell.f = formulae[p.read_shift(4)]; */ p.l += 4; break;&#13;
							default: throw "Unrecognized QPW cell type " + (flags &amp; 0x1F);&#13;
						}&#13;
						var delta = 0;&#13;
						if(flags &amp; 0x20) switch(flags &amp; 0x1F) {&#13;
							case 2: delta = p.read_shift(2); break;&#13;
							case 3: delta = p.read_shift(2, 'i'); break;&#13;
							case 7: delta = p.read_shift(2); break;&#13;
							default: throw "Unsupported delta for QPW cell type " + (flags &amp; 0x1F);&#13;
						}&#13;
						if(!(!o.sheetStubs &amp;&amp; cell.t == "z")) {&#13;
							if(Array.isArray(s)) {&#13;
								if(!s[R]) s[R] = [];&#13;
								s[R][C] = cell;&#13;
							} else s[encode_cell({r:R, c:C})] = cell;&#13;
						}&#13;
						++R; --cnt;&#13;
						while(mul-- &gt; 0 &amp;&amp; cnt &gt;= 0) {&#13;
							if(flags &amp; 0x20) switch(flags &amp; 0x1F) {&#13;
								case 2: cell = { t: "n", v: (cell.v + delta) &amp; 0xFFFF }; break;&#13;
								case 3: cell = { t: "n", v: (cell.v + delta) &amp; 0xFFFF }; if(cell.v &gt; 0x7FFF) cell.v -= 0x10000; break;&#13;
								case 7: cell = { t: "s", v: SST[type = (type + delta) &gt;&gt;&gt; 0] }; break;&#13;
								default: throw "Cannot apply delta for QPW cell type " + (flags &amp; 0x1F);&#13;
							} else switch(flags &amp; 0x1F) {&#13;
								case 1: cell = { t: "z" }; break;&#13;
								case 2: cell = { t: "n", v: p.read_shift(2) }; break;&#13;
								case 7: cell = { t: "s", v: SST[type = p.read_shift(4) - 1] }; break;&#13;
								default: throw "Cannot apply repeat for QPW cell type " + (flags &amp; 0x1F);&#13;
							}&#13;
							if(!(!o.sheetStubs &amp;&amp; cell.t == "z")) {&#13;
								if(Array.isArray(s)) {&#13;
									if(!s[R]) s[R] = [];&#13;
									s[R][C] = cell;&#13;
								} else s[encode_cell({r:R, c:C})] = cell;&#13;
							}&#13;
							++R; --cnt;&#13;
						}&#13;
					}&#13;
				} break;&#13;
&#13;
				default: break;&#13;
			}&#13;
			d.l += length;&#13;
		}&#13;
		return wb;&#13;
	}&#13;
&#13;
	return {&#13;
		sheet_to_wk1: sheet_to_wk1,&#13;
		book_to_wk3: book_to_wk3,&#13;
		to_workbook: lotus_to_workbook&#13;
	};&#13;
})();&#13;
/* 18.4.7 rPr CT_RPrElt */&#13;
function parse_rpr(rpr) {&#13;
	var font = {}, m = rpr.match(tagregex), i = 0;&#13;
	var pass = false;&#13;
	if(m) for(;i!=m.length; ++i) {&#13;
		var y = parsexmltag(m[i]);&#13;
		switch(y[0].replace(/\w*:/g,"")) {&#13;
			/* 18.8.12 condense CT_BooleanProperty */&#13;
			/* ** not required . */&#13;
			case '&lt;condense': break;&#13;
			/* 18.8.17 extend CT_BooleanProperty */&#13;
			/* ** not required . */&#13;
			case '&lt;extend': break;&#13;
			/* 18.8.36 shadow CT_BooleanProperty */&#13;
			/* ** not required . */&#13;
			case '&lt;shadow':&#13;
				if(!y.val) break;&#13;
				/* falls through */&#13;
			case '&lt;shadow&gt;':&#13;
			case '&lt;shadow/&gt;': font.shadow = 1; break;&#13;
			case '&lt;/shadow&gt;': break;&#13;
&#13;
			/* 18.4.1 charset CT_IntProperty TODO */&#13;
			case '&lt;charset':&#13;
				if(y.val == '1') break;&#13;
				font.cp = CS2CP[parseInt(y.val, 10)];&#13;
				break;&#13;
&#13;
			/* 18.4.2 outline CT_BooleanProperty TODO */&#13;
			case '&lt;outline':&#13;
				if(!y.val) break;&#13;
				/* falls through */&#13;
			case '&lt;outline&gt;':&#13;
			case '&lt;outline/&gt;': font.outline = 1; break;&#13;
			case '&lt;/outline&gt;': break;&#13;
&#13;
			/* 18.4.5 rFont CT_FontName */&#13;
			case '&lt;rFont': font.name = y.val; break;&#13;
&#13;
			/* 18.4.11 sz CT_FontSize */&#13;
			case '&lt;sz': font.sz = y.val; break;&#13;
&#13;
			/* 18.4.10 strike CT_BooleanProperty */&#13;
			case '&lt;strike':&#13;
				if(!y.val) break;&#13;
				/* falls through */&#13;
			case '&lt;strike&gt;':&#13;
			case '&lt;strike/&gt;': font.strike = 1; break;&#13;
			case '&lt;/strike&gt;': break;&#13;
&#13;
			/* 18.4.13 u CT_UnderlineProperty */&#13;
			case '&lt;u':&#13;
				if(!y.val) break;&#13;
				switch(y.val) {&#13;
					case 'double': font.uval = "double"; break;&#13;
					case 'singleAccounting': font.uval = "single-accounting"; break;&#13;
					case 'doubleAccounting': font.uval = "double-accounting"; break;&#13;
				}&#13;
				/* falls through */&#13;
			case '&lt;u&gt;':&#13;
			case '&lt;u/&gt;': font.u = 1; break;&#13;
			case '&lt;/u&gt;': break;&#13;
&#13;
			/* 18.8.2 b */&#13;
			case '&lt;b':&#13;
				if(y.val == '0') break;&#13;
				/* falls through */&#13;
			case '&lt;b&gt;':&#13;
			case '&lt;b/&gt;': font.b = 1; break;&#13;
			case '&lt;/b&gt;': break;&#13;
&#13;
			/* 18.8.26 i */&#13;
			case '&lt;i':&#13;
				if(y.val == '0') break;&#13;
				/* falls through */&#13;
			case '&lt;i&gt;':&#13;
			case '&lt;i/&gt;': font.i = 1; break;&#13;
			case '&lt;/i&gt;': break;&#13;
&#13;
			/* 18.3.1.15 color CT_Color TODO: tint, theme, auto, indexed */&#13;
			case '&lt;color':&#13;
				if(y.rgb) font.color = y.rgb.slice(2,8);&#13;
				break;&#13;
			case '&lt;color&gt;': case '&lt;color/&gt;': case '&lt;/color&gt;': break;&#13;
&#13;
			/* 18.8.18 family ST_FontFamily */&#13;
			case '&lt;family': font.family = y.val; break;&#13;
			case '&lt;family&gt;': case '&lt;family/&gt;': case '&lt;/family&gt;': break;&#13;
&#13;
			/* 18.4.14 vertAlign CT_VerticalAlignFontProperty TODO */&#13;
			case '&lt;vertAlign': font.valign = y.val; break;&#13;
			case '&lt;vertAlign&gt;': case '&lt;vertAlign/&gt;': case '&lt;/vertAlign&gt;': break;&#13;
&#13;
			/* 18.8.35 scheme CT_FontScheme TODO */&#13;
			case '&lt;scheme': break;&#13;
			case '&lt;scheme&gt;': case '&lt;scheme/&gt;': case '&lt;/scheme&gt;': break;&#13;
&#13;
			/* 18.2.10 extLst CT_ExtensionList ? */&#13;
			case '&lt;extLst': case '&lt;extLst&gt;': case '&lt;/extLst&gt;': break;&#13;
			case '&lt;ext': pass = true; break;&#13;
			case '&lt;/ext&gt;': pass = false; break;&#13;
			default:&#13;
				if(y[0].charCodeAt(1) !== 47 &amp;&amp; !pass) throw new Error('Unrecognized rich format ' + y[0]);&#13;
		}&#13;
	}&#13;
	return font;&#13;
}&#13;
&#13;
var parse_rs = (function() {&#13;
	var tregex = matchtag("t"), rpregex = matchtag("rPr");&#13;
	/* 18.4.4 r CT_RElt */&#13;
	function parse_r(r) {&#13;
		/* 18.4.12 t ST_Xstring */&#13;
		var t = r.match(tregex)/*, cp = 65001*/;&#13;
		if(!t) return {t:"s", v:""};&#13;
&#13;
		var o = ({t:'s', v:unescapexml(t[1])});&#13;
		var rpr = r.match(rpregex);&#13;
		if(rpr) o.s = parse_rpr(rpr[1]);&#13;
		return o;&#13;
	}&#13;
	var rregex = /&lt;(?:\w+:)?r&gt;/g, rend = /&lt;\/(?:\w+:)?r&gt;/;&#13;
	return function parse_rs(rs) {&#13;
		return rs.replace(rregex,"").split(rend).map(parse_r).filter(function(r) { return r.v; });&#13;
	};&#13;
})();&#13;
&#13;
&#13;
/* Parse a list of &lt;r&gt; tags */&#13;
var rs_to_html = (function parse_rs_factory() {&#13;
	var nlregex = /(\r\n|\n)/g;&#13;
	function parse_rpr2(font, intro, outro) {&#13;
		var style = [];&#13;
&#13;
		if(font.u) style.push("text-decoration: underline;");&#13;
		if(font.uval) style.push("text-underline-style:" + font.uval + ";");&#13;
		if(font.sz) style.push("font-size:" + font.sz + "pt;");&#13;
		if(font.outline) style.push("text-effect: outline;");&#13;
		if(font.shadow) style.push("text-shadow: auto;");&#13;
		intro.push('&lt;span style="' + style.join("") + '"&gt;');&#13;
&#13;
		if(font.b) { intro.push("&lt;b&gt;"); outro.push("&lt;/b&gt;"); }&#13;
		if(font.i) { intro.push("&lt;i&gt;"); outro.push("&lt;/i&gt;"); }&#13;
		if(font.strike) { intro.push("&lt;s&gt;"); outro.push("&lt;/s&gt;"); }&#13;
&#13;
		var align = font.valign || "";&#13;
		if(align == "superscript" || align == "super") align = "sup";&#13;
		else if(align == "subscript") align = "sub";&#13;
		if(align != "") { intro.push("&lt;" + align + "&gt;"); outro.push("&lt;/" + align + "&gt;"); }&#13;
&#13;
		outro.push("&lt;/span&gt;");&#13;
		return font;&#13;
	}&#13;
&#13;
	/* 18.4.4 r CT_RElt */&#13;
	function r_to_html(r) {&#13;
		var terms = [[],r.v,[]];&#13;
		if(!r.v) return "";&#13;
&#13;
		if(r.s) parse_rpr2(r.s, terms[0], terms[2]);&#13;
&#13;
		return terms[0].join("") + terms[1].replace(nlregex,'&lt;br/&gt;') + terms[2].join("");&#13;
	}&#13;
&#13;
	return function parse_rs(rs) {&#13;
		return rs.map(r_to_html).join("");&#13;
	};&#13;
})();&#13;
&#13;
/* 18.4.8 si CT_Rst */&#13;
var sitregex = /&lt;(?:\w+:)?t[^&gt;]*&gt;([^&lt;]*)&lt;\/(?:\w+:)?t&gt;/g, sirregex = /&lt;(?:\w+:)?r&gt;/;&#13;
var sirphregex = /&lt;(?:\w+:)?rPh.*?&gt;([\s\S]*?)&lt;\/(?:\w+:)?rPh&gt;/g;&#13;
function parse_si(x, opts) {&#13;
	var html = opts ? opts.cellHTML : true;&#13;
	var z = {};&#13;
	if(!x) return { t: "" };&#13;
	//var y;&#13;
	/* 18.4.12 t ST_Xstring (Plaintext String) */&#13;
	// TODO: is whitespace actually valid here?&#13;
	if(x.match(/^\s*&lt;(?:\w+:)?t[^&gt;]*&gt;/)) {&#13;
		z.t = unescapexml(utf8read(x.slice(x.indexOf("&gt;")+1).split(/&lt;\/(?:\w+:)?t&gt;/)[0]||""), true);&#13;
		z.r = utf8read(x);&#13;
		if(html) z.h = escapehtml(z.t);&#13;
	}&#13;
	/* 18.4.4 r CT_RElt (Rich Text Run) */&#13;
	else if((/*y = */x.match(sirregex))) {&#13;
		z.r = utf8read(x);&#13;
		z.t = unescapexml(utf8read((x.replace(sirphregex, '').match(sitregex)||[]).join("").replace(tagregex,"")), true);&#13;
		if(html) z.h = rs_to_html(parse_rs(z.r));&#13;
	}&#13;
	/* 18.4.3 phoneticPr CT_PhoneticPr (TODO: needed for Asian support) */&#13;
	/* 18.4.6 rPh CT_PhoneticRun (TODO: needed for Asian support) */&#13;
	return z;&#13;
}&#13;
&#13;
/* 18.4 Shared String Table */&#13;
var sstr0 = /&lt;(?:\w+:)?sst([^&gt;]*)&gt;([\s\S]*)&lt;\/(?:\w+:)?sst&gt;/;&#13;
var sstr1 = /&lt;(?:\w+:)?(?:si|sstItem)&gt;/g;&#13;
var sstr2 = /&lt;\/(?:\w+:)?(?:si|sstItem)&gt;/;&#13;
function parse_sst_xml(data, opts) {&#13;
	var s = ([]), ss = "";&#13;
	if(!data) return s;&#13;
	/* 18.4.9 sst CT_Sst */&#13;
	var sst = data.match(sstr0);&#13;
	if(sst) {&#13;
		ss = sst[2].replace(sstr1,"").split(sstr2);&#13;
		for(var i = 0; i != ss.length; ++i) {&#13;
			var o = parse_si(ss[i].trim(), opts);&#13;
			if(o != null) s[s.length] = o;&#13;
		}&#13;
		sst = parsexmltag(sst[1]); s.Count = sst.count; s.Unique = sst.uniqueCount;&#13;
	}&#13;
	return s;&#13;
}&#13;
&#13;
var straywsregex = /^\s|\s$|[\t\n\r]/;&#13;
function write_sst_xml(sst, opts) {&#13;
	if(!opts.bookSST) return "";&#13;
	var o = [XML_HEADER];&#13;
	o[o.length] = (writextag('sst', null, {&#13;
		xmlns: XMLNS_main[0],&#13;
		count: sst.Count,&#13;
		uniqueCount: sst.Unique&#13;
	}));&#13;
	for(var i = 0; i != sst.length; ++i) { if(sst[i] == null) continue;&#13;
		var s = sst[i];&#13;
		var sitag = "&lt;si&gt;";&#13;
		if(s.r) sitag += s.r;&#13;
		else {&#13;
			sitag += "&lt;t";&#13;
			if(!s.t) s.t = "";&#13;
			if(typeof s.t !== "string") s.t = String(s.t);&#13;
			if(s.t.match(straywsregex)) sitag += ' xml:space="preserve"';&#13;
			sitag += "&gt;" + escapexml(s.t) + "&lt;/t&gt;";&#13;
		}&#13;
		sitag += "&lt;/si&gt;";&#13;
		o[o.length] = (sitag);&#13;
	}&#13;
	if(o.length&gt;2){ o[o.length] = ('&lt;/sst&gt;'); o[1]=o[1].replace("/&gt;","&gt;"); }&#13;
	return o.join("");&#13;
}&#13;
/* [MS-XLSB] 2.4.221 BrtBeginSst */&#13;
function parse_BrtBeginSst(data) {&#13;
	return [data.read_shift(4), data.read_shift(4)];&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.1.7.45 Shared Strings */&#13;
function parse_sst_bin(data, opts) {&#13;
	var s = ([]);&#13;
	var pass = false;&#13;
	recordhopper(data, function hopper_sst(val, R, RT) {&#13;
		switch(RT) {&#13;
			case 0x009F: /* BrtBeginSst */&#13;
				s.Count = val[0]; s.Unique = val[1]; break;&#13;
			case 0x0013: /* BrtSSTItem */&#13;
				s.push(val); break;&#13;
			case 0x00A0: /* BrtEndSst */&#13;
				return true;&#13;
&#13;
			case 0x0023: /* BrtFRTBegin */&#13;
				pass = true; break;&#13;
			case 0x0024: /* BrtFRTEnd */&#13;
				pass = false; break;&#13;
&#13;
			default:&#13;
				if(R.T){}&#13;
				if(!pass || opts.WTF) throw new Error("Unexpected record 0x" + RT.toString(16));&#13;
		}&#13;
	});&#13;
	return s;&#13;
}&#13;
&#13;
function write_BrtBeginSst(sst, o) {&#13;
	if(!o) o = new_buf(8);&#13;
	o.write_shift(4, sst.Count);&#13;
	o.write_shift(4, sst.Unique);&#13;
	return o;&#13;
}&#13;
&#13;
var write_BrtSSTItem = write_RichStr;&#13;
&#13;
function write_sst_bin(sst) {&#13;
	var ba = buf_array();&#13;
	write_record(ba, 0x009F /* BrtBeginSst */, write_BrtBeginSst(sst));&#13;
	for(var i = 0; i &lt; sst.length; ++i) write_record(ba, 0x0013 /* BrtSSTItem */, write_BrtSSTItem(sst[i]));&#13;
	/* FRTSST */&#13;
	write_record(ba, 0x00A0 /* BrtEndSst */);&#13;
	return ba.end();&#13;
}&#13;
function _JS2ANSI(str) {&#13;
	if(typeof $cptable !== 'undefined') return $cptable.utils.encode(current_ansi, str);&#13;
	var o = [], oo = str.split("");&#13;
	for(var i = 0; i &lt; oo.length; ++i) o[i] = oo[i].charCodeAt(0);&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-OFFCRYPTO] 2.1.4 Version */&#13;
function parse_CRYPTOVersion(blob, length) {&#13;
	var o = {};&#13;
	o.Major = blob.read_shift(2);&#13;
	o.Minor = blob.read_shift(2);&#13;
if(length &gt;= 4) blob.l += length - 4;&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-OFFCRYPTO] 2.1.5 DataSpaceVersionInfo */&#13;
function parse_DataSpaceVersionInfo(blob) {&#13;
	var o = {};&#13;
	o.id = blob.read_shift(0, 'lpp4');&#13;
	o.R = parse_CRYPTOVersion(blob, 4);&#13;
	o.U = parse_CRYPTOVersion(blob, 4);&#13;
	o.W = parse_CRYPTOVersion(blob, 4);&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-OFFCRYPTO] 2.1.6.1 DataSpaceMapEntry Structure */&#13;
function parse_DataSpaceMapEntry(blob) {&#13;
	var len = blob.read_shift(4);&#13;
	var end = blob.l + len - 4;&#13;
	var o = {};&#13;
	var cnt = blob.read_shift(4);&#13;
	var comps = [];&#13;
	/* [MS-OFFCRYPTO] 2.1.6.2 DataSpaceReferenceComponent Structure */&#13;
	while(cnt-- &gt; 0) comps.push({ t: blob.read_shift(4), v: blob.read_shift(0, 'lpp4') });&#13;
	o.name = blob.read_shift(0, 'lpp4');&#13;
	o.comps = comps;&#13;
	if(blob.l != end) throw new Error("Bad DataSpaceMapEntry: " + blob.l + " != " + end);&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-OFFCRYPTO] 2.1.6 DataSpaceMap */&#13;
function parse_DataSpaceMap(blob) {&#13;
	var o = [];&#13;
	blob.l += 4; // must be 0x8&#13;
	var cnt = blob.read_shift(4);&#13;
	while(cnt-- &gt; 0) o.push(parse_DataSpaceMapEntry(blob));&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-OFFCRYPTO] 2.1.7 DataSpaceDefinition */&#13;
function parse_DataSpaceDefinition(blob) {&#13;
	var o = [];&#13;
	blob.l += 4; // must be 0x8&#13;
	var cnt = blob.read_shift(4);&#13;
	while(cnt-- &gt; 0) o.push(blob.read_shift(0, 'lpp4'));&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-OFFCRYPTO] 2.1.8 DataSpaceDefinition */&#13;
function parse_TransformInfoHeader(blob) {&#13;
	var o = {};&#13;
	/*var len = */blob.read_shift(4);&#13;
	blob.l += 4; // must be 0x1&#13;
	o.id = blob.read_shift(0, 'lpp4');&#13;
	o.name = blob.read_shift(0, 'lpp4');&#13;
	o.R = parse_CRYPTOVersion(blob, 4);&#13;
	o.U = parse_CRYPTOVersion(blob, 4);&#13;
	o.W = parse_CRYPTOVersion(blob, 4);&#13;
	return o;&#13;
}&#13;
&#13;
function parse_Primary(blob) {&#13;
	/* [MS-OFFCRYPTO] 2.2.6 IRMDSTransformInfo */&#13;
	var hdr = parse_TransformInfoHeader(blob);&#13;
	/* [MS-OFFCRYPTO] 2.1.9 EncryptionTransformInfo */&#13;
	hdr.ename = blob.read_shift(0, '8lpp4');&#13;
	hdr.blksz = blob.read_shift(4);&#13;
	hdr.cmode = blob.read_shift(4);&#13;
	if(blob.read_shift(4) != 0x04) throw new Error("Bad !Primary record");&#13;
	return hdr;&#13;
}&#13;
&#13;
/* [MS-OFFCRYPTO] 2.3.2 Encryption Header */&#13;
function parse_EncryptionHeader(blob, length) {&#13;
	var tgt = blob.l + length;&#13;
	var o = {};&#13;
	o.Flags = (blob.read_shift(4) &amp; 0x3F);&#13;
	blob.l += 4;&#13;
	o.AlgID = blob.read_shift(4);&#13;
	var valid = false;&#13;
	switch(o.AlgID) {&#13;
		case 0x660E: case 0x660F: case 0x6610: valid = (o.Flags == 0x24); break;&#13;
		case 0x6801: valid = (o.Flags == 0x04); break;&#13;
		case 0: valid = (o.Flags == 0x10 || o.Flags == 0x04 || o.Flags == 0x24); break;&#13;
		default: throw 'Unrecognized encryption algorithm: ' + o.AlgID;&#13;
	}&#13;
	if(!valid) throw new Error("Encryption Flags/AlgID mismatch");&#13;
	o.AlgIDHash = blob.read_shift(4);&#13;
	o.KeySize = blob.read_shift(4);&#13;
	o.ProviderType = blob.read_shift(4);&#13;
	blob.l += 8;&#13;
	o.CSPName = blob.read_shift((tgt-blob.l)&gt;&gt;1, 'utf16le');&#13;
	blob.l = tgt;&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-OFFCRYPTO] 2.3.3 Encryption Verifier */&#13;
function parse_EncryptionVerifier(blob, length) {&#13;
	var o = {}, tgt = blob.l + length;&#13;
	blob.l += 4; // SaltSize must be 0x10&#13;
	o.Salt = blob.slice(blob.l, blob.l+16); blob.l += 16;&#13;
	o.Verifier = blob.slice(blob.l, blob.l+16); blob.l += 16;&#13;
	/*var sz = */blob.read_shift(4);&#13;
	o.VerifierHash = blob.slice(blob.l, tgt); blob.l = tgt;&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-OFFCRYPTO] 2.3.4.* EncryptionInfo Stream */&#13;
function parse_EncryptionInfo(blob) {&#13;
	var vers = parse_CRYPTOVersion(blob);&#13;
	switch(vers.Minor) {&#13;
		case 0x02: return [vers.Minor, parse_EncInfoStd(blob, vers)];&#13;
		case 0x03: return [vers.Minor, parse_EncInfoExt(blob, vers)];&#13;
		case 0x04: return [vers.Minor, parse_EncInfoAgl(blob, vers)];&#13;
	}&#13;
	throw new Error("ECMA-376 Encrypted file unrecognized Version: " + vers.Minor);&#13;
}&#13;
&#13;
/* [MS-OFFCRYPTO] 2.3.4.5  EncryptionInfo Stream (Standard Encryption) */&#13;
function parse_EncInfoStd(blob) {&#13;
	var flags = blob.read_shift(4);&#13;
	if((flags &amp; 0x3F) != 0x24) throw new Error("EncryptionInfo mismatch");&#13;
	var sz = blob.read_shift(4);&#13;
	//var tgt = blob.l + sz;&#13;
	var hdr = parse_EncryptionHeader(blob, sz);&#13;
	var verifier = parse_EncryptionVerifier(blob, blob.length - blob.l);&#13;
	return { t:"Std", h:hdr, v:verifier };&#13;
}&#13;
/* [MS-OFFCRYPTO] 2.3.4.6  EncryptionInfo Stream (Extensible Encryption) */&#13;
function parse_EncInfoExt() { throw new Error("File is password-protected: ECMA-376 Extensible"); }&#13;
/* [MS-OFFCRYPTO] 2.3.4.10 EncryptionInfo Stream (Agile Encryption) */&#13;
function parse_EncInfoAgl(blob) {&#13;
	var KeyData = ["saltSize","blockSize","keyBits","hashSize","cipherAlgorithm","cipherChaining","hashAlgorithm","saltValue"];&#13;
	blob.l+=4;&#13;
	var xml = blob.read_shift(blob.length - blob.l, 'utf8');&#13;
	var o = {};&#13;
	xml.replace(tagregex, function xml_agile(x) {&#13;
		var y = parsexmltag(x);&#13;
		switch(strip_ns(y[0])) {&#13;
			case '&lt;?xml': break;&#13;
			case '&lt;encryption': case '&lt;/encryption&gt;': break;&#13;
			case '&lt;keyData': KeyData.forEach(function(k) { o[k] = y[k]; }); break;&#13;
			case '&lt;dataIntegrity': o.encryptedHmacKey = y.encryptedHmacKey; o.encryptedHmacValue = y.encryptedHmacValue; break;&#13;
			case '&lt;keyEncryptors&gt;': case '&lt;keyEncryptors': o.encs = []; break;&#13;
			case '&lt;/keyEncryptors&gt;': break;&#13;
&#13;
			case '&lt;keyEncryptor': o.uri = y.uri; break;&#13;
			case '&lt;/keyEncryptor&gt;': break;&#13;
			case '&lt;encryptedKey': o.encs.push(y); break;&#13;
			default: throw y[0];&#13;
		}&#13;
	});&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-OFFCRYPTO] 2.3.5.1 RC4 CryptoAPI Encryption Header */&#13;
function parse_RC4CryptoHeader(blob, length) {&#13;
	var o = {};&#13;
	var vers = o.EncryptionVersionInfo = parse_CRYPTOVersion(blob, 4); length -= 4;&#13;
	if(vers.Minor != 2) throw new Error('unrecognized minor version code: ' + vers.Minor);&#13;
	if(vers.Major &gt; 4 || vers.Major &lt; 2) throw new Error('unrecognized major version code: ' + vers.Major);&#13;
	o.Flags = blob.read_shift(4); length -= 4;&#13;
	var sz = blob.read_shift(4); length -= 4;&#13;
	o.EncryptionHeader = parse_EncryptionHeader(blob, sz); length -= sz;&#13;
	o.EncryptionVerifier = parse_EncryptionVerifier(blob, length);&#13;
	return o;&#13;
}&#13;
/* [MS-OFFCRYPTO] 2.3.6.1 RC4 Encryption Header */&#13;
function parse_RC4Header(blob) {&#13;
	var o = {};&#13;
	var vers = o.EncryptionVersionInfo = parse_CRYPTOVersion(blob, 4);&#13;
	if(vers.Major != 1 || vers.Minor != 1) throw 'unrecognized version code ' + vers.Major + ' : ' + vers.Minor;&#13;
	o.Salt = blob.read_shift(16);&#13;
	o.EncryptedVerifier = blob.read_shift(16);&#13;
	o.EncryptedVerifierHash = blob.read_shift(16);&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-OFFCRYPTO] 2.3.7.1 Binary Document Password Verifier Derivation */&#13;
function crypto_CreatePasswordVerifier_Method1(Password) {&#13;
	var Verifier = 0x0000, PasswordArray;&#13;
	var PasswordDecoded = _JS2ANSI(Password);&#13;
	var len = PasswordDecoded.length + 1, i, PasswordByte;&#13;
	var Intermediate1, Intermediate2, Intermediate3;&#13;
	PasswordArray = new_raw_buf(len);&#13;
	PasswordArray[0] = PasswordDecoded.length;&#13;
	for(i = 1; i != len; ++i) PasswordArray[i] = PasswordDecoded[i-1];&#13;
	for(i = len-1; i &gt;= 0; --i) {&#13;
		PasswordByte = PasswordArray[i];&#13;
		Intermediate1 = ((Verifier &amp; 0x4000) === 0x0000) ? 0 : 1;&#13;
		Intermediate2 = (Verifier &lt;&lt; 1) &amp; 0x7FFF;&#13;
		Intermediate3 = Intermediate1 | Intermediate2;&#13;
		Verifier = Intermediate3 ^ PasswordByte;&#13;
	}&#13;
	return Verifier ^ 0xCE4B;&#13;
}&#13;
&#13;
/* [MS-OFFCRYPTO] 2.3.7.2 Binary Document XOR Array Initialization */&#13;
var crypto_CreateXorArray_Method1 = (function() {&#13;
	var PadArray = [0xBB, 0xFF, 0xFF, 0xBA, 0xFF, 0xFF, 0xB9, 0x80, 0x00, 0xBE, 0x0F, 0x00, 0xBF, 0x0F, 0x00];&#13;
	var InitialCode = [0xE1F0, 0x1D0F, 0xCC9C, 0x84C0, 0x110C, 0x0E10, 0xF1CE, 0x313E, 0x1872, 0xE139, 0xD40F, 0x84F9, 0x280C, 0xA96A, 0x4EC3];&#13;
	var XorMatrix = [0xAEFC, 0x4DD9, 0x9BB2, 0x2745, 0x4E8A, 0x9D14, 0x2A09, 0x7B61, 0xF6C2, 0xFDA5, 0xEB6B, 0xC6F7, 0x9DCF, 0x2BBF, 0x4563, 0x8AC6, 0x05AD, 0x0B5A, 0x16B4, 0x2D68, 0x5AD0, 0x0375, 0x06EA, 0x0DD4, 0x1BA8, 0x3750, 0x6EA0, 0xDD40, 0xD849, 0xA0B3, 0x5147, 0xA28E, 0x553D, 0xAA7A, 0x44D5, 0x6F45, 0xDE8A, 0xAD35, 0x4A4B, 0x9496, 0x390D, 0x721A, 0xEB23, 0xC667, 0x9CEF, 0x29FF, 0x53FE, 0xA7FC, 0x5FD9, 0x47D3, 0x8FA6, 0x0F6D, 0x1EDA, 0x3DB4, 0x7B68, 0xF6D0, 0xB861, 0x60E3, 0xC1C6, 0x93AD, 0x377B, 0x6EF6, 0xDDEC, 0x45A0, 0x8B40, 0x06A1, 0x0D42, 0x1A84, 0x3508, 0x6A10, 0xAA51, 0x4483, 0x8906, 0x022D, 0x045A, 0x08B4, 0x1168, 0x76B4, 0xED68, 0xCAF1, 0x85C3, 0x1BA7, 0x374E, 0x6E9C, 0x3730, 0x6E60, 0xDCC0, 0xA9A1, 0x4363, 0x86C6, 0x1DAD, 0x3331, 0x6662, 0xCCC4, 0x89A9, 0x0373, 0x06E6, 0x0DCC, 0x1021, 0x2042, 0x4084, 0x8108, 0x1231, 0x2462, 0x48C4];&#13;
	var Ror = function(Byte) { return ((Byte/2) | (Byte*128)) &amp; 0xFF; };&#13;
	var XorRor = function(byte1, byte2) { return Ror(byte1 ^ byte2); };&#13;
	var CreateXorKey_Method1 = function(Password) {&#13;
		var XorKey = InitialCode[Password.length - 1];&#13;
		var CurrentElement = 0x68;&#13;
		for(var i = Password.length-1; i &gt;= 0; --i) {&#13;
			var Char = Password[i];&#13;
			for(var j = 0; j != 7; ++j) {&#13;
				if(Char &amp; 0x40) XorKey ^= XorMatrix[CurrentElement];&#13;
				Char *= 2; --CurrentElement;&#13;
			}&#13;
		}&#13;
		return XorKey;&#13;
	};&#13;
	return function(password) {&#13;
		var Password = _JS2ANSI(password);&#13;
		var XorKey = CreateXorKey_Method1(Password);&#13;
		var Index = Password.length;&#13;
		var ObfuscationArray = new_raw_buf(16);&#13;
		for(var i = 0; i != 16; ++i) ObfuscationArray[i] = 0x00;&#13;
		var Temp, PasswordLastChar, PadIndex;&#13;
		if((Index &amp; 1) === 1) {&#13;
			Temp = XorKey &gt;&gt; 8;&#13;
			ObfuscationArray[Index] = XorRor(PadArray[0], Temp);&#13;
			--Index;&#13;
			Temp = XorKey &amp; 0xFF;&#13;
			PasswordLastChar = Password[Password.length - 1];&#13;
			ObfuscationArray[Index] = XorRor(PasswordLastChar, Temp);&#13;
		}&#13;
		while(Index &gt; 0) {&#13;
			--Index;&#13;
			Temp = XorKey &gt;&gt; 8;&#13;
			ObfuscationArray[Index] = XorRor(Password[Index], Temp);&#13;
			--Index;&#13;
			Temp = XorKey &amp; 0xFF;&#13;
			ObfuscationArray[Index] = XorRor(Password[Index], Temp);&#13;
		}&#13;
		Index = 15;&#13;
		PadIndex = 15 - Password.length;&#13;
		while(PadIndex &gt; 0) {&#13;
			Temp = XorKey &gt;&gt; 8;&#13;
			ObfuscationArray[Index] = XorRor(PadArray[PadIndex], Temp);&#13;
			--Index;&#13;
			--PadIndex;&#13;
			Temp = XorKey &amp; 0xFF;&#13;
			ObfuscationArray[Index] = XorRor(Password[Index], Temp);&#13;
			--Index;&#13;
			--PadIndex;&#13;
		}&#13;
		return ObfuscationArray;&#13;
	};&#13;
})();&#13;
&#13;
/* [MS-OFFCRYPTO] 2.3.7.3 Binary Document XOR Data Transformation Method 1 */&#13;
var crypto_DecryptData_Method1 = function(password, Data, XorArrayIndex, XorArray, O) {&#13;
	/* If XorArray is set, use it; if O is not set, make changes in-place */&#13;
	if(!O) O = Data;&#13;
	if(!XorArray) XorArray = crypto_CreateXorArray_Method1(password);&#13;
	var Index, Value;&#13;
	for(Index = 0; Index != Data.length; ++Index) {&#13;
		Value = Data[Index];&#13;
		Value ^= XorArray[XorArrayIndex];&#13;
		Value = ((Value&gt;&gt;5) | (Value&lt;&lt;3)) &amp; 0xFF;&#13;
		O[Index] = Value;&#13;
		++XorArrayIndex;&#13;
	}&#13;
	return [O, XorArrayIndex, XorArray];&#13;
};&#13;
&#13;
var crypto_MakeXorDecryptor = function(password) {&#13;
	var XorArrayIndex = 0, XorArray = crypto_CreateXorArray_Method1(password);&#13;
	return function(Data) {&#13;
		var O = crypto_DecryptData_Method1("", Data, XorArrayIndex, XorArray);&#13;
		XorArrayIndex = O[1];&#13;
		return O[0];&#13;
	};&#13;
};&#13;
&#13;
/* 2.5.343 */&#13;
function parse_XORObfuscation(blob, length, opts, out) {&#13;
	var o = ({ key: parseuint16(blob), verificationBytes: parseuint16(blob) });&#13;
	if(opts.password) o.verifier = crypto_CreatePasswordVerifier_Method1(opts.password);&#13;
	out.valid = o.verificationBytes === o.verifier;&#13;
	if(out.valid) out.insitu = crypto_MakeXorDecryptor(opts.password);&#13;
	return o;&#13;
}&#13;
&#13;
/* 2.4.117 */&#13;
function parse_FilePassHeader(blob, length, oo) {&#13;
	var o = oo || {}; o.Info = blob.read_shift(2); blob.l -= 2;&#13;
	if(o.Info === 1) o.Data = parse_RC4Header(blob, length);&#13;
	else o.Data = parse_RC4CryptoHeader(blob, length);&#13;
	return o;&#13;
}&#13;
function parse_FilePass(blob, length, opts) {&#13;
	var o = ({ Type: opts.biff &gt;= 8 ? blob.read_shift(2) : 0 }); /* wEncryptionType */&#13;
	if(o.Type) parse_FilePassHeader(blob, length-2, o);&#13;
	else parse_XORObfuscation(blob, opts.biff &gt;= 8 ? length : length - 2, opts, o);&#13;
	return o;&#13;
}&#13;
&#13;
&#13;
function rtf_to_sheet(d, opts) {&#13;
  switch (opts.type) {&#13;
    case "base64":&#13;
      return rtf_to_sheet_str(Base64_decode(d), opts);&#13;
    case "binary":&#13;
      return rtf_to_sheet_str(d, opts);&#13;
    case "buffer":&#13;
      return rtf_to_sheet_str(has_buf &amp;&amp; Buffer.isBuffer(d) ? d.toString("binary") : a2s(d), opts);&#13;
    case "array":&#13;
      return rtf_to_sheet_str(cc2str(d), opts);&#13;
  }&#13;
  throw new Error("Unrecognized type " + opts.type);&#13;
}&#13;
function rtf_to_sheet_str(str, opts) {&#13;
  var o = opts || {};&#13;
  var ws = o.dense ? [] : {};&#13;
  var rows = str.match(/\\trowd[\s\S]*?\\row\b/g);&#13;
  if (!rows)&#13;
    throw new Error("RTF missing table");&#13;
  var range = { s: { c: 0, r: 0 }, e: { c: 0, r: rows.length - 1 } };&#13;
  rows.forEach(function(rowtf, R) {&#13;
    if (Array.isArray(ws))&#13;
      ws[R] = [];&#13;
    var rtfre = /\\[\w\-]+\b/g;&#13;
    var last_index = 0;&#13;
    var res;&#13;
    var C = -1;&#13;
    var payload = [];&#13;
    while ((res = rtfre.exec(rowtf)) != null) {&#13;
      var data = rowtf.slice(last_index, rtfre.lastIndex - res[0].length);&#13;
      if (data.charCodeAt(0) == 32)&#13;
        data = data.slice(1);&#13;
      if (data.length)&#13;
        payload.push(data);&#13;
      switch (res[0]) {&#13;
        case "\\cell":&#13;
          ++C;&#13;
          if (payload.length) {&#13;
            var cell = { v: payload.join(""), t: "s" };&#13;
            if (cell.v == "TRUE" || cell.v == "FALSE") {&#13;
              cell.v = cell.v == "TRUE";&#13;
              cell.t = "b";&#13;
            } else if (!isNaN(fuzzynum(cell.v))) {&#13;
              cell.t = "n";&#13;
              if (o.cellText !== false)&#13;
                cell.w = cell.v;&#13;
              cell.v = fuzzynum(cell.v);&#13;
            }&#13;
            if (Array.isArray(ws))&#13;
              ws[R][C] = cell;&#13;
            else&#13;
              ws[encode_cell({ r: R, c: C })] = cell;&#13;
          }&#13;
          payload = [];&#13;
          break;&#13;
        case "\\par":&#13;
          payload.push("\n");&#13;
          break;&#13;
      }&#13;
      last_index = rtfre.lastIndex;&#13;
    }&#13;
    if (C &gt; range.e.c)&#13;
      range.e.c = C;&#13;
  });&#13;
  ws["!ref"] = encode_range(range);&#13;
  return ws;&#13;
}&#13;
function rtf_to_workbook(d, opts) {&#13;
  var wb = sheet_to_workbook(rtf_to_sheet(d, opts), opts);&#13;
  wb.bookType = "rtf";&#13;
  return wb;&#13;
}&#13;
function sheet_to_rtf(ws, opts) {&#13;
  var o = ["{\\rtf1\\ansi"];&#13;
  if (!ws["!ref"])&#13;
    return o[0] + "}";&#13;
  var r = safe_decode_range(ws["!ref"]), cell;&#13;
  var dense = Array.isArray(ws);&#13;
  for (var R = r.s.r; R &lt;= r.e.r; ++R) {&#13;
    o.push("\\trowd\\trautofit1");&#13;
    for (var C = r.s.c; C &lt;= r.e.c; ++C)&#13;
      o.push("\\cellx" + (C + 1));&#13;
    o.push("\\pard\\intbl");&#13;
    for (C = r.s.c; C &lt;= r.e.c; ++C) {&#13;
      var coord = encode_cell({ r: R, c: C });&#13;
      cell = dense ? (ws[R] || [])[C] : ws[coord];&#13;
      if (!cell || cell.v == null &amp;&amp; (!cell.f || cell.F)) {&#13;
        o.push(" \\cell");&#13;
        continue;&#13;
      }&#13;
      o.push(" " + (cell.w || (format_cell(cell), cell.w) || "").replace(/[\r\n]/g, "\\par "));&#13;
      o.push("\\cell");&#13;
    }&#13;
    o.push("\\pard\\intbl\\row");&#13;
  }&#13;
  return o.join("") + "}";&#13;
}&#13;
function hex2RGB(h) {&#13;
	var o = h.slice(h[0]==="#"?1:0).slice(0,6);&#13;
	return [parseInt(o.slice(0,2),16),parseInt(o.slice(2,4),16),parseInt(o.slice(4,6),16)];&#13;
}&#13;
function rgb2Hex(rgb) {&#13;
	for(var i=0,o=1; i!=3; ++i) o = o*256 + (rgb[i]&gt;255?255:rgb[i]&lt;0?0:rgb[i]);&#13;
	return o.toString(16).toUpperCase().slice(1);&#13;
}&#13;
&#13;
function rgb2HSL(rgb) {&#13;
	var R = rgb[0]/255, G = rgb[1]/255, B=rgb[2]/255;&#13;
	var M = Math.max(R, G, B), m = Math.min(R, G, B), C = M - m;&#13;
	if(C === 0) return [0, 0, R];&#13;
&#13;
	var H6 = 0, S = 0, L2 = (M + m);&#13;
	S = C / (L2 &gt; 1 ? 2 - L2 : L2);&#13;
	switch(M){&#13;
		case R: H6 = ((G - B) / C + 6)%6; break;&#13;
		case G: H6 = ((B - R) / C + 2); break;&#13;
		case B: H6 = ((R - G) / C + 4); break;&#13;
	}&#13;
	return [H6 / 6, S, L2 / 2];&#13;
}&#13;
&#13;
function hsl2RGB(hsl){&#13;
	var H = hsl[0], S = hsl[1], L = hsl[2];&#13;
	var C = S * 2 * (L &lt; 0.5 ? L : 1 - L), m = L - C/2;&#13;
	var rgb = [m,m,m], h6 = 6*H;&#13;
&#13;
	var X;&#13;
	if(S !== 0) switch(h6|0) {&#13;
		case 0: case 6: X = C * h6; rgb[0] += C; rgb[1] += X; break;&#13;
		case 1: X = C * (2 - h6);   rgb[0] += X; rgb[1] += C; break;&#13;
		case 2: X = C * (h6 - 2);   rgb[1] += C; rgb[2] += X; break;&#13;
		case 3: X = C * (4 - h6);   rgb[1] += X; rgb[2] += C; break;&#13;
		case 4: X = C * (h6 - 4);   rgb[2] += C; rgb[0] += X; break;&#13;
		case 5: X = C * (6 - h6);   rgb[2] += X; rgb[0] += C; break;&#13;
	}&#13;
	for(var i = 0; i != 3; ++i) rgb[i] = Math.round(rgb[i]*255);&#13;
	return rgb;&#13;
}&#13;
&#13;
/* 18.8.3 bgColor tint algorithm */&#13;
function rgb_tint(hex, tint) {&#13;
	if(tint === 0) return hex;&#13;
	var hsl = rgb2HSL(hex2RGB(hex));&#13;
	if (tint &lt; 0) hsl[2] = hsl[2] * (1 + tint);&#13;
	else hsl[2] = 1 - (1 - hsl[2]) * (1 - tint);&#13;
	return rgb2Hex(hsl2RGB(hsl));&#13;
}&#13;
&#13;
/* 18.3.1.13 width calculations */&#13;
/* [MS-OI29500] 2.1.595 Column Width &amp; Formatting */&#13;
var DEF_MDW = 6, MAX_MDW = 15, MIN_MDW = 1, MDW = DEF_MDW;&#13;
function width2px(width) { return Math.floor(( width + (Math.round(128/MDW))/256 )* MDW ); }&#13;
function px2char(px) { return (Math.floor((px - 5)/MDW * 100 + 0.5))/100; }&#13;
function char2width(chr) { return (Math.round((chr * MDW + 5)/MDW*256))/256; }&#13;
//function px2char_(px) { return (((px - 5)/MDW * 100 + 0.5))/100; }&#13;
//function char2width_(chr) { return (((chr * MDW + 5)/MDW*256))/256; }&#13;
function cycle_width(collw) { return char2width(px2char(width2px(collw))); }&#13;
/* XLSX/XLSB/XLS specify width in units of MDW */&#13;
function find_mdw_colw(collw) {&#13;
	var delta = Math.abs(collw - cycle_width(collw)), _MDW = MDW;&#13;
	if(delta &gt; 0.005) for(MDW=MIN_MDW; MDW&lt;MAX_MDW; ++MDW) if(Math.abs(collw - cycle_width(collw)) &lt;= delta) { delta = Math.abs(collw - cycle_width(collw)); _MDW = MDW; }&#13;
	MDW = _MDW;&#13;
}&#13;
/* XLML specifies width in terms of pixels */&#13;
/*function find_mdw_wpx(wpx) {&#13;
	var delta = Infinity, guess = 0, _MDW = MIN_MDW;&#13;
	for(MDW=MIN_MDW; MDW&lt;MAX_MDW; ++MDW) {&#13;
		guess = char2width_(px2char_(wpx))*256;&#13;
		guess = (guess) % 1;&#13;
		if(guess &gt; 0.5) guess--;&#13;
		if(Math.abs(guess) &lt; delta) { delta = Math.abs(guess); _MDW = MDW; }&#13;
	}&#13;
	MDW = _MDW;&#13;
}*/&#13;
&#13;
function process_col(coll) {&#13;
	if(coll.width) {&#13;
		coll.wpx = width2px(coll.width);&#13;
		coll.wch = px2char(coll.wpx);&#13;
		coll.MDW = MDW;&#13;
	} else if(coll.wpx) {&#13;
		coll.wch = px2char(coll.wpx);&#13;
		coll.width = char2width(coll.wch);&#13;
		coll.MDW = MDW;&#13;
	} else if(typeof coll.wch == 'number') {&#13;
		coll.width = char2width(coll.wch);&#13;
		coll.wpx = width2px(coll.width);&#13;
		coll.MDW = MDW;&#13;
	}&#13;
	if(coll.customWidth) delete coll.customWidth;&#13;
}&#13;
&#13;
var DEF_PPI = 96, PPI = DEF_PPI;&#13;
function px2pt(px) { return px * 96 / PPI; }&#13;
function pt2px(pt) { return pt * PPI / 96; }&#13;
&#13;
/* [MS-EXSPXML3] 2.4.54 ST_enmPattern */&#13;
var XLMLPatternTypeMap = {&#13;
	"None": "none",&#13;
	"Solid": "solid",&#13;
	"Gray50": "mediumGray",&#13;
	"Gray75": "darkGray",&#13;
	"Gray25": "lightGray",&#13;
	"HorzStripe": "darkHorizontal",&#13;
	"VertStripe": "darkVertical",&#13;
	"ReverseDiagStripe": "darkDown",&#13;
	"DiagStripe": "darkUp",&#13;
	"DiagCross": "darkGrid",&#13;
	"ThickDiagCross": "darkTrellis",&#13;
	"ThinHorzStripe": "lightHorizontal",&#13;
	"ThinVertStripe": "lightVertical",&#13;
	"ThinReverseDiagStripe": "lightDown",&#13;
	"ThinHorzCross": "lightGrid"&#13;
};&#13;
&#13;
/* 18.8.5 borders CT_Borders */&#13;
function parse_borders(t, styles, themes, opts) {&#13;
	styles.Borders = [];&#13;
	var border = {};&#13;
	var pass = false;&#13;
	(t[0].match(tagregex)||[]).forEach(function(x) {&#13;
		var y = parsexmltag(x);&#13;
		switch(strip_ns(y[0])) {&#13;
			case '&lt;borders': case '&lt;borders&gt;': case '&lt;/borders&gt;': break;&#13;
&#13;
			/* 18.8.4 border CT_Border */&#13;
			case '&lt;border': case '&lt;border&gt;': case '&lt;border/&gt;':&#13;
				border = {};&#13;
				if(y.diagonalUp) border.diagonalUp = parsexmlbool(y.diagonalUp);&#13;
				if(y.diagonalDown) border.diagonalDown = parsexmlbool(y.diagonalDown);&#13;
				styles.Borders.push(border);&#13;
				break;&#13;
			case '&lt;/border&gt;': break;&#13;
&#13;
			/* note: not in spec, appears to be CT_BorderPr */&#13;
			case '&lt;left/&gt;': break;&#13;
			case '&lt;left': case '&lt;left&gt;': break;&#13;
			case '&lt;/left&gt;': break;&#13;
&#13;
			/* note: not in spec, appears to be CT_BorderPr */&#13;
			case '&lt;right/&gt;': break;&#13;
			case '&lt;right': case '&lt;right&gt;': break;&#13;
			case '&lt;/right&gt;': break;&#13;
&#13;
			/* 18.8.43 top CT_BorderPr */&#13;
			case '&lt;top/&gt;': break;&#13;
			case '&lt;top': case '&lt;top&gt;': break;&#13;
			case '&lt;/top&gt;': break;&#13;
&#13;
			/* 18.8.6 bottom CT_BorderPr */&#13;
			case '&lt;bottom/&gt;': break;&#13;
			case '&lt;bottom': case '&lt;bottom&gt;': break;&#13;
			case '&lt;/bottom&gt;': break;&#13;
&#13;
			/* 18.8.13 diagonal CT_BorderPr */&#13;
			case '&lt;diagonal': case '&lt;diagonal&gt;': case '&lt;diagonal/&gt;': break;&#13;
			case '&lt;/diagonal&gt;': break;&#13;
&#13;
			/* 18.8.25 horizontal CT_BorderPr */&#13;
			case '&lt;horizontal': case '&lt;horizontal&gt;': case '&lt;horizontal/&gt;': break;&#13;
			case '&lt;/horizontal&gt;': break;&#13;
&#13;
			/* 18.8.44 vertical CT_BorderPr */&#13;
			case '&lt;vertical': case '&lt;vertical&gt;': case '&lt;vertical/&gt;': break;&#13;
			case '&lt;/vertical&gt;': break;&#13;
&#13;
			/* 18.8.37 start CT_BorderPr */&#13;
			case '&lt;start': case '&lt;start&gt;': case '&lt;start/&gt;': break;&#13;
			case '&lt;/start&gt;': break;&#13;
&#13;
			/* 18.8.16 end CT_BorderPr */&#13;
			case '&lt;end': case '&lt;end&gt;': case '&lt;end/&gt;': break;&#13;
			case '&lt;/end&gt;': break;&#13;
&#13;
			/* 18.8.? color CT_Color */&#13;
			case '&lt;color': case '&lt;color&gt;':&#13;
				break;&#13;
			case '&lt;color/&gt;': case '&lt;/color&gt;': break;&#13;
&#13;
			/* 18.2.10 extLst CT_ExtensionList ? */&#13;
			case '&lt;extLst': case '&lt;extLst&gt;': case '&lt;/extLst&gt;': break;&#13;
			case '&lt;ext': pass = true; break;&#13;
			case '&lt;/ext&gt;': pass = false; break;&#13;
			default: if(opts &amp;&amp; opts.WTF) {&#13;
				if(!pass) throw new Error('unrecognized ' + y[0] + ' in borders');&#13;
			}&#13;
		}&#13;
	});&#13;
}&#13;
&#13;
/* 18.8.21 fills CT_Fills */&#13;
function parse_fills(t, styles, themes, opts) {&#13;
	styles.Fills = [];&#13;
	var fill = {};&#13;
	var pass = false;&#13;
	(t[0].match(tagregex)||[]).forEach(function(x) {&#13;
		var y = parsexmltag(x);&#13;
		switch(strip_ns(y[0])) {&#13;
			case '&lt;fills': case '&lt;fills&gt;': case '&lt;/fills&gt;': break;&#13;
&#13;
			/* 18.8.20 fill CT_Fill */&#13;
			case '&lt;fill&gt;': case '&lt;fill': case '&lt;fill/&gt;':&#13;
				fill = {}; styles.Fills.push(fill); break;&#13;
			case '&lt;/fill&gt;': break;&#13;
&#13;
			/* 18.8.24 gradientFill CT_GradientFill */&#13;
			case '&lt;gradientFill&gt;': break;&#13;
			case '&lt;gradientFill':&#13;
			case '&lt;/gradientFill&gt;': styles.Fills.push(fill); fill = {}; break;&#13;
&#13;
			/* 18.8.32 patternFill CT_PatternFill */&#13;
			case '&lt;patternFill': case '&lt;patternFill&gt;':&#13;
				if(y.patternType) fill.patternType = y.patternType;&#13;
				break;&#13;
			case '&lt;patternFill/&gt;': case '&lt;/patternFill&gt;': break;&#13;
&#13;
			/* 18.8.3 bgColor CT_Color */&#13;
			case '&lt;bgColor':&#13;
				if(!fill.bgColor) fill.bgColor = {};&#13;
				if(y.indexed) fill.bgColor.indexed = parseInt(y.indexed, 10);&#13;
				if(y.theme) fill.bgColor.theme = parseInt(y.theme, 10);&#13;
				if(y.tint) fill.bgColor.tint = parseFloat(y.tint);&#13;
				/* Excel uses ARGB strings */&#13;
				if(y.rgb) fill.bgColor.rgb = y.rgb.slice(-6);&#13;
				break;&#13;
			case '&lt;bgColor/&gt;': case '&lt;/bgColor&gt;': break;&#13;
&#13;
			/* 18.8.19 fgColor CT_Color */&#13;
			case '&lt;fgColor':&#13;
				if(!fill.fgColor) fill.fgColor = {};&#13;
				if(y.theme) fill.fgColor.theme = parseInt(y.theme, 10);&#13;
				if(y.tint) fill.fgColor.tint = parseFloat(y.tint);&#13;
				/* Excel uses ARGB strings */&#13;
				if(y.rgb != null) fill.fgColor.rgb = y.rgb.slice(-6);&#13;
				break;&#13;
			case '&lt;fgColor/&gt;': case '&lt;/fgColor&gt;': break;&#13;
&#13;
			/* 18.8.38 stop CT_GradientStop */&#13;
			case '&lt;stop': case '&lt;stop/&gt;': break;&#13;
			case '&lt;/stop&gt;': break;&#13;
&#13;
			/* 18.8.? color CT_Color */&#13;
			case '&lt;color': case '&lt;color/&gt;': break;&#13;
			case '&lt;/color&gt;': break;&#13;
&#13;
			/* 18.2.10 extLst CT_ExtensionList ? */&#13;
			case '&lt;extLst': case '&lt;extLst&gt;': case '&lt;/extLst&gt;': break;&#13;
			case '&lt;ext': pass = true; break;&#13;
			case '&lt;/ext&gt;': pass = false; break;&#13;
			default: if(opts &amp;&amp; opts.WTF) {&#13;
				if(!pass) throw new Error('unrecognized ' + y[0] + ' in fills');&#13;
			}&#13;
		}&#13;
	});&#13;
}&#13;
&#13;
/* 18.8.23 fonts CT_Fonts */&#13;
function parse_fonts(t, styles, themes, opts) {&#13;
	styles.Fonts = [];&#13;
	var font = {};&#13;
	var pass = false;&#13;
	(t[0].match(tagregex)||[]).forEach(function(x) {&#13;
		var y = parsexmltag(x);&#13;
		switch(strip_ns(y[0])) {&#13;
			case '&lt;fonts': case '&lt;fonts&gt;': case '&lt;/fonts&gt;': break;&#13;
&#13;
			/* 18.8.22 font CT_Font */&#13;
			case '&lt;font': case '&lt;font&gt;': break;&#13;
			case '&lt;/font&gt;': case '&lt;font/&gt;':&#13;
				styles.Fonts.push(font);&#13;
				font = {};&#13;
				break;&#13;
&#13;
			/* 18.8.29 name CT_FontName */&#13;
			case '&lt;name': if(y.val) font.name = utf8read(y.val); break;&#13;
			case '&lt;name/&gt;': case '&lt;/name&gt;': break;&#13;
&#13;
			/* 18.8.2  b CT_BooleanProperty */&#13;
			case '&lt;b': font.bold = y.val ? parsexmlbool(y.val) : 1; break;&#13;
			case '&lt;b/&gt;': font.bold = 1; break;&#13;
&#13;
			/* 18.8.26 i CT_BooleanProperty */&#13;
			case '&lt;i': font.italic = y.val ? parsexmlbool(y.val) : 1; break;&#13;
			case '&lt;i/&gt;': font.italic = 1; break;&#13;
&#13;
			/* 18.4.13 u CT_UnderlineProperty */&#13;
			case '&lt;u':&#13;
				switch(y.val) {&#13;
					case "none": font.underline = 0x00; break;&#13;
					case "single": font.underline = 0x01; break;&#13;
					case "double": font.underline = 0x02; break;&#13;
					case "singleAccounting": font.underline = 0x21; break;&#13;
					case "doubleAccounting": font.underline = 0x22; break;&#13;
				} break;&#13;
			case '&lt;u/&gt;': font.underline = 1; break;&#13;
&#13;
			/* 18.4.10 strike CT_BooleanProperty */&#13;
			case '&lt;strike': font.strike = y.val ? parsexmlbool(y.val) : 1; break;&#13;
			case '&lt;strike/&gt;': font.strike = 1; break;&#13;
&#13;
			/* 18.4.2  outline CT_BooleanProperty */&#13;
			case '&lt;outline': font.outline = y.val ? parsexmlbool(y.val) : 1; break;&#13;
			case '&lt;outline/&gt;': font.outline = 1; break;&#13;
&#13;
			/* 18.8.36 shadow CT_BooleanProperty */&#13;
			case '&lt;shadow': font.shadow = y.val ? parsexmlbool(y.val) : 1; break;&#13;
			case '&lt;shadow/&gt;': font.shadow = 1; break;&#13;
&#13;
			/* 18.8.12 condense CT_BooleanProperty */&#13;
			case '&lt;condense': font.condense = y.val ? parsexmlbool(y.val) : 1; break;&#13;
			case '&lt;condense/&gt;': font.condense = 1; break;&#13;
&#13;
			/* 18.8.17 extend CT_BooleanProperty */&#13;
			case '&lt;extend': font.extend = y.val ? parsexmlbool(y.val) : 1; break;&#13;
			case '&lt;extend/&gt;': font.extend = 1; break;&#13;
&#13;
			/* 18.4.11 sz CT_FontSize */&#13;
			case '&lt;sz': if(y.val) font.sz = +y.val; break;&#13;
			case '&lt;sz/&gt;': case '&lt;/sz&gt;': break;&#13;
&#13;
			/* 18.4.14 vertAlign CT_VerticalAlignFontProperty */&#13;
			case '&lt;vertAlign': if(y.val) font.vertAlign = y.val; break;&#13;
			case '&lt;vertAlign/&gt;': case '&lt;/vertAlign&gt;': break;&#13;
&#13;
			/* 18.8.18 family CT_FontFamily */&#13;
			case '&lt;family': if(y.val) font.family = parseInt(y.val,10); break;&#13;
			case '&lt;family/&gt;': case '&lt;/family&gt;': break;&#13;
&#13;
			/* 18.8.35 scheme CT_FontScheme */&#13;
			case '&lt;scheme': if(y.val) font.scheme = y.val; break;&#13;
			case '&lt;scheme/&gt;': case '&lt;/scheme&gt;': break;&#13;
&#13;
			/* 18.4.1 charset CT_IntProperty */&#13;
			case '&lt;charset':&#13;
				if(y.val == '1') break;&#13;
				y.codepage = CS2CP[parseInt(y.val, 10)];&#13;
				break;&#13;
&#13;
			/* 18.?.? color CT_Color */&#13;
			case '&lt;color':&#13;
				if(!font.color) font.color = {};&#13;
				if(y.auto) font.color.auto = parsexmlbool(y.auto);&#13;
&#13;
				if(y.rgb) font.color.rgb = y.rgb.slice(-6);&#13;
				else if(y.indexed) {&#13;
					font.color.index = parseInt(y.indexed, 10);&#13;
					var icv = XLSIcv[font.color.index];&#13;
					if(font.color.index == 81) icv = XLSIcv[1];&#13;
					if(!icv) icv = XLSIcv[1]; //throw new Error(x); // note: 206 is valid&#13;
					font.color.rgb = icv[0].toString(16) + icv[1].toString(16) + icv[2].toString(16);&#13;
				} else if(y.theme) {&#13;
					font.color.theme = parseInt(y.theme, 10);&#13;
					if(y.tint) font.color.tint = parseFloat(y.tint);&#13;
					if(y.theme &amp;&amp; themes.themeElements &amp;&amp; themes.themeElements.clrScheme) {&#13;
						font.color.rgb = rgb_tint(themes.themeElements.clrScheme[font.color.theme].rgb, font.color.tint || 0);&#13;
					}&#13;
				}&#13;
&#13;
				break;&#13;
			case '&lt;color/&gt;': case '&lt;/color&gt;': break;&#13;
&#13;
			/* note: sometimes mc:AlternateContent appears bare */&#13;
			case '&lt;AlternateContent': pass = true; break;&#13;
			case '&lt;/AlternateContent&gt;': pass = false; break;&#13;
&#13;
			/* 18.2.10 extLst CT_ExtensionList ? */&#13;
			case '&lt;extLst': case '&lt;extLst&gt;': case '&lt;/extLst&gt;': break;&#13;
			case '&lt;ext': pass = true; break;&#13;
			case '&lt;/ext&gt;': pass = false; break;&#13;
			default: if(opts &amp;&amp; opts.WTF) {&#13;
				if(!pass) throw new Error('unrecognized ' + y[0] + ' in fonts');&#13;
			}&#13;
		}&#13;
	});&#13;
}&#13;
&#13;
/* 18.8.31 numFmts CT_NumFmts */&#13;
function parse_numFmts(t, styles, opts) {&#13;
	styles.NumberFmt = [];&#13;
	var k/*Array&lt;number&gt;*/ = (keys(table_fmt));&#13;
	for(var i=0; i &lt; k.length; ++i) styles.NumberFmt[k[i]] = table_fmt[k[i]];&#13;
	var m = t[0].match(tagregex);&#13;
	if(!m) return;&#13;
	for(i=0; i &lt; m.length; ++i) {&#13;
		var y = parsexmltag(m[i]);&#13;
		switch(strip_ns(y[0])) {&#13;
			case '&lt;numFmts': case '&lt;/numFmts&gt;': case '&lt;numFmts/&gt;': case '&lt;numFmts&gt;': break;&#13;
			case '&lt;numFmt': {&#13;
				var f=unescapexml(utf8read(y.formatCode)), j=parseInt(y.numFmtId,10);&#13;
				styles.NumberFmt[j] = f;&#13;
				if(j&gt;0) {&#13;
					if(j &gt; 0x188) {&#13;
						for(j = 0x188; j &gt; 0x3c; --j) if(styles.NumberFmt[j] == null) break;&#13;
						styles.NumberFmt[j] = f;&#13;
					}&#13;
					SSF__load(f,j);&#13;
				}&#13;
			} break;&#13;
			case '&lt;/numFmt&gt;': break;&#13;
			default: if(opts.WTF) throw new Error('unrecognized ' + y[0] + ' in numFmts');&#13;
		}&#13;
	}&#13;
}&#13;
&#13;
function write_numFmts(NF) {&#13;
	var o = ["&lt;numFmts&gt;"];&#13;
	[[5,8],[23,26],[41,44],[/*63*/50,/*66],[164,*/392]].forEach(function(r) {&#13;
		for(var i = r[0]; i &lt;= r[1]; ++i) if(NF[i] != null) o[o.length] = (writextag('numFmt',null,{numFmtId:i,formatCode:escapexml(NF[i])}));&#13;
	});&#13;
	if(o.length === 1) return "";&#13;
	o[o.length] = ("&lt;/numFmts&gt;");&#13;
	o[0] = writextag('numFmts', null, { count:o.length-2 }).replace("/&gt;", "&gt;");&#13;
	return o.join("");&#13;
}&#13;
&#13;
/* 18.8.10 cellXfs CT_CellXfs */&#13;
var cellXF_uint = [ "numFmtId", "fillId", "fontId", "borderId", "xfId" ];&#13;
var cellXF_bool = [ "applyAlignment", "applyBorder", "applyFill", "applyFont", "applyNumberFormat", "applyProtection", "pivotButton", "quotePrefix" ];&#13;
function parse_cellXfs(t, styles, opts) {&#13;
	styles.CellXf = [];&#13;
	var xf;&#13;
	var pass = false;&#13;
	(t[0].match(tagregex)||[]).forEach(function(x) {&#13;
		var y = parsexmltag(x), i = 0;&#13;
		switch(strip_ns(y[0])) {&#13;
			case '&lt;cellXfs': case '&lt;cellXfs&gt;': case '&lt;cellXfs/&gt;': case '&lt;/cellXfs&gt;': break;&#13;
&#13;
			/* 18.8.45 xf CT_Xf */&#13;
			case '&lt;xf': case '&lt;xf/&gt;':&#13;
				xf = y;&#13;
				delete xf[0];&#13;
				for(i = 0; i &lt; cellXF_uint.length; ++i) if(xf[cellXF_uint[i]])&#13;
					xf[cellXF_uint[i]] = parseInt(xf[cellXF_uint[i]], 10);&#13;
				for(i = 0; i &lt; cellXF_bool.length; ++i) if(xf[cellXF_bool[i]])&#13;
					xf[cellXF_bool[i]] = parsexmlbool(xf[cellXF_bool[i]]);&#13;
				if(styles.NumberFmt &amp;&amp; xf.numFmtId &gt; 0x188) {&#13;
					for(i = 0x188; i &gt; 0x3c; --i) if(styles.NumberFmt[xf.numFmtId] == styles.NumberFmt[i]) { xf.numFmtId = i; break; }&#13;
				}&#13;
				styles.CellXf.push(xf); break;&#13;
			case '&lt;/xf&gt;': break;&#13;
&#13;
			/* 18.8.1 alignment CT_CellAlignment */&#13;
			case '&lt;alignment': case '&lt;alignment/&gt;':&#13;
				var alignment = {};&#13;
				if(y.vertical) alignment.vertical = y.vertical;&#13;
				if(y.horizontal) alignment.horizontal = y.horizontal;&#13;
				if(y.textRotation != null) alignment.textRotation = y.textRotation;&#13;
				if(y.indent) alignment.indent = y.indent;&#13;
				if(y.wrapText) alignment.wrapText = parsexmlbool(y.wrapText);&#13;
				xf.alignment = alignment;&#13;
				break;&#13;
			case '&lt;/alignment&gt;': break;&#13;
&#13;
			/* 18.8.33 protection CT_CellProtection */&#13;
			case '&lt;protection':&#13;
				break;&#13;
			case '&lt;/protection&gt;': case '&lt;protection/&gt;': break;&#13;
&#13;
			/* note: sometimes mc:AlternateContent appears bare */&#13;
			case '&lt;AlternateContent': pass = true; break;&#13;
			case '&lt;/AlternateContent&gt;': pass = false; break;&#13;
&#13;
			/* 18.2.10 extLst CT_ExtensionList ? */&#13;
			case '&lt;extLst': case '&lt;extLst&gt;': case '&lt;/extLst&gt;': break;&#13;
			case '&lt;ext': pass = true; break;&#13;
			case '&lt;/ext&gt;': pass = false; break;&#13;
			default: if(opts &amp;&amp; opts.WTF) {&#13;
				if(!pass) throw new Error('unrecognized ' + y[0] + ' in cellXfs');&#13;
			}&#13;
		}&#13;
	});&#13;
}&#13;
&#13;
function write_cellXfs(cellXfs) {&#13;
	var o = [];&#13;
	o[o.length] = (writextag('cellXfs',null));&#13;
	cellXfs.forEach(function(c) {&#13;
		o[o.length] = (writextag('xf', null, c));&#13;
	});&#13;
	o[o.length] = ("&lt;/cellXfs&gt;");&#13;
	if(o.length === 2) return "";&#13;
	o[0] = writextag('cellXfs',null, {count:o.length-2}).replace("/&gt;","&gt;");&#13;
	return o.join("");&#13;
}&#13;
&#13;
/* 18.8 Styles CT_Stylesheet*/&#13;
var parse_sty_xml= (function make_pstyx() {&#13;
var numFmtRegex = /&lt;(?:\w+:)?numFmts([^&gt;]*)&gt;[\S\s]*?&lt;\/(?:\w+:)?numFmts&gt;/;&#13;
var cellXfRegex = /&lt;(?:\w+:)?cellXfs([^&gt;]*)&gt;[\S\s]*?&lt;\/(?:\w+:)?cellXfs&gt;/;&#13;
var fillsRegex = /&lt;(?:\w+:)?fills([^&gt;]*)&gt;[\S\s]*?&lt;\/(?:\w+:)?fills&gt;/;&#13;
var fontsRegex = /&lt;(?:\w+:)?fonts([^&gt;]*)&gt;[\S\s]*?&lt;\/(?:\w+:)?fonts&gt;/;&#13;
var bordersRegex = /&lt;(?:\w+:)?borders([^&gt;]*)&gt;[\S\s]*?&lt;\/(?:\w+:)?borders&gt;/;&#13;
&#13;
return function parse_sty_xml(data, themes, opts) {&#13;
	var styles = {};&#13;
	if(!data) return styles;&#13;
	data = data.replace(/&lt;!--([\s\S]*?)--&gt;/mg,"").replace(/&lt;!DOCTYPE[^\[]*\[[^\]]*\]&gt;/gm,"");&#13;
	/* 18.8.39 styleSheet CT_Stylesheet */&#13;
	var t;&#13;
&#13;
	/* 18.8.31 numFmts CT_NumFmts ? */&#13;
	if((t=data.match(numFmtRegex))) parse_numFmts(t, styles, opts);&#13;
&#13;
	/* 18.8.23 fonts CT_Fonts ? */&#13;
	if((t=data.match(fontsRegex))) parse_fonts(t, styles, themes, opts);&#13;
&#13;
	/* 18.8.21 fills CT_Fills ? */&#13;
	if((t=data.match(fillsRegex))) parse_fills(t, styles, themes, opts);&#13;
&#13;
	/* 18.8.5  borders CT_Borders ? */&#13;
	if((t=data.match(bordersRegex))) parse_borders(t, styles, themes, opts);&#13;
&#13;
	/* 18.8.9  cellStyleXfs CT_CellStyleXfs ? */&#13;
	/* 18.8.8  cellStyles CT_CellStyles ? */&#13;
&#13;
	/* 18.8.10 cellXfs CT_CellXfs ? */&#13;
	if((t=data.match(cellXfRegex))) parse_cellXfs(t, styles, opts);&#13;
&#13;
	/* 18.8.15 dxfs CT_Dxfs ? */&#13;
	/* 18.8.42 tableStyles CT_TableStyles ? */&#13;
	/* 18.8.11 colors CT_Colors ? */&#13;
	/* 18.2.10 extLst CT_ExtensionList ? */&#13;
&#13;
	return styles;&#13;
};&#13;
})();&#13;
&#13;
function write_sty_xml(wb, opts) {&#13;
	var o = [XML_HEADER, writextag('styleSheet', null, {&#13;
		'xmlns': XMLNS_main[0],&#13;
		'xmlns:vt': XMLNS.vt&#13;
	})], w;&#13;
	if(wb.SSF &amp;&amp; (w = write_numFmts(wb.SSF)) != null) o[o.length] = w;&#13;
	o[o.length] = ('&lt;fonts count="1"&gt;&lt;font&gt;&lt;sz val="12"/&gt;&lt;color theme="1"/&gt;&lt;name val="Calibri"/&gt;&lt;family val="2"/&gt;&lt;scheme val="minor"/&gt;&lt;/font&gt;&lt;/fonts&gt;');&#13;
	o[o.length] = ('&lt;fills count="2"&gt;&lt;fill&gt;&lt;patternFill patternType="none"/&gt;&lt;/fill&gt;&lt;fill&gt;&lt;patternFill patternType="gray125"/&gt;&lt;/fill&gt;&lt;/fills&gt;');&#13;
	o[o.length] = ('&lt;borders count="1"&gt;&lt;border&gt;&lt;left/&gt;&lt;right/&gt;&lt;top/&gt;&lt;bottom/&gt;&lt;diagonal/&gt;&lt;/border&gt;&lt;/borders&gt;');&#13;
	o[o.length] = ('&lt;cellStyleXfs count="1"&gt;&lt;xf numFmtId="0" fontId="0" fillId="0" borderId="0"/&gt;&lt;/cellStyleXfs&gt;');&#13;
	if((w = write_cellXfs(opts.cellXfs))) o[o.length] = (w);&#13;
	o[o.length] = ('&lt;cellStyles count="1"&gt;&lt;cellStyle name="Normal" xfId="0" builtinId="0"/&gt;&lt;/cellStyles&gt;');&#13;
	o[o.length] = ('&lt;dxfs count="0"/&gt;');&#13;
	o[o.length] = ('&lt;tableStyles count="0" defaultTableStyle="TableStyleMedium9" defaultPivotStyle="PivotStyleMedium4"/&gt;');&#13;
&#13;
	if(o.length&gt;2){ o[o.length] = ('&lt;/styleSheet&gt;'); o[1]=o[1].replace("/&gt;","&gt;"); }&#13;
	return o.join("");&#13;
}&#13;
/* [MS-XLSB] 2.4.657 BrtFmt */&#13;
function parse_BrtFmt(data, length) {&#13;
	var numFmtId = data.read_shift(2);&#13;
	var stFmtCode = parse_XLWideString(data,length-2);&#13;
	return [numFmtId, stFmtCode];&#13;
}&#13;
function write_BrtFmt(i, f, o) {&#13;
	if(!o) o = new_buf(6 + 4 * f.length);&#13;
	o.write_shift(2, i);&#13;
	write_XLWideString(f, o);&#13;
	var out = (o.length &gt; o.l) ? o.slice(0, o.l) : o;&#13;
	if(o.l == null) o.l = o.length;&#13;
	return out;&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.4.659 BrtFont TODO */&#13;
function parse_BrtFont(data, length, opts) {&#13;
	var out = ({});&#13;
&#13;
	out.sz = data.read_shift(2) / 20;&#13;
&#13;
	var grbit = parse_FontFlags(data, 2, opts);&#13;
	if(grbit.fItalic) out.italic = 1;&#13;
	if(grbit.fCondense) out.condense = 1;&#13;
	if(grbit.fExtend) out.extend = 1;&#13;
	if(grbit.fShadow) out.shadow = 1;&#13;
	if(grbit.fOutline) out.outline = 1;&#13;
	if(grbit.fStrikeout) out.strike = 1;&#13;
&#13;
	var bls = data.read_shift(2);&#13;
	if(bls === 0x02BC) out.bold = 1;&#13;
&#13;
	switch(data.read_shift(2)) {&#13;
		/* case 0: out.vertAlign = "baseline"; break; */&#13;
		case 1: out.vertAlign = "superscript"; break;&#13;
		case 2: out.vertAlign = "subscript"; break;&#13;
	}&#13;
&#13;
	var underline = data.read_shift(1);&#13;
	if(underline != 0) out.underline = underline;&#13;
&#13;
	var family = data.read_shift(1);&#13;
	if(family &gt; 0) out.family = family;&#13;
&#13;
	var bCharSet = data.read_shift(1);&#13;
	if(bCharSet &gt; 0) out.charset = bCharSet;&#13;
&#13;
	data.l++;&#13;
	out.color = parse_BrtColor(data, 8);&#13;
&#13;
	switch(data.read_shift(1)) {&#13;
		/* case 0: out.scheme = "none": break; */&#13;
		case 1: out.scheme = "major"; break;&#13;
		case 2: out.scheme = "minor"; break;&#13;
	}&#13;
&#13;
	out.name = parse_XLWideString(data, length - 21);&#13;
&#13;
	return out;&#13;
}&#13;
function write_BrtFont(font, o) {&#13;
	if(!o) o = new_buf(25+4*32);&#13;
	o.write_shift(2, font.sz * 20);&#13;
	write_FontFlags(font, o);&#13;
	o.write_shift(2, font.bold ? 0x02BC : 0x0190);&#13;
	var sss = 0;&#13;
	if(font.vertAlign == "superscript") sss = 1;&#13;
	else if(font.vertAlign == "subscript") sss = 2;&#13;
	o.write_shift(2, sss);&#13;
	o.write_shift(1, font.underline || 0);&#13;
	o.write_shift(1, font.family || 0);&#13;
	o.write_shift(1, font.charset || 0);&#13;
	o.write_shift(1, 0);&#13;
	write_BrtColor(font.color, o);&#13;
	var scheme = 0;&#13;
	if(font.scheme == "major") scheme = 1;&#13;
	if(font.scheme == "minor") scheme = 2;&#13;
	o.write_shift(1, scheme);&#13;
	write_XLWideString(font.name, o);&#13;
	return o.length &gt; o.l ? o.slice(0, o.l) : o;&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.4.650 BrtFill */&#13;
var XLSBFillPTNames = [&#13;
	"none",&#13;
	"solid",&#13;
	"mediumGray",&#13;
	"darkGray",&#13;
	"lightGray",&#13;
	"darkHorizontal",&#13;
	"darkVertical",&#13;
	"darkDown",&#13;
	"darkUp",&#13;
	"darkGrid",&#13;
	"darkTrellis",&#13;
	"lightHorizontal",&#13;
	"lightVertical",&#13;
	"lightDown",&#13;
	"lightUp",&#13;
	"lightGrid",&#13;
	"lightTrellis",&#13;
	"gray125",&#13;
	"gray0625"&#13;
];&#13;
var rev_XLSBFillPTNames;&#13;
/* TODO: gradient fill representation */&#13;
var parse_BrtFill = parsenoop;&#13;
function write_BrtFill(fill, o) {&#13;
	if(!o) o = new_buf(4*3 + 8*7 + 16*1);&#13;
	if(!rev_XLSBFillPTNames) rev_XLSBFillPTNames = (evert(XLSBFillPTNames));&#13;
	var fls = rev_XLSBFillPTNames[fill.patternType];&#13;
	if(fls == null) fls = 0x28;&#13;
	o.write_shift(4, fls);&#13;
	var j = 0;&#13;
	if(fls != 0x28) {&#13;
		/* TODO: custom FG Color */&#13;
		write_BrtColor({auto:1}, o);&#13;
		/* TODO: custom BG Color */&#13;
		write_BrtColor({auto:1}, o);&#13;
&#13;
		for(; j &lt; 12; ++j) o.write_shift(4, 0);&#13;
	} else {&#13;
		for(; j &lt; 4; ++j) o.write_shift(4, 0);&#13;
&#13;
		for(; j &lt; 12; ++j) o.write_shift(4, 0); /* TODO */&#13;
		/* iGradientType */&#13;
		/* xnumDegree */&#13;
		/* xnumFillToLeft */&#13;
		/* xnumFillToRight */&#13;
		/* xnumFillToTop */&#13;
		/* xnumFillToBottom */&#13;
		/* cNumStop */&#13;
		/* xfillGradientStop */&#13;
	}&#13;
	return o.length &gt; o.l ? o.slice(0, o.l) : o;&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.4.824 BrtXF */&#13;
function parse_BrtXF(data, length) {&#13;
	var tgt = data.l + length;&#13;
	var ixfeParent = data.read_shift(2);&#13;
	var ifmt = data.read_shift(2);&#13;
	data.l = tgt;&#13;
	return {ixfe:ixfeParent, numFmtId:ifmt };&#13;
}&#13;
function write_BrtXF(data, ixfeP, o) {&#13;
	if(!o) o = new_buf(16);&#13;
	o.write_shift(2, ixfeP||0);&#13;
	o.write_shift(2, data.numFmtId||0);&#13;
	o.write_shift(2, 0); /* iFont */&#13;
	o.write_shift(2, 0); /* iFill */&#13;
	o.write_shift(2, 0); /* ixBorder */&#13;
	o.write_shift(1, 0); /* trot */&#13;
	o.write_shift(1, 0); /* indent */&#13;
	var flow = 0;&#13;
	o.write_shift(1, flow); /* flags */&#13;
	o.write_shift(1, 0); /* flags */&#13;
	o.write_shift(1, 0); /* xfGrbitAtr */&#13;
	o.write_shift(1, 0);&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.5.4 Blxf TODO */&#13;
function write_Blxf(data, o) {&#13;
	if(!o) o = new_buf(10);&#13;
	o.write_shift(1, 0); /* dg */&#13;
	o.write_shift(1, 0);&#13;
	o.write_shift(4, 0); /* color */&#13;
	o.write_shift(4, 0); /* color */&#13;
	return o;&#13;
}&#13;
/* [MS-XLSB] 2.4.302 BrtBorder TODO */&#13;
var parse_BrtBorder = parsenoop;&#13;
function write_BrtBorder(border, o) {&#13;
	if(!o) o = new_buf(51);&#13;
	o.write_shift(1, 0); /* diagonal */&#13;
	write_Blxf(null, o); /* top */&#13;
	write_Blxf(null, o); /* bottom */&#13;
	write_Blxf(null, o); /* left */&#13;
	write_Blxf(null, o); /* right */&#13;
	write_Blxf(null, o); /* diag */&#13;
	return o.length &gt; o.l ? o.slice(0, o.l) : o;&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.4.763 BrtStyle TODO */&#13;
function write_BrtStyle(style, o) {&#13;
	if(!o) o = new_buf(12+4*10);&#13;
	o.write_shift(4, style.xfId);&#13;
	o.write_shift(2, 1);&#13;
	o.write_shift(1, +style.builtinId);&#13;
	o.write_shift(1, 0); /* iLevel */&#13;
	write_XLNullableWideString(style.name || "", o);&#13;
	return o.length &gt; o.l ? o.slice(0, o.l) : o;&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.4.272 BrtBeginTableStyles */&#13;
function write_BrtBeginTableStyles(cnt, defTableStyle, defPivotStyle) {&#13;
	var o = new_buf(4+256*2*4);&#13;
	o.write_shift(4, cnt);&#13;
	write_XLNullableWideString(defTableStyle, o);&#13;
	write_XLNullableWideString(defPivotStyle, o);&#13;
	return o.length &gt; o.l ? o.slice(0, o.l) : o;&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.1.7.50 Styles */&#13;
function parse_sty_bin(data, themes, opts) {&#13;
	var styles = {};&#13;
	styles.NumberFmt = ([]);&#13;
	for(var y in table_fmt) styles.NumberFmt[y] = table_fmt[y];&#13;
&#13;
	styles.CellXf = [];&#13;
	styles.Fonts = [];&#13;
	var state = [];&#13;
	var pass = false;&#13;
	recordhopper(data, function hopper_sty(val, R, RT) {&#13;
		switch(RT) {&#13;
			case 0x002C: /* BrtFmt */&#13;
				styles.NumberFmt[val[0]] = val[1]; SSF__load(val[1], val[0]);&#13;
				break;&#13;
			case 0x002B: /* BrtFont */&#13;
				styles.Fonts.push(val);&#13;
				if(val.color.theme != null &amp;&amp; themes &amp;&amp; themes.themeElements &amp;&amp; themes.themeElements.clrScheme) {&#13;
					val.color.rgb = rgb_tint(themes.themeElements.clrScheme[val.color.theme].rgb, val.color.tint || 0);&#13;
				}&#13;
				break;&#13;
			case 0x0401: /* BrtKnownFonts */ break;&#13;
			case 0x002D: /* BrtFill */&#13;
				break;&#13;
			case 0x002E: /* BrtBorder */&#13;
				break;&#13;
			case 0x002F: /* BrtXF */&#13;
				if(state[state.length - 1] == 0x0269 /* BrtBeginCellXFs */) {&#13;
					styles.CellXf.push(val);&#13;
				}&#13;
				break;&#13;
			case 0x0030: /* BrtStyle */&#13;
			case 0x01FB: /* BrtDXF */&#13;
			case 0x023C: /* BrtMRUColor */&#13;
			case 0x01DB: /* BrtIndexedColor */&#13;
				break;&#13;
&#13;
			case 0x0493: /* BrtDXF14 */&#13;
			case 0x0836: /* BrtDXF15 */&#13;
			case 0x046A: /* BrtSlicerStyleElement */&#13;
			case 0x0200: /* BrtTableStyleElement */&#13;
			case 0x082F: /* BrtTimelineStyleElement */&#13;
			case 0x0C00: /* BrtUid */&#13;
				break;&#13;
&#13;
			case 0x0023: /* BrtFRTBegin */&#13;
				pass = true; break;&#13;
			case 0x0024: /* BrtFRTEnd */&#13;
				pass = false; break;&#13;
			case 0x0025: /* BrtACBegin */&#13;
				state.push(RT); pass = true; break;&#13;
			case 0x0026: /* BrtACEnd */&#13;
				state.pop(); pass = false; break;&#13;
&#13;
			default:&#13;
				if(R.T &gt; 0) state.push(RT);&#13;
				else if(R.T &lt; 0) state.pop();&#13;
				else if(!pass || (opts.WTF &amp;&amp; state[state.length-1] != 0x0025 /* BrtACBegin */)) throw new Error("Unexpected record 0x" + RT.toString(16));&#13;
		}&#13;
	});&#13;
	return styles;&#13;
}&#13;
&#13;
function write_FMTS_bin(ba, NF) {&#13;
	if(!NF) return;&#13;
	var cnt = 0;&#13;
	[[5,8],[23,26],[41,44],[/*63*/50,/*66],[164,*/392]].forEach(function(r) {&#13;
for(var i = r[0]; i &lt;= r[1]; ++i) if(NF[i] != null) ++cnt;&#13;
	});&#13;
&#13;
	if(cnt == 0) return;&#13;
	write_record(ba, 0x0267 /* BrtBeginFmts */, write_UInt32LE(cnt));&#13;
	[[5,8],[23,26],[41,44],[/*63*/50,/*66],[164,*/392]].forEach(function(r) {&#13;
for(var i = r[0]; i &lt;= r[1]; ++i) if(NF[i] != null) write_record(ba, 0x002C /* BrtFmt */, write_BrtFmt(i, NF[i]));&#13;
	});&#13;
	write_record(ba, 0x0268 /* BrtEndFmts */);&#13;
}&#13;
&#13;
function write_FONTS_bin(ba) {&#13;
	var cnt = 1;&#13;
&#13;
	if(cnt == 0) return;&#13;
	write_record(ba, 0x0263 /* BrtBeginFonts */, write_UInt32LE(cnt));&#13;
	write_record(ba, 0x002B /* BrtFont */, write_BrtFont({&#13;
		sz:12,&#13;
		color: {theme:1},&#13;
		name: "Calibri",&#13;
		family: 2,&#13;
		scheme: "minor"&#13;
	}));&#13;
	/* 1*65491BrtFont [ACFONTS] */&#13;
	write_record(ba, 0x0264 /* BrtEndFonts */);&#13;
}&#13;
&#13;
function write_FILLS_bin(ba) {&#13;
	var cnt = 2;&#13;
&#13;
	if(cnt == 0) return;&#13;
	write_record(ba, 0x025B /* BrtBeginFills */, write_UInt32LE(cnt));&#13;
	write_record(ba, 0x002D /* BrtFill */, write_BrtFill({patternType:"none"}));&#13;
	write_record(ba, 0x002D /* BrtFill */, write_BrtFill({patternType:"gray125"}));&#13;
	/* 1*65431BrtFill */&#13;
	write_record(ba, 0x025C /* BrtEndFills */);&#13;
}&#13;
&#13;
function write_BORDERS_bin(ba) {&#13;
	var cnt = 1;&#13;
&#13;
	if(cnt == 0) return;&#13;
	write_record(ba, 0x0265 /* BrtBeginBorders */, write_UInt32LE(cnt));&#13;
	write_record(ba, 0x002E /* BrtBorder */, write_BrtBorder({}));&#13;
	/* 1*65430BrtBorder */&#13;
	write_record(ba, 0x0266 /* BrtEndBorders */);&#13;
}&#13;
&#13;
function write_CELLSTYLEXFS_bin(ba) {&#13;
	var cnt = 1;&#13;
	write_record(ba, 0x0272 /* BrtBeginCellStyleXFs */, write_UInt32LE(cnt));&#13;
	write_record(ba, 0x002F /* BrtXF */, write_BrtXF({&#13;
		numFmtId: 0,&#13;
		fontId:   0,&#13;
		fillId:   0,&#13;
		borderId: 0&#13;
	}, 0xFFFF));&#13;
	/* 1*65430(BrtXF *FRT) */&#13;
	write_record(ba, 0x0273 /* BrtEndCellStyleXFs */);&#13;
}&#13;
&#13;
function write_CELLXFS_bin(ba, data) {&#13;
	write_record(ba, 0x0269 /* BrtBeginCellXFs */, write_UInt32LE(data.length));&#13;
	data.forEach(function(c) { write_record(ba, 0x002F /* BrtXF */, write_BrtXF(c,0)); });&#13;
	/* 1*65430(BrtXF *FRT) */&#13;
	write_record(ba, 0x026A /* BrtEndCellXFs */);&#13;
}&#13;
&#13;
function write_STYLES_bin(ba) {&#13;
	var cnt = 1;&#13;
&#13;
	write_record(ba, 0x026B /* BrtBeginStyles */, write_UInt32LE(cnt));&#13;
	write_record(ba, 0x0030 /* BrtStyle */, write_BrtStyle({&#13;
		xfId:0,&#13;
		builtinId:0,&#13;
		name:"Normal"&#13;
	}));&#13;
	/* 1*65430(BrtStyle *FRT) */&#13;
	write_record(ba, 0x026C /* BrtEndStyles */);&#13;
}&#13;
&#13;
function write_DXFS_bin(ba) {&#13;
	var cnt = 0;&#13;
&#13;
	write_record(ba, 0x01F9 /* BrtBeginDXFs */, write_UInt32LE(cnt));&#13;
	/* *2147483647(BrtDXF *FRT) */&#13;
	write_record(ba, 0x01FA /* BrtEndDXFs */);&#13;
}&#13;
&#13;
function write_TABLESTYLES_bin(ba) {&#13;
	var cnt = 0;&#13;
&#13;
	write_record(ba, 0x01FC /* BrtBeginTableStyles */, write_BrtBeginTableStyles(cnt, "TableStyleMedium9", "PivotStyleMedium4"));&#13;
	/* *TABLESTYLE */&#13;
	write_record(ba, 0x01FD /* BrtEndTableStyles */);&#13;
}&#13;
&#13;
function write_COLORPALETTE_bin() {&#13;
	return;&#13;
	/* BrtBeginColorPalette [INDEXEDCOLORS] [MRUCOLORS] BrtEndColorPalette */&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.1.7.50 Styles */&#13;
function write_sty_bin(wb, opts) {&#13;
	var ba = buf_array();&#13;
	write_record(ba, 0x0116 /* BrtBeginStyleSheet */);&#13;
	write_FMTS_bin(ba, wb.SSF);&#13;
	write_FONTS_bin(ba, wb);&#13;
	write_FILLS_bin(ba, wb);&#13;
	write_BORDERS_bin(ba, wb);&#13;
	write_CELLSTYLEXFS_bin(ba, wb);&#13;
	write_CELLXFS_bin(ba, opts.cellXfs);&#13;
	write_STYLES_bin(ba, wb);&#13;
	write_DXFS_bin(ba, wb);&#13;
	write_TABLESTYLES_bin(ba, wb);&#13;
	write_COLORPALETTE_bin(ba, wb);&#13;
	/* FRTSTYLESHEET*/&#13;
	write_record(ba, 0x0117 /* BrtEndStyleSheet */);&#13;
	return ba.end();&#13;
}&#13;
/* Even though theme layout is dk1 lt1 dk2 lt2, true order is lt1 dk1 lt2 dk2 */&#13;
var XLSXThemeClrScheme = [&#13;
	'&lt;/a:lt1&gt;', '&lt;/a:dk1&gt;', '&lt;/a:lt2&gt;', '&lt;/a:dk2&gt;',&#13;
	'&lt;/a:accent1&gt;', '&lt;/a:accent2&gt;', '&lt;/a:accent3&gt;',&#13;
	'&lt;/a:accent4&gt;', '&lt;/a:accent5&gt;', '&lt;/a:accent6&gt;',&#13;
	'&lt;/a:hlink&gt;', '&lt;/a:folHlink&gt;'&#13;
];&#13;
/* 20.1.6.2 clrScheme CT_ColorScheme */&#13;
function parse_clrScheme(t, themes, opts) {&#13;
	themes.themeElements.clrScheme = [];&#13;
	var color = {};&#13;
	(t[0].match(tagregex)||[]).forEach(function(x) {&#13;
		var y = parsexmltag(x);&#13;
		switch(y[0]) {&#13;
			/* 20.1.6.2 clrScheme (Color Scheme) CT_ColorScheme */&#13;
			case '&lt;a:clrScheme': case '&lt;/a:clrScheme&gt;': break;&#13;
&#13;
			/* 20.1.2.3.32 srgbClr CT_SRgbColor */&#13;
			case '&lt;a:srgbClr':&#13;
				color.rgb = y.val; break;&#13;
&#13;
			/* 20.1.2.3.33 sysClr CT_SystemColor */&#13;
			case '&lt;a:sysClr':&#13;
				color.rgb = y.lastClr; break;&#13;
&#13;
			/* 20.1.4.1.1 accent1 (Accent 1) */&#13;
			/* 20.1.4.1.2 accent2 (Accent 2) */&#13;
			/* 20.1.4.1.3 accent3 (Accent 3) */&#13;
			/* 20.1.4.1.4 accent4 (Accent 4) */&#13;
			/* 20.1.4.1.5 accent5 (Accent 5) */&#13;
			/* 20.1.4.1.6 accent6 (Accent 6) */&#13;
			/* 20.1.4.1.9 dk1 (Dark 1) */&#13;
			/* 20.1.4.1.10 dk2 (Dark 2) */&#13;
			/* 20.1.4.1.15 folHlink (Followed Hyperlink) */&#13;
			/* 20.1.4.1.19 hlink (Hyperlink) */&#13;
			/* 20.1.4.1.22 lt1 (Light 1) */&#13;
			/* 20.1.4.1.23 lt2 (Light 2) */&#13;
			case '&lt;a:dk1&gt;': case '&lt;/a:dk1&gt;':&#13;
			case '&lt;a:lt1&gt;': case '&lt;/a:lt1&gt;':&#13;
			case '&lt;a:dk2&gt;': case '&lt;/a:dk2&gt;':&#13;
			case '&lt;a:lt2&gt;': case '&lt;/a:lt2&gt;':&#13;
			case '&lt;a:accent1&gt;': case '&lt;/a:accent1&gt;':&#13;
			case '&lt;a:accent2&gt;': case '&lt;/a:accent2&gt;':&#13;
			case '&lt;a:accent3&gt;': case '&lt;/a:accent3&gt;':&#13;
			case '&lt;a:accent4&gt;': case '&lt;/a:accent4&gt;':&#13;
			case '&lt;a:accent5&gt;': case '&lt;/a:accent5&gt;':&#13;
			case '&lt;a:accent6&gt;': case '&lt;/a:accent6&gt;':&#13;
			case '&lt;a:hlink&gt;': case '&lt;/a:hlink&gt;':&#13;
			case '&lt;a:folHlink&gt;': case '&lt;/a:folHlink&gt;':&#13;
				if (y[0].charAt(1) === '/') {&#13;
					themes.themeElements.clrScheme[XLSXThemeClrScheme.indexOf(y[0])] = color;&#13;
					color = {};&#13;
				} else {&#13;
					color.name = y[0].slice(3, y[0].length - 1);&#13;
				}&#13;
				break;&#13;
&#13;
			default: if(opts &amp;&amp; opts.WTF) throw new Error('Unrecognized ' + y[0] + ' in clrScheme');&#13;
		}&#13;
	});&#13;
}&#13;
&#13;
/* 20.1.4.1.18 fontScheme CT_FontScheme */&#13;
function parse_fontScheme() { }&#13;
&#13;
/* 20.1.4.1.15 fmtScheme CT_StyleMatrix */&#13;
function parse_fmtScheme() { }&#13;
&#13;
var clrsregex = /&lt;a:clrScheme([^&gt;]*)&gt;[\s\S]*&lt;\/a:clrScheme&gt;/;&#13;
var fntsregex = /&lt;a:fontScheme([^&gt;]*)&gt;[\s\S]*&lt;\/a:fontScheme&gt;/;&#13;
var fmtsregex = /&lt;a:fmtScheme([^&gt;]*)&gt;[\s\S]*&lt;\/a:fmtScheme&gt;/;&#13;
&#13;
/* 20.1.6.10 themeElements CT_BaseStyles */&#13;
function parse_themeElements(data, themes, opts) {&#13;
	themes.themeElements = {};&#13;
&#13;
	var t;&#13;
&#13;
	[&#13;
		/* clrScheme CT_ColorScheme */&#13;
		['clrScheme', clrsregex, parse_clrScheme],&#13;
		/* fontScheme CT_FontScheme */&#13;
		['fontScheme', fntsregex, parse_fontScheme],&#13;
		/* fmtScheme CT_StyleMatrix */&#13;
		['fmtScheme', fmtsregex, parse_fmtScheme]&#13;
	].forEach(function(m) {&#13;
		if(!(t=data.match(m[1]))) throw new Error(m[0] + ' not found in themeElements');&#13;
		m[2](t, themes, opts);&#13;
	});&#13;
}&#13;
&#13;
var themeltregex = /&lt;a:themeElements([^&gt;]*)&gt;[\s\S]*&lt;\/a:themeElements&gt;/;&#13;
&#13;
/* 14.2.7 Theme Part */&#13;
function parse_theme_xml(data, opts) {&#13;
	/* 20.1.6.9 theme CT_OfficeStyleSheet */&#13;
	if(!data || data.length === 0) data = write_theme();&#13;
&#13;
	var t;&#13;
	var themes = {};&#13;
&#13;
	/* themeElements CT_BaseStyles */&#13;
	if(!(t=data.match(themeltregex))) throw new Error('themeElements not found in theme');&#13;
	parse_themeElements(t[0], themes, opts);&#13;
	themes.raw = data;&#13;
	return themes;&#13;
}&#13;
&#13;
function write_theme(Themes, opts) {&#13;
	if(opts &amp;&amp; opts.themeXLSX) return opts.themeXLSX;&#13;
	if(Themes &amp;&amp; typeof Themes.raw == "string") return Themes.raw;&#13;
	var o = [XML_HEADER];&#13;
	o[o.length] = '&lt;a:theme xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" name="Office Theme"&gt;';&#13;
	o[o.length] =  '&lt;a:themeElements&gt;';&#13;
&#13;
	o[o.length] =   '&lt;a:clrScheme name="Office"&gt;';&#13;
	o[o.length] =    '&lt;a:dk1&gt;&lt;a:sysClr val="windowText" lastClr="000000"/&gt;&lt;/a:dk1&gt;';&#13;
	o[o.length] =    '&lt;a:lt1&gt;&lt;a:sysClr val="window" lastClr="FFFFFF"/&gt;&lt;/a:lt1&gt;';&#13;
	o[o.length] =    '&lt;a:dk2&gt;&lt;a:srgbClr val="1F497D"/&gt;&lt;/a:dk2&gt;';&#13;
	o[o.length] =    '&lt;a:lt2&gt;&lt;a:srgbClr val="EEECE1"/&gt;&lt;/a:lt2&gt;';&#13;
	o[o.length] =    '&lt;a:accent1&gt;&lt;a:srgbClr val="4F81BD"/&gt;&lt;/a:accent1&gt;';&#13;
	o[o.length] =    '&lt;a:accent2&gt;&lt;a:srgbClr val="C0504D"/&gt;&lt;/a:accent2&gt;';&#13;
	o[o.length] =    '&lt;a:accent3&gt;&lt;a:srgbClr val="9BBB59"/&gt;&lt;/a:accent3&gt;';&#13;
	o[o.length] =    '&lt;a:accent4&gt;&lt;a:srgbClr val="8064A2"/&gt;&lt;/a:accent4&gt;';&#13;
	o[o.length] =    '&lt;a:accent5&gt;&lt;a:srgbClr val="4BACC6"/&gt;&lt;/a:accent5&gt;';&#13;
	o[o.length] =    '&lt;a:accent6&gt;&lt;a:srgbClr val="F79646"/&gt;&lt;/a:accent6&gt;';&#13;
	o[o.length] =    '&lt;a:hlink&gt;&lt;a:srgbClr val="0000FF"/&gt;&lt;/a:hlink&gt;';&#13;
	o[o.length] =    '&lt;a:folHlink&gt;&lt;a:srgbClr val="800080"/&gt;&lt;/a:folHlink&gt;';&#13;
	o[o.length] =   '&lt;/a:clrScheme&gt;';&#13;
&#13;
	o[o.length] =   '&lt;a:fontScheme name="Office"&gt;';&#13;
	o[o.length] =    '&lt;a:majorFont&gt;';&#13;
	o[o.length] =     '&lt;a:latin typeface="Cambria"/&gt;';&#13;
	o[o.length] =     '&lt;a:ea typeface=""/&gt;';&#13;
	o[o.length] =     '&lt;a:cs typeface=""/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Jpan" typeface="ＭＳ Ｐゴシック"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Hang" typeface="맑은 고딕"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Hans" typeface="宋体"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Hant" typeface="新細明體"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Arab" typeface="Times New Roman"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Hebr" typeface="Times New Roman"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Thai" typeface="Tahoma"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Ethi" typeface="Nyala"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Beng" typeface="Vrinda"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Gujr" typeface="Shruti"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Khmr" typeface="MoolBoran"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Knda" typeface="Tunga"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Guru" typeface="Raavi"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Cans" typeface="Euphemia"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Cher" typeface="Plantagenet Cherokee"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Yiii" typeface="Microsoft Yi Baiti"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Tibt" typeface="Microsoft Himalaya"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Thaa" typeface="MV Boli"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Deva" typeface="Mangal"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Telu" typeface="Gautami"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Taml" typeface="Latha"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Syrc" typeface="Estrangelo Edessa"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Orya" typeface="Kalinga"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Mlym" typeface="Kartika"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Laoo" typeface="DokChampa"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Sinh" typeface="Iskoola Pota"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Mong" typeface="Mongolian Baiti"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Viet" typeface="Times New Roman"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Uigh" typeface="Microsoft Uighur"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Geor" typeface="Sylfaen"/&gt;';&#13;
	o[o.length] =    '&lt;/a:majorFont&gt;';&#13;
	o[o.length] =    '&lt;a:minorFont&gt;';&#13;
	o[o.length] =     '&lt;a:latin typeface="Calibri"/&gt;';&#13;
	o[o.length] =     '&lt;a:ea typeface=""/&gt;';&#13;
	o[o.length] =     '&lt;a:cs typeface=""/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Jpan" typeface="ＭＳ Ｐゴシック"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Hang" typeface="맑은 고딕"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Hans" typeface="宋体"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Hant" typeface="新細明體"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Arab" typeface="Arial"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Hebr" typeface="Arial"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Thai" typeface="Tahoma"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Ethi" typeface="Nyala"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Beng" typeface="Vrinda"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Gujr" typeface="Shruti"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Khmr" typeface="DaunPenh"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Knda" typeface="Tunga"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Guru" typeface="Raavi"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Cans" typeface="Euphemia"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Cher" typeface="Plantagenet Cherokee"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Yiii" typeface="Microsoft Yi Baiti"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Tibt" typeface="Microsoft Himalaya"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Thaa" typeface="MV Boli"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Deva" typeface="Mangal"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Telu" typeface="Gautami"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Taml" typeface="Latha"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Syrc" typeface="Estrangelo Edessa"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Orya" typeface="Kalinga"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Mlym" typeface="Kartika"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Laoo" typeface="DokChampa"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Sinh" typeface="Iskoola Pota"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Mong" typeface="Mongolian Baiti"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Viet" typeface="Arial"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Uigh" typeface="Microsoft Uighur"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Geor" typeface="Sylfaen"/&gt;';&#13;
	o[o.length] =    '&lt;/a:minorFont&gt;';&#13;
	o[o.length] =   '&lt;/a:fontScheme&gt;';&#13;
&#13;
	o[o.length] =   '&lt;a:fmtScheme name="Office"&gt;';&#13;
	o[o.length] =    '&lt;a:fillStyleLst&gt;';&#13;
	o[o.length] =     '&lt;a:solidFill&gt;&lt;a:schemeClr val="phClr"/&gt;&lt;/a:solidFill&gt;';&#13;
	o[o.length] =     '&lt;a:gradFill rotWithShape="1"&gt;';&#13;
	o[o.length] =      '&lt;a:gsLst&gt;';&#13;
	o[o.length] =       '&lt;a:gs pos="0"&gt;&lt;a:schemeClr val="phClr"&gt;&lt;a:tint val="50000"/&gt;&lt;a:satMod val="300000"/&gt;&lt;/a:schemeClr&gt;&lt;/a:gs&gt;';&#13;
	o[o.length] =       '&lt;a:gs pos="35000"&gt;&lt;a:schemeClr val="phClr"&gt;&lt;a:tint val="37000"/&gt;&lt;a:satMod val="300000"/&gt;&lt;/a:schemeClr&gt;&lt;/a:gs&gt;';&#13;
	o[o.length] =       '&lt;a:gs pos="100000"&gt;&lt;a:schemeClr val="phClr"&gt;&lt;a:tint val="15000"/&gt;&lt;a:satMod val="350000"/&gt;&lt;/a:schemeClr&gt;&lt;/a:gs&gt;';&#13;
	o[o.length] =      '&lt;/a:gsLst&gt;';&#13;
	o[o.length] =      '&lt;a:lin ang="16200000" scaled="1"/&gt;';&#13;
	o[o.length] =     '&lt;/a:gradFill&gt;';&#13;
	o[o.length] =     '&lt;a:gradFill rotWithShape="1"&gt;';&#13;
	o[o.length] =      '&lt;a:gsLst&gt;';&#13;
	o[o.length] =       '&lt;a:gs pos="0"&gt;&lt;a:schemeClr val="phClr"&gt;&lt;a:tint val="100000"/&gt;&lt;a:shade val="100000"/&gt;&lt;a:satMod val="130000"/&gt;&lt;/a:schemeClr&gt;&lt;/a:gs&gt;';&#13;
	o[o.length] =       '&lt;a:gs pos="100000"&gt;&lt;a:schemeClr val="phClr"&gt;&lt;a:tint val="50000"/&gt;&lt;a:shade val="100000"/&gt;&lt;a:satMod val="350000"/&gt;&lt;/a:schemeClr&gt;&lt;/a:gs&gt;';&#13;
	o[o.length] =      '&lt;/a:gsLst&gt;';&#13;
	o[o.length] =      '&lt;a:lin ang="16200000" scaled="0"/&gt;';&#13;
	o[o.length] =     '&lt;/a:gradFill&gt;';&#13;
	o[o.length] =    '&lt;/a:fillStyleLst&gt;';&#13;
	o[o.length] =    '&lt;a:lnStyleLst&gt;';&#13;
	o[o.length] =     '&lt;a:ln w="9525" cap="flat" cmpd="sng" algn="ctr"&gt;&lt;a:solidFill&gt;&lt;a:schemeClr val="phClr"&gt;&lt;a:shade val="95000"/&gt;&lt;a:satMod val="105000"/&gt;&lt;/a:schemeClr&gt;&lt;/a:solidFill&gt;&lt;a:prstDash val="solid"/&gt;&lt;/a:ln&gt;';&#13;
	o[o.length] =     '&lt;a:ln w="25400" cap="flat" cmpd="sng" algn="ctr"&gt;&lt;a:solidFill&gt;&lt;a:schemeClr val="phClr"/&gt;&lt;/a:solidFill&gt;&lt;a:prstDash val="solid"/&gt;&lt;/a:ln&gt;';&#13;
	o[o.length] =     '&lt;a:ln w="38100" cap="flat" cmpd="sng" algn="ctr"&gt;&lt;a:solidFill&gt;&lt;a:schemeClr val="phClr"/&gt;&lt;/a:solidFill&gt;&lt;a:prstDash val="solid"/&gt;&lt;/a:ln&gt;';&#13;
	o[o.length] =    '&lt;/a:lnStyleLst&gt;';&#13;
	o[o.length] =    '&lt;a:effectStyleLst&gt;';&#13;
	o[o.length] =     '&lt;a:effectStyle&gt;';&#13;
	o[o.length] =      '&lt;a:effectLst&gt;';&#13;
	o[o.length] =       '&lt;a:outerShdw blurRad="40000" dist="20000" dir="5400000" rotWithShape="0"&gt;&lt;a:srgbClr val="000000"&gt;&lt;a:alpha val="38000"/&gt;&lt;/a:srgbClr&gt;&lt;/a:outerShdw&gt;';&#13;
	o[o.length] =      '&lt;/a:effectLst&gt;';&#13;
	o[o.length] =     '&lt;/a:effectStyle&gt;';&#13;
	o[o.length] =     '&lt;a:effectStyle&gt;';&#13;
	o[o.length] =      '&lt;a:effectLst&gt;';&#13;
	o[o.length] =       '&lt;a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"&gt;&lt;a:srgbClr val="000000"&gt;&lt;a:alpha val="35000"/&gt;&lt;/a:srgbClr&gt;&lt;/a:outerShdw&gt;';&#13;
	o[o.length] =      '&lt;/a:effectLst&gt;';&#13;
	o[o.length] =     '&lt;/a:effectStyle&gt;';&#13;
	o[o.length] =     '&lt;a:effectStyle&gt;';&#13;
	o[o.length] =      '&lt;a:effectLst&gt;';&#13;
	o[o.length] =       '&lt;a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"&gt;&lt;a:srgbClr val="000000"&gt;&lt;a:alpha val="35000"/&gt;&lt;/a:srgbClr&gt;&lt;/a:outerShdw&gt;';&#13;
	o[o.length] =      '&lt;/a:effectLst&gt;';&#13;
	o[o.length] =      '&lt;a:scene3d&gt;&lt;a:camera prst="orthographicFront"&gt;&lt;a:rot lat="0" lon="0" rev="0"/&gt;&lt;/a:camera&gt;&lt;a:lightRig rig="threePt" dir="t"&gt;&lt;a:rot lat="0" lon="0" rev="1200000"/&gt;&lt;/a:lightRig&gt;&lt;/a:scene3d&gt;';&#13;
	o[o.length] =      '&lt;a:sp3d&gt;&lt;a:bevelT w="63500" h="25400"/&gt;&lt;/a:sp3d&gt;';&#13;
	o[o.length] =     '&lt;/a:effectStyle&gt;';&#13;
	o[o.length] =    '&lt;/a:effectStyleLst&gt;';&#13;
	o[o.length] =    '&lt;a:bgFillStyleLst&gt;';&#13;
	o[o.length] =     '&lt;a:solidFill&gt;&lt;a:schemeClr val="phClr"/&gt;&lt;/a:solidFill&gt;';&#13;
	o[o.length] =     '&lt;a:gradFill rotWithShape="1"&gt;';&#13;
	o[o.length] =      '&lt;a:gsLst&gt;';&#13;
	o[o.length] =       '&lt;a:gs pos="0"&gt;&lt;a:schemeClr val="phClr"&gt;&lt;a:tint val="40000"/&gt;&lt;a:satMod val="350000"/&gt;&lt;/a:schemeClr&gt;&lt;/a:gs&gt;';&#13;
	o[o.length] =       '&lt;a:gs pos="40000"&gt;&lt;a:schemeClr val="phClr"&gt;&lt;a:tint val="45000"/&gt;&lt;a:shade val="99000"/&gt;&lt;a:satMod val="350000"/&gt;&lt;/a:schemeClr&gt;&lt;/a:gs&gt;';&#13;
	o[o.length] =       '&lt;a:gs pos="100000"&gt;&lt;a:schemeClr val="phClr"&gt;&lt;a:shade val="20000"/&gt;&lt;a:satMod val="255000"/&gt;&lt;/a:schemeClr&gt;&lt;/a:gs&gt;';&#13;
	o[o.length] =      '&lt;/a:gsLst&gt;';&#13;
	o[o.length] =      '&lt;a:path path="circle"&gt;&lt;a:fillToRect l="50000" t="-80000" r="50000" b="180000"/&gt;&lt;/a:path&gt;';&#13;
	o[o.length] =     '&lt;/a:gradFill&gt;';&#13;
	o[o.length] =     '&lt;a:gradFill rotWithShape="1"&gt;';&#13;
	o[o.length] =      '&lt;a:gsLst&gt;';&#13;
	o[o.length] =       '&lt;a:gs pos="0"&gt;&lt;a:schemeClr val="phClr"&gt;&lt;a:tint val="80000"/&gt;&lt;a:satMod val="300000"/&gt;&lt;/a:schemeClr&gt;&lt;/a:gs&gt;';&#13;
	o[o.length] =       '&lt;a:gs pos="100000"&gt;&lt;a:schemeClr val="phClr"&gt;&lt;a:shade val="30000"/&gt;&lt;a:satMod val="200000"/&gt;&lt;/a:schemeClr&gt;&lt;/a:gs&gt;';&#13;
	o[o.length] =      '&lt;/a:gsLst&gt;';&#13;
	o[o.length] =      '&lt;a:path path="circle"&gt;&lt;a:fillToRect l="50000" t="50000" r="50000" b="50000"/&gt;&lt;/a:path&gt;';&#13;
	o[o.length] =     '&lt;/a:gradFill&gt;';&#13;
	o[o.length] =    '&lt;/a:bgFillStyleLst&gt;';&#13;
	o[o.length] =   '&lt;/a:fmtScheme&gt;';&#13;
	o[o.length] =  '&lt;/a:themeElements&gt;';&#13;
&#13;
	o[o.length] =  '&lt;a:objectDefaults&gt;';&#13;
	o[o.length] =   '&lt;a:spDef&gt;';&#13;
	o[o.length] =    '&lt;a:spPr/&gt;&lt;a:bodyPr/&gt;&lt;a:lstStyle/&gt;&lt;a:style&gt;&lt;a:lnRef idx="1"&gt;&lt;a:schemeClr val="accent1"/&gt;&lt;/a:lnRef&gt;&lt;a:fillRef idx="3"&gt;&lt;a:schemeClr val="accent1"/&gt;&lt;/a:fillRef&gt;&lt;a:effectRef idx="2"&gt;&lt;a:schemeClr val="accent1"/&gt;&lt;/a:effectRef&gt;&lt;a:fontRef idx="minor"&gt;&lt;a:schemeClr val="lt1"/&gt;&lt;/a:fontRef&gt;&lt;/a:style&gt;';&#13;
	o[o.length] =   '&lt;/a:spDef&gt;';&#13;
	o[o.length] =   '&lt;a:lnDef&gt;';&#13;
	o[o.length] =    '&lt;a:spPr/&gt;&lt;a:bodyPr/&gt;&lt;a:lstStyle/&gt;&lt;a:style&gt;&lt;a:lnRef idx="2"&gt;&lt;a:schemeClr val="accent1"/&gt;&lt;/a:lnRef&gt;&lt;a:fillRef idx="0"&gt;&lt;a:schemeClr val="accent1"/&gt;&lt;/a:fillRef&gt;&lt;a:effectRef idx="1"&gt;&lt;a:schemeClr val="accent1"/&gt;&lt;/a:effectRef&gt;&lt;a:fontRef idx="minor"&gt;&lt;a:schemeClr val="tx1"/&gt;&lt;/a:fontRef&gt;&lt;/a:style&gt;';&#13;
	o[o.length] =   '&lt;/a:lnDef&gt;';&#13;
	o[o.length] =  '&lt;/a:objectDefaults&gt;';&#13;
	o[o.length] =  '&lt;a:extraClrSchemeLst/&gt;';&#13;
	o[o.length] = '&lt;/a:theme&gt;';&#13;
	return o.join("");&#13;
}&#13;
/* [MS-XLS] 2.4.326 TODO: payload is a zip file */&#13;
function parse_Theme(blob, length, opts) {&#13;
	var end = blob.l + length;&#13;
	var dwThemeVersion = blob.read_shift(4);&#13;
	if(dwThemeVersion === 124226) return;&#13;
	if(!opts.cellStyles) { blob.l = end; return; }&#13;
	var data = blob.slice(blob.l);&#13;
	blob.l = end;&#13;
	var zip; try { zip = zip_read(data, {type: "array"}); } catch(e) { return; }&#13;
	var themeXML = getzipstr(zip, "theme/theme/theme1.xml", true);&#13;
	if(!themeXML) return;&#13;
	return parse_theme_xml(themeXML, opts);&#13;
}&#13;
&#13;
/* 2.5.49 */&#13;
function parse_ColorTheme(blob) { return blob.read_shift(4); }&#13;
&#13;
/* 2.5.155 */&#13;
function parse_FullColorExt(blob) {&#13;
	var o = {};&#13;
	o.xclrType = blob.read_shift(2);&#13;
	o.nTintShade = blob.read_shift(2);&#13;
	switch(o.xclrType) {&#13;
		case 0: blob.l += 4; break;&#13;
		case 1: o.xclrValue = parse_IcvXF(blob, 4); break;&#13;
		case 2: o.xclrValue = parse_LongRGBA(blob, 4); break;&#13;
		case 3: o.xclrValue = parse_ColorTheme(blob, 4); break;&#13;
		case 4: blob.l += 4; break;&#13;
	}&#13;
	blob.l += 8;&#13;
	return o;&#13;
}&#13;
&#13;
/* 2.5.164 TODO: read 7 bits*/&#13;
function parse_IcvXF(blob, length) {&#13;
	return parsenoop(blob, length);&#13;
}&#13;
&#13;
/* 2.5.280 */&#13;
function parse_XFExtGradient(blob, length) {&#13;
	return parsenoop(blob, length);&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.108 */&#13;
function parse_ExtProp(blob) {&#13;
	var extType = blob.read_shift(2);&#13;
	var cb = blob.read_shift(2) - 4;&#13;
	var o = [extType];&#13;
	switch(extType) {&#13;
		case 0x04: case 0x05: case 0x07: case 0x08:&#13;
		case 0x09: case 0x0A: case 0x0B: case 0x0D:&#13;
			o[1] = parse_FullColorExt(blob, cb); break;&#13;
		case 0x06: o[1] = parse_XFExtGradient(blob, cb); break;&#13;
		case 0x0E: case 0x0F: o[1] = blob.read_shift(cb === 1 ? 1 : 2); break;&#13;
		default: throw new Error("Unrecognized ExtProp type: " + extType + " " + cb);&#13;
	}&#13;
	return o;&#13;
}&#13;
&#13;
/* 2.4.355 */&#13;
function parse_XFExt(blob, length) {&#13;
	var end = blob.l + length;&#13;
	blob.l += 2;&#13;
	var ixfe = blob.read_shift(2);&#13;
	blob.l += 2;&#13;
	var cexts = blob.read_shift(2);&#13;
	var ext = [];&#13;
	while(cexts-- &gt; 0) ext.push(parse_ExtProp(blob, end-blob.l));&#13;
	return {ixfe:ixfe, ext:ext};&#13;
}&#13;
&#13;
/* xf is an XF, see parse_XFExt for xfext */&#13;
function update_xfext(xf, xfext) {&#13;
	xfext.forEach(function(xfe) {&#13;
		switch(xfe[0]) { /* 2.5.108 extPropData */&#13;
			case 0x04: break; /* foreground color */&#13;
			case 0x05: break; /* background color */&#13;
			case 0x06: break; /* gradient fill */&#13;
			case 0x07: break; /* top cell border color */&#13;
			case 0x08: break; /* bottom cell border color */&#13;
			case 0x09: break; /* left cell border color */&#13;
			case 0x0a: break; /* right cell border color */&#13;
			case 0x0b: break; /* diagonal cell border color */&#13;
			case 0x0d: /* text color */&#13;
				break;&#13;
			case 0x0e: break; /* font scheme */&#13;
			case 0x0f: break; /* indentation level */&#13;
		}&#13;
	});&#13;
}&#13;
&#13;
function parse_BrtMdtinfo(data, length) {&#13;
  return {&#13;
    flags: data.read_shift(4),&#13;
    version: data.read_shift(4),&#13;
    name: parse_XLWideString(data, length - 8)&#13;
  };&#13;
}&#13;
function write_BrtMdtinfo(data) {&#13;
  var o = new_buf(12 + 2 * data.name.length);&#13;
  o.write_shift(4, data.flags);&#13;
  o.write_shift(4, data.version);&#13;
  write_XLWideString(data.name, o);&#13;
  return o.slice(0, o.l);&#13;
}&#13;
function parse_BrtMdb(data) {&#13;
  var out = [];&#13;
  var cnt = data.read_shift(4);&#13;
  while (cnt-- &gt; 0)&#13;
    out.push([data.read_shift(4), data.read_shift(4)]);&#13;
  return out;&#13;
}&#13;
function write_BrtMdb(mdb) {&#13;
  var o = new_buf(4 + 8 * mdb.length);&#13;
  o.write_shift(4, mdb.length);&#13;
  for (var i = 0; i &lt; mdb.length; ++i) {&#13;
    o.write_shift(4, mdb[i][0]);&#13;
    o.write_shift(4, mdb[i][1]);&#13;
  }&#13;
  return o;&#13;
}&#13;
function write_BrtBeginEsfmd(cnt, name) {&#13;
  var o = new_buf(8 + 2 * name.length);&#13;
  o.write_shift(4, cnt);&#13;
  write_XLWideString(name, o);&#13;
  return o.slice(0, o.l);&#13;
}&#13;
function parse_BrtBeginEsmdb(data) {&#13;
  data.l += 4;&#13;
  return data.read_shift(4) != 0;&#13;
}&#13;
function write_BrtBeginEsmdb(cnt, cm) {&#13;
  var o = new_buf(8);&#13;
  o.write_shift(4, cnt);&#13;
  o.write_shift(4, cm ? 1 : 0);&#13;
  return o;&#13;
}&#13;
function parse_xlmeta_bin(data, name, _opts) {&#13;
  var out = { Types: [], Cell: [], Value: [] };&#13;
  var opts = _opts || {};&#13;
  var state = [];&#13;
  var pass = false;&#13;
  var metatype = 2;&#13;
  recordhopper(data, function(val, R, RT) {&#13;
    switch (RT) {&#13;
      case 335:&#13;
        out.Types.push({ name: val.name });&#13;
        break;&#13;
      case 51:&#13;
        val.forEach(function(r) {&#13;
          if (metatype == 1)&#13;
            out.Cell.push({ type: out.Types[r[0] - 1].name, index: r[1] });&#13;
          else if (metatype == 0)&#13;
            out.Value.push({ type: out.Types[r[0] - 1].name, index: r[1] });&#13;
        });&#13;
        break;&#13;
      case 337:&#13;
        metatype = val ? 1 : 0;&#13;
        break;&#13;
      case 338:&#13;
        metatype = 2;&#13;
        break;&#13;
      case 35:&#13;
        state.push(RT);&#13;
        pass = true;&#13;
        break;&#13;
      case 36:&#13;
        state.pop();&#13;
        pass = false;&#13;
        break;&#13;
      default:&#13;
        if (R.T) {&#13;
        } else if (!pass || opts.WTF &amp;&amp; state[state.length - 1] != 35)&#13;
          throw new Error("Unexpected record 0x" + RT.toString(16));&#13;
    }&#13;
  });&#13;
  return out;&#13;
}&#13;
function write_xlmeta_bin() {&#13;
  var ba = buf_array();&#13;
  write_record(ba, 332);&#13;
  write_record(ba, 334, write_UInt32LE(1));&#13;
  write_record(ba, 335, write_BrtMdtinfo({&#13;
    name: "XLDAPR",&#13;
    version: 12e4,&#13;
    flags: 3496657072&#13;
  }));&#13;
  write_record(ba, 336);&#13;
  write_record(ba, 339, write_BrtBeginEsfmd(1, "XLDAPR"));&#13;
  write_record(ba, 52);&#13;
  write_record(ba, 35, write_UInt32LE(514));&#13;
  write_record(ba, 4096, write_UInt32LE(0));&#13;
  write_record(ba, 4097, writeuint16(1));&#13;
  write_record(ba, 36);&#13;
  write_record(ba, 53);&#13;
  write_record(ba, 340);&#13;
  write_record(ba, 337, write_BrtBeginEsmdb(1, true));&#13;
  write_record(ba, 51, write_BrtMdb([[1, 0]]));&#13;
  write_record(ba, 338);&#13;
  write_record(ba, 333);&#13;
  return ba.end();&#13;
}&#13;
function parse_xlmeta_xml(data, name, opts) {&#13;
  var out = { Types: [], Cell: [], Value: [] };&#13;
  if (!data)&#13;
    return out;&#13;
  var pass = false;&#13;
  var metatype = 2;&#13;
  var lastmeta;&#13;
  data.replace(tagregex, function(x) {&#13;
    var y = parsexmltag(x);&#13;
    switch (strip_ns(y[0])) {&#13;
      case "&lt;?xml":&#13;
        break;&#13;
      case "&lt;metadata":&#13;
      case "&lt;/metadata&gt;":&#13;
        break;&#13;
      case "&lt;metadataTypes":&#13;
      case "&lt;/metadataTypes&gt;":&#13;
        break;&#13;
      case "&lt;metadataType":&#13;
        out.Types.push({ name: y.name });&#13;
        break;&#13;
      case "&lt;/metadataType&gt;":&#13;
        break;&#13;
      case "&lt;futureMetadata":&#13;
        for (var j = 0; j &lt; out.Types.length; ++j)&#13;
          if (out.Types[j].name == y.name)&#13;
            lastmeta = out.Types[j];&#13;
        break;&#13;
      case "&lt;/futureMetadata&gt;":&#13;
        break;&#13;
      case "&lt;bk&gt;":&#13;
        break;&#13;
      case "&lt;/bk&gt;":&#13;
        break;&#13;
      case "&lt;rc":&#13;
        if (metatype == 1)&#13;
          out.Cell.push({ type: out.Types[y.t - 1].name, index: +y.v });&#13;
        else if (metatype == 0)&#13;
          out.Value.push({ type: out.Types[y.t - 1].name, index: +y.v });&#13;
        break;&#13;
      case "&lt;/rc&gt;":&#13;
        break;&#13;
      case "&lt;cellMetadata":&#13;
        metatype = 1;&#13;
        break;&#13;
      case "&lt;/cellMetadata&gt;":&#13;
        metatype = 2;&#13;
        break;&#13;
      case "&lt;valueMetadata":&#13;
        metatype = 0;&#13;
        break;&#13;
      case "&lt;/valueMetadata&gt;":&#13;
        metatype = 2;&#13;
        break;&#13;
      case "&lt;extLst":&#13;
      case "&lt;extLst&gt;":&#13;
      case "&lt;/extLst&gt;":&#13;
      case "&lt;extLst/&gt;":&#13;
        break;&#13;
      case "&lt;ext":&#13;
        pass = true;&#13;
        break;&#13;
      case "&lt;/ext&gt;":&#13;
        pass = false;&#13;
        break;&#13;
      case "&lt;rvb":&#13;
        if (!lastmeta)&#13;
          break;&#13;
        if (!lastmeta.offsets)&#13;
          lastmeta.offsets = [];&#13;
        lastmeta.offsets.push(+y.i);&#13;
        break;&#13;
      default:&#13;
        if (!pass &amp;&amp; (opts == null ? void 0 : opts.WTF))&#13;
          throw new Error("unrecognized " + y[0] + " in metadata");&#13;
    }&#13;
    return x;&#13;
  });&#13;
  return out;&#13;
}&#13;
function write_xlmeta_xml() {&#13;
  var o = [XML_HEADER];&#13;
  o.push('&lt;metadata xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:xlrd="http://schemas.microsoft.com/office/spreadsheetml/2017/richdata" xmlns:xda="http://schemas.microsoft.com/office/spreadsheetml/2017/dynamicarray"&gt;\n  &lt;metadataTypes count="1"&gt;\n    &lt;metadataType name="XLDAPR" minSupportedVersion="120000" copy="1" pasteAll="1" pasteValues="1" merge="1" splitFirst="1" rowColShift="1" clearFormats="1" clearComments="1" assign="1" coerce="1" cellMeta="1"/&gt;\n  &lt;/metadataTypes&gt;\n  &lt;futureMetadata name="XLDAPR" count="1"&gt;\n    &lt;bk&gt;\n      &lt;extLst&gt;\n        &lt;ext uri="{bdbb8cdc-fa1e-496e-a857-3c3f30c029c3}"&gt;\n          &lt;xda:dynamicArrayProperties fDynamic="1" fCollapsed="0"/&gt;\n        &lt;/ext&gt;\n      &lt;/extLst&gt;\n    &lt;/bk&gt;\n  &lt;/futureMetadata&gt;\n  &lt;cellMetadata count="1"&gt;\n    &lt;bk&gt;\n      &lt;rc t="1" v="0"/&gt;\n    &lt;/bk&gt;\n  &lt;/cellMetadata&gt;\n&lt;/metadata&gt;');&#13;
  return o.join("");&#13;
}&#13;
/* 18.6 Calculation Chain */&#13;
function parse_cc_xml(data) {&#13;
	var d = [];&#13;
	if(!data) return d;&#13;
	var i = 1;&#13;
	(data.match(tagregex)||[]).forEach(function(x) {&#13;
		var y = parsexmltag(x);&#13;
		switch(y[0]) {&#13;
			case '&lt;?xml': break;&#13;
			/* 18.6.2  calcChain CT_CalcChain 1 */&#13;
			case '&lt;calcChain': case '&lt;calcChain&gt;': case '&lt;/calcChain&gt;': break;&#13;
			/* 18.6.1  c CT_CalcCell 1 */&#13;
			case '&lt;c': delete y[0]; if(y.i) i = y.i; else y.i = i; d.push(y); break;&#13;
		}&#13;
	});&#13;
	return d;&#13;
}&#13;
&#13;
//function write_cc_xml(data, opts) { }&#13;
&#13;
/* [MS-XLSB] 2.6.4.1 */&#13;
function parse_BrtCalcChainItem$(data) {&#13;
	var out = {};&#13;
	out.i = data.read_shift(4);&#13;
	var cell = {};&#13;
	cell.r = data.read_shift(4);&#13;
	cell.c = data.read_shift(4);&#13;
	out.r = encode_cell(cell);&#13;
	var flags = data.read_shift(1);&#13;
	if(flags &amp; 0x2) out.l = '1';&#13;
	if(flags &amp; 0x8) out.a = '1';&#13;
	return out;&#13;
}&#13;
&#13;
/* 18.6 Calculation Chain */&#13;
function parse_cc_bin(data, name, opts) {&#13;
	var out = [];&#13;
	var pass = false;&#13;
	recordhopper(data, function hopper_cc(val, R, RT) {&#13;
		switch(RT) {&#13;
			case 0x003F: /* 'BrtCalcChainItem$' */&#13;
				out.push(val); break;&#13;
&#13;
			default:&#13;
				if(R.T){/* empty */}&#13;
				else if(!pass || opts.WTF) throw new Error("Unexpected record 0x" + RT.toString(16));&#13;
		}&#13;
	});&#13;
	return out;&#13;
}&#13;
&#13;
//function write_cc_bin(data, opts) { }&#13;
/* 18.14 Supplementary Workbook Data */&#13;
function parse_xlink_xml() {&#13;
	//var opts = _opts || {};&#13;
	//if(opts.WTF) throw "XLSX External Link";&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.1.7.25 External Link */&#13;
function parse_xlink_bin(data, rel, name, _opts) {&#13;
	if(!data) return data;&#13;
	var opts = _opts || {};&#13;
&#13;
	var pass = false, end = false;&#13;
&#13;
	recordhopper(data, function xlink_parse(val, R, RT) {&#13;
		if(end) return;&#13;
		switch(RT) {&#13;
			case 0x0167: /* 'BrtSupTabs' */&#13;
			case 0x016B: /* 'BrtExternTableStart' */&#13;
			case 0x016C: /* 'BrtExternTableEnd' */&#13;
			case 0x016E: /* 'BrtExternRowHdr' */&#13;
			case 0x016F: /* 'BrtExternCellBlank' */&#13;
			case 0x0170: /* 'BrtExternCellReal' */&#13;
			case 0x0171: /* 'BrtExternCellBool' */&#13;
			case 0x0172: /* 'BrtExternCellError' */&#13;
			case 0x0173: /* 'BrtExternCellString' */&#13;
			case 0x01D8: /* 'BrtExternValueMeta' */&#13;
			case 0x0241: /* 'BrtSupNameStart' */&#13;
			case 0x0242: /* 'BrtSupNameValueStart' */&#13;
			case 0x0243: /* 'BrtSupNameValueEnd' */&#13;
			case 0x0244: /* 'BrtSupNameNum' */&#13;
			case 0x0245: /* 'BrtSupNameErr' */&#13;
			case 0x0246: /* 'BrtSupNameSt' */&#13;
			case 0x0247: /* 'BrtSupNameNil' */&#13;
			case 0x0248: /* 'BrtSupNameBool' */&#13;
			case 0x0249: /* 'BrtSupNameFmla' */&#13;
			case 0x024A: /* 'BrtSupNameBits' */&#13;
			case 0x024B: /* 'BrtSupNameEnd' */&#13;
				break;&#13;
&#13;
			case 0x0023: /* 'BrtFRTBegin' */&#13;
				pass = true; break;&#13;
			case 0x0024: /* 'BrtFRTEnd' */&#13;
				pass = false; break;&#13;
&#13;
			default:&#13;
				if(R.T){/* empty */}&#13;
				else if(!pass || opts.WTF) throw new Error("Unexpected record 0x" + RT.toString(16));&#13;
		}&#13;
	}, opts);&#13;
}&#13;
/* 20.5 DrawingML - SpreadsheetML Drawing */&#13;
/* 20.5.2.35 wsDr CT_Drawing */&#13;
function parse_drawing(data, rels) {&#13;
	if(!data) return "??";&#13;
	/*&#13;
	  Chartsheet Drawing:&#13;
	   - 20.5.2.35 wsDr CT_Drawing&#13;
	    - 20.5.2.1  absoluteAnchor CT_AbsoluteAnchor&#13;
	     - 20.5.2.16 graphicFrame CT_GraphicalObjectFrame&#13;
	      - 20.1.2.2.16 graphic CT_GraphicalObject&#13;
	       - 20.1.2.2.17 graphicData CT_GraphicalObjectData&#13;
          - chart reference&#13;
	   the actual type is based on the URI of the graphicData&#13;
		TODO: handle embedded charts and other types of graphics&#13;
	*/&#13;
	var id = (data.match(/&lt;c:chart [^&gt;]*r:id="([^"]*)"/)||["",""])[1];&#13;
&#13;
	return rels['!id'][id].Target;&#13;
}&#13;
&#13;
/* L.5.5.2 SpreadsheetML Comments + VML Schema */&#13;
function write_vml(rId, comments) {&#13;
	var csize = [21600, 21600];&#13;
	/* L.5.2.1.2 Path Attribute */&#13;
	var bbox = ["m0,0l0",csize[1],csize[0],csize[1],csize[0],"0xe"].join(",");&#13;
	var o = [&#13;
		writextag("xml", null, { 'xmlns:v': XLMLNS.v, 'xmlns:o': XLMLNS.o, 'xmlns:x': XLMLNS.x, 'xmlns:mv': XLMLNS.mv }).replace(/\/&gt;/,"&gt;"),&#13;
		writextag("o:shapelayout", writextag("o:idmap", null, {'v:ext':"edit", 'data':rId}), {'v:ext':"edit"})&#13;
	];&#13;
&#13;
	var _shapeid = 65536 * rId;&#13;
&#13;
	var _comments = comments || [];&#13;
	if(_comments.length &gt; 0) o.push(writextag("v:shapetype", [&#13;
		writextag("v:stroke", null, {joinstyle:"miter"}),&#13;
		writextag("v:path", null, {gradientshapeok:"t", 'o:connecttype':"rect"})&#13;
	].join(""), {id:"_x0000_t202", coordsize:csize.join(","), 'o:spt':202, path:bbox}));&#13;
&#13;
	_comments.forEach(function(x) { ++_shapeid; o.push(write_vml_comment(x, _shapeid)); });&#13;
	o.push('&lt;/xml&gt;');&#13;
	return o.join("");&#13;
}&#13;
&#13;
function write_vml_comment(x, _shapeid) {&#13;
	var c = decode_cell(x[0]);&#13;
	var fillopts = {'color2':"#BEFF82", 'type':"gradient"};&#13;
	if(fillopts.type == "gradient") fillopts.angle = "-180";&#13;
	var fillparm = fillopts.type == "gradient" ? writextag("o:fill", null, {type:"gradientUnscaled", 'v:ext':"view"}) : null;&#13;
	var fillxml = writextag('v:fill', fillparm, fillopts);&#13;
&#13;
	var shadata = ({on:"t", 'obscured':"t"});&#13;
&#13;
	return [&#13;
	'&lt;v:shape' + wxt_helper({&#13;
		id:'_x0000_s' + _shapeid,&#13;
		type:"#_x0000_t202",&#13;
		style:"position:absolute; margin-left:80pt;margin-top:5pt;width:104pt;height:64pt;z-index:10" + (x[1].hidden ? ";visibility:hidden" : "") ,&#13;
		fillcolor:"#ECFAD4",&#13;
		strokecolor:"#edeaa1"&#13;
	}) + '&gt;',&#13;
		fillxml,&#13;
		writextag("v:shadow", null, shadata),&#13;
		writextag("v:path", null, {'o:connecttype':"none"}),&#13;
		'&lt;v:textbox&gt;&lt;div style="text-align:left"&gt;&lt;/div&gt;&lt;/v:textbox&gt;',&#13;
		'&lt;x:ClientData ObjectType="Note"&gt;',&#13;
			'&lt;x:MoveWithCells/&gt;',&#13;
			'&lt;x:SizeWithCells/&gt;',&#13;
			/* Part 4 19.4.2.3 Anchor (Anchor) */&#13;
			writetag('x:Anchor', [c.c+1, 0, c.r+1, 0, c.c+3, 20, c.r+5, 20].join(",")),&#13;
			writetag('x:AutoFill', "False"),&#13;
			writetag('x:Row', String(c.r)),&#13;
			writetag('x:Column', String(c.c)),&#13;
			x[1].hidden ? '' : '&lt;x:Visible/&gt;',&#13;
		'&lt;/x:ClientData&gt;',&#13;
	'&lt;/v:shape&gt;'&#13;
	].join("");&#13;
}&#13;
function sheet_insert_comments(sheet, comments, threaded, people) {&#13;
	var dense = Array.isArray(sheet);&#13;
	var cell;&#13;
	comments.forEach(function(comment) {&#13;
		var r = decode_cell(comment.ref);&#13;
		if(dense) {&#13;
			if(!sheet[r.r]) sheet[r.r] = [];&#13;
			cell = sheet[r.r][r.c];&#13;
		} else cell = sheet[comment.ref];&#13;
		if (!cell) {&#13;
			cell = ({t:"z"});&#13;
			if(dense) sheet[r.r][r.c] = cell;&#13;
			else sheet[comment.ref] = cell;&#13;
			var range = safe_decode_range(sheet["!ref"]||"BDWGO1000001:A1");&#13;
			if(range.s.r &gt; r.r) range.s.r = r.r;&#13;
			if(range.e.r &lt; r.r) range.e.r = r.r;&#13;
			if(range.s.c &gt; r.c) range.s.c = r.c;&#13;
			if(range.e.c &lt; r.c) range.e.c = r.c;&#13;
			var encoded = encode_range(range);&#13;
			if (encoded !== sheet["!ref"]) sheet["!ref"] = encoded;&#13;
		}&#13;
&#13;
		if (!cell.c) cell.c = [];&#13;
		var o = ({a: comment.author, t: comment.t, r: comment.r, T: threaded});&#13;
		if(comment.h) o.h = comment.h;&#13;
&#13;
		/* threaded comments always override */&#13;
		for(var i = cell.c.length - 1; i &gt;= 0; --i) {&#13;
			if(!threaded &amp;&amp; cell.c[i].T) return;&#13;
			if(threaded &amp;&amp; !cell.c[i].T) cell.c.splice(i, 1);&#13;
		}&#13;
		if(threaded &amp;&amp; people) for(i = 0; i &lt; people.length; ++i) {&#13;
			if(o.a == people[i].id) { o.a = people[i].name || o.a; break; }&#13;
		}&#13;
		cell.c.push(o);&#13;
	});&#13;
}&#13;
&#13;
/* 18.7 Comments */&#13;
function parse_comments_xml(data, opts) {&#13;
	/* 18.7.6 CT_Comments */&#13;
	if(data.match(/&lt;(?:\w+:)?comments *\/&gt;/)) return [];&#13;
	var authors = [];&#13;
	var commentList = [];&#13;
	var authtag = data.match(/&lt;(?:\w+:)?authors&gt;([\s\S]*)&lt;\/(?:\w+:)?authors&gt;/);&#13;
	if(authtag &amp;&amp; authtag[1]) authtag[1].split(/&lt;\/\w*:?author&gt;/).forEach(function(x) {&#13;
		if(x === "" || x.trim() === "") return;&#13;
		var a = x.match(/&lt;(?:\w+:)?author[^&gt;]*&gt;(.*)/);&#13;
		if(a) authors.push(a[1]);&#13;
	});&#13;
	var cmnttag = data.match(/&lt;(?:\w+:)?commentList&gt;([\s\S]*)&lt;\/(?:\w+:)?commentList&gt;/);&#13;
	if(cmnttag &amp;&amp; cmnttag[1]) cmnttag[1].split(/&lt;\/\w*:?comment&gt;/).forEach(function(x) {&#13;
		if(x === "" || x.trim() === "") return;&#13;
		var cm = x.match(/&lt;(?:\w+:)?comment[^&gt;]*&gt;/);&#13;
		if(!cm) return;&#13;
		var y = parsexmltag(cm[0]);&#13;
		var comment = ({ author: y.authorId &amp;&amp; authors[y.authorId] || "sheetjsghost", ref: y.ref, guid: y.guid });&#13;
		var cell = decode_cell(y.ref);&#13;
		if(opts.sheetRows &amp;&amp; opts.sheetRows &lt;= cell.r) return;&#13;
		var textMatch = x.match(/&lt;(?:\w+:)?text&gt;([\s\S]*)&lt;\/(?:\w+:)?text&gt;/);&#13;
		var rt = !!textMatch &amp;&amp; !!textMatch[1] &amp;&amp; parse_si(textMatch[1]) || {r:"",t:"",h:""};&#13;
		comment.r = rt.r;&#13;
		if(rt.r == "&lt;t&gt;&lt;/t&gt;") rt.t = rt.h = "";&#13;
		comment.t = (rt.t||"").replace(/\r\n/g,"\n").replace(/\r/g,"\n");&#13;
		if(opts.cellHTML) comment.h = rt.h;&#13;
		commentList.push(comment);&#13;
	});&#13;
	return commentList;&#13;
}&#13;
&#13;
function write_comments_xml(data) {&#13;
	var o = [XML_HEADER, writextag('comments', null, { 'xmlns': XMLNS_main[0] })];&#13;
&#13;
	var iauthor = [];&#13;
	o.push("&lt;authors&gt;");&#13;
	data.forEach(function(x) { x[1].forEach(function(w) { var a = escapexml(w.a);&#13;
		if(iauthor.indexOf(a) == -1) {&#13;
			iauthor.push(a);&#13;
			o.push("&lt;author&gt;" + a + "&lt;/author&gt;");&#13;
		}&#13;
		if(w.T &amp;&amp; w.ID &amp;&amp; iauthor.indexOf("tc=" + w.ID) == -1) {&#13;
			iauthor.push("tc=" + w.ID);&#13;
			o.push("&lt;author&gt;" + "tc=" + w.ID + "&lt;/author&gt;");&#13;
		}&#13;
	}); });&#13;
	if(iauthor.length == 0) { iauthor.push("SheetJ5"); o.push("&lt;author&gt;SheetJ5&lt;/author&gt;"); }&#13;
	o.push("&lt;/authors&gt;");&#13;
	o.push("&lt;commentList&gt;");&#13;
	data.forEach(function(d) {&#13;
		/* 18.7.3 CT_Comment */&#13;
		var lastauthor = 0, ts = [], tcnt = 0;&#13;
		if(d[1][0] &amp;&amp; d[1][0].T &amp;&amp; d[1][0].ID) lastauthor = iauthor.indexOf("tc=" + d[1][0].ID);&#13;
		d[1].forEach(function(c) {&#13;
			if(c.a) lastauthor = iauthor.indexOf(escapexml(c.a));&#13;
			if(c.T) ++tcnt;&#13;
			ts.push(c.t == null ? "" : escapexml(c.t));&#13;
		});&#13;
		if(tcnt === 0) {&#13;
			d[1].forEach(function(c) {&#13;
				o.push('&lt;comment ref="' + d[0] + '" authorId="' + iauthor.indexOf(escapexml(c.a)) + '"&gt;&lt;text&gt;');&#13;
				o.push(writetag("t", c.t == null ? "" : escapexml(c.t)));&#13;
				o.push('&lt;/text&gt;&lt;/comment&gt;');&#13;
			});&#13;
		} else {&#13;
			/* based on Threaded Comments -&gt; Comments projection */&#13;
			o.push('&lt;comment ref="' + d[0] + '" authorId="' + lastauthor + '"&gt;&lt;text&gt;');&#13;
			var t = "Comment:\n    " + (ts[0]) + "\n";&#13;
			for(var i = 1; i &lt; ts.length; ++i) t += "Reply:\n    " + ts[i] + "\n";&#13;
			o.push(writetag("t", escapexml(t)));&#13;
			o.push('&lt;/text&gt;&lt;/comment&gt;');&#13;
		}&#13;
	});&#13;
	o.push("&lt;/commentList&gt;");&#13;
	if(o.length&gt;2) { o[o.length] = ('&lt;/comments&gt;'); o[1]=o[1].replace("/&gt;","&gt;"); }&#13;
	return o.join("");&#13;
}&#13;
&#13;
/* [MS-XLSX] 2.1.17 */&#13;
function parse_tcmnt_xml(data, opts) {&#13;
	var out = [];&#13;
	var pass = false, comment = {}, tidx = 0;&#13;
	data.replace(tagregex, function xml_tcmnt(x, idx) {&#13;
		var y = parsexmltag(x);&#13;
		switch(strip_ns(y[0])) {&#13;
			case '&lt;?xml': break;&#13;
&#13;
			/* 2.6.207 ThreadedComments CT_ThreadedComments */&#13;
			case '&lt;ThreadedComments': break;&#13;
			case '&lt;/ThreadedComments&gt;': break;&#13;
&#13;
			/* 2.6.205 threadedComment CT_ThreadedComment */&#13;
			case '&lt;threadedComment': comment = {author: y.personId, guid: y.id, ref: y.ref, T: 1}; break;&#13;
			case '&lt;/threadedComment&gt;': if(comment.t != null) out.push(comment); break;&#13;
&#13;
			case '&lt;text&gt;': case '&lt;text': tidx = idx + x.length; break;&#13;
			case '&lt;/text&gt;': comment.t = data.slice(tidx, idx).replace(/\r\n/g, "\n").replace(/\r/g, "\n"); break;&#13;
&#13;
			/* 2.6.206 mentions CT_ThreadedCommentMentions TODO */&#13;
			case '&lt;mentions': case '&lt;mentions&gt;': pass = true; break;&#13;
			case '&lt;/mentions&gt;': pass = false; break;&#13;
&#13;
			/* 2.6.202 mention CT_Mention TODO */&#13;
&#13;
			/* 18.2.10 extLst CT_ExtensionList ? */&#13;
			case '&lt;extLst': case '&lt;extLst&gt;': case '&lt;/extLst&gt;': case '&lt;extLst/&gt;': break;&#13;
			/* 18.2.7  ext CT_Extension + */&#13;
			case '&lt;ext': pass=true; break;&#13;
			case '&lt;/ext&gt;': pass=false; break;&#13;
&#13;
			default: if(!pass &amp;&amp; opts.WTF) throw new Error('unrecognized ' + y[0] + ' in threaded comments');&#13;
		}&#13;
		return x;&#13;
	});&#13;
	return out;&#13;
}&#13;
&#13;
function write_tcmnt_xml(comments, people, opts) {&#13;
	var o = [XML_HEADER, writextag('ThreadedComments', null, { 'xmlns': XMLNS.TCMNT }).replace(/[\/]&gt;/, "&gt;")];&#13;
	comments.forEach(function(carr) {&#13;
		var rootid = "";&#13;
		(carr[1] || []).forEach(function(c, idx) {&#13;
			if(!c.T) { delete c.ID; return; }&#13;
			if(c.a &amp;&amp; people.indexOf(c.a) == -1) people.push(c.a);&#13;
			var tcopts = {&#13;
				ref: carr[0],&#13;
				id: "{54EE7951-7262-4200-6969-" + ("000000000000" + opts.tcid++).slice(-12) + "}"&#13;
			};&#13;
			if(idx == 0) rootid = tcopts.id;&#13;
			else tcopts.parentId = rootid;&#13;
			c.ID = tcopts.id;&#13;
			if(c.a) tcopts.personId = "{54EE7950-7262-4200-6969-" + ("000000000000" + people.indexOf(c.a)).slice(-12) + "}";&#13;
			o.push(writextag('threadedComment', writetag('text', c.t||""), tcopts));&#13;
		});&#13;
	});&#13;
	o.push('&lt;/ThreadedComments&gt;');&#13;
	return o.join("");&#13;
}&#13;
&#13;
/* [MS-XLSX] 2.1.18 */&#13;
function parse_people_xml(data, opts) {&#13;
	var out = [];&#13;
	var pass = false;&#13;
	data.replace(tagregex, function xml_tcmnt(x) {&#13;
		var y = parsexmltag(x);&#13;
		switch(strip_ns(y[0])) {&#13;
			case '&lt;?xml': break;&#13;
&#13;
			/* 2.4.85 personList CT_PersonList */&#13;
			case '&lt;personList': break;&#13;
			case '&lt;/personList&gt;': break;&#13;
&#13;
			/* 2.6.203 person CT_Person TODO: providers */&#13;
			case '&lt;person': out.push({name: y.displayname, id: y.id }); break;&#13;
			case '&lt;/person&gt;': break;&#13;
&#13;
			/* 18.2.10 extLst CT_ExtensionList ? */&#13;
			case '&lt;extLst': case '&lt;extLst&gt;': case '&lt;/extLst&gt;': case '&lt;extLst/&gt;': break;&#13;
			/* 18.2.7  ext CT_Extension + */&#13;
			case '&lt;ext': pass=true; break;&#13;
			case '&lt;/ext&gt;': pass=false; break;&#13;
&#13;
			default: if(!pass &amp;&amp; opts.WTF) throw new Error('unrecognized ' + y[0] + ' in threaded comments');&#13;
		}&#13;
		return x;&#13;
	});&#13;
	return out;&#13;
}&#13;
function write_people_xml(people/*, opts*/) {&#13;
	var o = [XML_HEADER, writextag('personList', null, {&#13;
		'xmlns': XMLNS.TCMNT,&#13;
		'xmlns:x': XMLNS_main[0]&#13;
	}).replace(/[\/]&gt;/, "&gt;")];&#13;
	people.forEach(function(person, idx) {&#13;
		o.push(writextag('person', null, {&#13;
			displayName: person,&#13;
			id: "{54EE7950-7262-4200-6969-" + ("000000000000" + idx).slice(-12) + "}",&#13;
			userId: person,&#13;
			providerId: "None"&#13;
		}));&#13;
	});&#13;
	o.push("&lt;/personList&gt;");&#13;
	return o.join("");&#13;
}&#13;
/* [MS-XLSB] 2.4.28 BrtBeginComment */&#13;
function parse_BrtBeginComment(data) {&#13;
	var out = {};&#13;
	out.iauthor = data.read_shift(4);&#13;
	var rfx = parse_UncheckedRfX(data, 16);&#13;
	out.rfx = rfx.s;&#13;
	out.ref = encode_cell(rfx.s);&#13;
	data.l += 16; /*var guid = parse_GUID(data); */&#13;
	return out;&#13;
}&#13;
function write_BrtBeginComment(data, o) {&#13;
	if(o == null) o = new_buf(36);&#13;
	o.write_shift(4, data[1].iauthor);&#13;
	write_UncheckedRfX((data[0]), o);&#13;
	o.write_shift(4, 0);&#13;
	o.write_shift(4, 0);&#13;
	o.write_shift(4, 0);&#13;
	o.write_shift(4, 0);&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.4.327 BrtCommentAuthor */&#13;
var parse_BrtCommentAuthor = parse_XLWideString;&#13;
function write_BrtCommentAuthor(data) { return write_XLWideString(data.slice(0, 54)); }&#13;
&#13;
/* [MS-XLSB] 2.1.7.8 Comments */&#13;
function parse_comments_bin(data, opts) {&#13;
	var out = [];&#13;
	var authors = [];&#13;
	var c = {};&#13;
	var pass = false;&#13;
	recordhopper(data, function hopper_cmnt(val, R, RT) {&#13;
		switch(RT) {&#13;
			case 0x0278: /* 'BrtCommentAuthor' */&#13;
				authors.push(val); break;&#13;
			case 0x027B: /* 'BrtBeginComment' */&#13;
				c = val; break;&#13;
			case 0x027D: /* 'BrtCommentText' */&#13;
				c.t = val.t; c.h = val.h; c.r = val.r; break;&#13;
			case 0x027C: /* 'BrtEndComment' */&#13;
				c.author = authors[c.iauthor];&#13;
				delete (c).iauthor;&#13;
				if(opts.sheetRows &amp;&amp; c.rfx &amp;&amp; opts.sheetRows &lt;= c.rfx.r) break;&#13;
				if(!c.t) c.t = "";&#13;
				delete c.rfx; out.push(c); break;&#13;
&#13;
			case 0x0C00: /* 'BrtUid' */&#13;
				break;&#13;
&#13;
			case 0x0023: /* 'BrtFRTBegin' */&#13;
				pass = true; break;&#13;
			case 0x0024: /* 'BrtFRTEnd' */&#13;
				pass = false; break;&#13;
			case 0x0025: /* 'BrtACBegin' */ break;&#13;
			case 0x0026: /* 'BrtACEnd' */ break;&#13;
&#13;
&#13;
			default:&#13;
				if(R.T){/* empty */}&#13;
				else if(!pass || opts.WTF) throw new Error("Unexpected record 0x" + RT.toString(16));&#13;
		}&#13;
	});&#13;
	return out;&#13;
}&#13;
&#13;
function write_comments_bin(data) {&#13;
	var ba = buf_array();&#13;
	var iauthor = [];&#13;
	write_record(ba, 0x0274 /* BrtBeginComments */);&#13;
&#13;
	write_record(ba, 0x0276 /* BrtBeginCommentAuthors */);&#13;
	data.forEach(function(comment) {&#13;
		comment[1].forEach(function(c) {&#13;
			if(iauthor.indexOf(c.a) &gt; -1) return;&#13;
			iauthor.push(c.a.slice(0,54));&#13;
			write_record(ba, 0x0278 /* BrtCommentAuthor */, write_BrtCommentAuthor(c.a));&#13;
		});&#13;
	});&#13;
	write_record(ba, 0x0277 /* BrtEndCommentAuthors */);&#13;
&#13;
	write_record(ba, 0x0279 /* BrtBeginCommentList */);&#13;
	data.forEach(function(comment) {&#13;
		comment[1].forEach(function(c) {&#13;
			c.iauthor = iauthor.indexOf(c.a);&#13;
			var range = {s:decode_cell(comment[0]),e:decode_cell(comment[0])};&#13;
			write_record(ba, 0x027B /* BrtBeginComment */, write_BrtBeginComment([range, c]));&#13;
			if(c.t &amp;&amp; c.t.length &gt; 0) write_record(ba, 0x027D /* BrtCommentText */, write_BrtCommentText(c));&#13;
			write_record(ba, 0x027C /* BrtEndComment */);&#13;
			delete c.iauthor;&#13;
		});&#13;
	});&#13;
	write_record(ba, 0x027A /* BrtEndCommentList */);&#13;
&#13;
	write_record(ba, 0x0275 /* BrtEndComments */);&#13;
	return ba.end();&#13;
}&#13;
var CT_VBA = "application/vnd.ms-office.vbaProject";&#13;
function make_vba_xls(cfb) {&#13;
  var newcfb = CFB.utils.cfb_new({ root: "R" });&#13;
  cfb.FullPaths.forEach(function(p, i) {&#13;
    if (p.slice(-1) === "/" || !p.match(/_VBA_PROJECT_CUR/))&#13;
      return;&#13;
    var newpath = p.replace(/^[^\/]*/, "R").replace(/\/_VBA_PROJECT_CUR\u0000*/, "");&#13;
    CFB.utils.cfb_add(newcfb, newpath, cfb.FileIndex[i].content);&#13;
  });&#13;
  return CFB.write(newcfb);&#13;
}&#13;
function fill_vba_xls(cfb, vba) {&#13;
  vba.FullPaths.forEach(function(p, i) {&#13;
    if (i == 0)&#13;
      return;&#13;
    var newpath = p.replace(/[^\/]*[\/]/, "/_VBA_PROJECT_CUR/");&#13;
    if (newpath.slice(-1) !== "/")&#13;
      CFB.utils.cfb_add(cfb, newpath, vba.FileIndex[i].content);&#13;
  });&#13;
}&#13;
var VBAFMTS = ["xlsb", "xlsm", "xlam", "biff8", "xla"];&#13;
/* macro and dialog sheet stubs */&#13;
function parse_ds_bin() { return {'!type':'dialog'}; }&#13;
function parse_ds_xml() { return {'!type':'dialog'}; }&#13;
function parse_ms_bin() { return {'!type':'macro'}; }&#13;
function parse_ms_xml() { return {'!type':'macro'}; }&#13;
/* TODO: it will be useful to parse the function str */&#13;
var rc_to_a1 = (function(){&#13;
	var rcregex = /(^|[^A-Za-z_])R(\[?-?\d+\]|[1-9]\d*|)C(\[?-?\d+\]|[1-9]\d*|)(?![A-Za-z0-9_])/g;&#13;
	var rcbase = ({r:0,c:0});&#13;
	function rcfunc($$,$1,$2,$3) {&#13;
		var cRel = false, rRel = false;&#13;
&#13;
		if($2.length == 0) rRel = true;&#13;
		else if($2.charAt(0) == "[") { rRel = true; $2 = $2.slice(1, -1); }&#13;
&#13;
		if($3.length == 0) cRel = true;&#13;
		else if($3.charAt(0) == "[") { cRel = true; $3 = $3.slice(1, -1); }&#13;
&#13;
		var R = $2.length&gt;0?parseInt($2,10)|0:0, C = $3.length&gt;0?parseInt($3,10)|0:0;&#13;
&#13;
		if(cRel) C += rcbase.c; else --C;&#13;
		if(rRel) R += rcbase.r; else --R;&#13;
		return $1 + (cRel ? "" : "$") + encode_col(C) + (rRel ? "" : "$") + encode_row(R);&#13;
	}&#13;
	return function rc_to_a1(fstr, base) {&#13;
		rcbase = base;&#13;
		return fstr.replace(rcregex, rcfunc);&#13;
	};&#13;
})();&#13;
&#13;
var crefregex = /(^|[^._A-Z0-9])([$]?)([A-Z]{1,2}|[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D])([$]?)(10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5})(?![_.\(A-Za-z0-9])/g;&#13;
var a1_to_rc = (function(){&#13;
	return function a1_to_rc(fstr, base) {&#13;
		return fstr.replace(crefregex, function($0, $1, $2, $3, $4, $5) {&#13;
			var c = decode_col($3) - ($2 ? 0 : base.c);&#13;
			var r = decode_row($5) - ($4 ? 0 : base.r);&#13;
			var R = $4 == "$" ? (r+1) : (r == 0 ? "" : "[" + r + "]");&#13;
			var C = $2 == "$" ? (c+1) : (c == 0 ? "" : "[" + c + "]");&#13;
			return $1 + "R" + R + "C" + C;&#13;
		});&#13;
	};&#13;
})();&#13;
&#13;
/* no defined name can collide with a valid cell address A1:XFD1048576 ... except LOG10! */&#13;
function shift_formula_str(f, delta) {&#13;
	return f.replace(crefregex, function($0, $1, $2, $3, $4, $5) {&#13;
		return $1+($2=="$" ? $2+$3 : encode_col(decode_col($3)+delta.c))+($4=="$" ? $4+$5 : encode_row(decode_row($5) + delta.r));&#13;
	});&#13;
}&#13;
&#13;
function shift_formula_xlsx(f, range, cell) {&#13;
	var r = decode_range(range), s = r.s, c = decode_cell(cell);&#13;
	var delta = {r:c.r - s.r, c:c.c - s.c};&#13;
	return shift_formula_str(f, delta);&#13;
}&#13;
&#13;
/* TODO: parse formula */&#13;
function fuzzyfmla(f) {&#13;
	if(f.length == 1) return false;&#13;
	return true;&#13;
}&#13;
&#13;
function _xlfn(f) {&#13;
	return f.replace(/_xlfn\./g,"");&#13;
}&#13;
function parseread1(blob) { blob.l+=1; return; }&#13;
&#13;
/* [MS-XLS] 2.5.51 */&#13;
function parse_ColRelU(blob, length) {&#13;
	var c = blob.read_shift(length == 1 ? 1 : 2);&#13;
	return [c &amp; 0x3FFF, (c &gt;&gt; 14) &amp; 1, (c &gt;&gt; 15) &amp; 1];&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.198.105 ; [MS-XLSB] 2.5.97.89 */&#13;
function parse_RgceArea(blob, length, opts) {&#13;
	var w = 2;&#13;
	if(opts) {&#13;
		if(opts.biff &gt;= 2 &amp;&amp; opts.biff &lt;= 5) return parse_RgceArea_BIFF2(blob, length, opts);&#13;
		else if(opts.biff == 12) w = 4;&#13;
	}&#13;
	var r=blob.read_shift(w), R=blob.read_shift(w);&#13;
	var c=parse_ColRelU(blob, 2);&#13;
	var C=parse_ColRelU(blob, 2);&#13;
	return { s:{r:r, c:c[0], cRel:c[1], rRel:c[2]}, e:{r:R, c:C[0], cRel:C[1], rRel:C[2]} };&#13;
}&#13;
/* BIFF 2-5 encodes flags in the row field */&#13;
function parse_RgceArea_BIFF2(blob) {&#13;
	var r=parse_ColRelU(blob, 2), R=parse_ColRelU(blob, 2);&#13;
	var c=blob.read_shift(1);&#13;
	var C=blob.read_shift(1);&#13;
	return { s:{r:r[0], c:c, cRel:r[1], rRel:r[2]}, e:{r:R[0], c:C, cRel:R[1], rRel:R[2]} };&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.198.105 ; [MS-XLSB] 2.5.97.90 */&#13;
function parse_RgceAreaRel(blob, length, opts) {&#13;
	if(opts.biff &lt; 8) return parse_RgceArea_BIFF2(blob, length, opts);&#13;
	var r=blob.read_shift(opts.biff == 12 ? 4 : 2), R=blob.read_shift(opts.biff == 12 ? 4 : 2);&#13;
	var c=parse_ColRelU(blob, 2);&#13;
	var C=parse_ColRelU(blob, 2);&#13;
	return { s:{r:r, c:c[0], cRel:c[1], rRel:c[2]}, e:{r:R, c:C[0], cRel:C[1], rRel:C[2]} };&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.198.109 ; [MS-XLSB] 2.5.97.91 */&#13;
function parse_RgceLoc(blob, length, opts) {&#13;
	if(opts &amp;&amp; opts.biff &gt;= 2 &amp;&amp; opts.biff &lt;= 5) return parse_RgceLoc_BIFF2(blob, length, opts);&#13;
	var r = blob.read_shift(opts &amp;&amp; opts.biff == 12 ? 4 : 2);&#13;
	var c = parse_ColRelU(blob, 2);&#13;
	return {r:r, c:c[0], cRel:c[1], rRel:c[2]};&#13;
}&#13;
function parse_RgceLoc_BIFF2(blob) {&#13;
	var r = parse_ColRelU(blob, 2);&#13;
	var c = blob.read_shift(1);&#13;
	return {r:r[0], c:c, cRel:r[1], rRel:r[2]};&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.198.107, 2.5.47 */&#13;
function parse_RgceElfLoc(blob) {&#13;
	var r = blob.read_shift(2);&#13;
	var c = blob.read_shift(2);&#13;
	return {r:r, c:c &amp; 0xFF, fQuoted:!!(c &amp; 0x4000), cRel:c&gt;&gt;15, rRel:c&gt;&gt;15 };&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.198.111 ; [MS-XLSB] 2.5.97.92 TODO */&#13;
function parse_RgceLocRel(blob, length, opts) {&#13;
	var biff = opts &amp;&amp; opts.biff ? opts.biff : 8;&#13;
	if(biff &gt;= 2 &amp;&amp; biff &lt;= 5) return parse_RgceLocRel_BIFF2(blob, length, opts);&#13;
	var r = blob.read_shift(biff &gt;= 12 ? 4 : 2);&#13;
	var cl = blob.read_shift(2);&#13;
	var cRel = (cl &amp; 0x4000) &gt;&gt; 14, rRel = (cl &amp; 0x8000) &gt;&gt; 15;&#13;
	cl &amp;= 0x3FFF;&#13;
	if(rRel == 1) while(r &gt; 0x7FFFF) r -= 0x100000;&#13;
	if(cRel == 1) while(cl &gt; 0x1FFF) cl = cl - 0x4000;&#13;
	return {r:r,c:cl,cRel:cRel,rRel:rRel};&#13;
}&#13;
function parse_RgceLocRel_BIFF2(blob) {&#13;
	var rl = blob.read_shift(2);&#13;
	var c = blob.read_shift(1);&#13;
	var rRel = (rl &amp; 0x8000) &gt;&gt; 15, cRel = (rl &amp; 0x4000) &gt;&gt; 14;&#13;
	rl &amp;= 0x3FFF;&#13;
	if(rRel == 1 &amp;&amp; rl &gt;= 0x2000) rl = rl - 0x4000;&#13;
	if(cRel == 1 &amp;&amp; c &gt;= 0x80) c = c - 0x100;&#13;
	return {r:rl,c:c,cRel:cRel,rRel:rRel};&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.198.27 ; [MS-XLSB] 2.5.97.18 */&#13;
function parse_PtgArea(blob, length, opts) {&#13;
	var type = (blob[blob.l++] &amp; 0x60) &gt;&gt; 5;&#13;
	var area = parse_RgceArea(blob, opts.biff &gt;= 2 &amp;&amp; opts.biff &lt;= 5 ? 6 : 8, opts);&#13;
	return [type, area];&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.198.28 ; [MS-XLSB] 2.5.97.19 */&#13;
function parse_PtgArea3d(blob, length, opts) {&#13;
	var type = (blob[blob.l++] &amp; 0x60) &gt;&gt; 5;&#13;
	var ixti = blob.read_shift(2, 'i');&#13;
	var w = 8;&#13;
	if(opts) switch(opts.biff) {&#13;
		case 5: blob.l += 12; w = 6; break;&#13;
		case 12: w = 12; break;&#13;
	}&#13;
	var area = parse_RgceArea(blob, w, opts);&#13;
	return [type, ixti, area];&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.198.29 ; [MS-XLSB] 2.5.97.20 */&#13;
function parse_PtgAreaErr(blob, length, opts) {&#13;
	var type = (blob[blob.l++] &amp; 0x60) &gt;&gt; 5;&#13;
	blob.l += opts &amp;&amp; (opts.biff &gt; 8) ? 12 : (opts.biff &lt; 8 ? 6 : 8);&#13;
	return [type];&#13;
}&#13;
/* [MS-XLS] 2.5.198.30 ; [MS-XLSB] 2.5.97.21 */&#13;
function parse_PtgAreaErr3d(blob, length, opts) {&#13;
	var type = (blob[blob.l++] &amp; 0x60) &gt;&gt; 5;&#13;
	var ixti = blob.read_shift(2);&#13;
	var w = 8;&#13;
	if(opts) switch(opts.biff) {&#13;
		case 5: blob.l += 12; w = 6; break;&#13;
		case 12: w = 12; break;&#13;
	}&#13;
	blob.l += w;&#13;
	return [type, ixti];&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.198.31 ; [MS-XLSB] 2.5.97.22 */&#13;
function parse_PtgAreaN(blob, length, opts) {&#13;
	var type = (blob[blob.l++] &amp; 0x60) &gt;&gt; 5;&#13;
	var area = parse_RgceAreaRel(blob, length - 1, opts);&#13;
	return [type, area];&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.198.32 ; [MS-XLSB] 2.5.97.23 */&#13;
function parse_PtgArray(blob, length, opts) {&#13;
	var type = (blob[blob.l++] &amp; 0x60) &gt;&gt; 5;&#13;
	blob.l += opts.biff == 2 ? 6 : opts.biff == 12 ? 14 : 7;&#13;
	return [type];&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.198.33 ; [MS-XLSB] 2.5.97.24 */&#13;
function parse_PtgAttrBaxcel(blob) {&#13;
	var bitSemi = blob[blob.l+1] &amp; 0x01; /* 1 = volatile */&#13;
	var bitBaxcel = 1;&#13;
	blob.l += 4;&#13;
	return [bitSemi, bitBaxcel];&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.198.34 ; [MS-XLSB] 2.5.97.25 */&#13;
function parse_PtgAttrChoose(blob, length, opts) {&#13;
	blob.l +=2;&#13;
	var offset = blob.read_shift(opts &amp;&amp; opts.biff == 2 ? 1 : 2);&#13;
	var o = [];&#13;
	/* offset is 1 less than the number of elements */&#13;
	for(var i = 0; i &lt;= offset; ++i) o.push(blob.read_shift(opts &amp;&amp; opts.biff == 2 ? 1 : 2));&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.198.35 ; [MS-XLSB] 2.5.97.26 */&#13;
function parse_PtgAttrGoto(blob, length, opts) {&#13;
	var bitGoto = (blob[blob.l+1] &amp; 0xFF) ? 1 : 0;&#13;
	blob.l += 2;&#13;
	return [bitGoto, blob.read_shift(opts &amp;&amp; opts.biff == 2 ? 1 : 2)];&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.198.36 ; [MS-XLSB] 2.5.97.27 */&#13;
function parse_PtgAttrIf(blob, length, opts) {&#13;
	var bitIf = (blob[blob.l+1] &amp; 0xFF) ? 1 : 0;&#13;
	blob.l += 2;&#13;
	return [bitIf, blob.read_shift(opts &amp;&amp; opts.biff == 2 ? 1 : 2)];&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.5.97.28 */&#13;
function parse_PtgAttrIfError(blob) {&#13;
	var bitIf = (blob[blob.l+1] &amp; 0xFF) ? 1 : 0;&#13;
	blob.l += 2;&#13;
	return [bitIf, blob.read_shift(2)];&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.198.37 ; [MS-XLSB] 2.5.97.29 */&#13;
function parse_PtgAttrSemi(blob, length, opts) {&#13;
	var bitSemi = (blob[blob.l+1] &amp; 0xFF) ? 1 : 0;&#13;
	blob.l += opts &amp;&amp; opts.biff == 2 ? 3 : 4;&#13;
	return [bitSemi];&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.198.40 ; [MS-XLSB] 2.5.97.32 */&#13;
function parse_PtgAttrSpaceType(blob) {&#13;
	var type = blob.read_shift(1), cch = blob.read_shift(1);&#13;
	return [type, cch];&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.198.38 ; [MS-XLSB] 2.5.97.30 */&#13;
function parse_PtgAttrSpace(blob) {&#13;
	blob.read_shift(2);&#13;
	return parse_PtgAttrSpaceType(blob, 2);&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.198.39 ; [MS-XLSB] 2.5.97.31 */&#13;
function parse_PtgAttrSpaceSemi(blob) {&#13;
	blob.read_shift(2);&#13;
	return parse_PtgAttrSpaceType(blob, 2);&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.198.84 ; [MS-XLSB] 2.5.97.68 TODO */&#13;
function parse_PtgRef(blob, length, opts) {&#13;
	//var ptg = blob[blob.l] &amp; 0x1F;&#13;
	var type = (blob[blob.l] &amp; 0x60)&gt;&gt;5;&#13;
	blob.l += 1;&#13;
	var loc = parse_RgceLoc(blob, 0, opts);&#13;
	return [type, loc];&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.198.88 ; [MS-XLSB] 2.5.97.72 TODO */&#13;
function parse_PtgRefN(blob, length, opts) {&#13;
	var type = (blob[blob.l] &amp; 0x60)&gt;&gt;5;&#13;
	blob.l += 1;&#13;
	var loc = parse_RgceLocRel(blob, 0, opts);&#13;
	return [type, loc];&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.198.85 ; [MS-XLSB] 2.5.97.69 TODO */&#13;
function parse_PtgRef3d(blob, length, opts) {&#13;
	var type = (blob[blob.l] &amp; 0x60)&gt;&gt;5;&#13;
	blob.l += 1;&#13;
	var ixti = blob.read_shift(2); // XtiIndex&#13;
	if(opts &amp;&amp; opts.biff == 5) blob.l += 12;&#13;
	var loc = parse_RgceLoc(blob, 0, opts); // TODO: or RgceLocRel&#13;
	return [type, ixti, loc];&#13;
}&#13;
&#13;
&#13;
/* [MS-XLS] 2.5.198.62 ; [MS-XLSB] 2.5.97.45 TODO */&#13;
function parse_PtgFunc(blob, length, opts) {&#13;
	//var ptg = blob[blob.l] &amp; 0x1F;&#13;
	var type = (blob[blob.l] &amp; 0x60)&gt;&gt;5;&#13;
	blob.l += 1;&#13;
	var iftab = blob.read_shift(opts &amp;&amp; opts.biff &lt;= 3 ? 1 : 2);&#13;
	return [FtabArgc[iftab], Ftab[iftab], type];&#13;
}&#13;
/* [MS-XLS] 2.5.198.63 ; [MS-XLSB] 2.5.97.46 TODO */&#13;
function parse_PtgFuncVar(blob, length, opts) {&#13;
	var type = blob[blob.l++];&#13;
	var cparams = blob.read_shift(1), tab = opts &amp;&amp; opts.biff &lt;= 3 ? [(type == 0x58 ? -1 : 0), blob.read_shift(1)]: parsetab(blob);&#13;
	return [cparams, (tab[0] === 0 ? Ftab : Cetab)[tab[1]]];&#13;
}&#13;
&#13;
function parsetab(blob) {&#13;
	return [blob[blob.l+1]&gt;&gt;7, blob.read_shift(2) &amp; 0x7FFF];&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.198.41 ; [MS-XLSB] 2.5.97.33 */&#13;
function parse_PtgAttrSum(blob, length, opts) {&#13;
	blob.l += opts &amp;&amp; opts.biff == 2 ? 3 : 4; return;&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.198.58 ; [MS-XLSB] 2.5.97.40 */&#13;
function parse_PtgExp(blob, length, opts) {&#13;
	blob.l++;&#13;
	if(opts &amp;&amp; opts.biff == 12) return [blob.read_shift(4, 'i'), 0];&#13;
	var row = blob.read_shift(2);&#13;
	var col = blob.read_shift(opts &amp;&amp; opts.biff == 2 ? 1 : 2);&#13;
	return [row, col];&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.198.57 ; [MS-XLSB] 2.5.97.39 */&#13;
function parse_PtgErr(blob) { blob.l++; return BErr[blob.read_shift(1)]; }&#13;
&#13;
/* [MS-XLS] 2.5.198.66 ; [MS-XLSB] 2.5.97.49 */&#13;
function parse_PtgInt(blob) { blob.l++; return blob.read_shift(2); }&#13;
&#13;
/* [MS-XLS] 2.5.198.42 ; [MS-XLSB] 2.5.97.34 */&#13;
function parse_PtgBool(blob) { blob.l++; return blob.read_shift(1)!==0;}&#13;
&#13;
/* [MS-XLS] 2.5.198.79 ; [MS-XLSB] 2.5.97.63 */&#13;
function parse_PtgNum(blob) { blob.l++; return parse_Xnum(blob, 8); }&#13;
&#13;
/* [MS-XLS] 2.5.198.89 ; [MS-XLSB] 2.5.97.74 */&#13;
function parse_PtgStr(blob, length, opts) { blob.l++; return parse_ShortXLUnicodeString(blob, length-1, opts); }&#13;
&#13;
/* [MS-XLS] 2.5.192.112 + 2.5.192.11{3,4,5,6,7} */&#13;
/* [MS-XLSB] 2.5.97.93 + 2.5.97.9{4,5,6,7} */&#13;
function parse_SerAr(blob, biff) {&#13;
	var val = [blob.read_shift(1)];&#13;
	if(biff == 12) switch(val[0]) {&#13;
		case 0x02: val[0] = 0x04; break; /* SerBool */&#13;
		case 0x04: val[0] = 0x10; break; /* SerErr */&#13;
		case 0x00: val[0] = 0x01; break; /* SerNum */&#13;
		case 0x01: val[0] = 0x02; break; /* SerStr */&#13;
	}&#13;
	switch(val[0]) {&#13;
		case 0x04: /* SerBool -- boolean */&#13;
			val[1] = parsebool(blob, 1) ? 'TRUE' : 'FALSE';&#13;
			if(biff != 12) blob.l += 7; break;&#13;
		case 0x25: /* appears to be an alias */&#13;
		case 0x10: /* SerErr -- error */&#13;
			val[1] = BErr[blob[blob.l]];&#13;
			blob.l += ((biff == 12) ? 4 : 8); break;&#13;
		case 0x00: /* SerNil -- honestly, I'm not sure how to reproduce this */&#13;
			blob.l += 8; break;&#13;
		case 0x01: /* SerNum -- Xnum */&#13;
			val[1] = parse_Xnum(blob, 8); break;&#13;
		case 0x02: /* SerStr -- XLUnicodeString (&lt;256 chars) */&#13;
			val[1] = parse_XLUnicodeString2(blob, 0, {biff:biff &gt; 0 &amp;&amp; biff &lt; 8 ? 2 : biff}); break;&#13;
		default: throw new Error("Bad SerAr: " + val[0]); /* Unreachable */&#13;
	}&#13;
	return val;&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.198.61 ; [MS-XLSB] 2.5.97.44 */&#13;
function parse_PtgExtraMem(blob, cce, opts) {&#13;
	var count = blob.read_shift((opts.biff == 12) ? 4 : 2);&#13;
	var out = [];&#13;
	for(var i = 0; i != count; ++i) out.push(((opts.biff == 12) ? parse_UncheckedRfX : parse_Ref8U)(blob, 8));&#13;
	return out;&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.198.59 ; [MS-XLSB] 2.5.97.41 */&#13;
function parse_PtgExtraArray(blob, length, opts) {&#13;
	var rows = 0, cols = 0;&#13;
	if(opts.biff == 12) {&#13;
		rows = blob.read_shift(4); // DRw&#13;
		cols = blob.read_shift(4); // DCol&#13;
	} else {&#13;
		cols = 1 + blob.read_shift(1); //DColByteU&#13;
		rows = 1 + blob.read_shift(2); //DRw&#13;
	}&#13;
	if(opts.biff &gt;= 2 &amp;&amp; opts.biff &lt; 8) { --rows; if(--cols == 0) cols = 0x100; }&#13;
	// $FlowIgnore&#13;
	for(var i = 0, o = []; i != rows &amp;&amp; (o[i] = []); ++i)&#13;
		for(var j = 0; j != cols; ++j) o[i][j] = parse_SerAr(blob, opts.biff);&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.198.76 ; [MS-XLSB] 2.5.97.60 */&#13;
function parse_PtgName(blob, length, opts) {&#13;
	var type = (blob.read_shift(1) &gt;&gt;&gt; 5) &amp; 0x03;&#13;
	var w = (!opts || (opts.biff &gt;= 8)) ? 4 : 2;&#13;
	var nameindex = blob.read_shift(w);&#13;
	switch(opts.biff) {&#13;
		case 2: blob.l += 5; break;&#13;
		case 3: case 4: blob.l += 8; break;&#13;
		case 5: blob.l += 12; break;&#13;
	}&#13;
	return [type, 0, nameindex];&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.198.77 ; [MS-XLSB] 2.5.97.61 */&#13;
function parse_PtgNameX(blob, length, opts) {&#13;
	if(opts.biff == 5) return parse_PtgNameX_BIFF5(blob, length, opts);&#13;
	var type = (blob.read_shift(1) &gt;&gt;&gt; 5) &amp; 0x03;&#13;
	var ixti = blob.read_shift(2); // XtiIndex&#13;
	var nameindex = blob.read_shift(4);&#13;
	return [type, ixti, nameindex];&#13;
}&#13;
function parse_PtgNameX_BIFF5(blob) {&#13;
	var type = (blob.read_shift(1) &gt;&gt;&gt; 5) &amp; 0x03;&#13;
	var ixti = blob.read_shift(2, 'i'); // XtiIndex&#13;
	blob.l += 8;&#13;
	var nameindex = blob.read_shift(2);&#13;
	blob.l += 12;&#13;
	return [type, ixti, nameindex];&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.198.70 ; [MS-XLSB] 2.5.97.54 */&#13;
function parse_PtgMemArea(blob, length, opts) {&#13;
	var type = (blob.read_shift(1) &gt;&gt;&gt; 5) &amp; 0x03;&#13;
	blob.l += (opts &amp;&amp; opts.biff == 2 ? 3 : 4);&#13;
	var cce = blob.read_shift(opts &amp;&amp; opts.biff == 2 ? 1 : 2);&#13;
	return [type, cce];&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.198.72 ; [MS-XLSB] 2.5.97.56 */&#13;
function parse_PtgMemFunc(blob, length, opts) {&#13;
	var type = (blob.read_shift(1) &gt;&gt;&gt; 5) &amp; 0x03;&#13;
	var cce = blob.read_shift(opts &amp;&amp; opts.biff == 2 ? 1 : 2);&#13;
	return [type, cce];&#13;
}&#13;
&#13;
&#13;
/* [MS-XLS] 2.5.198.86 ; [MS-XLSB] 2.5.97.69 */&#13;
function parse_PtgRefErr(blob, length, opts) {&#13;
	var type = (blob.read_shift(1) &gt;&gt;&gt; 5) &amp; 0x03;&#13;
	blob.l += 4;&#13;
	if(opts.biff &lt; 8) blob.l--;&#13;
	if(opts.biff == 12) blob.l += 2;&#13;
	return [type];&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.198.87 ; [MS-XLSB] 2.5.97.71 */&#13;
function parse_PtgRefErr3d(blob, length, opts) {&#13;
	var type = (blob[blob.l++] &amp; 0x60) &gt;&gt; 5;&#13;
	var ixti = blob.read_shift(2);&#13;
	var w = 4;&#13;
	if(opts) switch(opts.biff) {&#13;
		case 5: w = 15; break;&#13;
		case 12: w = 6; break;&#13;
	}&#13;
	blob.l += w;&#13;
	return [type, ixti];&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.198.71 ; [MS-XLSB] 2.5.97.55 */&#13;
var parse_PtgMemErr = parsenoop;&#13;
/* [MS-XLS] 2.5.198.73  ; [MS-XLSB] 2.5.97.57 */&#13;
var parse_PtgMemNoMem = parsenoop;&#13;
/* [MS-XLS] 2.5.198.92 */&#13;
var parse_PtgTbl = parsenoop;&#13;
&#13;
function parse_PtgElfLoc(blob, length, opts) {&#13;
	blob.l += 2;&#13;
	return [parse_RgceElfLoc(blob, 4, opts)];&#13;
}&#13;
function parse_PtgElfNoop(blob) {&#13;
	blob.l += 6;&#13;
	return [];&#13;
}&#13;
/* [MS-XLS] 2.5.198.46 */&#13;
var parse_PtgElfCol = parse_PtgElfLoc;&#13;
/* [MS-XLS] 2.5.198.47 */&#13;
var parse_PtgElfColS = parse_PtgElfNoop;&#13;
/* [MS-XLS] 2.5.198.48 */&#13;
var parse_PtgElfColSV = parse_PtgElfNoop;&#13;
/* [MS-XLS] 2.5.198.49 */&#13;
var parse_PtgElfColV = parse_PtgElfLoc;&#13;
/* [MS-XLS] 2.5.198.50 */&#13;
function parse_PtgElfLel(blob) {&#13;
	blob.l += 2;&#13;
	return [parseuint16(blob), blob.read_shift(2) &amp; 0x01];&#13;
}&#13;
/* [MS-XLS] 2.5.198.51 */&#13;
var parse_PtgElfRadical = parse_PtgElfLoc;&#13;
/* [MS-XLS] 2.5.198.52 */&#13;
var parse_PtgElfRadicalLel = parse_PtgElfLel;&#13;
/* [MS-XLS] 2.5.198.53 */&#13;
var parse_PtgElfRadicalS = parse_PtgElfNoop;&#13;
/* [MS-XLS] 2.5.198.54 */&#13;
var parse_PtgElfRw = parse_PtgElfLoc;&#13;
/* [MS-XLS] 2.5.198.55 */&#13;
var parse_PtgElfRwV = parse_PtgElfLoc;&#13;
&#13;
/* [MS-XLSB] 2.5.97.52 TODO */&#13;
var PtgListRT = [&#13;
	"Data",&#13;
	"All",&#13;
	"Headers",&#13;
	"??",&#13;
	"?Data2",&#13;
	"??",&#13;
	"?DataHeaders",&#13;
	"??",&#13;
	"Totals",&#13;
	"??",&#13;
	"??",&#13;
	"??",&#13;
	"?DataTotals",&#13;
	"??",&#13;
	"??",&#13;
	"??",&#13;
	"?Current"&#13;
];&#13;
function parse_PtgList(blob) {&#13;
	blob.l += 2;&#13;
	var ixti = blob.read_shift(2);&#13;
	var flags = blob.read_shift(2);&#13;
	var idx = blob.read_shift(4);&#13;
	var c = blob.read_shift(2);&#13;
	var C = blob.read_shift(2);&#13;
	var rt = PtgListRT[(flags &gt;&gt; 2) &amp; 0x1F];&#13;
	return {ixti: ixti, coltype:(flags&amp;0x3), rt:rt, idx:idx, c:c, C:C};&#13;
}&#13;
/* [MS-XLS] 2.5.198.91 ; [MS-XLSB] 2.5.97.76 */&#13;
function parse_PtgSxName(blob) {&#13;
	blob.l += 2;&#13;
	return [blob.read_shift(4)];&#13;
}&#13;
&#13;
/* [XLS] old spec */&#13;
function parse_PtgSheet(blob, length, opts) {&#13;
	blob.l += 5;&#13;
	blob.l += 2;&#13;
	blob.l += (opts.biff == 2 ? 1 : 4);&#13;
	return ["PTGSHEET"];&#13;
}&#13;
function parse_PtgEndSheet(blob, length, opts) {&#13;
	blob.l += (opts.biff == 2 ? 4 : 5);&#13;
	return ["PTGENDSHEET"];&#13;
}&#13;
function parse_PtgMemAreaN(blob) {&#13;
	var type = (blob.read_shift(1) &gt;&gt;&gt; 5) &amp; 0x03;&#13;
	var cce = blob.read_shift(2);&#13;
	return [type, cce];&#13;
}&#13;
function parse_PtgMemNoMemN(blob) {&#13;
	var type = (blob.read_shift(1) &gt;&gt;&gt; 5) &amp; 0x03;&#13;
	var cce = blob.read_shift(2);&#13;
	return [type, cce];&#13;
}&#13;
function parse_PtgAttrNoop(blob) {&#13;
	blob.l += 4;&#13;
	return [0, 0];&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.198.25 ; [MS-XLSB] 2.5.97.16 */&#13;
var PtgTypes = {&#13;
0x01: { n:'PtgExp', f:parse_PtgExp },&#13;
0x02: { n:'PtgTbl', f:parse_PtgTbl },&#13;
0x03: { n:'PtgAdd', f:parseread1 },&#13;
0x04: { n:'PtgSub', f:parseread1 },&#13;
0x05: { n:'PtgMul', f:parseread1 },&#13;
0x06: { n:'PtgDiv', f:parseread1 },&#13;
0x07: { n:'PtgPower', f:parseread1 },&#13;
0x08: { n:'PtgConcat', f:parseread1 },&#13;
0x09: { n:'PtgLt', f:parseread1 },&#13;
0x0A: { n:'PtgLe', f:parseread1 },&#13;
0x0B: { n:'PtgEq', f:parseread1 },&#13;
0x0C: { n:'PtgGe', f:parseread1 },&#13;
0x0D: { n:'PtgGt', f:parseread1 },&#13;
0x0E: { n:'PtgNe', f:parseread1 },&#13;
0x0F: { n:'PtgIsect', f:parseread1 },&#13;
0x10: { n:'PtgUnion', f:parseread1 },&#13;
0x11: { n:'PtgRange', f:parseread1 },&#13;
0x12: { n:'PtgUplus', f:parseread1 },&#13;
0x13: { n:'PtgUminus', f:parseread1 },&#13;
0x14: { n:'PtgPercent', f:parseread1 },&#13;
0x15: { n:'PtgParen', f:parseread1 },&#13;
0x16: { n:'PtgMissArg', f:parseread1 },&#13;
0x17: { n:'PtgStr', f:parse_PtgStr },&#13;
0x1A: { n:'PtgSheet', f:parse_PtgSheet },&#13;
0x1B: { n:'PtgEndSheet', f:parse_PtgEndSheet },&#13;
0x1C: { n:'PtgErr', f:parse_PtgErr },&#13;
0x1D: { n:'PtgBool', f:parse_PtgBool },&#13;
0x1E: { n:'PtgInt', f:parse_PtgInt },&#13;
0x1F: { n:'PtgNum', f:parse_PtgNum },&#13;
0x20: { n:'PtgArray', f:parse_PtgArray },&#13;
0x21: { n:'PtgFunc', f:parse_PtgFunc },&#13;
0x22: { n:'PtgFuncVar', f:parse_PtgFuncVar },&#13;
0x23: { n:'PtgName', f:parse_PtgName },&#13;
0x24: { n:'PtgRef', f:parse_PtgRef },&#13;
0x25: { n:'PtgArea', f:parse_PtgArea },&#13;
0x26: { n:'PtgMemArea', f:parse_PtgMemArea },&#13;
0x27: { n:'PtgMemErr', f:parse_PtgMemErr },&#13;
0x28: { n:'PtgMemNoMem', f:parse_PtgMemNoMem },&#13;
0x29: { n:'PtgMemFunc', f:parse_PtgMemFunc },&#13;
0x2A: { n:'PtgRefErr', f:parse_PtgRefErr },&#13;
0x2B: { n:'PtgAreaErr', f:parse_PtgAreaErr },&#13;
0x2C: { n:'PtgRefN', f:parse_PtgRefN },&#13;
0x2D: { n:'PtgAreaN', f:parse_PtgAreaN },&#13;
0x2E: { n:'PtgMemAreaN', f:parse_PtgMemAreaN },&#13;
0x2F: { n:'PtgMemNoMemN', f:parse_PtgMemNoMemN },&#13;
0x39: { n:'PtgNameX', f:parse_PtgNameX },&#13;
0x3A: { n:'PtgRef3d', f:parse_PtgRef3d },&#13;
0x3B: { n:'PtgArea3d', f:parse_PtgArea3d },&#13;
0x3C: { n:'PtgRefErr3d', f:parse_PtgRefErr3d },&#13;
0x3D: { n:'PtgAreaErr3d', f:parse_PtgAreaErr3d },&#13;
0xFF: {}&#13;
};&#13;
/* These are duplicated in the PtgTypes table */&#13;
var PtgDupes = {&#13;
0x40: 0x20, 0x60: 0x20,&#13;
0x41: 0x21, 0x61: 0x21,&#13;
0x42: 0x22, 0x62: 0x22,&#13;
0x43: 0x23, 0x63: 0x23,&#13;
0x44: 0x24, 0x64: 0x24,&#13;
0x45: 0x25, 0x65: 0x25,&#13;
0x46: 0x26, 0x66: 0x26,&#13;
0x47: 0x27, 0x67: 0x27,&#13;
0x48: 0x28, 0x68: 0x28,&#13;
0x49: 0x29, 0x69: 0x29,&#13;
0x4A: 0x2A, 0x6A: 0x2A,&#13;
0x4B: 0x2B, 0x6B: 0x2B,&#13;
0x4C: 0x2C, 0x6C: 0x2C,&#13;
0x4D: 0x2D, 0x6D: 0x2D,&#13;
0x4E: 0x2E, 0x6E: 0x2E,&#13;
0x4F: 0x2F, 0x6F: 0x2F,&#13;
0x58: 0x22, 0x78: 0x22,&#13;
0x59: 0x39, 0x79: 0x39,&#13;
0x5A: 0x3A, 0x7A: 0x3A,&#13;
0x5B: 0x3B, 0x7B: 0x3B,&#13;
0x5C: 0x3C, 0x7C: 0x3C,&#13;
0x5D: 0x3D, 0x7D: 0x3D&#13;
};&#13;
&#13;
var Ptg18 = {&#13;
0x01: { n:'PtgElfLel', f:parse_PtgElfLel },&#13;
0x02: { n:'PtgElfRw', f:parse_PtgElfRw },&#13;
0x03: { n:'PtgElfCol', f:parse_PtgElfCol },&#13;
0x06: { n:'PtgElfRwV', f:parse_PtgElfRwV },&#13;
0x07: { n:'PtgElfColV', f:parse_PtgElfColV },&#13;
0x0A: { n:'PtgElfRadical', f:parse_PtgElfRadical },&#13;
0x0B: { n:'PtgElfRadicalS', f:parse_PtgElfRadicalS },&#13;
0x0D: { n:'PtgElfColS', f:parse_PtgElfColS },&#13;
0x0F: { n:'PtgElfColSV', f:parse_PtgElfColSV },&#13;
0x10: { n:'PtgElfRadicalLel', f:parse_PtgElfRadicalLel },&#13;
0x19: { n:'PtgList', f:parse_PtgList },&#13;
0x1D: { n:'PtgSxName', f:parse_PtgSxName },&#13;
0xFF: {}&#13;
};&#13;
var Ptg19 = {&#13;
0x00: { n:'PtgAttrNoop', f:parse_PtgAttrNoop },&#13;
0x01: { n:'PtgAttrSemi', f:parse_PtgAttrSemi },&#13;
0x02: { n:'PtgAttrIf', f:parse_PtgAttrIf },&#13;
0x04: { n:'PtgAttrChoose', f:parse_PtgAttrChoose },&#13;
0x08: { n:'PtgAttrGoto', f:parse_PtgAttrGoto },&#13;
0x10: { n:'PtgAttrSum', f:parse_PtgAttrSum },&#13;
0x20: { n:'PtgAttrBaxcel', f:parse_PtgAttrBaxcel },&#13;
0x21: { n:'PtgAttrBaxcel', f:parse_PtgAttrBaxcel },&#13;
0x40: { n:'PtgAttrSpace', f:parse_PtgAttrSpace },&#13;
0x41: { n:'PtgAttrSpaceSemi', f:parse_PtgAttrSpaceSemi },&#13;
0x80: { n:'PtgAttrIfError', f:parse_PtgAttrIfError },&#13;
0xFF: {}&#13;
};&#13;
&#13;
/* [MS-XLS] 2.5.198.103 ; [MS-XLSB] 2.5.97.87 */&#13;
function parse_RgbExtra(blob, length, rgce, opts) {&#13;
	if(opts.biff &lt; 8) return parsenoop(blob, length);&#13;
	var target = blob.l + length;&#13;
	var o = [];&#13;
	for(var i = 0; i !== rgce.length; ++i) {&#13;
		switch(rgce[i][0]) {&#13;
			case 'PtgArray': /* PtgArray -&gt; PtgExtraArray */&#13;
				rgce[i][1] = parse_PtgExtraArray(blob, 0, opts);&#13;
				o.push(rgce[i][1]);&#13;
				break;&#13;
			case 'PtgMemArea': /* PtgMemArea -&gt; PtgExtraMem */&#13;
				rgce[i][2] = parse_PtgExtraMem(blob, rgce[i][1], opts);&#13;
				o.push(rgce[i][2]);&#13;
				break;&#13;
			case 'PtgExp': /* PtgExp -&gt; PtgExtraCol */&#13;
				if(opts &amp;&amp; opts.biff == 12) {&#13;
					rgce[i][1][1] = blob.read_shift(4);&#13;
					o.push(rgce[i][1]);&#13;
				} break;&#13;
			case 'PtgList': /* TODO: PtgList -&gt; PtgExtraList */&#13;
			case 'PtgElfRadicalS': /* TODO: PtgElfRadicalS -&gt; PtgExtraElf */&#13;
			case 'PtgElfColS': /* TODO: PtgElfColS -&gt; PtgExtraElf */&#13;
			case 'PtgElfColSV': /* TODO: PtgElfColSV -&gt; PtgExtraElf */&#13;
				throw "Unsupported " + rgce[i][0];&#13;
			default: break;&#13;
		}&#13;
	}&#13;
	length = target - blob.l;&#13;
	/* note: this is technically an error but Excel disregards */&#13;
	//if(target !== blob.l &amp;&amp; blob.l !== target - length) throw new Error(target + " != " + blob.l);&#13;
	if(length !== 0) o.push(parsenoop(blob, length));&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.198.104 ; [MS-XLSB] 2.5.97.88 */&#13;
function parse_Rgce(blob, length, opts) {&#13;
	var target = blob.l + length;&#13;
	var R, id, ptgs = [];&#13;
	while(target != blob.l) {&#13;
		length = target - blob.l;&#13;
		id = blob[blob.l];&#13;
		R = PtgTypes[id] || PtgTypes[PtgDupes[id]];&#13;
		if(id === 0x18 || id === 0x19) R = (id === 0x18 ? Ptg18 : Ptg19)[blob[blob.l + 1]];&#13;
		if(!R || !R.f) { /*ptgs.push*/(parsenoop(blob, length)); }&#13;
		else { ptgs.push([R.n, R.f(blob, length, opts)]); }&#13;
	}&#13;
	return ptgs;&#13;
}&#13;
&#13;
function stringify_array(f) {&#13;
	var o = [];&#13;
	for(var i = 0; i &lt; f.length; ++i) {&#13;
		var x = f[i], r = [];&#13;
		for(var j = 0; j &lt; x.length; ++j) {&#13;
			var y = x[j];&#13;
			if(y) switch(y[0]) {&#13;
				// TODO: handle embedded quotes&#13;
				case 0x02:&#13;
r.push('"' + y[1].replace(/"/g,'""') + '"'); break;&#13;
				default: r.push(y[1]);&#13;
			} else r.push("");&#13;
		}&#13;
		o.push(r.join(","));&#13;
	}&#13;
	return o.join(";");&#13;
}&#13;
&#13;
/* [MS-XLS] 2.2.2 ; [MS-XLSB] 2.2.2 TODO */&#13;
var PtgBinOp = {&#13;
	PtgAdd: "+",&#13;
	PtgConcat: "&amp;",&#13;
	PtgDiv: "/",&#13;
	PtgEq: "=",&#13;
	PtgGe: "&gt;=",&#13;
	PtgGt: "&gt;",&#13;
	PtgLe: "&lt;=",&#13;
	PtgLt: "&lt;",&#13;
	PtgMul: "*",&#13;
	PtgNe: "&lt;&gt;",&#13;
	PtgPower: "^",&#13;
	PtgSub: "-"&#13;
};&#13;
&#13;
// TODO: explore space&#13;
function make_3d_range(start, end) {&#13;
	var s = start.lastIndexOf("!"), e = end.lastIndexOf("!");&#13;
	if(s == -1 &amp;&amp; e == -1) return start + ":" + end;&#13;
	if(s &gt; 0 &amp;&amp; e &gt; 0 &amp;&amp; start.slice(0, s).toLowerCase() == end.slice(0, e).toLowerCase()) return start + ":" + end.slice(e+1);&#13;
	console.error("Cannot hydrate range", start, end);&#13;
	return start + ":" + end;&#13;
}&#13;
&#13;
function get_ixti_raw(supbooks, ixti, opts) {&#13;
	if(!supbooks) return "SH33TJSERR0";&#13;
	if(opts.biff &gt; 8 &amp;&amp; (!supbooks.XTI || !supbooks.XTI[ixti])) return supbooks.SheetNames[ixti];&#13;
	if(!supbooks.XTI) return "SH33TJSERR6";&#13;
	var XTI = supbooks.XTI[ixti];&#13;
	if(opts.biff &lt; 8) {&#13;
		if(ixti &gt; 10000) ixti-= 65536;&#13;
		if(ixti &lt; 0) ixti = -ixti;&#13;
		return ixti == 0 ? "" : supbooks.XTI[ixti - 1];&#13;
	}&#13;
	if(!XTI) return "SH33TJSERR1";&#13;
	var o = "";&#13;
	if(opts.biff &gt; 8) switch(supbooks[XTI[0]][0]) {&#13;
		case 0x0165: /* 'BrtSupSelf' */&#13;
			o = XTI[1] == -1 ? "#REF" : supbooks.SheetNames[XTI[1]];&#13;
			return XTI[1] == XTI[2] ? o : o + ":" + supbooks.SheetNames[XTI[2]];&#13;
		case 0x0166: /* 'BrtSupSame' */&#13;
			if(opts.SID != null) return supbooks.SheetNames[opts.SID];&#13;
			return "SH33TJSSAME" + supbooks[XTI[0]][0];&#13;
		case 0x0163: /* 'BrtSupBookSrc' */&#13;
			/* falls through */&#13;
		default: return "SH33TJSSRC" + supbooks[XTI[0]][0];&#13;
	}&#13;
	switch(supbooks[XTI[0]][0][0]) {&#13;
		case 0x0401:&#13;
			o = XTI[1] == -1 ? "#REF" : (supbooks.SheetNames[XTI[1]] || "SH33TJSERR3");&#13;
			return XTI[1] == XTI[2] ? o : o + ":" + supbooks.SheetNames[XTI[2]];&#13;
		case 0x3A01: return supbooks[XTI[0]].slice(1).map(function(name) { return name.Name; }).join(";;"); //return "SH33TJSERR8";&#13;
		default:&#13;
			if(!supbooks[XTI[0]][0][3]) return "SH33TJSERR2";&#13;
			o = XTI[1] == -1 ? "#REF" : (supbooks[XTI[0]][0][3][XTI[1]] || "SH33TJSERR4");&#13;
			return XTI[1] == XTI[2] ? o : o + ":" + supbooks[XTI[0]][0][3][XTI[2]];&#13;
	}&#13;
}&#13;
function get_ixti(supbooks, ixti, opts) {&#13;
	var ixtiraw = get_ixti_raw(supbooks, ixti, opts);&#13;
	return ixtiraw == "#REF" ? ixtiraw : formula_quote_sheet_name(ixtiraw, opts);&#13;
}&#13;
function stringify_formula(formula/*Array&lt;any&gt;*/, range, cell, supbooks, opts) {&#13;
	var biff = (opts &amp;&amp; opts.biff) || 8;&#13;
	var _range = /*range != null ? range :*/ {s:{c:0, r:0},e:{c:0, r:0}};&#13;
	var stack = [], e1, e2,  c, ixti=0, nameidx=0, r, sname="";&#13;
	if(!formula[0] || !formula[0][0]) return "";&#13;
	var last_sp = -1, sp = "";&#13;
	for(var ff = 0, fflen = formula[0].length; ff &lt; fflen; ++ff) {&#13;
		var f = formula[0][ff];&#13;
		switch(f[0]) {&#13;
			case 'PtgUminus': /* [MS-XLS] 2.5.198.93 */&#13;
				stack.push("-" + stack.pop()); break;&#13;
			case 'PtgUplus': /* [MS-XLS] 2.5.198.95 */&#13;
				stack.push("+" + stack.pop()); break;&#13;
			case 'PtgPercent': /* [MS-XLS] 2.5.198.81 */&#13;
				stack.push(stack.pop() + "%"); break;&#13;
&#13;
			case 'PtgAdd':    /* [MS-XLS] 2.5.198.26 */&#13;
			case 'PtgConcat': /* [MS-XLS] 2.5.198.43 */&#13;
			case 'PtgDiv':    /* [MS-XLS] 2.5.198.45 */&#13;
			case 'PtgEq':     /* [MS-XLS] 2.5.198.56 */&#13;
			case 'PtgGe':     /* [MS-XLS] 2.5.198.64 */&#13;
			case 'PtgGt':     /* [MS-XLS] 2.5.198.65 */&#13;
			case 'PtgLe':     /* [MS-XLS] 2.5.198.68 */&#13;
			case 'PtgLt':     /* [MS-XLS] 2.5.198.69 */&#13;
			case 'PtgMul':    /* [MS-XLS] 2.5.198.75 */&#13;
			case 'PtgNe':     /* [MS-XLS] 2.5.198.78 */&#13;
			case 'PtgPower':  /* [MS-XLS] 2.5.198.82 */&#13;
			case 'PtgSub':    /* [MS-XLS] 2.5.198.90 */&#13;
				e1 = stack.pop(); e2 = stack.pop();&#13;
				if(last_sp &gt;= 0) {&#13;
					switch(formula[0][last_sp][1][0]) {&#13;
						case 0:&#13;
							// $FlowIgnore&#13;
							sp = fill(" ", formula[0][last_sp][1][1]); break;&#13;
						case 1:&#13;
							// $FlowIgnore&#13;
							sp = fill("\r", formula[0][last_sp][1][1]); break;&#13;
						default:&#13;
							sp = "";&#13;
							// $FlowIgnore&#13;
							if(opts.WTF) throw new Error("Unexpected PtgAttrSpaceType " + formula[0][last_sp][1][0]);&#13;
					}&#13;
					e2 = e2 + sp;&#13;
					last_sp = -1;&#13;
				}&#13;
				stack.push(e2+PtgBinOp[f[0]]+e1);&#13;
				break;&#13;
&#13;
			case 'PtgIsect': /* [MS-XLS] 2.5.198.67 */&#13;
				e1 = stack.pop(); e2 = stack.pop();&#13;
				stack.push(e2+" "+e1);&#13;
				break;&#13;
			case 'PtgUnion': /* [MS-XLS] 2.5.198.94 */&#13;
				e1 = stack.pop(); e2 = stack.pop();&#13;
				stack.push(e2+","+e1);&#13;
				break;&#13;
			case 'PtgRange': /* [MS-XLS] 2.5.198.83 */&#13;
				e1 = stack.pop(); e2 = stack.pop();&#13;
				stack.push(make_3d_range(e2,e1));&#13;
				break;&#13;
&#13;
			case 'PtgAttrChoose': /* [MS-XLS] 2.5.198.34 */&#13;
				break;&#13;
			case 'PtgAttrGoto': /* [MS-XLS] 2.5.198.35 */&#13;
				break;&#13;
			case 'PtgAttrIf': /* [MS-XLS] 2.5.198.36 */&#13;
				break;&#13;
			case 'PtgAttrIfError': /* [MS-XLSB] 2.5.97.28 */&#13;
				break;&#13;
&#13;
&#13;
			case 'PtgRef': /* [MS-XLS] 2.5.198.84 */&#13;
c = shift_cell_xls((f[1][1]), _range, opts);&#13;
				stack.push(encode_cell_xls(c, biff));&#13;
				break;&#13;
			case 'PtgRefN': /* [MS-XLS] 2.5.198.88 */&#13;
c = cell ? shift_cell_xls((f[1][1]), cell, opts) : (f[1][1]);&#13;
				stack.push(encode_cell_xls(c, biff));&#13;
				break;&#13;
			case 'PtgRef3d': /* [MS-XLS] 2.5.198.85 */&#13;
ixti = f[1][1]; c = shift_cell_xls((f[1][2]), _range, opts);&#13;
				sname = get_ixti(supbooks, ixti, opts);&#13;
				var w = sname; /* IE9 fails on defined names */ // eslint-disable-line no-unused-vars&#13;
				stack.push(sname + "!" + encode_cell_xls(c, biff));&#13;
				break;&#13;
&#13;
			case 'PtgFunc': /* [MS-XLS] 2.5.198.62 */&#13;
			case 'PtgFuncVar': /* [MS-XLS] 2.5.198.63 */&#13;
				/* f[1] = [argc, func, type] */&#13;
				var argc = (f[1][0]), func = (f[1][1]);&#13;
				if(!argc) argc = 0;&#13;
				argc &amp;= 0x7F;&#13;
				var args = argc == 0 ? [] : stack.slice(-argc);&#13;
				stack.length -= argc;&#13;
				if(func === 'User') func = args.shift();&#13;
				stack.push(func + "(" + args.join(",") + ")");&#13;
				break;&#13;
&#13;
			case 'PtgBool': /* [MS-XLS] 2.5.198.42 */&#13;
				stack.push(f[1] ? "TRUE" : "FALSE"); break;&#13;
			case 'PtgInt': /* [MS-XLS] 2.5.198.66 */&#13;
				stack.push(f[1]); break;&#13;
			case 'PtgNum': /* [MS-XLS] 2.5.198.79 TODO: precision? */&#13;
				stack.push(String(f[1])); break;&#13;
			case 'PtgStr': /* [MS-XLS] 2.5.198.89 */&#13;
				// $FlowIgnore&#13;
				stack.push('"' + f[1].replace(/"/g, '""') + '"'); break;&#13;
			case 'PtgErr': /* [MS-XLS] 2.5.198.57 */&#13;
				stack.push(f[1]); break;&#13;
			case 'PtgAreaN': /* [MS-XLS] 2.5.198.31 TODO */&#13;
r = shift_range_xls(f[1][1], cell ? {s:cell} : _range, opts);&#13;
				stack.push(encode_range_xls((r), opts));&#13;
				break;&#13;
			case 'PtgArea': /* [MS-XLS] 2.5.198.27 TODO: fixed points */&#13;
r = shift_range_xls(f[1][1], _range, opts);&#13;
				stack.push(encode_range_xls((r), opts));&#13;
				break;&#13;
			case 'PtgArea3d': /* [MS-XLS] 2.5.198.28 TODO */&#13;
ixti = f[1][1]; r = f[1][2];&#13;
				sname = get_ixti(supbooks, ixti, opts);&#13;
				stack.push(sname + "!" + encode_range_xls((r), opts));&#13;
				break;&#13;
			case 'PtgAttrSum': /* [MS-XLS] 2.5.198.41 */&#13;
				stack.push("SUM(" + stack.pop() + ")");&#13;
				break;&#13;
&#13;
			case 'PtgAttrBaxcel': /* [MS-XLS] 2.5.198.33 */&#13;
			case 'PtgAttrSemi': /* [MS-XLS] 2.5.198.37 */&#13;
				break;&#13;
&#13;
			case 'PtgName': /* [MS-XLS] 2.5.198.76 ; [MS-XLSB] 2.5.97.60 TODO: revisions */&#13;
				/* f[1] = type, 0, nameindex */&#13;
				nameidx = (f[1][2]);&#13;
				var lbl = (supbooks.names||[])[nameidx-1] || (supbooks[0]||[])[nameidx];&#13;
				var name = lbl ? lbl.Name : "SH33TJSNAME" + String(nameidx);&#13;
				/* [MS-XLSB] 2.5.97.10 Ftab -- last verified 20220204 */&#13;
				if(name &amp;&amp; name.slice(0,6) == "_xlfn." &amp;&amp; !opts.xlfn) name = name.slice(6);&#13;
				stack.push(name);&#13;
				break;&#13;
&#13;
			case 'PtgNameX': /* [MS-XLS] 2.5.198.77 ; [MS-XLSB] 2.5.97.61 TODO: revisions */&#13;
				/* f[1] = type, ixti, nameindex */&#13;
				var bookidx = (f[1][1]); nameidx = (f[1][2]); var externbook;&#13;
				/* TODO: Properly handle missing values -- this should be using get_ixti_raw primarily */&#13;
				if(opts.biff &lt;= 5) {&#13;
					if(bookidx &lt; 0) bookidx = -bookidx;&#13;
					if(supbooks[bookidx]) externbook = supbooks[bookidx][nameidx];&#13;
				} else {&#13;
					var o = "";&#13;
					if(((supbooks[bookidx]||[])[0]||[])[0] == 0x3A01){/* empty */}&#13;
					else if(((supbooks[bookidx]||[])[0]||[])[0] == 0x0401){&#13;
						if(supbooks[bookidx][nameidx] &amp;&amp; supbooks[bookidx][nameidx].itab &gt; 0) {&#13;
							o = supbooks.SheetNames[supbooks[bookidx][nameidx].itab-1] + "!";&#13;
						}&#13;
					}&#13;
					else o = supbooks.SheetNames[nameidx-1]+ "!";&#13;
					if(supbooks[bookidx] &amp;&amp; supbooks[bookidx][nameidx]) o += supbooks[bookidx][nameidx].Name;&#13;
					else if(supbooks[0] &amp;&amp; supbooks[0][nameidx]) o += supbooks[0][nameidx].Name;&#13;
					else {&#13;
						var ixtidata = (get_ixti_raw(supbooks, bookidx, opts)||"").split(";;");&#13;
						if(ixtidata[nameidx - 1]) o = ixtidata[nameidx - 1]; // TODO: confirm this is correct&#13;
						else o += "SH33TJSERRX";&#13;
					}&#13;
					stack.push(o);&#13;
					break;&#13;
				}&#13;
				if(!externbook) externbook = {Name: "SH33TJSERRY"};&#13;
				stack.push(externbook.Name);&#13;
				break;&#13;
&#13;
			case 'PtgParen': /* [MS-XLS] 2.5.198.80 */&#13;
				var lp = '(', rp = ')';&#13;
				if(last_sp &gt;= 0) {&#13;
					sp = "";&#13;
					switch(formula[0][last_sp][1][0]) {&#13;
						// $FlowIgnore&#13;
						case 2: lp = fill(" ", formula[0][last_sp][1][1]) + lp; break;&#13;
						// $FlowIgnore&#13;
						case 3: lp = fill("\r", formula[0][last_sp][1][1]) + lp; break;&#13;
						// $FlowIgnore&#13;
						case 4: rp = fill(" ", formula[0][last_sp][1][1]) + rp; break;&#13;
						// $FlowIgnore&#13;
						case 5: rp = fill("\r", formula[0][last_sp][1][1]) + rp; break;&#13;
						default:&#13;
							// $FlowIgnore&#13;
							if(opts.WTF) throw new Error("Unexpected PtgAttrSpaceType " + formula[0][last_sp][1][0]);&#13;
					}&#13;
					last_sp = -1;&#13;
				}&#13;
				stack.push(lp + stack.pop() + rp); break;&#13;
&#13;
			case 'PtgRefErr': /* [MS-XLS] 2.5.198.86 */&#13;
				stack.push('#REF!'); break;&#13;
&#13;
			case 'PtgRefErr3d': /* [MS-XLS] 2.5.198.87 */&#13;
				stack.push('#REF!'); break;&#13;
&#13;
			case 'PtgExp': /* [MS-XLS] 2.5.198.58 TODO */&#13;
				c = {c:(f[1][1]),r:(f[1][0])};&#13;
				var q = ({c: cell.c, r:cell.r});&#13;
				if(supbooks.sharedf[encode_cell(c)]) {&#13;
					var parsedf = (supbooks.sharedf[encode_cell(c)]);&#13;
					stack.push(stringify_formula(parsedf, _range, q, supbooks, opts));&#13;
				} else {&#13;
					var fnd = false;&#13;
					for(e1=0;e1!=supbooks.arrayf.length; ++e1) {&#13;
						/* TODO: should be something like range_has */&#13;
						e2 = supbooks.arrayf[e1];&#13;
						if(c.c &lt; e2[0].s.c || c.c &gt; e2[0].e.c) continue;&#13;
						if(c.r &lt; e2[0].s.r || c.r &gt; e2[0].e.r) continue;&#13;
						stack.push(stringify_formula(e2[1], _range, q, supbooks, opts));&#13;
						fnd = true;&#13;
						break;&#13;
					}&#13;
					if(!fnd) stack.push(f[1]);&#13;
				}&#13;
				break;&#13;
&#13;
			case 'PtgArray': /* [MS-XLS] 2.5.198.32 TODO */&#13;
				stack.push("{" + stringify_array(f[1]) + "}");&#13;
				break;&#13;
&#13;
			case 'PtgMemArea': /* [MS-XLS] 2.5.198.70 TODO: confirm this is a non-display */&#13;
				//stack.push("(" + f[2].map(encode_range).join(",") + ")");&#13;
				break;&#13;
&#13;
			case 'PtgAttrSpace': /* [MS-XLS] 2.5.198.38 */&#13;
			case 'PtgAttrSpaceSemi': /* [MS-XLS] 2.5.198.39 */&#13;
				last_sp = ff;&#13;
				break;&#13;
&#13;
			case 'PtgTbl': /* [MS-XLS] 2.5.198.92 TODO */&#13;
				break;&#13;
&#13;
			case 'PtgMemErr': /* [MS-XLS] 2.5.198.71 */&#13;
				break;&#13;
&#13;
			case 'PtgMissArg': /* [MS-XLS] 2.5.198.74 */&#13;
				stack.push("");&#13;
				break;&#13;
&#13;
			case 'PtgAreaErr': /* [MS-XLS] 2.5.198.29 */&#13;
				stack.push("#REF!"); break;&#13;
&#13;
			case 'PtgAreaErr3d': /* [MS-XLS] 2.5.198.30 */&#13;
				stack.push("#REF!"); break;&#13;
&#13;
			case 'PtgList': /* [MS-XLSB] 2.5.97.52 */&#13;
				// $FlowIgnore&#13;
				stack.push("Table" + f[1].idx + "[#" + f[1].rt + "]");&#13;
				break;&#13;
&#13;
			case 'PtgMemAreaN':&#13;
			case 'PtgMemNoMemN':&#13;
			case 'PtgAttrNoop':&#13;
			case 'PtgSheet':&#13;
			case 'PtgEndSheet':&#13;
				break;&#13;
&#13;
			case 'PtgMemFunc': /* [MS-XLS] 2.5.198.72 TODO */&#13;
				break;&#13;
			case 'PtgMemNoMem': /* [MS-XLS] 2.5.198.73 TODO */&#13;
				break;&#13;
&#13;
			case 'PtgElfCol': /* [MS-XLS] 2.5.198.46 */&#13;
			case 'PtgElfColS': /* [MS-XLS] 2.5.198.47 */&#13;
			case 'PtgElfColSV': /* [MS-XLS] 2.5.198.48 */&#13;
			case 'PtgElfColV': /* [MS-XLS] 2.5.198.49 */&#13;
			case 'PtgElfLel': /* [MS-XLS] 2.5.198.50 */&#13;
			case 'PtgElfRadical': /* [MS-XLS] 2.5.198.51 */&#13;
			case 'PtgElfRadicalLel': /* [MS-XLS] 2.5.198.52 */&#13;
			case 'PtgElfRadicalS': /* [MS-XLS] 2.5.198.53 */&#13;
			case 'PtgElfRw': /* [MS-XLS] 2.5.198.54 */&#13;
			case 'PtgElfRwV': /* [MS-XLS] 2.5.198.55 */&#13;
				throw new Error("Unsupported ELFs");&#13;
&#13;
			case 'PtgSxName': /* [MS-XLS] 2.5.198.91 TODO -- find a test case */&#13;
				throw new Error('Unrecognized Formula Token: ' + String(f));&#13;
			default: throw new Error('Unrecognized Formula Token: ' + String(f));&#13;
		}&#13;
		var PtgNonDisp = ['PtgAttrSpace', 'PtgAttrSpaceSemi', 'PtgAttrGoto'];&#13;
		if(opts.biff != 3) if(last_sp &gt;= 0 &amp;&amp; PtgNonDisp.indexOf(formula[0][ff][0]) == -1) {&#13;
			f = formula[0][last_sp];&#13;
			var _left = true;&#13;
			switch(f[1][0]) {&#13;
				/* note: some bad XLSB files omit the PtgParen */&#13;
				case 4: _left = false;&#13;
				/* falls through */&#13;
				case 0:&#13;
					// $FlowIgnore&#13;
					sp = fill(" ", f[1][1]); break;&#13;
				case 5: _left = false;&#13;
				/* falls through */&#13;
				case 1:&#13;
					// $FlowIgnore&#13;
					sp = fill("\r", f[1][1]); break;&#13;
				default:&#13;
					sp = "";&#13;
					// $FlowIgnore&#13;
					if(opts.WTF) throw new Error("Unexpected PtgAttrSpaceType " + f[1][0]);&#13;
			}&#13;
			stack.push((_left ? sp : "") + stack.pop() + (_left ? "" : sp));&#13;
			last_sp = -1;&#13;
		}&#13;
	}&#13;
	if(stack.length &gt; 1 &amp;&amp; opts.WTF) throw new Error("bad formula stack");&#13;
	if(stack[0] == "TRUE") return true; if(stack[0] == "FALSE") return false;&#13;
	return stack[0];&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.198.1 TODO */&#13;
function parse_ArrayParsedFormula(blob, length, opts) {&#13;
	var target = blob.l + length, len = opts.biff == 2 ? 1 : 2;&#13;
	var rgcb, cce = blob.read_shift(len); // length of rgce&#13;
	if(cce == 0xFFFF) return [[],parsenoop(blob, length-2)];&#13;
	var rgce = parse_Rgce(blob, cce, opts);&#13;
	if(length !== cce + len) rgcb = parse_RgbExtra(blob, length - cce - len, rgce, opts);&#13;
	blob.l = target;&#13;
	return [rgce, rgcb];&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.198.3 TODO */&#13;
function parse_XLSCellParsedFormula(blob, length, opts) {&#13;
	var target = blob.l + length, len = opts.biff == 2 ? 1 : 2;&#13;
	var rgcb, cce = blob.read_shift(len); // length of rgce&#13;
	if(cce == 0xFFFF) return [[],parsenoop(blob, length-2)];&#13;
	var rgce = parse_Rgce(blob, cce, opts);&#13;
	if(length !== cce + len) rgcb = parse_RgbExtra(blob, length - cce - len, rgce, opts);&#13;
	blob.l = target;&#13;
	return [rgce, rgcb];&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.198.21 */&#13;
function parse_NameParsedFormula(blob, length, opts, cce) {&#13;
	var target = blob.l + length;&#13;
	var rgce = parse_Rgce(blob, cce, opts);&#13;
	var rgcb;&#13;
	if(target !== blob.l) rgcb = parse_RgbExtra(blob, target - blob.l, rgce, opts);&#13;
	return [rgce, rgcb];&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.198.118 TODO */&#13;
function parse_SharedParsedFormula(blob, length, opts) {&#13;
	var target = blob.l + length;&#13;
	var rgcb, cce = blob.read_shift(2); // length of rgce&#13;
	var rgce = parse_Rgce(blob, cce, opts);&#13;
	if(cce == 0xFFFF) return [[],parsenoop(blob, length-2)];&#13;
	if(length !== cce + 2) rgcb = parse_RgbExtra(blob, target - cce - 2, rgce, opts);&#13;
	return [rgce, rgcb];&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.133 TODO: how to emit empty strings? */&#13;
function parse_FormulaValue(blob) {&#13;
	var b;&#13;
	if(__readUInt16LE(blob,blob.l + 6) !== 0xFFFF) return [parse_Xnum(blob),'n'];&#13;
	switch(blob[blob.l]) {&#13;
		case 0x00: blob.l += 8; return ["String", 's'];&#13;
		case 0x01: b = blob[blob.l+2] === 0x1; blob.l += 8; return [b,'b'];&#13;
		case 0x02: b = blob[blob.l+2]; blob.l += 8; return [b,'e'];&#13;
		case 0x03: blob.l += 8; return ["",'s'];&#13;
	}&#13;
	return [];&#13;
}&#13;
function write_FormulaValue(value) {&#13;
	if(value == null) {&#13;
		// Blank String Value&#13;
		var o = new_buf(8);&#13;
		o.write_shift(1, 0x03);&#13;
		o.write_shift(1, 0);&#13;
		o.write_shift(2, 0);&#13;
		o.write_shift(2, 0);&#13;
		o.write_shift(2, 0xFFFF);&#13;
		return o;&#13;
	} else if(typeof value == "number") return write_Xnum(value);&#13;
	return write_Xnum(0);&#13;
}&#13;
&#13;
/* [MS-XLS] 2.4.127 TODO */&#13;
function parse_Formula(blob, length, opts) {&#13;
	var end = blob.l + length;&#13;
	var cell = parse_XLSCell(blob, 6);&#13;
	if(opts.biff == 2) ++blob.l;&#13;
	var val = parse_FormulaValue(blob,8);&#13;
	var flags = blob.read_shift(1);&#13;
	if(opts.biff != 2) {&#13;
		blob.read_shift(1);&#13;
		if(opts.biff &gt;= 5) {&#13;
			/*var chn = */blob.read_shift(4);&#13;
		}&#13;
	}&#13;
	var cbf = parse_XLSCellParsedFormula(blob, end - blob.l, opts);&#13;
	return {cell:cell, val:val[0], formula:cbf, shared: (flags &gt;&gt; 3) &amp; 1, tt:val[1]};&#13;
}&#13;
function write_Formula(cell, R, C, opts, os) {&#13;
	// Cell&#13;
	var o1 = write_XLSCell(R, C, os);&#13;
&#13;
	// FormulaValue&#13;
	var o2 = write_FormulaValue(cell.v);&#13;
&#13;
	// flags + cache&#13;
	var o3 = new_buf(6);&#13;
	var flags = 0x01 | 0x20;&#13;
	o3.write_shift(2, flags);&#13;
	o3.write_shift(4, 0);&#13;
&#13;
	// CellParsedFormula&#13;
	var bf = new_buf(cell.bf.length);&#13;
	for(var i = 0; i &lt; cell.bf.length; ++i) bf[i] = cell.bf[i];&#13;
&#13;
	var out = bconcat([o1, o2, o3, bf]);&#13;
	return out;&#13;
}&#13;
&#13;
&#13;
/* XLSB Parsed Formula records have the same shape */&#13;
function parse_XLSBParsedFormula(data, length, opts) {&#13;
	var cce = data.read_shift(4);&#13;
	var rgce = parse_Rgce(data, cce, opts);&#13;
	var cb = data.read_shift(4);&#13;
	var rgcb = cb &gt; 0 ? parse_RgbExtra(data, cb, rgce, opts) : null;&#13;
	return [rgce, rgcb];&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.5.97.1 ArrayParsedFormula */&#13;
var parse_XLSBArrayParsedFormula = parse_XLSBParsedFormula;&#13;
/* [MS-XLSB] 2.5.97.4 CellParsedFormula */&#13;
var parse_XLSBCellParsedFormula = parse_XLSBParsedFormula;&#13;
/* [MS-XLSB] 2.5.97.8 DVParsedFormula */&#13;
//var parse_XLSBDVParsedFormula = parse_XLSBParsedFormula;&#13;
/* [MS-XLSB] 2.5.97.9 FRTParsedFormula */&#13;
//var parse_XLSBFRTParsedFormula = parse_XLSBParsedFormula2;&#13;
/* [MS-XLSB] 2.5.97.12 NameParsedFormula */&#13;
var parse_XLSBNameParsedFormula = parse_XLSBParsedFormula;&#13;
/* [MS-XLSB] 2.5.97.98 SharedParsedFormula */&#13;
var parse_XLSBSharedParsedFormula = parse_XLSBParsedFormula;&#13;
&#13;
/* Writes a PtgNum or PtgInt */&#13;
function write_XLSBFormulaNum(val) {&#13;
	if((val | 0) == val &amp;&amp; val &lt; Math.pow(2,16) &amp;&amp; val &gt;= 0) {&#13;
		var oint = new_buf(11);&#13;
		oint.write_shift(4, 3);&#13;
		oint.write_shift(1, 0x1e);&#13;
		oint.write_shift(2, val);&#13;
		oint.write_shift(4, 0);&#13;
		return oint;&#13;
	}&#13;
&#13;
	var num = new_buf(17);&#13;
	num.write_shift(4, 11);&#13;
	num.write_shift(1, 0x1f);&#13;
	num.write_shift(8, val);&#13;
	num.write_shift(4, 0);&#13;
	return num;&#13;
}&#13;
/* Writes a PtgErr */&#13;
function write_XLSBFormulaErr(val) {&#13;
	var oint = new_buf(10);&#13;
	oint.write_shift(4, 2);&#13;
	oint.write_shift(1, 0x1C);&#13;
	oint.write_shift(1, val);&#13;
	oint.write_shift(4, 0);&#13;
	return oint;&#13;
}&#13;
/* Writes a PtgBool */&#13;
function write_XLSBFormulaBool(val) {&#13;
	var oint = new_buf(10);&#13;
	oint.write_shift(4, 2);&#13;
	oint.write_shift(1, 0x1D);&#13;
	oint.write_shift(1, val?1:0);&#13;
	oint.write_shift(4, 0);&#13;
	return oint;&#13;
}&#13;
&#13;
/* Writes a PtgStr */&#13;
function write_XLSBFormulaStr(val) {&#13;
	var preamble = new_buf(7);&#13;
	preamble.write_shift(4, 3 + 2 * val.length);&#13;
	preamble.write_shift(1, 0x17);&#13;
	preamble.write_shift(2, val.length);&#13;
&#13;
	var body = new_buf(2 * val.length);&#13;
	body.write_shift(2 * val.length, val, "utf16le");&#13;
&#13;
	var postamble = new_buf(4);&#13;
	postamble.write_shift(4, 0);&#13;
&#13;
	return bconcat([preamble, body, postamble]);&#13;
}&#13;
&#13;
/* Writes a PtgRef */&#13;
function write_XLSBFormulaRef(str) {&#13;
	var cell = decode_cell(str);&#13;
	var out = new_buf(15);&#13;
	out.write_shift(4, 7);&#13;
	out.write_shift(1, 0x04 | ((1)&lt;&lt;5));&#13;
	out.write_shift(4, cell.r);&#13;
	out.write_shift(2, cell.c | ((str.charAt(0) == "$" ? 0 : 1)&lt;&lt;14) | ((str.match(/\$\d/) ? 0 : 1)&lt;&lt;15)); // &lt;== ColRelShort&#13;
	out.write_shift(4, 0);&#13;
&#13;
	return out;&#13;
}&#13;
&#13;
/* Writes a PtgRef3d */&#13;
function write_XLSBFormulaRef3D(str, wb) {&#13;
	var lastbang = str.lastIndexOf("!");&#13;
	var sname = str.slice(0, lastbang);&#13;
	str = str.slice(lastbang+1);&#13;
	var cell = decode_cell(str);&#13;
	if(sname.charAt(0) == "'") sname = sname.slice(1, -1).replace(/''/g, "'");&#13;
&#13;
	var out = new_buf(17);&#13;
	out.write_shift(4, 9);&#13;
	out.write_shift(1, 0x1A | ((1)&lt;&lt;5));&#13;
	out.write_shift(2, 2 + wb.SheetNames.map(function(n) { return n.toLowerCase(); }).indexOf(sname.toLowerCase()));&#13;
	out.write_shift(4, cell.r);&#13;
	out.write_shift(2, cell.c | ((str.charAt(0) == "$" ? 0 : 1)&lt;&lt;14) | ((str.match(/\$\d/) ? 0 : 1)&lt;&lt;15)); // &lt;== ColRelShort&#13;
	out.write_shift(4, 0);&#13;
&#13;
	return out;&#13;
}&#13;
&#13;
/* Writes a PtgRefErr3d */&#13;
function write_XLSBFormulaRefErr3D(str, wb) {&#13;
	var lastbang = str.lastIndexOf("!");&#13;
	var sname = str.slice(0, lastbang);&#13;
	str = str.slice(lastbang+1);&#13;
	if(sname.charAt(0) == "'") sname = sname.slice(1, -1).replace(/''/g, "'");&#13;
&#13;
	var out = new_buf(17);&#13;
	out.write_shift(4, 9);&#13;
	out.write_shift(1, 0x1C | ((1)&lt;&lt;5));&#13;
	out.write_shift(2, 2 + wb.SheetNames.map(function(n) { return n.toLowerCase(); }).indexOf(sname.toLowerCase()));&#13;
	out.write_shift(4, 0);&#13;
	out.write_shift(2, 0); // &lt;== ColRelShort&#13;
	out.write_shift(4, 0);&#13;
&#13;
	return out;&#13;
}&#13;
&#13;
/* Writes a single sheet range [PtgRef PtgRef PtgRange] */&#13;
function write_XLSBFormulaRange(_str) {&#13;
	var parts = _str.split(":"), str = parts[0];&#13;
&#13;
	var out = new_buf(23);&#13;
	out.write_shift(4, 15);&#13;
&#13;
	/* start cell */&#13;
	str = parts[0]; var cell = decode_cell(str);&#13;
	out.write_shift(1, 0x04 | ((1)&lt;&lt;5));&#13;
	out.write_shift(4, cell.r);&#13;
	out.write_shift(2, cell.c | ((str.charAt(0) == "$" ? 0 : 1)&lt;&lt;14) | ((str.match(/\$\d/) ? 0 : 1)&lt;&lt;15)); // &lt;== ColRelShort&#13;
	out.write_shift(4, 0);&#13;
&#13;
	/* end cell */&#13;
	str = parts[1]; cell = decode_cell(str);&#13;
	out.write_shift(1, 0x04 | ((1)&lt;&lt;5));&#13;
	out.write_shift(4, cell.r);&#13;
	out.write_shift(2, cell.c | ((str.charAt(0) == "$" ? 0 : 1)&lt;&lt;14) | ((str.match(/\$\d/) ? 0 : 1)&lt;&lt;15)); // &lt;== ColRelShort&#13;
	out.write_shift(4, 0);&#13;
&#13;
	/* PtgRange */&#13;
	out.write_shift(1, 0x11);&#13;
&#13;
	out.write_shift(4, 0);&#13;
&#13;
	return out;&#13;
}&#13;
&#13;
/* Writes a range with explicit sheet name [PtgRef3D PtgRef3D PtgRange] */&#13;
function write_XLSBFormulaRangeWS(_str, wb) {&#13;
	var lastbang = _str.lastIndexOf("!");&#13;
	var sname = _str.slice(0, lastbang);&#13;
	_str = _str.slice(lastbang+1);&#13;
	if(sname.charAt(0) == "'") sname = sname.slice(1, -1).replace(/''/g, "'");&#13;
	var parts = _str.split(":"); str = parts[0];&#13;
&#13;
	var out = new_buf(27);&#13;
	out.write_shift(4, 19);&#13;
&#13;
	/* start cell */&#13;
	var str = parts[0], cell = decode_cell(str);&#13;
	out.write_shift(1, 0x1A | ((1)&lt;&lt;5));&#13;
	out.write_shift(2, 2 + wb.SheetNames.map(function(n) { return n.toLowerCase(); }).indexOf(sname.toLowerCase()));&#13;
	out.write_shift(4, cell.r);&#13;
	out.write_shift(2, cell.c | ((str.charAt(0) == "$" ? 0 : 1)&lt;&lt;14) | ((str.match(/\$\d/) ? 0 : 1)&lt;&lt;15)); // &lt;== ColRelShort&#13;
&#13;
	/* end cell */&#13;
	str = parts[1]; cell = decode_cell(str);&#13;
	out.write_shift(1, 0x1A | ((1)&lt;&lt;5));&#13;
	out.write_shift(2, 2 + wb.SheetNames.map(function(n) { return n.toLowerCase(); }).indexOf(sname.toLowerCase()));&#13;
	out.write_shift(4, cell.r);&#13;
	out.write_shift(2, cell.c | ((str.charAt(0) == "$" ? 0 : 1)&lt;&lt;14) | ((str.match(/\$\d/) ? 0 : 1)&lt;&lt;15)); // &lt;== ColRelShort&#13;
&#13;
	/* PtgRange */&#13;
	out.write_shift(1, 0x11);&#13;
&#13;
	out.write_shift(4, 0);&#13;
&#13;
	return out;&#13;
}&#13;
&#13;
/* Writes a range with explicit sheet name [PtgArea3d] */&#13;
function write_XLSBFormulaArea3D(_str, wb) {&#13;
	var lastbang = _str.lastIndexOf("!");&#13;
	var sname = _str.slice(0, lastbang);&#13;
	_str = _str.slice(lastbang+1);&#13;
	if(sname.charAt(0) == "'") sname = sname.slice(1, -1).replace(/''/g, "'");&#13;
	var range = decode_range(_str);&#13;
&#13;
	var out = new_buf(23);&#13;
	out.write_shift(4, 15);&#13;
&#13;
	out.write_shift(1, 0x1B | ((1)&lt;&lt;5));&#13;
	out.write_shift(2, 2 + wb.SheetNames.map(function(n) { return n.toLowerCase(); }).indexOf(sname.toLowerCase()));&#13;
	out.write_shift(4, range.s.r);&#13;
	out.write_shift(4, range.e.r);&#13;
	out.write_shift(2, range.s.c);&#13;
	out.write_shift(2, range.e.c);&#13;
&#13;
	out.write_shift(4, 0);&#13;
&#13;
	return out;&#13;
}&#13;
&#13;
&#13;
/* General Formula */&#13;
function write_XLSBFormula(val, wb) {&#13;
	if(typeof val == "number") return write_XLSBFormulaNum(val);&#13;
	if(typeof val == "boolean") return write_XLSBFormulaBool(val);&#13;
	if(/^#(DIV\/0!|GETTING_DATA|N\/A|NAME\?|NULL!|NUM!|REF!|VALUE!)$/.test(val)) return write_XLSBFormulaErr(+RBErr[val]);&#13;
	if(val.match(/^\$?(?:[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D]|[A-Z]{1,2})\$?(?:10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5})$/)) return write_XLSBFormulaRef(val);&#13;
	if(val.match(/^\$?(?:[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D]|[A-Z]{1,2})\$?(?:10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5}):\$?(?:[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D]|[A-Z]{1,2})\$?(?:10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5})$/)) return write_XLSBFormulaRange(val);&#13;
	if(val.match(/^#REF!\$?(?:[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D]|[A-Z]{1,2})\$?(?:10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5}):\$?(?:[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D]|[A-Z]{1,2})\$?(?:10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5})$/)) return write_XLSBFormulaArea3D(val, wb);&#13;
	if(val.match(/^(?:'[^\\\/?*\[\]:]*'|[^'][^\\\/?*\[\]:'`~!@#$%^()\-=+{}|;,&lt;.&gt;]*)!\$?(?:[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D]|[A-Z]{1,2})\$?(?:10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5})$/)) return write_XLSBFormulaRef3D(val, wb);&#13;
	if(val.match(/^(?:'[^\\\/?*\[\]:]*'|[^'][^\\\/?*\[\]:'`~!@#$%^()\-=+{}|;,&lt;.&gt;]*)!\$?(?:[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D]|[A-Z]{1,2})\$?(?:10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5}):\$?(?:[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D]|[A-Z]{1,2})\$?(?:10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5})$/)) return write_XLSBFormulaRangeWS(val, wb);&#13;
	if(/^(?:'[^\\\/?*\[\]:]*'|[^'][^\\\/?*\[\]:'`~!@#$%^()\-=+{}|;,&lt;.&gt;]*)!#REF!$/.test(val)) return write_XLSBFormulaRefErr3D(val, wb);&#13;
	if(/^".*"$/.test(val)) return write_XLSBFormulaStr(val);&#13;
	if(/^[+-]\d+$/.test(val)) return write_XLSBFormulaNum(parseInt(val, 10));&#13;
	throw "Formula |" + val + "| not supported for XLSB";&#13;
}&#13;
var write_XLSBNameParsedFormula = write_XLSBFormula;&#13;
var Cetab = {&#13;
  0: "BEEP",&#13;
  1: "OPEN",&#13;
  2: "OPEN.LINKS",&#13;
  3: "CLOSE.ALL",&#13;
  4: "SAVE",&#13;
  5: "SAVE.AS",&#13;
  6: "FILE.DELETE",&#13;
  7: "PAGE.SETUP",&#13;
  8: "PRINT",&#13;
  9: "PRINTER.SETUP",&#13;
  10: "QUIT",&#13;
  11: "NEW.WINDOW",&#13;
  12: "ARRANGE.ALL",&#13;
  13: "WINDOW.SIZE",&#13;
  14: "WINDOW.MOVE",&#13;
  15: "FULL",&#13;
  16: "CLOSE",&#13;
  17: "RUN",&#13;
  22: "SET.PRINT.AREA",&#13;
  23: "SET.PRINT.TITLES",&#13;
  24: "SET.PAGE.BREAK",&#13;
  25: "REMOVE.PAGE.BREAK",&#13;
  26: "FONT",&#13;
  27: "DISPLAY",&#13;
  28: "PROTECT.DOCUMENT",&#13;
  29: "PRECISION",&#13;
  30: "A1.R1C1",&#13;
  31: "CALCULATE.NOW",&#13;
  32: "CALCULATION",&#13;
  34: "DATA.FIND",&#13;
  35: "EXTRACT",&#13;
  36: "DATA.DELETE",&#13;
  37: "SET.DATABASE",&#13;
  38: "SET.CRITERIA",&#13;
  39: "SORT",&#13;
  40: "DATA.SERIES",&#13;
  41: "TABLE",&#13;
  42: "FORMAT.NUMBER",&#13;
  43: "ALIGNMENT",&#13;
  44: "STYLE",&#13;
  45: "BORDER",&#13;
  46: "CELL.PROTECTION",&#13;
  47: "COLUMN.WIDTH",&#13;
  48: "UNDO",&#13;
  49: "CUT",&#13;
  50: "COPY",&#13;
  51: "PASTE",&#13;
  52: "CLEAR",&#13;
  53: "PASTE.SPECIAL",&#13;
  54: "EDIT.DELETE",&#13;
  55: "INSERT",&#13;
  56: "FILL.RIGHT",&#13;
  57: "FILL.DOWN",&#13;
  61: "DEFINE.NAME",&#13;
  62: "CREATE.NAMES",&#13;
  63: "FORMULA.GOTO",&#13;
  64: "FORMULA.FIND",&#13;
  65: "SELECT.LAST.CELL",&#13;
  66: "SHOW.ACTIVE.CELL",&#13;
  67: "GALLERY.AREA",&#13;
  68: "GALLERY.BAR",&#13;
  69: "GALLERY.COLUMN",&#13;
  70: "GALLERY.LINE",&#13;
  71: "GALLERY.PIE",&#13;
  72: "GALLERY.SCATTER",&#13;
  73: "COMBINATION",&#13;
  74: "PREFERRED",&#13;
  75: "ADD.OVERLAY",&#13;
  76: "GRIDLINES",&#13;
  77: "SET.PREFERRED",&#13;
  78: "AXES",&#13;
  79: "LEGEND",&#13;
  80: "ATTACH.TEXT",&#13;
  81: "ADD.ARROW",&#13;
  82: "SELECT.CHART",&#13;
  83: "SELECT.PLOT.AREA",&#13;
  84: "PATTERNS",&#13;
  85: "MAIN.CHART",&#13;
  86: "OVERLAY",&#13;
  87: "SCALE",&#13;
  88: "FORMAT.LEGEND",&#13;
  89: "FORMAT.TEXT",&#13;
  90: "EDIT.REPEAT",&#13;
  91: "PARSE",&#13;
  92: "JUSTIFY",&#13;
  93: "HIDE",&#13;
  94: "UNHIDE",&#13;
  95: "WORKSPACE",&#13;
  96: "FORMULA",&#13;
  97: "FORMULA.FILL",&#13;
  98: "FORMULA.ARRAY",&#13;
  99: "DATA.FIND.NEXT",&#13;
  100: "DATA.FIND.PREV",&#13;
  101: "FORMULA.FIND.NEXT",&#13;
  102: "FORMULA.FIND.PREV",&#13;
  103: "ACTIVATE",&#13;
  104: "ACTIVATE.NEXT",&#13;
  105: "ACTIVATE.PREV",&#13;
  106: "UNLOCKED.NEXT",&#13;
  107: "UNLOCKED.PREV",&#13;
  108: "COPY.PICTURE",&#13;
  109: "SELECT",&#13;
  110: "DELETE.NAME",&#13;
  111: "DELETE.FORMAT",&#13;
  112: "VLINE",&#13;
  113: "HLINE",&#13;
  114: "VPAGE",&#13;
  115: "HPAGE",&#13;
  116: "VSCROLL",&#13;
  117: "HSCROLL",&#13;
  118: "ALERT",&#13;
  119: "NEW",&#13;
  120: "CANCEL.COPY",&#13;
  121: "SHOW.CLIPBOARD",&#13;
  122: "MESSAGE",&#13;
  124: "PASTE.LINK",&#13;
  125: "APP.ACTIVATE",&#13;
  126: "DELETE.ARROW",&#13;
  127: "ROW.HEIGHT",&#13;
  128: "FORMAT.MOVE",&#13;
  129: "FORMAT.SIZE",&#13;
  130: "FORMULA.REPLACE",&#13;
  131: "SEND.KEYS",&#13;
  132: "SELECT.SPECIAL",&#13;
  133: "APPLY.NAMES",&#13;
  134: "REPLACE.FONT",&#13;
  135: "FREEZE.PANES",&#13;
  136: "SHOW.INFO",&#13;
  137: "SPLIT",&#13;
  138: "ON.WINDOW",&#13;
  139: "ON.DATA",&#13;
  140: "DISABLE.INPUT",&#13;
  142: "OUTLINE",&#13;
  143: "LIST.NAMES",&#13;
  144: "FILE.CLOSE",&#13;
  145: "SAVE.WORKBOOK",&#13;
  146: "DATA.FORM",&#13;
  147: "COPY.CHART",&#13;
  148: "ON.TIME",&#13;
  149: "WAIT",&#13;
  150: "FORMAT.FONT",&#13;
  151: "FILL.UP",&#13;
  152: "FILL.LEFT",&#13;
  153: "DELETE.OVERLAY",&#13;
  155: "SHORT.MENUS",&#13;
  159: "SET.UPDATE.STATUS",&#13;
  161: "COLOR.PALETTE",&#13;
  162: "DELETE.STYLE",&#13;
  163: "WINDOW.RESTORE",&#13;
  164: "WINDOW.MAXIMIZE",&#13;
  166: "CHANGE.LINK",&#13;
  167: "CALCULATE.DOCUMENT",&#13;
  168: "ON.KEY",&#13;
  169: "APP.RESTORE",&#13;
  170: "APP.MOVE",&#13;
  171: "APP.SIZE",&#13;
  172: "APP.MINIMIZE",&#13;
  173: "APP.MAXIMIZE",&#13;
  174: "BRING.TO.FRONT",&#13;
  175: "SEND.TO.BACK",&#13;
  185: "MAIN.CHART.TYPE",&#13;
  186: "OVERLAY.CHART.TYPE",&#13;
  187: "SELECT.END",&#13;
  188: "OPEN.MAIL",&#13;
  189: "SEND.MAIL",&#13;
  190: "STANDARD.FONT",&#13;
  191: "CONSOLIDATE",&#13;
  192: "SORT.SPECIAL",&#13;
  193: "GALLERY.3D.AREA",&#13;
  194: "GALLERY.3D.COLUMN",&#13;
  195: "GALLERY.3D.LINE",&#13;
  196: "GALLERY.3D.PIE",&#13;
  197: "VIEW.3D",&#13;
  198: "GOAL.SEEK",&#13;
  199: "WORKGROUP",&#13;
  200: "FILL.GROUP",&#13;
  201: "UPDATE.LINK",&#13;
  202: "PROMOTE",&#13;
  203: "DEMOTE",&#13;
  204: "SHOW.DETAIL",&#13;
  206: "UNGROUP",&#13;
  207: "OBJECT.PROPERTIES",&#13;
  208: "SAVE.NEW.OBJECT",&#13;
  209: "SHARE",&#13;
  210: "SHARE.NAME",&#13;
  211: "DUPLICATE",&#13;
  212: "APPLY.STYLE",&#13;
  213: "ASSIGN.TO.OBJECT",&#13;
  214: "OBJECT.PROTECTION",&#13;
  215: "HIDE.OBJECT",&#13;
  216: "SET.EXTRACT",&#13;
  217: "CREATE.PUBLISHER",&#13;
  218: "SUBSCRIBE.TO",&#13;
  219: "ATTRIBUTES",&#13;
  220: "SHOW.TOOLBAR",&#13;
  222: "PRINT.PREVIEW",&#13;
  223: "EDIT.COLOR",&#13;
  224: "SHOW.LEVELS",&#13;
  225: "FORMAT.MAIN",&#13;
  226: "FORMAT.OVERLAY",&#13;
  227: "ON.RECALC",&#13;
  228: "EDIT.SERIES",&#13;
  229: "DEFINE.STYLE",&#13;
  240: "LINE.PRINT",&#13;
  243: "ENTER.DATA",&#13;
  249: "GALLERY.RADAR",&#13;
  250: "MERGE.STYLES",&#13;
  251: "EDITION.OPTIONS",&#13;
  252: "PASTE.PICTURE",&#13;
  253: "PASTE.PICTURE.LINK",&#13;
  254: "SPELLING",&#13;
  256: "ZOOM",&#13;
  259: "INSERT.OBJECT",&#13;
  260: "WINDOW.MINIMIZE",&#13;
  265: "SOUND.NOTE",&#13;
  266: "SOUND.PLAY",&#13;
  267: "FORMAT.SHAPE",&#13;
  268: "EXTEND.POLYGON",&#13;
  269: "FORMAT.AUTO",&#13;
  272: "GALLERY.3D.BAR",&#13;
  273: "GALLERY.3D.SURFACE",&#13;
  274: "FILL.AUTO",&#13;
  276: "CUSTOMIZE.TOOLBAR",&#13;
  277: "ADD.TOOL",&#13;
  278: "EDIT.OBJECT",&#13;
  279: "ON.DOUBLECLICK",&#13;
  280: "ON.ENTRY",&#13;
  281: "WORKBOOK.ADD",&#13;
  282: "WORKBOOK.MOVE",&#13;
  283: "WORKBOOK.COPY",&#13;
  284: "WORKBOOK.OPTIONS",&#13;
  285: "SAVE.WORKSPACE",&#13;
  288: "CHART.WIZARD",&#13;
  289: "DELETE.TOOL",&#13;
  290: "MOVE.TOOL",&#13;
  291: "WORKBOOK.SELECT",&#13;
  292: "WORKBOOK.ACTIVATE",&#13;
  293: "ASSIGN.TO.TOOL",&#13;
  295: "COPY.TOOL",&#13;
  296: "RESET.TOOL",&#13;
  297: "CONSTRAIN.NUMERIC",&#13;
  298: "PASTE.TOOL",&#13;
  302: "WORKBOOK.NEW",&#13;
  305: "SCENARIO.CELLS",&#13;
  306: "SCENARIO.DELETE",&#13;
  307: "SCENARIO.ADD",&#13;
  308: "SCENARIO.EDIT",&#13;
  309: "SCENARIO.SHOW",&#13;
  310: "SCENARIO.SHOW.NEXT",&#13;
  311: "SCENARIO.SUMMARY",&#13;
  312: "PIVOT.TABLE.WIZARD",&#13;
  313: "PIVOT.FIELD.PROPERTIES",&#13;
  314: "PIVOT.FIELD",&#13;
  315: "PIVOT.ITEM",&#13;
  316: "PIVOT.ADD.FIELDS",&#13;
  318: "OPTIONS.CALCULATION",&#13;
  319: "OPTIONS.EDIT",&#13;
  320: "OPTIONS.VIEW",&#13;
  321: "ADDIN.MANAGER",&#13;
  322: "MENU.EDITOR",&#13;
  323: "ATTACH.TOOLBARS",&#13;
  324: "VBAActivate",&#13;
  325: "OPTIONS.CHART",&#13;
  328: "VBA.INSERT.FILE",&#13;
  330: "VBA.PROCEDURE.DEFINITION",&#13;
  336: "ROUTING.SLIP",&#13;
  338: "ROUTE.DOCUMENT",&#13;
  339: "MAIL.LOGON",&#13;
  342: "INSERT.PICTURE",&#13;
  343: "EDIT.TOOL",&#13;
  344: "GALLERY.DOUGHNUT",&#13;
  350: "CHART.TREND",&#13;
  352: "PIVOT.ITEM.PROPERTIES",&#13;
  354: "WORKBOOK.INSERT",&#13;
  355: "OPTIONS.TRANSITION",&#13;
  356: "OPTIONS.GENERAL",&#13;
  370: "FILTER.ADVANCED",&#13;
  373: "MAIL.ADD.MAILER",&#13;
  374: "MAIL.DELETE.MAILER",&#13;
  375: "MAIL.REPLY",&#13;
  376: "MAIL.REPLY.ALL",&#13;
  377: "MAIL.FORWARD",&#13;
  378: "MAIL.NEXT.LETTER",&#13;
  379: "DATA.LABEL",&#13;
  380: "INSERT.TITLE",&#13;
  381: "FONT.PROPERTIES",&#13;
  382: "MACRO.OPTIONS",&#13;
  383: "WORKBOOK.HIDE",&#13;
  384: "WORKBOOK.UNHIDE",&#13;
  385: "WORKBOOK.DELETE",&#13;
  386: "WORKBOOK.NAME",&#13;
  388: "GALLERY.CUSTOM",&#13;
  390: "ADD.CHART.AUTOFORMAT",&#13;
  391: "DELETE.CHART.AUTOFORMAT",&#13;
  392: "CHART.ADD.DATA",&#13;
  393: "AUTO.OUTLINE",&#13;
  394: "TAB.ORDER",&#13;
  395: "SHOW.DIALOG",&#13;
  396: "SELECT.ALL",&#13;
  397: "UNGROUP.SHEETS",&#13;
  398: "SUBTOTAL.CREATE",&#13;
  399: "SUBTOTAL.REMOVE",&#13;
  400: "RENAME.OBJECT",&#13;
  412: "WORKBOOK.SCROLL",&#13;
  413: "WORKBOOK.NEXT",&#13;
  414: "WORKBOOK.PREV",&#13;
  415: "WORKBOOK.TAB.SPLIT",&#13;
  416: "FULL.SCREEN",&#13;
  417: "WORKBOOK.PROTECT",&#13;
  420: "SCROLLBAR.PROPERTIES",&#13;
  421: "PIVOT.SHOW.PAGES",&#13;
  422: "TEXT.TO.COLUMNS",&#13;
  423: "FORMAT.CHARTTYPE",&#13;
  424: "LINK.FORMAT",&#13;
  425: "TRACER.DISPLAY",&#13;
  430: "TRACER.NAVIGATE",&#13;
  431: "TRACER.CLEAR",&#13;
  432: "TRACER.ERROR",&#13;
  433: "PIVOT.FIELD.GROUP",&#13;
  434: "PIVOT.FIELD.UNGROUP",&#13;
  435: "CHECKBOX.PROPERTIES",&#13;
  436: "LABEL.PROPERTIES",&#13;
  437: "LISTBOX.PROPERTIES",&#13;
  438: "EDITBOX.PROPERTIES",&#13;
  439: "PIVOT.REFRESH",&#13;
  440: "LINK.COMBO",&#13;
  441: "OPEN.TEXT",&#13;
  442: "HIDE.DIALOG",&#13;
  443: "SET.DIALOG.FOCUS",&#13;
  444: "ENABLE.OBJECT",&#13;
  445: "PUSHBUTTON.PROPERTIES",&#13;
  446: "SET.DIALOG.DEFAULT",&#13;
  447: "FILTER",&#13;
  448: "FILTER.SHOW.ALL",&#13;
  449: "CLEAR.OUTLINE",&#13;
  450: "FUNCTION.WIZARD",&#13;
  451: "ADD.LIST.ITEM",&#13;
  452: "SET.LIST.ITEM",&#13;
  453: "REMOVE.LIST.ITEM",&#13;
  454: "SELECT.LIST.ITEM",&#13;
  455: "SET.CONTROL.VALUE",&#13;
  456: "SAVE.COPY.AS",&#13;
  458: "OPTIONS.LISTS.ADD",&#13;
  459: "OPTIONS.LISTS.DELETE",&#13;
  460: "SERIES.AXES",&#13;
  461: "SERIES.X",&#13;
  462: "SERIES.Y",&#13;
  463: "ERRORBAR.X",&#13;
  464: "ERRORBAR.Y",&#13;
  465: "FORMAT.CHART",&#13;
  466: "SERIES.ORDER",&#13;
  467: "MAIL.LOGOFF",&#13;
  468: "CLEAR.ROUTING.SLIP",&#13;
  469: "APP.ACTIVATE.MICROSOFT",&#13;
  470: "MAIL.EDIT.MAILER",&#13;
  471: "ON.SHEET",&#13;
  472: "STANDARD.WIDTH",&#13;
  473: "SCENARIO.MERGE",&#13;
  474: "SUMMARY.INFO",&#13;
  475: "FIND.FILE",&#13;
  476: "ACTIVE.CELL.FONT",&#13;
  477: "ENABLE.TIPWIZARD",&#13;
  478: "VBA.MAKE.ADDIN",&#13;
  480: "INSERTDATATABLE",&#13;
  481: "WORKGROUP.OPTIONS",&#13;
  482: "MAIL.SEND.MAILER",&#13;
  485: "AUTOCORRECT",&#13;
  489: "POST.DOCUMENT",&#13;
  491: "PICKLIST",&#13;
  493: "VIEW.SHOW",&#13;
  494: "VIEW.DEFINE",&#13;
  495: "VIEW.DELETE",&#13;
  509: "SHEET.BACKGROUND",&#13;
  510: "INSERT.MAP.OBJECT",&#13;
  511: "OPTIONS.MENONO",&#13;
  517: "MSOCHECKS",&#13;
  518: "NORMAL",&#13;
  519: "LAYOUT",&#13;
  520: "RM.PRINT.AREA",&#13;
  521: "CLEAR.PRINT.AREA",&#13;
  522: "ADD.PRINT.AREA",&#13;
  523: "MOVE.BRK",&#13;
  545: "HIDECURR.NOTE",&#13;
  546: "HIDEALL.NOTES",&#13;
  547: "DELETE.NOTE",&#13;
  548: "TRAVERSE.NOTES",&#13;
  549: "ACTIVATE.NOTES",&#13;
  620: "PROTECT.REVISIONS",&#13;
  621: "UNPROTECT.REVISIONS",&#13;
  647: "OPTIONS.ME",&#13;
  653: "WEB.PUBLISH",&#13;
  667: "NEWWEBQUERY",&#13;
  673: "PIVOT.TABLE.CHART",&#13;
  753: "OPTIONS.SAVE",&#13;
  755: "OPTIONS.SPELL",&#13;
  808: "HIDEALL.INKANNOTS"&#13;
};&#13;
var Ftab = {&#13;
  0: "COUNT",&#13;
  1: "IF",&#13;
  2: "ISNA",&#13;
  3: "ISERROR",&#13;
  4: "SUM",&#13;
  5: "AVERAGE",&#13;
  6: "MIN",&#13;
  7: "MAX",&#13;
  8: "ROW",&#13;
  9: "COLUMN",&#13;
  10: "NA",&#13;
  11: "NPV",&#13;
  12: "STDEV",&#13;
  13: "DOLLAR",&#13;
  14: "FIXED",&#13;
  15: "SIN",&#13;
  16: "COS",&#13;
  17: "TAN",&#13;
  18: "ATAN",&#13;
  19: "PI",&#13;
  20: "SQRT",&#13;
  21: "EXP",&#13;
  22: "LN",&#13;
  23: "LOG10",&#13;
  24: "ABS",&#13;
  25: "INT",&#13;
  26: "SIGN",&#13;
  27: "ROUND",&#13;
  28: "LOOKUP",&#13;
  29: "INDEX",&#13;
  30: "REPT",&#13;
  31: "MID",&#13;
  32: "LEN",&#13;
  33: "VALUE",&#13;
  34: "TRUE",&#13;
  35: "FALSE",&#13;
  36: "AND",&#13;
  37: "OR",&#13;
  38: "NOT",&#13;
  39: "MOD",&#13;
  40: "DCOUNT",&#13;
  41: "DSUM",&#13;
  42: "DAVERAGE",&#13;
  43: "DMIN",&#13;
  44: "DMAX",&#13;
  45: "DSTDEV",&#13;
  46: "VAR",&#13;
  47: "DVAR",&#13;
  48: "TEXT",&#13;
  49: "LINEST",&#13;
  50: "TREND",&#13;
  51: "LOGEST",&#13;
  52: "GROWTH",&#13;
  53: "GOTO",&#13;
  54: "HALT",&#13;
  55: "RETURN",&#13;
  56: "PV",&#13;
  57: "FV",&#13;
  58: "NPER",&#13;
  59: "PMT",&#13;
  60: "RATE",&#13;
  61: "MIRR",&#13;
  62: "IRR",&#13;
  63: "RAND",&#13;
  64: "MATCH",&#13;
  65: "DATE",&#13;
  66: "TIME",&#13;
  67: "DAY",&#13;
  68: "MONTH",&#13;
  69: "YEAR",&#13;
  70: "WEEKDAY",&#13;
  71: "HOUR",&#13;
  72: "MINUTE",&#13;
  73: "SECOND",&#13;
  74: "NOW",&#13;
  75: "AREAS",&#13;
  76: "ROWS",&#13;
  77: "COLUMNS",&#13;
  78: "OFFSET",&#13;
  79: "ABSREF",&#13;
  80: "RELREF",&#13;
  81: "ARGUMENT",&#13;
  82: "SEARCH",&#13;
  83: "TRANSPOSE",&#13;
  84: "ERROR",&#13;
  85: "STEP",&#13;
  86: "TYPE",&#13;
  87: "ECHO",&#13;
  88: "SET.NAME",&#13;
  89: "CALLER",&#13;
  90: "DEREF",&#13;
  91: "WINDOWS",&#13;
  92: "SERIES",&#13;
  93: "DOCUMENTS",&#13;
  94: "ACTIVE.CELL",&#13;
  95: "SELECTION",&#13;
  96: "RESULT",&#13;
  97: "ATAN2",&#13;
  98: "ASIN",&#13;
  99: "ACOS",&#13;
  100: "CHOOSE",&#13;
  101: "HLOOKUP",&#13;
  102: "VLOOKUP",&#13;
  103: "LINKS",&#13;
  104: "INPUT",&#13;
  105: "ISREF",&#13;
  106: "GET.FORMULA",&#13;
  107: "GET.NAME",&#13;
  108: "SET.VALUE",&#13;
  109: "LOG",&#13;
  110: "EXEC",&#13;
  111: "CHAR",&#13;
  112: "LOWER",&#13;
  113: "UPPER",&#13;
  114: "PROPER",&#13;
  115: "LEFT",&#13;
  116: "RIGHT",&#13;
  117: "EXACT",&#13;
  118: "TRIM",&#13;
  119: "REPLACE",&#13;
  120: "SUBSTITUTE",&#13;
  121: "CODE",&#13;
  122: "NAMES",&#13;
  123: "DIRECTORY",&#13;
  124: "FIND",&#13;
  125: "CELL",&#13;
  126: "ISERR",&#13;
  127: "ISTEXT",&#13;
  128: "ISNUMBER",&#13;
  129: "ISBLANK",&#13;
  130: "T",&#13;
  131: "N",&#13;
  132: "FOPEN",&#13;
  133: "FCLOSE",&#13;
  134: "FSIZE",&#13;
  135: "FREADLN",&#13;
  136: "FREAD",&#13;
  137: "FWRITELN",&#13;
  138: "FWRITE",&#13;
  139: "FPOS",&#13;
  140: "DATEVALUE",&#13;
  141: "TIMEVALUE",&#13;
  142: "SLN",&#13;
  143: "SYD",&#13;
  144: "DDB",&#13;
  145: "GET.DEF",&#13;
  146: "REFTEXT",&#13;
  147: "TEXTREF",&#13;
  148: "INDIRECT",&#13;
  149: "REGISTER",&#13;
  150: "CALL",&#13;
  151: "ADD.BAR",&#13;
  152: "ADD.MENU",&#13;
  153: "ADD.COMMAND",&#13;
  154: "ENABLE.COMMAND",&#13;
  155: "CHECK.COMMAND",&#13;
  156: "RENAME.COMMAND",&#13;
  157: "SHOW.BAR",&#13;
  158: "DELETE.MENU",&#13;
  159: "DELETE.COMMAND",&#13;
  160: "GET.CHART.ITEM",&#13;
  161: "DIALOG.BOX",&#13;
  162: "CLEAN",&#13;
  163: "MDETERM",&#13;
  164: "MINVERSE",&#13;
  165: "MMULT",&#13;
  166: "FILES",&#13;
  167: "IPMT",&#13;
  168: "PPMT",&#13;
  169: "COUNTA",&#13;
  170: "CANCEL.KEY",&#13;
  171: "FOR",&#13;
  172: "WHILE",&#13;
  173: "BREAK",&#13;
  174: "NEXT",&#13;
  175: "INITIATE",&#13;
  176: "REQUEST",&#13;
  177: "POKE",&#13;
  178: "EXECUTE",&#13;
  179: "TERMINATE",&#13;
  180: "RESTART",&#13;
  181: "HELP",&#13;
  182: "GET.BAR",&#13;
  183: "PRODUCT",&#13;
  184: "FACT",&#13;
  185: "GET.CELL",&#13;
  186: "GET.WORKSPACE",&#13;
  187: "GET.WINDOW",&#13;
  188: "GET.DOCUMENT",&#13;
  189: "DPRODUCT",&#13;
  190: "ISNONTEXT",&#13;
  191: "GET.NOTE",&#13;
  192: "NOTE",&#13;
  193: "STDEVP",&#13;
  194: "VARP",&#13;
  195: "DSTDEVP",&#13;
  196: "DVARP",&#13;
  197: "TRUNC",&#13;
  198: "ISLOGICAL",&#13;
  199: "DCOUNTA",&#13;
  200: "DELETE.BAR",&#13;
  201: "UNREGISTER",&#13;
  204: "USDOLLAR",&#13;
  205: "FINDB",&#13;
  206: "SEARCHB",&#13;
  207: "REPLACEB",&#13;
  208: "LEFTB",&#13;
  209: "RIGHTB",&#13;
  210: "MIDB",&#13;
  211: "LENB",&#13;
  212: "ROUNDUP",&#13;
  213: "ROUNDDOWN",&#13;
  214: "ASC",&#13;
  215: "DBCS",&#13;
  216: "RANK",&#13;
  219: "ADDRESS",&#13;
  220: "DAYS360",&#13;
  221: "TODAY",&#13;
  222: "VDB",&#13;
  223: "ELSE",&#13;
  224: "ELSE.IF",&#13;
  225: "END.IF",&#13;
  226: "FOR.CELL",&#13;
  227: "MEDIAN",&#13;
  228: "SUMPRODUCT",&#13;
  229: "SINH",&#13;
  230: "COSH",&#13;
  231: "TANH",&#13;
  232: "ASINH",&#13;
  233: "ACOSH",&#13;
  234: "ATANH",&#13;
  235: "DGET",&#13;
  236: "CREATE.OBJECT",&#13;
  237: "VOLATILE",&#13;
  238: "LAST.ERROR",&#13;
  239: "CUSTOM.UNDO",&#13;
  240: "CUSTOM.REPEAT",&#13;
  241: "FORMULA.CONVERT",&#13;
  242: "GET.LINK.INFO",&#13;
  243: "TEXT.BOX",&#13;
  244: "INFO",&#13;
  245: "GROUP",&#13;
  246: "GET.OBJECT",&#13;
  247: "DB",&#13;
  248: "PAUSE",&#13;
  251: "RESUME",&#13;
  252: "FREQUENCY",&#13;
  253: "ADD.TOOLBAR",&#13;
  254: "DELETE.TOOLBAR",&#13;
  255: "User",&#13;
  256: "RESET.TOOLBAR",&#13;
  257: "EVALUATE",&#13;
  258: "GET.TOOLBAR",&#13;
  259: "GET.TOOL",&#13;
  260: "SPELLING.CHECK",&#13;
  261: "ERROR.TYPE",&#13;
  262: "APP.TITLE",&#13;
  263: "WINDOW.TITLE",&#13;
  264: "SAVE.TOOLBAR",&#13;
  265: "ENABLE.TOOL",&#13;
  266: "PRESS.TOOL",&#13;
  267: "REGISTER.ID",&#13;
  268: "GET.WORKBOOK",&#13;
  269: "AVEDEV",&#13;
  270: "BETADIST",&#13;
  271: "GAMMALN",&#13;
  272: "BETAINV",&#13;
  273: "BINOMDIST",&#13;
  274: "CHIDIST",&#13;
  275: "CHIINV",&#13;
  276: "COMBIN",&#13;
  277: "CONFIDENCE",&#13;
  278: "CRITBINOM",&#13;
  279: "EVEN",&#13;
  280: "EXPONDIST",&#13;
  281: "FDIST",&#13;
  282: "FINV",&#13;
  283: "FISHER",&#13;
  284: "FISHERINV",&#13;
  285: "FLOOR",&#13;
  286: "GAMMADIST",&#13;
  287: "GAMMAINV",&#13;
  288: "CEILING",&#13;
  289: "HYPGEOMDIST",&#13;
  290: "LOGNORMDIST",&#13;
  291: "LOGINV",&#13;
  292: "NEGBINOMDIST",&#13;
  293: "NORMDIST",&#13;
  294: "NORMSDIST",&#13;
  295: "NORMINV",&#13;
  296: "NORMSINV",&#13;
  297: "STANDARDIZE",&#13;
  298: "ODD",&#13;
  299: "PERMUT",&#13;
  300: "POISSON",&#13;
  301: "TDIST",&#13;
  302: "WEIBULL",&#13;
  303: "SUMXMY2",&#13;
  304: "SUMX2MY2",&#13;
  305: "SUMX2PY2",&#13;
  306: "CHITEST",&#13;
  307: "CORREL",&#13;
  308: "COVAR",&#13;
  309: "FORECAST",&#13;
  310: "FTEST",&#13;
  311: "INTERCEPT",&#13;
  312: "PEARSON",&#13;
  313: "RSQ",&#13;
  314: "STEYX",&#13;
  315: "SLOPE",&#13;
  316: "TTEST",&#13;
  317: "PROB",&#13;
  318: "DEVSQ",&#13;
  319: "GEOMEAN",&#13;
  320: "HARMEAN",&#13;
  321: "SUMSQ",&#13;
  322: "KURT",&#13;
  323: "SKEW",&#13;
  324: "ZTEST",&#13;
  325: "LARGE",&#13;
  326: "SMALL",&#13;
  327: "QUARTILE",&#13;
  328: "PERCENTILE",&#13;
  329: "PERCENTRANK",&#13;
  330: "MODE",&#13;
  331: "TRIMMEAN",&#13;
  332: "TINV",&#13;
  334: "MOVIE.COMMAND",&#13;
  335: "GET.MOVIE",&#13;
  336: "CONCATENATE",&#13;
  337: "POWER",&#13;
  338: "PIVOT.ADD.DATA",&#13;
  339: "GET.PIVOT.TABLE",&#13;
  340: "GET.PIVOT.FIELD",&#13;
  341: "GET.PIVOT.ITEM",&#13;
  342: "RADIANS",&#13;
  343: "DEGREES",&#13;
  344: "SUBTOTAL",&#13;
  345: "SUMIF",&#13;
  346: "COUNTIF",&#13;
  347: "COUNTBLANK",&#13;
  348: "SCENARIO.GET",&#13;
  349: "OPTIONS.LISTS.GET",&#13;
  350: "ISPMT",&#13;
  351: "DATEDIF",&#13;
  352: "DATESTRING",&#13;
  353: "NUMBERSTRING",&#13;
  354: "ROMAN",&#13;
  355: "OPEN.DIALOG",&#13;
  356: "SAVE.DIALOG",&#13;
  357: "VIEW.GET",&#13;
  358: "GETPIVOTDATA",&#13;
  359: "HYPERLINK",&#13;
  360: "PHONETIC",&#13;
  361: "AVERAGEA",&#13;
  362: "MAXA",&#13;
  363: "MINA",&#13;
  364: "STDEVPA",&#13;
  365: "VARPA",&#13;
  366: "STDEVA",&#13;
  367: "VARA",&#13;
  368: "BAHTTEXT",&#13;
  369: "THAIDAYOFWEEK",&#13;
  370: "THAIDIGIT",&#13;
  371: "THAIMONTHOFYEAR",&#13;
  372: "THAINUMSOUND",&#13;
  373: "THAINUMSTRING",&#13;
  374: "THAISTRINGLENGTH",&#13;
  375: "ISTHAIDIGIT",&#13;
  376: "ROUNDBAHTDOWN",&#13;
  377: "ROUNDBAHTUP",&#13;
  378: "THAIYEAR",&#13;
  379: "RTD",&#13;
  380: "CUBEVALUE",&#13;
  381: "CUBEMEMBER",&#13;
  382: "CUBEMEMBERPROPERTY",&#13;
  383: "CUBERANKEDMEMBER",&#13;
  384: "HEX2BIN",&#13;
  385: "HEX2DEC",&#13;
  386: "HEX2OCT",&#13;
  387: "DEC2BIN",&#13;
  388: "DEC2HEX",&#13;
  389: "DEC2OCT",&#13;
  390: "OCT2BIN",&#13;
  391: "OCT2HEX",&#13;
  392: "OCT2DEC",&#13;
  393: "BIN2DEC",&#13;
  394: "BIN2OCT",&#13;
  395: "BIN2HEX",&#13;
  396: "IMSUB",&#13;
  397: "IMDIV",&#13;
  398: "IMPOWER",&#13;
  399: "IMABS",&#13;
  400: "IMSQRT",&#13;
  401: "IMLN",&#13;
  402: "IMLOG2",&#13;
  403: "IMLOG10",&#13;
  404: "IMSIN",&#13;
  405: "IMCOS",&#13;
  406: "IMEXP",&#13;
  407: "IMARGUMENT",&#13;
  408: "IMCONJUGATE",&#13;
  409: "IMAGINARY",&#13;
  410: "IMREAL",&#13;
  411: "COMPLEX",&#13;
  412: "IMSUM",&#13;
  413: "IMPRODUCT",&#13;
  414: "SERIESSUM",&#13;
  415: "FACTDOUBLE",&#13;
  416: "SQRTPI",&#13;
  417: "QUOTIENT",&#13;
  418: "DELTA",&#13;
  419: "GESTEP",&#13;
  420: "ISEVEN",&#13;
  421: "ISODD",&#13;
  422: "MROUND",&#13;
  423: "ERF",&#13;
  424: "ERFC",&#13;
  425: "BESSELJ",&#13;
  426: "BESSELK",&#13;
  427: "BESSELY",&#13;
  428: "BESSELI",&#13;
  429: "XIRR",&#13;
  430: "XNPV",&#13;
  431: "PRICEMAT",&#13;
  432: "YIELDMAT",&#13;
  433: "INTRATE",&#13;
  434: "RECEIVED",&#13;
  435: "DISC",&#13;
  436: "PRICEDISC",&#13;
  437: "YIELDDISC",&#13;
  438: "TBILLEQ",&#13;
  439: "TBILLPRICE",&#13;
  440: "TBILLYIELD",&#13;
  441: "PRICE",&#13;
  442: "YIELD",&#13;
  443: "DOLLARDE",&#13;
  444: "DOLLARFR",&#13;
  445: "NOMINAL",&#13;
  446: "EFFECT",&#13;
  447: "CUMPRINC",&#13;
  448: "CUMIPMT",&#13;
  449: "EDATE",&#13;
  450: "EOMONTH",&#13;
  451: "YEARFRAC",&#13;
  452: "COUPDAYBS",&#13;
  453: "COUPDAYS",&#13;
  454: "COUPDAYSNC",&#13;
  455: "COUPNCD",&#13;
  456: "COUPNUM",&#13;
  457: "COUPPCD",&#13;
  458: "DURATION",&#13;
  459: "MDURATION",&#13;
  460: "ODDLPRICE",&#13;
  461: "ODDLYIELD",&#13;
  462: "ODDFPRICE",&#13;
  463: "ODDFYIELD",&#13;
  464: "RANDBETWEEN",&#13;
  465: "WEEKNUM",&#13;
  466: "AMORDEGRC",&#13;
  467: "AMORLINC",&#13;
  468: "CONVERT",&#13;
  724: "SHEETJS",&#13;
  469: "ACCRINT",&#13;
  470: "ACCRINTM",&#13;
  471: "WORKDAY",&#13;
  472: "NETWORKDAYS",&#13;
  473: "GCD",&#13;
  474: "MULTINOMIAL",&#13;
  475: "LCM",&#13;
  476: "FVSCHEDULE",&#13;
  477: "CUBEKPIMEMBER",&#13;
  478: "CUBESET",&#13;
  479: "CUBESETCOUNT",&#13;
  480: "IFERROR",&#13;
  481: "COUNTIFS",&#13;
  482: "SUMIFS",&#13;
  483: "AVERAGEIF",&#13;
  484: "AVERAGEIFS"&#13;
};&#13;
var FtabArgc = {&#13;
  2: 1,&#13;
  3: 1,&#13;
  10: 0,&#13;
  15: 1,&#13;
  16: 1,&#13;
  17: 1,&#13;
  18: 1,&#13;
  19: 0,&#13;
  20: 1,&#13;
  21: 1,&#13;
  22: 1,&#13;
  23: 1,&#13;
  24: 1,&#13;
  25: 1,&#13;
  26: 1,&#13;
  27: 2,&#13;
  30: 2,&#13;
  31: 3,&#13;
  32: 1,&#13;
  33: 1,&#13;
  34: 0,&#13;
  35: 0,&#13;
  38: 1,&#13;
  39: 2,&#13;
  40: 3,&#13;
  41: 3,&#13;
  42: 3,&#13;
  43: 3,&#13;
  44: 3,&#13;
  45: 3,&#13;
  47: 3,&#13;
  48: 2,&#13;
  53: 1,&#13;
  61: 3,&#13;
  63: 0,&#13;
  65: 3,&#13;
  66: 3,&#13;
  67: 1,&#13;
  68: 1,&#13;
  69: 1,&#13;
  70: 1,&#13;
  71: 1,&#13;
  72: 1,&#13;
  73: 1,&#13;
  74: 0,&#13;
  75: 1,&#13;
  76: 1,&#13;
  77: 1,&#13;
  79: 2,&#13;
  80: 2,&#13;
  83: 1,&#13;
  85: 0,&#13;
  86: 1,&#13;
  89: 0,&#13;
  90: 1,&#13;
  94: 0,&#13;
  95: 0,&#13;
  97: 2,&#13;
  98: 1,&#13;
  99: 1,&#13;
  101: 3,&#13;
  102: 3,&#13;
  105: 1,&#13;
  106: 1,&#13;
  108: 2,&#13;
  111: 1,&#13;
  112: 1,&#13;
  113: 1,&#13;
  114: 1,&#13;
  117: 2,&#13;
  118: 1,&#13;
  119: 4,&#13;
  121: 1,&#13;
  126: 1,&#13;
  127: 1,&#13;
  128: 1,&#13;
  129: 1,&#13;
  130: 1,&#13;
  131: 1,&#13;
  133: 1,&#13;
  134: 1,&#13;
  135: 1,&#13;
  136: 2,&#13;
  137: 2,&#13;
  138: 2,&#13;
  140: 1,&#13;
  141: 1,&#13;
  142: 3,&#13;
  143: 4,&#13;
  144: 4,&#13;
  161: 1,&#13;
  162: 1,&#13;
  163: 1,&#13;
  164: 1,&#13;
  165: 2,&#13;
  172: 1,&#13;
  175: 2,&#13;
  176: 2,&#13;
  177: 3,&#13;
  178: 2,&#13;
  179: 1,&#13;
  184: 1,&#13;
  186: 1,&#13;
  189: 3,&#13;
  190: 1,&#13;
  195: 3,&#13;
  196: 3,&#13;
  197: 1,&#13;
  198: 1,&#13;
  199: 3,&#13;
  201: 1,&#13;
  207: 4,&#13;
  210: 3,&#13;
  211: 1,&#13;
  212: 2,&#13;
  213: 2,&#13;
  214: 1,&#13;
  215: 1,&#13;
  225: 0,&#13;
  229: 1,&#13;
  230: 1,&#13;
  231: 1,&#13;
  232: 1,&#13;
  233: 1,&#13;
  234: 1,&#13;
  235: 3,&#13;
  244: 1,&#13;
  247: 4,&#13;
  252: 2,&#13;
  257: 1,&#13;
  261: 1,&#13;
  271: 1,&#13;
  273: 4,&#13;
  274: 2,&#13;
  275: 2,&#13;
  276: 2,&#13;
  277: 3,&#13;
  278: 3,&#13;
  279: 1,&#13;
  280: 3,&#13;
  281: 3,&#13;
  282: 3,&#13;
  283: 1,&#13;
  284: 1,&#13;
  285: 2,&#13;
  286: 4,&#13;
  287: 3,&#13;
  288: 2,&#13;
  289: 4,&#13;
  290: 3,&#13;
  291: 3,&#13;
  292: 3,&#13;
  293: 4,&#13;
  294: 1,&#13;
  295: 3,&#13;
  296: 1,&#13;
  297: 3,&#13;
  298: 1,&#13;
  299: 2,&#13;
  300: 3,&#13;
  301: 3,&#13;
  302: 4,&#13;
  303: 2,&#13;
  304: 2,&#13;
  305: 2,&#13;
  306: 2,&#13;
  307: 2,&#13;
  308: 2,&#13;
  309: 3,&#13;
  310: 2,&#13;
  311: 2,&#13;
  312: 2,&#13;
  313: 2,&#13;
  314: 2,&#13;
  315: 2,&#13;
  316: 4,&#13;
  325: 2,&#13;
  326: 2,&#13;
  327: 2,&#13;
  328: 2,&#13;
  331: 2,&#13;
  332: 2,&#13;
  337: 2,&#13;
  342: 1,&#13;
  343: 1,&#13;
  346: 2,&#13;
  347: 1,&#13;
  350: 4,&#13;
  351: 3,&#13;
  352: 1,&#13;
  353: 2,&#13;
  360: 1,&#13;
  368: 1,&#13;
  369: 1,&#13;
  370: 1,&#13;
  371: 1,&#13;
  372: 1,&#13;
  373: 1,&#13;
  374: 1,&#13;
  375: 1,&#13;
  376: 1,&#13;
  377: 1,&#13;
  378: 1,&#13;
  382: 3,&#13;
  385: 1,&#13;
  392: 1,&#13;
  393: 1,&#13;
  396: 2,&#13;
  397: 2,&#13;
  398: 2,&#13;
  399: 1,&#13;
  400: 1,&#13;
  401: 1,&#13;
  402: 1,&#13;
  403: 1,&#13;
  404: 1,&#13;
  405: 1,&#13;
  406: 1,&#13;
  407: 1,&#13;
  408: 1,&#13;
  409: 1,&#13;
  410: 1,&#13;
  414: 4,&#13;
  415: 1,&#13;
  416: 1,&#13;
  417: 2,&#13;
  420: 1,&#13;
  421: 1,&#13;
  422: 2,&#13;
  424: 1,&#13;
  425: 2,&#13;
  426: 2,&#13;
  427: 2,&#13;
  428: 2,&#13;
  430: 3,&#13;
  438: 3,&#13;
  439: 3,&#13;
  440: 3,&#13;
  443: 2,&#13;
  444: 2,&#13;
  445: 2,&#13;
  446: 2,&#13;
  447: 6,&#13;
  448: 6,&#13;
  449: 2,&#13;
  450: 2,&#13;
  464: 2,&#13;
  468: 3,&#13;
  476: 2,&#13;
  479: 1,&#13;
  480: 2,&#13;
  65535: 0&#13;
};&#13;
/* Part 3 TODO: actually parse formulae */&#13;
function ods_to_csf_formula(f) {&#13;
	if(f.slice(0,3) == "of:") f = f.slice(3);&#13;
	/* 5.2 Basic Expressions */&#13;
	if(f.charCodeAt(0) == 61) {&#13;
		f = f.slice(1);&#13;
		if(f.charCodeAt(0) == 61) f = f.slice(1);&#13;
	}&#13;
	f = f.replace(/COM\.MICROSOFT\./g, "");&#13;
	/* Part 3 Section 5.8 References */&#13;
	f = f.replace(/\[((?:\.[A-Z]+[0-9]+)(?::\.[A-Z]+[0-9]+)?)\]/g, function($$, $1) { return $1.replace(/\./g,""); });&#13;
	f = f.replace(/\$'([^']|'')+'/g, function($$) { return $$.slice(1); });&#13;
	f = f.replace(/\$([^\]\. #$]+)/g, function($$, $1) { return ($1).match(/^([A-Z]{1,2}|[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D])?(10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5})?$/) ? $$ : $1; });&#13;
	/* TODO: something other than this */&#13;
	f = f.replace(/\[.(#[A-Z]*[?!])\]/g, "$1");&#13;
	return f.replace(/[;~]/g,",").replace(/\|/g,";");&#13;
}&#13;
&#13;
function csf_to_ods_formula(f) {&#13;
	var o = "of:=" + f.replace(crefregex, "$1[.$2$3$4$5]").replace(/\]:\[/g,":");&#13;
	/* TODO: something other than this */&#13;
	return o.replace(/;/g, "|").replace(/,/g,";");&#13;
}&#13;
&#13;
function ods_to_csf_3D(r) {&#13;
	r = r.replace(/\$'([^']|'')+'/g, function($$) { return $$.slice(1); });&#13;
	r = r.replace(/\$([^\]\. #$]+)/g, function($$, $1) { return ($1).match(/^([A-Z]{1,2}|[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D])?(10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5})?$/) ? $$ : $1; });&#13;
	var a = r.split(":");&#13;
	var s = a[0].split(".")[0];&#13;
	return [s, a[0].split(".")[1] + (a.length &gt; 1 ? (":" + (a[1].split(".")[1] || a[1].split(".")[0])) : "")];&#13;
}&#13;
&#13;
function csf_to_ods_3D(r) {&#13;
	return r.replace(/!/,".");&#13;
}&#13;
&#13;
var strs = {}; // shared strings&#13;
var _ssfopts = {}; // spreadsheet formatting options&#13;
&#13;
&#13;
/*global Map */&#13;
var browser_has_Map = typeof Map !== 'undefined';&#13;
&#13;
function get_sst_id(sst, str, rev) {&#13;
	var i = 0, len = sst.length;&#13;
	if(rev) {&#13;
		if(browser_has_Map ? rev.has(str) : Object.prototype.hasOwnProperty.call(rev, str)) {&#13;
			var revarr = browser_has_Map ? rev.get(str) : rev[str];&#13;
			for(; i &lt; revarr.length; ++i) {&#13;
				if(sst[revarr[i]].t === str) { sst.Count ++; return revarr[i]; }&#13;
			}&#13;
		}&#13;
	} else for(; i &lt; len; ++i) {&#13;
		if(sst[i].t === str) { sst.Count ++; return i; }&#13;
	}&#13;
	sst[len] = ({t:str}); sst.Count ++; sst.Unique ++;&#13;
	if(rev) {&#13;
		if(browser_has_Map) {&#13;
			if(!rev.has(str)) rev.set(str, []);&#13;
			rev.get(str).push(len);&#13;
		} else {&#13;
			if(!Object.prototype.hasOwnProperty.call(rev, str)) rev[str] = [];&#13;
			rev[str].push(len);&#13;
		}&#13;
	}&#13;
	return len;&#13;
}&#13;
&#13;
function col_obj_w(C, col) {&#13;
	var p = ({min:C+1,max:C+1});&#13;
	/* wch (chars), wpx (pixels) */&#13;
	var wch = -1;&#13;
	if(col.MDW) MDW = col.MDW;&#13;
	if(col.width != null) p.customWidth = 1;&#13;
	else if(col.wpx != null) wch = px2char(col.wpx);&#13;
	else if(col.wch != null) wch = col.wch;&#13;
	if(wch &gt; -1) { p.width = char2width(wch); p.customWidth = 1; }&#13;
	else if(col.width != null) p.width = col.width;&#13;
	if(col.hidden) p.hidden = true;&#13;
	if(col.level != null) { p.outlineLevel = p.level = col.level; }&#13;
	return p;&#13;
}&#13;
&#13;
function default_margins(margins, mode) {&#13;
	if(!margins) return;&#13;
	var defs = [0.7, 0.7, 0.75, 0.75, 0.3, 0.3];&#13;
	if(mode == 'xlml') defs = [1, 1, 1, 1, 0.5, 0.5];&#13;
	if(margins.left   == null) margins.left   = defs[0];&#13;
	if(margins.right  == null) margins.right  = defs[1];&#13;
	if(margins.top    == null) margins.top    = defs[2];&#13;
	if(margins.bottom == null) margins.bottom = defs[3];&#13;
	if(margins.header == null) margins.header = defs[4];&#13;
	if(margins.footer == null) margins.footer = defs[5];&#13;
}&#13;
&#13;
function get_cell_style(styles, cell, opts) {&#13;
	var z = opts.revssf[cell.z != null ? cell.z : "General"];&#13;
	var i = 0x3c, len = styles.length;&#13;
	if(z == null &amp;&amp; opts.ssf) {&#13;
		for(; i &lt; 0x188; ++i) if(opts.ssf[i] == null) {&#13;
			SSF__load(cell.z, i);&#13;
			// $FlowIgnore&#13;
			opts.ssf[i] = cell.z;&#13;
			opts.revssf[cell.z] = z = i;&#13;
			break;&#13;
		}&#13;
	}&#13;
	for(i = 0; i != len; ++i) if(styles[i].numFmtId === z) return i;&#13;
	styles[len] = {&#13;
		numFmtId:z,&#13;
		fontId:0,&#13;
		fillId:0,&#13;
		borderId:0,&#13;
		xfId:0,&#13;
		applyNumberFormat:1&#13;
	};&#13;
	return len;&#13;
}&#13;
&#13;
function safe_format(p, fmtid, fillid, opts, themes, styles) {&#13;
	try {&#13;
		if(opts.cellNF) p.z = table_fmt[fmtid];&#13;
	} catch(e) { if(opts.WTF) throw e; }&#13;
	if(p.t === 'z' &amp;&amp; !opts.cellStyles) return;&#13;
	if(p.t === 'd' &amp;&amp; typeof p.v === 'string') p.v = parseDate(p.v);&#13;
	if((!opts || opts.cellText !== false) &amp;&amp; p.t !== 'z') try {&#13;
		if(table_fmt[fmtid] == null) SSF__load(SSFImplicit[fmtid] || "General", fmtid);&#13;
		if(p.t === 'e') p.w = p.w || BErr[p.v];&#13;
		else if(fmtid === 0) {&#13;
			if(p.t === 'n') {&#13;
				if((p.v|0) === p.v) p.w = p.v.toString(10);&#13;
				else p.w = SSF_general_num(p.v);&#13;
			}&#13;
			else if(p.t === 'd') {&#13;
				var dd = datenum(p.v);&#13;
				if((dd|0) === dd) p.w = dd.toString(10);&#13;
				else p.w = SSF_general_num(dd);&#13;
			}&#13;
			else if(p.v === undefined) return "";&#13;
			else p.w = SSF_general(p.v,_ssfopts);&#13;
		}&#13;
		else if(p.t === 'd') p.w = SSF_format(fmtid,datenum(p.v),_ssfopts);&#13;
		else p.w = SSF_format(fmtid,p.v,_ssfopts);&#13;
	} catch(e) { if(opts.WTF) throw e; }&#13;
	if(!opts.cellStyles) return;&#13;
	if(fillid != null) try {&#13;
		p.s = styles.Fills[fillid];&#13;
		if (p.s.fgColor &amp;&amp; p.s.fgColor.theme &amp;&amp; !p.s.fgColor.rgb) {&#13;
			p.s.fgColor.rgb = rgb_tint(themes.themeElements.clrScheme[p.s.fgColor.theme].rgb, p.s.fgColor.tint || 0);&#13;
			if(opts.WTF) p.s.fgColor.raw_rgb = themes.themeElements.clrScheme[p.s.fgColor.theme].rgb;&#13;
		}&#13;
		if (p.s.bgColor &amp;&amp; p.s.bgColor.theme) {&#13;
			p.s.bgColor.rgb = rgb_tint(themes.themeElements.clrScheme[p.s.bgColor.theme].rgb, p.s.bgColor.tint || 0);&#13;
			if(opts.WTF) p.s.bgColor.raw_rgb = themes.themeElements.clrScheme[p.s.bgColor.theme].rgb;&#13;
		}&#13;
	} catch(e) { if(opts.WTF &amp;&amp; styles.Fills) throw e; }&#13;
}&#13;
&#13;
function check_ws(ws, sname, i) {&#13;
	if(ws &amp;&amp; ws['!ref']) {&#13;
		var range = safe_decode_range(ws['!ref']);&#13;
		if(range.e.c &lt; range.s.c || range.e.r &lt; range.s.r) throw new Error("Bad range (" + i + "): " + ws['!ref']);&#13;
	}&#13;
}&#13;
function parse_ws_xml_dim(ws, s) {&#13;
	var d = safe_decode_range(s);&#13;
	if(d.s.r&lt;=d.e.r &amp;&amp; d.s.c&lt;=d.e.c &amp;&amp; d.s.r&gt;=0 &amp;&amp; d.s.c&gt;=0) ws["!ref"] = encode_range(d);&#13;
}&#13;
var mergecregex = /&lt;(?:\w:)?mergeCell ref="[A-Z0-9:]+"\s*[\/]?&gt;/g;&#13;
var sheetdataregex = /&lt;(?:\w+:)?sheetData[^&gt;]*&gt;([\s\S]*)&lt;\/(?:\w+:)?sheetData&gt;/;&#13;
var hlinkregex = /&lt;(?:\w:)?hyperlink [^&gt;]*&gt;/mg;&#13;
var dimregex = /"(\w*:\w*)"/;&#13;
var colregex = /&lt;(?:\w:)?col\b[^&gt;]*[\/]?&gt;/g;&#13;
var afregex = /&lt;(?:\w:)?autoFilter[^&gt;]*([\/]|&gt;([\s\S]*)&lt;\/(?:\w:)?autoFilter)&gt;/g;&#13;
var marginregex= /&lt;(?:\w:)?pageMargins[^&gt;]*\/&gt;/g;&#13;
var sheetprregex = /&lt;(?:\w:)?sheetPr\b(?:[^&gt;a-z][^&gt;]*)?\/&gt;/;&#13;
var sheetprregex2= /&lt;(?:\w:)?sheetPr[^&gt;]*(?:[\/]|&gt;([\s\S]*)&lt;\/(?:\w:)?sheetPr)&gt;/;&#13;
var svsregex = /&lt;(?:\w:)?sheetViews[^&gt;]*(?:[\/]|&gt;([\s\S]*)&lt;\/(?:\w:)?sheetViews)&gt;/;&#13;
&#13;
/* 18.3 Worksheets */&#13;
function parse_ws_xml(data, opts, idx, rels, wb, themes, styles) {&#13;
	if(!data) return data;&#13;
	if(!rels) rels = {'!id':{}};&#13;
	if(DENSE != null &amp;&amp; opts.dense == null) opts.dense = DENSE;&#13;
&#13;
	/* 18.3.1.99 worksheet CT_Worksheet */&#13;
	var s = opts.dense ? ([]) : ({});&#13;
	var refguess = ({s: {r:2000000, c:2000000}, e: {r:0, c:0} });&#13;
&#13;
	var data1 = "", data2 = "";&#13;
	var mtch = data.match(sheetdataregex);&#13;
	if(mtch) {&#13;
		data1 = data.slice(0, mtch.index);&#13;
		data2 = data.slice(mtch.index + mtch[0].length);&#13;
	} else data1 = data2 = data;&#13;
&#13;
	/* 18.3.1.82 sheetPr CT_SheetPr */&#13;
	var sheetPr = data1.match(sheetprregex);&#13;
	if(sheetPr) parse_ws_xml_sheetpr(sheetPr[0], s, wb, idx);&#13;
	else if((sheetPr = data1.match(sheetprregex2))) parse_ws_xml_sheetpr2(sheetPr[0], sheetPr[1]||"", s, wb, idx, styles, themes);&#13;
&#13;
	/* 18.3.1.35 dimension CT_SheetDimension */&#13;
	var ridx = (data1.match(/&lt;(?:\w*:)?dimension/)||{index:-1}).index;&#13;
	if(ridx &gt; 0) {&#13;
		var ref = data1.slice(ridx,ridx+50).match(dimregex);&#13;
		if(ref) parse_ws_xml_dim(s, ref[1]);&#13;
	}&#13;
&#13;
	/* 18.3.1.88 sheetViews CT_SheetViews */&#13;
	var svs = data1.match(svsregex);&#13;
	if(svs &amp;&amp; svs[1]) parse_ws_xml_sheetviews(svs[1], wb);&#13;
&#13;
	/* 18.3.1.17 cols CT_Cols */&#13;
	var columns = [];&#13;
	if(opts.cellStyles) {&#13;
		/* 18.3.1.13 col CT_Col */&#13;
		var cols = data1.match(colregex);&#13;
		if(cols) parse_ws_xml_cols(columns, cols);&#13;
	}&#13;
&#13;
	/* 18.3.1.80 sheetData CT_SheetData ? */&#13;
	if(mtch) parse_ws_xml_data(mtch[1], s, opts, refguess, themes, styles);&#13;
&#13;
	/* 18.3.1.2  autoFilter CT_AutoFilter */&#13;
	var afilter = data2.match(afregex);&#13;
	if(afilter) s['!autofilter'] = parse_ws_xml_autofilter(afilter[0]);&#13;
&#13;
	/* 18.3.1.55 mergeCells CT_MergeCells */&#13;
	var merges = [];&#13;
	var _merge = data2.match(mergecregex);&#13;
	if(_merge) for(ridx = 0; ridx != _merge.length; ++ridx)&#13;
		merges[ridx] = safe_decode_range(_merge[ridx].slice(_merge[ridx].indexOf("\"")+1));&#13;
&#13;
	/* 18.3.1.48 hyperlinks CT_Hyperlinks */&#13;
	var hlink = data2.match(hlinkregex);&#13;
	if(hlink) parse_ws_xml_hlinks(s, hlink, rels);&#13;
&#13;
	/* 18.3.1.62 pageMargins CT_PageMargins */&#13;
	var margins = data2.match(marginregex);&#13;
	if(margins) s['!margins'] = parse_ws_xml_margins(parsexmltag(margins[0]));&#13;
&#13;
	if(!s["!ref"] &amp;&amp; refguess.e.c &gt;= refguess.s.c &amp;&amp; refguess.e.r &gt;= refguess.s.r) s["!ref"] = encode_range(refguess);&#13;
	if(opts.sheetRows &gt; 0 &amp;&amp; s["!ref"]) {&#13;
		var tmpref = safe_decode_range(s["!ref"]);&#13;
		if(opts.sheetRows &lt;= +tmpref.e.r) {&#13;
			tmpref.e.r = opts.sheetRows - 1;&#13;
			if(tmpref.e.r &gt; refguess.e.r) tmpref.e.r = refguess.e.r;&#13;
			if(tmpref.e.r &lt; tmpref.s.r) tmpref.s.r = tmpref.e.r;&#13;
			if(tmpref.e.c &gt; refguess.e.c) tmpref.e.c = refguess.e.c;&#13;
			if(tmpref.e.c &lt; tmpref.s.c) tmpref.s.c = tmpref.e.c;&#13;
			s["!fullref"] = s["!ref"];&#13;
			s["!ref"] = encode_range(tmpref);&#13;
		}&#13;
	}&#13;
	if(columns.length &gt; 0) s["!cols"] = columns;&#13;
	if(merges.length &gt; 0) s["!merges"] = merges;&#13;
	return s;&#13;
}&#13;
&#13;
function write_ws_xml_merges(merges) {&#13;
	if(merges.length === 0) return "";&#13;
	var o = '&lt;mergeCells count="' + merges.length + '"&gt;';&#13;
	for(var i = 0; i != merges.length; ++i) o += '&lt;mergeCell ref="' + encode_range(merges[i]) + '"/&gt;';&#13;
	return o + '&lt;/mergeCells&gt;';&#13;
}&#13;
&#13;
/* 18.3.1.82-3 sheetPr CT_ChartsheetPr / CT_SheetPr */&#13;
function parse_ws_xml_sheetpr(sheetPr, s, wb, idx) {&#13;
	var data = parsexmltag(sheetPr);&#13;
	if(!wb.Sheets[idx]) wb.Sheets[idx] = {};&#13;
	if(data.codeName) wb.Sheets[idx].CodeName = unescapexml(utf8read(data.codeName));&#13;
}&#13;
function parse_ws_xml_sheetpr2(sheetPr, body, s, wb, idx) {&#13;
	parse_ws_xml_sheetpr(sheetPr.slice(0, sheetPr.indexOf("&gt;")), s, wb, idx);&#13;
}&#13;
function write_ws_xml_sheetpr(ws, wb, idx, opts, o) {&#13;
	var needed = false;&#13;
	var props = {}, payload = null;&#13;
	if(opts.bookType !== 'xlsx' &amp;&amp; wb.vbaraw) {&#13;
		var cname = wb.SheetNames[idx];&#13;
		try { if(wb.Workbook) cname = wb.Workbook.Sheets[idx].CodeName || cname; } catch(e) {}&#13;
		needed = true;&#13;
		props.codeName = utf8write(escapexml(cname));&#13;
	}&#13;
&#13;
	if(ws &amp;&amp; ws["!outline"]) {&#13;
		var outlineprops = {summaryBelow:1, summaryRight:1};&#13;
		if(ws["!outline"].above) outlineprops.summaryBelow = 0;&#13;
		if(ws["!outline"].left) outlineprops.summaryRight = 0;&#13;
		payload = (payload||"") + writextag('outlinePr', null, outlineprops);&#13;
	}&#13;
&#13;
	if(!needed &amp;&amp; !payload) return;&#13;
	o[o.length] = (writextag('sheetPr', payload, props));&#13;
}&#13;
&#13;
/* 18.3.1.85 sheetProtection CT_SheetProtection */&#13;
var sheetprot_deffalse = ["objects", "scenarios", "selectLockedCells", "selectUnlockedCells"];&#13;
var sheetprot_deftrue = [&#13;
	"formatColumns", "formatRows", "formatCells",&#13;
	"insertColumns", "insertRows", "insertHyperlinks",&#13;
	"deleteColumns", "deleteRows",&#13;
	"sort", "autoFilter", "pivotTables"&#13;
];&#13;
function write_ws_xml_protection(sp) {&#13;
	// algorithmName, hashValue, saltValue, spinCount&#13;
	var o = ({sheet:1});&#13;
	sheetprot_deffalse.forEach(function(n) { if(sp[n] != null &amp;&amp; sp[n]) o[n] = "1"; });&#13;
	sheetprot_deftrue.forEach(function(n) { if(sp[n] != null &amp;&amp; !sp[n]) o[n] = "0"; });&#13;
	/* TODO: algorithm */&#13;
	if(sp.password) o.password = crypto_CreatePasswordVerifier_Method1(sp.password).toString(16).toUpperCase();&#13;
	return writextag('sheetProtection', null, o);&#13;
}&#13;
&#13;
function parse_ws_xml_hlinks(s, data, rels) {&#13;
	var dense = Array.isArray(s);&#13;
	for(var i = 0; i != data.length; ++i) {&#13;
		var val = parsexmltag(utf8read(data[i]), true);&#13;
		if(!val.ref) return;&#13;
		var rel = ((rels || {})['!id']||[])[val.id];&#13;
		if(rel) {&#13;
			val.Target = rel.Target;&#13;
			if(val.location) val.Target += "#"+unescapexml(val.location);&#13;
		} else {&#13;
			val.Target = "#" + unescapexml(val.location);&#13;
			rel = {Target: val.Target, TargetMode: 'Internal'};&#13;
		}&#13;
		val.Rel = rel;&#13;
		if(val.tooltip) { val.Tooltip = val.tooltip; delete val.tooltip; }&#13;
		var rng = safe_decode_range(val.ref);&#13;
		for(var R=rng.s.r;R&lt;=rng.e.r;++R) for(var C=rng.s.c;C&lt;=rng.e.c;++C) {&#13;
			var addr = encode_cell({c:C,r:R});&#13;
			if(dense) {&#13;
				if(!s[R]) s[R] = [];&#13;
				if(!s[R][C]) s[R][C] = {t:"z",v:undefined};&#13;
				s[R][C].l = val;&#13;
			} else {&#13;
				if(!s[addr]) s[addr] = {t:"z",v:undefined};&#13;
				s[addr].l = val;&#13;
			}&#13;
		}&#13;
	}&#13;
}&#13;
&#13;
function parse_ws_xml_margins(margin) {&#13;
	var o = {};&#13;
	["left", "right", "top", "bottom", "header", "footer"].forEach(function(k) {&#13;
		if(margin[k]) o[k] = parseFloat(margin[k]);&#13;
	});&#13;
	return o;&#13;
}&#13;
function write_ws_xml_margins(margin) {&#13;
	default_margins(margin);&#13;
	return writextag('pageMargins', null, margin);&#13;
}&#13;
&#13;
function parse_ws_xml_cols(columns, cols) {&#13;
	var seencol = false;&#13;
	for(var coli = 0; coli != cols.length; ++coli) {&#13;
		var coll = parsexmltag(cols[coli], true);&#13;
		if(coll.hidden) coll.hidden = parsexmlbool(coll.hidden);&#13;
		var colm=parseInt(coll.min, 10)-1, colM=parseInt(coll.max,10)-1;&#13;
		if(coll.outlineLevel) coll.level = (+coll.outlineLevel || 0);&#13;
		delete coll.min; delete coll.max; coll.width = +coll.width;&#13;
		if(!seencol &amp;&amp; coll.width) { seencol = true; find_mdw_colw(coll.width); }&#13;
		process_col(coll);&#13;
		while(colm &lt;= colM) columns[colm++] = dup(coll);&#13;
	}&#13;
}&#13;
function write_ws_xml_cols(ws, cols) {&#13;
	var o = ["&lt;cols&gt;"], col;&#13;
	for(var i = 0; i != cols.length; ++i) {&#13;
		if(!(col = cols[i])) continue;&#13;
		o[o.length] = (writextag('col', null, col_obj_w(i, col)));&#13;
	}&#13;
	o[o.length] = "&lt;/cols&gt;";&#13;
	return o.join("");&#13;
}&#13;
&#13;
function parse_ws_xml_autofilter(data) {&#13;
	var o = { ref: (data.match(/ref="([^"]*)"/)||[])[1]};&#13;
	return o;&#13;
}&#13;
function write_ws_xml_autofilter(data, ws, wb, idx) {&#13;
	var ref = typeof data.ref == "string" ? data.ref : encode_range(data.ref);&#13;
	if(!wb.Workbook) wb.Workbook = ({Sheets:[]});&#13;
	if(!wb.Workbook.Names) wb.Workbook.Names = [];&#13;
	var names = wb.Workbook.Names;&#13;
	var range = decode_range(ref);&#13;
	if(range.s.r == range.e.r) { range.e.r = decode_range(ws["!ref"]).e.r; ref = encode_range(range); }&#13;
	for(var i = 0; i &lt; names.length; ++i) {&#13;
		var name = names[i];&#13;
		if(name.Name != '_xlnm._FilterDatabase') continue;&#13;
		if(name.Sheet != idx) continue;&#13;
		name.Ref = formula_quote_sheet_name(wb.SheetNames[idx]) + "!" + fix_range(ref); break;&#13;
	}&#13;
	if(i == names.length) names.push({ Name: '_xlnm._FilterDatabase', Sheet: idx, Ref: "'" + wb.SheetNames[idx] + "'!" + ref  });&#13;
	return writextag("autoFilter", null, {ref:ref});&#13;
}&#13;
&#13;
/* 18.3.1.88 sheetViews CT_SheetViews */&#13;
/* 18.3.1.87 sheetView CT_SheetView */&#13;
var sviewregex = /&lt;(?:\w:)?sheetView(?:[^&gt;a-z][^&gt;]*)?\/?&gt;/g;&#13;
function parse_ws_xml_sheetviews(data, wb) {&#13;
	if(!wb.Views) wb.Views = [{}];&#13;
	(data.match(sviewregex)||[]).forEach(function(r, i) {&#13;
		var tag = parsexmltag(r);&#13;
		// $FlowIgnore&#13;
		if(!wb.Views[i]) wb.Views[i] = {};&#13;
		// $FlowIgnore&#13;
		if(+tag.zoomScale) wb.Views[i].zoom = +tag.zoomScale;&#13;
		// $FlowIgnore&#13;
		if(tag.rightToLeft &amp;&amp; parsexmlbool(tag.rightToLeft)) wb.Views[i].RTL = true;&#13;
	});&#13;
}&#13;
function write_ws_xml_sheetviews(ws, opts, idx, wb) {&#13;
	var sview = ({workbookViewId:"0"});&#13;
	// $FlowIgnore&#13;
	if((((wb||{}).Workbook||{}).Views||[])[0]) sview.rightToLeft = wb.Workbook.Views[0].RTL ? "1" : "0";&#13;
	return writextag("sheetViews", writextag("sheetView", null, sview), {});&#13;
}&#13;
&#13;
function write_ws_xml_cell(cell, ref, ws, opts) {&#13;
	if(cell.c) ws['!comments'].push([ref, cell.c]);&#13;
	if((cell.v === undefined || cell.t === "z" &amp;&amp; !(opts||{}).sheetStubs) &amp;&amp; typeof cell.f !== "string" &amp;&amp; typeof cell.z == "undefined") return "";&#13;
	var vv = "";&#13;
	var oldt = cell.t, oldv = cell.v;&#13;
	if(cell.t !== "z") switch(cell.t) {&#13;
		case 'b': vv = cell.v ? "1" : "0"; break;&#13;
		case 'n': vv = ''+cell.v; break;&#13;
		case 'e': vv = BErr[cell.v]; break;&#13;
		case 'd':&#13;
			if(opts &amp;&amp; opts.cellDates) vv = parseDate(cell.v, -1).toISOString();&#13;
			else {&#13;
				cell = dup(cell);&#13;
				cell.t = 'n';&#13;
				vv = ''+(cell.v = datenum(parseDate(cell.v)));&#13;
			}&#13;
			if(typeof cell.z === 'undefined') cell.z = table_fmt[14];&#13;
			break;&#13;
		default: vv = cell.v; break;&#13;
	}&#13;
	var v = (cell.t == "z" || cell.v == null)? "" : writetag('v', escapexml(vv)), o = ({r:ref});&#13;
	/* TODO: cell style */&#13;
	var os = get_cell_style(opts.cellXfs, cell, opts);&#13;
	if(os !== 0) o.s = os;&#13;
	switch(cell.t) {&#13;
		case 'n': break;&#13;
		case 'd': o.t = "d"; break;&#13;
		case 'b': o.t = "b"; break;&#13;
		case 'e': o.t = "e"; break;&#13;
		case 'z': break;&#13;
		default: if(cell.v == null) { delete cell.t; break; }&#13;
			if(cell.v.length &gt; 32767) throw new Error("Text length must not exceed 32767 characters");&#13;
			if(opts &amp;&amp; opts.bookSST) {&#13;
				v = writetag('v', ''+get_sst_id(opts.Strings, cell.v, opts.revStrings));&#13;
				o.t = "s"; break;&#13;
			}&#13;
			else o.t = "str"; break;&#13;
	}&#13;
	if(cell.t != oldt) { cell.t = oldt; cell.v = oldv; }&#13;
	if(typeof cell.f == "string" &amp;&amp; cell.f) {&#13;
		var ff = cell.F &amp;&amp; cell.F.slice(0, ref.length) == ref ? {t:"array", ref:cell.F} : null;&#13;
		v = writextag('f', escapexml(cell.f), ff) + (cell.v != null ? v : "");&#13;
	}&#13;
	if(cell.l) {&#13;
		cell.l.display = escapexml(vv);&#13;
		ws['!links'].push([ref, cell.l]);&#13;
	}&#13;
	if(cell.D) o.cm = 1;&#13;
	return writextag('c', v, o);&#13;
}&#13;
&#13;
var parse_ws_xml_data = (function() {&#13;
	var cellregex = /&lt;(?:\w+:)?c[ \/&gt;]/, rowregex = /&lt;\/(?:\w+:)?row&gt;/;&#13;
	var rregex = /r=["']([^"']*)["']/, isregex = /&lt;(?:\w+:)?is&gt;([\S\s]*?)&lt;\/(?:\w+:)?is&gt;/;&#13;
	var refregex = /ref=["']([^"']*)["']/;&#13;
	var match_v = matchtag("v"), match_f = matchtag("f");&#13;
&#13;
return function parse_ws_xml_data(sdata, s, opts, guess, themes, styles) {&#13;
	var ri = 0, x = "", cells = [], cref = [], idx=0, i=0, cc=0, d="", p;&#13;
	var tag, tagr = 0, tagc = 0;&#13;
	var sstr, ftag;&#13;
	var fmtid = 0, fillid = 0;&#13;
	var do_format = Array.isArray(styles.CellXf), cf;&#13;
	var arrayf = [];&#13;
	var sharedf = [];&#13;
	var dense = Array.isArray(s);&#13;
	var rows = [], rowobj = {}, rowrite = false;&#13;
	var sheetStubs = !!opts.sheetStubs;&#13;
	for(var marr = sdata.split(rowregex), mt = 0, marrlen = marr.length; mt != marrlen; ++mt) {&#13;
		x = marr[mt].trim();&#13;
		var xlen = x.length;&#13;
		if(xlen === 0) continue;&#13;
&#13;
		/* 18.3.1.73 row CT_Row */&#13;
		var rstarti = 0;&#13;
		outa: for(ri = 0; ri &lt; xlen; ++ri) switch(/*x.charCodeAt(ri)*/x[ri]) {&#13;
			case "&gt;" /*62*/:&#13;
				if(/*x.charCodeAt(ri-1) != 47*/x[ri-1] != "/") { ++ri; break outa; }&#13;
				if(opts &amp;&amp; opts.cellStyles) {&#13;
					// TODO: avoid duplication&#13;
					tag = parsexmltag(x.slice(rstarti,ri), true);&#13;
					tagr = tag.r != null ? parseInt(tag.r, 10) : tagr+1; tagc = -1;&#13;
					if(opts.sheetRows &amp;&amp; opts.sheetRows &lt; tagr) continue;&#13;
					rowobj = {}; rowrite = false;&#13;
					if(tag.ht) { rowrite = true; rowobj.hpt = parseFloat(tag.ht); rowobj.hpx = pt2px(rowobj.hpt); }&#13;
					if(tag.hidden &amp;&amp; parsexmlbool(tag.hidden)) { rowrite = true; rowobj.hidden = true; }&#13;
					if(tag.outlineLevel != null) { rowrite = true; rowobj.level = +tag.outlineLevel; }&#13;
					if(rowrite) rows[tagr-1] = rowobj;&#13;
				}&#13;
				break;&#13;
			case "&lt;" /*60*/: rstarti = ri; break;&#13;
		}&#13;
		if(rstarti &gt;= ri) break;&#13;
		tag = parsexmltag(x.slice(rstarti,ri), true);&#13;
		tagr = tag.r != null ? parseInt(tag.r, 10) : tagr+1; tagc = -1;&#13;
		if(opts.sheetRows &amp;&amp; opts.sheetRows &lt; tagr) continue;&#13;
		if(guess.s.r &gt; tagr - 1) guess.s.r = tagr - 1;&#13;
		if(guess.e.r &lt; tagr - 1) guess.e.r = tagr - 1;&#13;
&#13;
		if(opts &amp;&amp; opts.cellStyles) {&#13;
			rowobj = {}; rowrite = false;&#13;
			if(tag.ht) { rowrite = true; rowobj.hpt = parseFloat(tag.ht); rowobj.hpx = pt2px(rowobj.hpt); }&#13;
			if(tag.hidden &amp;&amp; parsexmlbool(tag.hidden)) { rowrite = true; rowobj.hidden = true; }&#13;
			if(tag.outlineLevel != null) { rowrite = true; rowobj.level = +tag.outlineLevel; }&#13;
			if(rowrite) rows[tagr-1] = rowobj;&#13;
		}&#13;
&#13;
		/* 18.3.1.4 c CT_Cell */&#13;
		cells = x.slice(ri).split(cellregex);&#13;
		for(var rslice = 0; rslice != cells.length; ++rslice) if(cells[rslice].trim().charAt(0) != "&lt;") break;&#13;
		cells = cells.slice(rslice);&#13;
		for(ri = 0; ri != cells.length; ++ri) {&#13;
			x = cells[ri].trim();&#13;
			if(x.length === 0) continue;&#13;
			cref = x.match(rregex); idx = ri; i=0; cc=0;&#13;
			x = "&lt;c " + (x.slice(0,1)=="&lt;"?"&gt;":"") + x;&#13;
			if(cref != null &amp;&amp; cref.length === 2) {&#13;
				idx = 0; d=cref[1];&#13;
				for(i=0; i != d.length; ++i) {&#13;
					if((cc=d.charCodeAt(i)-64) &lt; 1 || cc &gt; 26) break;&#13;
					idx = 26*idx + cc;&#13;
				}&#13;
				--idx;&#13;
				tagc = idx;&#13;
			} else ++tagc;&#13;
			for(i = 0; i != x.length; ++i) if(x.charCodeAt(i) === 62) break; ++i;&#13;
			tag = parsexmltag(x.slice(0,i), true);&#13;
			if(!tag.r) tag.r = encode_cell({r:tagr-1, c:tagc});&#13;
			d = x.slice(i);&#13;
			p = ({t:""});&#13;
&#13;
			if((cref=d.match(match_v))!= null &amp;&amp; cref[1] !== '') p.v=unescapexml(cref[1]);&#13;
			if(opts.cellFormula) {&#13;
				if((cref=d.match(match_f))!= null &amp;&amp; cref[1] !== '') {&#13;
					/* TODO: match against XLSXFutureFunctions */&#13;
					p.f=unescapexml(utf8read(cref[1]), true);&#13;
					if(!opts.xlfn) p.f = _xlfn(p.f);&#13;
					if(cref[0].indexOf('t="array"') &gt; -1) {&#13;
						p.F = (d.match(refregex)||[])[1];&#13;
						if(p.F.indexOf(":") &gt; -1) arrayf.push([safe_decode_range(p.F), p.F]);&#13;
					} else if(cref[0].indexOf('t="shared"') &gt; -1) {&#13;
						// TODO: parse formula&#13;
						ftag = parsexmltag(cref[0]);&#13;
						var ___f = unescapexml(utf8read(cref[1]));&#13;
						if(!opts.xlfn) ___f = _xlfn(___f);&#13;
						sharedf[parseInt(ftag.si, 10)] = [ftag, ___f, tag.r];&#13;
					}&#13;
				} else if((cref=d.match(/&lt;f[^&gt;]*\/&gt;/))) {&#13;
					ftag = parsexmltag(cref[0]);&#13;
					if(sharedf[ftag.si]) p.f = shift_formula_xlsx(sharedf[ftag.si][1], sharedf[ftag.si][2]/*[0].ref*/, tag.r);&#13;
				}&#13;
				/* TODO: factor out contains logic */&#13;
				var _tag = decode_cell(tag.r);&#13;
				for(i = 0; i &lt; arrayf.length; ++i)&#13;
					if(_tag.r &gt;= arrayf[i][0].s.r &amp;&amp; _tag.r &lt;= arrayf[i][0].e.r)&#13;
						if(_tag.c &gt;= arrayf[i][0].s.c &amp;&amp; _tag.c &lt;= arrayf[i][0].e.c)&#13;
							p.F = arrayf[i][1];&#13;
			}&#13;
&#13;
			if(tag.t == null &amp;&amp; p.v === undefined) {&#13;
				if(p.f || p.F) {&#13;
					p.v = 0; p.t = "n";&#13;
				} else if(!sheetStubs) continue;&#13;
				else p.t = "z";&#13;
			}&#13;
			else p.t = tag.t || "n";&#13;
			if(guess.s.c &gt; tagc) guess.s.c = tagc;&#13;
			if(guess.e.c &lt; tagc) guess.e.c = tagc;&#13;
			/* 18.18.11 t ST_CellType */&#13;
			switch(p.t) {&#13;
				case 'n':&#13;
					if(p.v == "" || p.v == null) {&#13;
						if(!sheetStubs) continue;&#13;
						p.t = 'z';&#13;
					} else p.v = parseFloat(p.v);&#13;
					break;&#13;
				case 's':&#13;
					if(typeof p.v == 'undefined') {&#13;
						if(!sheetStubs) continue;&#13;
						p.t = 'z';&#13;
					} else {&#13;
						sstr = strs[parseInt(p.v, 10)];&#13;
						p.v = sstr.t;&#13;
						p.r = sstr.r;&#13;
						if(opts.cellHTML) p.h = sstr.h;&#13;
					}&#13;
					break;&#13;
				case 'str':&#13;
					p.t = "s";&#13;
					p.v = (p.v!=null) ? unescapexml(utf8read(p.v), true) : '';&#13;
					if(opts.cellHTML) p.h = escapehtml(p.v);&#13;
					break;&#13;
				case 'inlineStr':&#13;
					cref = d.match(isregex);&#13;
					p.t = 's';&#13;
					if(cref != null &amp;&amp; (sstr = parse_si(cref[1]))) {&#13;
						p.v = sstr.t;&#13;
						if(opts.cellHTML) p.h = sstr.h;&#13;
					} else p.v = "";&#13;
					break;&#13;
				case 'b': p.v = parsexmlbool(p.v); break;&#13;
				case 'd':&#13;
					if(opts.cellDates) p.v = parseDate(p.v, 1);&#13;
					else { p.v = datenum(parseDate(p.v, 1)); p.t = 'n'; }&#13;
					break;&#13;
				/* error string in .w, number in .v */&#13;
				case 'e':&#13;
					if(!opts || opts.cellText !== false) p.w = p.v;&#13;
					p.v = RBErr[p.v]; break;&#13;
			}&#13;
			/* formatting */&#13;
			fmtid = fillid = 0;&#13;
			cf = null;&#13;
			if(do_format &amp;&amp; tag.s !== undefined) {&#13;
				cf = styles.CellXf[tag.s];&#13;
				if(cf != null) {&#13;
					if(cf.numFmtId != null) fmtid = cf.numFmtId;&#13;
					if(opts.cellStyles) {&#13;
						if(cf.fillId != null) fillid = cf.fillId;&#13;
					}&#13;
				}&#13;
			}&#13;
			safe_format(p, fmtid, fillid, opts, themes, styles);&#13;
			if(opts.cellDates &amp;&amp; do_format &amp;&amp; p.t == 'n' &amp;&amp; fmt_is_date(table_fmt[fmtid])) { p.t = 'd'; p.v = numdate(p.v); }&#13;
			if(tag.cm &amp;&amp; opts.xlmeta) {&#13;
				var cm = (opts.xlmeta.Cell||[])[+tag.cm-1];&#13;
				if(cm &amp;&amp; cm.type == 'XLDAPR') p.D = true;&#13;
			}&#13;
			if(dense) {&#13;
				var _r = decode_cell(tag.r);&#13;
				if(!s[_r.r]) s[_r.r] = [];&#13;
				s[_r.r][_r.c] = p;&#13;
			} else s[tag.r] = p;&#13;
		}&#13;
	}&#13;
	if(rows.length &gt; 0) s['!rows'] = rows;&#13;
}; })();&#13;
&#13;
function write_ws_xml_data(ws, opts, idx, wb) {&#13;
	var o = [], r = [], range = safe_decode_range(ws['!ref']), cell="", ref, rr = "", cols = [], R=0, C=0, rows = ws['!rows'];&#13;
	var dense = Array.isArray(ws);&#13;
	var params = ({r:rr}), row, height = -1;&#13;
	for(C = range.s.c; C &lt;= range.e.c; ++C) cols[C] = encode_col(C);&#13;
	for(R = range.s.r; R &lt;= range.e.r; ++R) {&#13;
		r = [];&#13;
		rr = encode_row(R);&#13;
		for(C = range.s.c; C &lt;= range.e.c; ++C) {&#13;
			ref = cols[C] + rr;&#13;
			var _cell = dense ? (ws[R]||[])[C]: ws[ref];&#13;
			if(_cell === undefined) continue;&#13;
			if((cell = write_ws_xml_cell(_cell, ref, ws, opts, idx, wb)) != null) r.push(cell);&#13;
		}&#13;
		if(r.length &gt; 0 || (rows &amp;&amp; rows[R])) {&#13;
			params = ({r:rr});&#13;
			if(rows &amp;&amp; rows[R]) {&#13;
				row = rows[R];&#13;
				if(row.hidden) params.hidden = 1;&#13;
				height = -1;&#13;
				if(row.hpx) height = px2pt(row.hpx);&#13;
				else if(row.hpt) height = row.hpt;&#13;
				if(height &gt; -1) { params.ht = height; params.customHeight = 1; }&#13;
				if(row.level) { params.outlineLevel = row.level; }&#13;
			}&#13;
			o[o.length] = (writextag('row', r.join(""), params));&#13;
		}&#13;
	}&#13;
	if(rows) for(; R &lt; rows.length; ++R) {&#13;
		if(rows &amp;&amp; rows[R]) {&#13;
			params = ({r:R+1});&#13;
			row = rows[R];&#13;
			if(row.hidden) params.hidden = 1;&#13;
			height = -1;&#13;
			if (row.hpx) height = px2pt(row.hpx);&#13;
			else if (row.hpt) height = row.hpt;&#13;
			if (height &gt; -1) { params.ht = height; params.customHeight = 1; }&#13;
			if (row.level) { params.outlineLevel = row.level; }&#13;
			o[o.length] = (writextag('row', "", params));&#13;
		}&#13;
	}&#13;
	return o.join("");&#13;
}&#13;
&#13;
function write_ws_xml(idx, opts, wb, rels) {&#13;
	var o = [XML_HEADER, writextag('worksheet', null, {&#13;
		'xmlns': XMLNS_main[0],&#13;
		'xmlns:r': XMLNS.r&#13;
	})];&#13;
	var s = wb.SheetNames[idx], sidx = 0, rdata = "";&#13;
	var ws = wb.Sheets[s];&#13;
	if(ws == null) ws = {};&#13;
	var ref = ws['!ref'] || 'A1';&#13;
	var range = safe_decode_range(ref);&#13;
	if(range.e.c &gt; 0x3FFF || range.e.r &gt; 0xFFFFF) {&#13;
		if(opts.WTF) throw new Error("Range " + ref + " exceeds format limit A1:XFD1048576");&#13;
		range.e.c = Math.min(range.e.c, 0x3FFF);&#13;
		range.e.r = Math.min(range.e.c, 0xFFFFF);&#13;
		ref = encode_range(range);&#13;
	}&#13;
	if(!rels) rels = {};&#13;
	ws['!comments'] = [];&#13;
	var _drawing = [];&#13;
&#13;
	write_ws_xml_sheetpr(ws, wb, idx, opts, o);&#13;
&#13;
	o[o.length] = (writextag('dimension', null, {'ref': ref}));&#13;
&#13;
	o[o.length] = write_ws_xml_sheetviews(ws, opts, idx, wb);&#13;
&#13;
	/* TODO: store in WB, process styles */&#13;
	if(opts.sheetFormat) o[o.length] = (writextag('sheetFormatPr', null, {&#13;
		defaultRowHeight:opts.sheetFormat.defaultRowHeight||'16',&#13;
		baseColWidth:opts.sheetFormat.baseColWidth||'10',&#13;
		outlineLevelRow:opts.sheetFormat.outlineLevelRow||'7'&#13;
	}));&#13;
&#13;
	if(ws['!cols'] != null &amp;&amp; ws['!cols'].length &gt; 0) o[o.length] = (write_ws_xml_cols(ws, ws['!cols']));&#13;
&#13;
	o[sidx = o.length] = '&lt;sheetData/&gt;';&#13;
	ws['!links'] = [];&#13;
	if(ws['!ref'] != null) {&#13;
		rdata = write_ws_xml_data(ws, opts, idx, wb, rels);&#13;
		if(rdata.length &gt; 0) o[o.length] = (rdata);&#13;
	}&#13;
	if(o.length&gt;sidx+1) { o[o.length] = ('&lt;/sheetData&gt;'); o[sidx]=o[sidx].replace("/&gt;","&gt;"); }&#13;
&#13;
	/* sheetCalcPr */&#13;
&#13;
	if(ws['!protect']) o[o.length] = write_ws_xml_protection(ws['!protect']);&#13;
&#13;
	/* protectedRanges */&#13;
	/* scenarios */&#13;
&#13;
	if(ws['!autofilter'] != null) o[o.length] = write_ws_xml_autofilter(ws['!autofilter'], ws, wb, idx);&#13;
&#13;
	/* sortState */&#13;
	/* dataConsolidate */&#13;
	/* customSheetViews */&#13;
&#13;
	if(ws['!merges'] != null &amp;&amp; ws['!merges'].length &gt; 0) o[o.length] = (write_ws_xml_merges(ws['!merges']));&#13;
&#13;
	/* phoneticPr */&#13;
	/* conditionalFormatting */&#13;
	/* dataValidations */&#13;
&#13;
	var relc = -1, rel, rId = -1;&#13;
	if(ws['!links'].length &gt; 0) {&#13;
		o[o.length] = "&lt;hyperlinks&gt;";&#13;
ws['!links'].forEach(function(l) {&#13;
			if(!l[1].Target) return;&#13;
			rel = ({"ref":l[0]});&#13;
			if(l[1].Target.charAt(0) != "#") {&#13;
				rId = add_rels(rels, -1, escapexml(l[1].Target).replace(/#.*$/, ""), RELS.HLINK);&#13;
				rel["r:id"] = "rId"+rId;&#13;
			}&#13;
			if((relc = l[1].Target.indexOf("#")) &gt; -1) rel.location = escapexml(l[1].Target.slice(relc+1));&#13;
			if(l[1].Tooltip) rel.tooltip = escapexml(l[1].Tooltip);&#13;
			rel.display = l[1].display;&#13;
			o[o.length] = writextag("hyperlink",null,rel);&#13;
		});&#13;
		o[o.length] = "&lt;/hyperlinks&gt;";&#13;
	}&#13;
	delete ws['!links'];&#13;
&#13;
	/* printOptions */&#13;
&#13;
	if(ws['!margins'] != null) o[o.length] =  write_ws_xml_margins(ws['!margins']);&#13;
&#13;
	/* pageSetup */&#13;
	/* headerFooter */&#13;
	/* rowBreaks */&#13;
	/* colBreaks */&#13;
	/* customProperties */&#13;
	/* cellWatches */&#13;
&#13;
	if(!opts || opts.ignoreEC || (opts.ignoreEC == (void 0))) o[o.length] = writetag("ignoredErrors", writextag("ignoredError", null, {numberStoredAsText:1, sqref:ref}));&#13;
&#13;
	/* smartTags */&#13;
&#13;
	if(_drawing.length &gt; 0) {&#13;
		rId = add_rels(rels, -1, "../drawings/drawing" + (idx+1) + ".xml", RELS.DRAW);&#13;
		o[o.length] = writextag("drawing", null, {"r:id":"rId" + rId});&#13;
		ws['!drawing'] = _drawing;&#13;
	}&#13;
&#13;
	if(ws['!comments'].length &gt; 0) {&#13;
		rId = add_rels(rels, -1, "../drawings/vmlDrawing" + (idx+1) + ".vml", RELS.VML);&#13;
		o[o.length] = writextag("legacyDrawing", null, {"r:id":"rId" + rId});&#13;
		ws['!legacy'] = rId;&#13;
	}&#13;
&#13;
	/* legacyDrawingHF */&#13;
	/* picture */&#13;
	/* oleObjects */&#13;
	/* controls */&#13;
	/* webPublishItems */&#13;
	/* tableParts */&#13;
	/* extLst */&#13;
&#13;
	if(o.length&gt;1) { o[o.length] = ('&lt;/worksheet&gt;'); o[1]=o[1].replace("/&gt;","&gt;"); }&#13;
	return o.join("");&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.4.726 BrtRowHdr */&#13;
function parse_BrtRowHdr(data, length) {&#13;
	var z = ({});&#13;
	var tgt = data.l + length;&#13;
	z.r = data.read_shift(4);&#13;
	data.l += 4; // TODO: ixfe&#13;
	var miyRw = data.read_shift(2);&#13;
	data.l += 1; // TODO: top/bot padding&#13;
	var flags = data.read_shift(1);&#13;
	data.l = tgt;&#13;
	if(flags &amp; 0x07) z.level = flags &amp; 0x07;&#13;
	if(flags &amp; 0x10) z.hidden = true;&#13;
	if(flags &amp; 0x20) z.hpt = miyRw / 20;&#13;
	return z;&#13;
}&#13;
function write_BrtRowHdr(R, range, ws) {&#13;
	var o = new_buf(17+8*16);&#13;
	var row = (ws['!rows']||[])[R]||{};&#13;
	o.write_shift(4, R);&#13;
&#13;
	o.write_shift(4, 0); /* TODO: ixfe */&#13;
&#13;
	var miyRw = 0x0140;&#13;
	if(row.hpx) miyRw = px2pt(row.hpx) * 20;&#13;
	else if(row.hpt) miyRw = row.hpt * 20;&#13;
	o.write_shift(2, miyRw);&#13;
&#13;
	o.write_shift(1, 0); /* top/bot padding */&#13;
&#13;
	var flags = 0x0;&#13;
	if(row.level) flags |= row.level;&#13;
	if(row.hidden) flags |= 0x10;&#13;
	if(row.hpx || row.hpt) flags |= 0x20;&#13;
	o.write_shift(1, flags);&#13;
&#13;
	o.write_shift(1, 0); /* phonetic guide */&#13;
&#13;
	/* [MS-XLSB] 2.5.8 BrtColSpan explains the mechanism */&#13;
	var ncolspan = 0, lcs = o.l;&#13;
	o.l += 4;&#13;
&#13;
	var caddr = {r:R, c:0};&#13;
	for(var i = 0; i &lt; 16; ++i) {&#13;
		if((range.s.c &gt; ((i+1) &lt;&lt; 10)) || (range.e.c &lt; (i &lt;&lt; 10))) continue;&#13;
		var first = -1, last = -1;&#13;
		for(var j = (i&lt;&lt;10); j &lt; ((i+1)&lt;&lt;10); ++j) {&#13;
			caddr.c = j;&#13;
			var cell = Array.isArray(ws) ? (ws[caddr.r]||[])[caddr.c] : ws[encode_cell(caddr)];&#13;
			if(cell) { if(first &lt; 0) first = j; last = j; }&#13;
		}&#13;
		if(first &lt; 0) continue;&#13;
		++ncolspan;&#13;
		o.write_shift(4, first);&#13;
		o.write_shift(4, last);&#13;
	}&#13;
&#13;
	var l = o.l;&#13;
	o.l = lcs;&#13;
	o.write_shift(4, ncolspan);&#13;
	o.l = l;&#13;
&#13;
	return o.length &gt; o.l ? o.slice(0, o.l) : o;&#13;
}&#13;
function write_row_header(ba, ws, range, R) {&#13;
	var o = write_BrtRowHdr(R, range, ws);&#13;
	if((o.length &gt; 17) || (ws['!rows']||[])[R]) write_record(ba, 0x0000 /* BrtRowHdr */, o);&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.4.820 BrtWsDim */&#13;
var parse_BrtWsDim = parse_UncheckedRfX;&#13;
var write_BrtWsDim = write_UncheckedRfX;&#13;
&#13;
/* [MS-XLSB] 2.4.821 BrtWsFmtInfo */&#13;
function parse_BrtWsFmtInfo() {&#13;
}&#13;
//function write_BrtWsFmtInfo(ws, o) { }&#13;
&#13;
/* [MS-XLSB] 2.4.823 BrtWsProp */&#13;
function parse_BrtWsProp(data, length) {&#13;
	var z = {};&#13;
	var f = data[data.l]; ++data.l;&#13;
	z.above = !(f &amp; 0x40);&#13;
	z.left  = !(f &amp; 0x80);&#13;
	/* TODO: pull flags */&#13;
	data.l += 18;&#13;
	z.name = parse_XLSBCodeName(data, length - 19);&#13;
	return z;&#13;
}&#13;
function write_BrtWsProp(str, outl, o) {&#13;
	if(o == null) o = new_buf(84+4*str.length);&#13;
	var f = 0xC0;&#13;
	if(outl) {&#13;
		if(outl.above) f &amp;= ~0x40;&#13;
		if(outl.left)  f &amp;= ~0x80;&#13;
	}&#13;
	o.write_shift(1, f);&#13;
	for(var i = 1; i &lt; 3; ++i) o.write_shift(1,0);&#13;
	write_BrtColor({auto:1}, o);&#13;
	o.write_shift(-4,-1);&#13;
	o.write_shift(-4,-1);&#13;
	write_XLSBCodeName(str, o);&#13;
	return o.slice(0, o.l);&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.4.306 BrtCellBlank */&#13;
function parse_BrtCellBlank(data) {&#13;
	var cell = parse_XLSBCell(data);&#13;
	return [cell];&#13;
}&#13;
function write_BrtCellBlank(cell, ncell, o) {&#13;
	if(o == null) o = new_buf(8);&#13;
	return write_XLSBCell(ncell, o);&#13;
}&#13;
function parse_BrtShortBlank(data) {&#13;
	var cell = parse_XLSBShortCell(data);&#13;
	return [cell];&#13;
}&#13;
function write_BrtShortBlank(cell, ncell, o) {&#13;
	if(o == null) o = new_buf(4);&#13;
	return write_XLSBShortCell(ncell, o);&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.4.307 BrtCellBool */&#13;
function parse_BrtCellBool(data) {&#13;
	var cell = parse_XLSBCell(data);&#13;
	var fBool = data.read_shift(1);&#13;
	return [cell, fBool, 'b'];&#13;
}&#13;
function write_BrtCellBool(cell, ncell, o) {&#13;
	if(o == null) o = new_buf(9);&#13;
	write_XLSBCell(ncell, o);&#13;
	o.write_shift(1, cell.v ? 1 : 0);&#13;
	return o;&#13;
}&#13;
function parse_BrtShortBool(data) {&#13;
	var cell = parse_XLSBShortCell(data);&#13;
	var fBool = data.read_shift(1);&#13;
	return [cell, fBool, 'b'];&#13;
}&#13;
function write_BrtShortBool(cell, ncell, o) {&#13;
	if(o == null) o = new_buf(5);&#13;
	write_XLSBShortCell(ncell, o);&#13;
	o.write_shift(1, cell.v ? 1 : 0);&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.4.308 BrtCellError */&#13;
function parse_BrtCellError(data) {&#13;
	var cell = parse_XLSBCell(data);&#13;
	var bError = data.read_shift(1);&#13;
	return [cell, bError, 'e'];&#13;
}&#13;
function write_BrtCellError(cell, ncell, o) {&#13;
	if(o == null) o = new_buf(9);&#13;
	write_XLSBCell(ncell, o);&#13;
	o.write_shift(1, cell.v);&#13;
	return o;&#13;
}&#13;
function parse_BrtShortError(data) {&#13;
	var cell = parse_XLSBShortCell(data);&#13;
	var bError = data.read_shift(1);&#13;
	return [cell, bError, 'e'];&#13;
}&#13;
function write_BrtShortError(cell, ncell, o) {&#13;
	if(o == null) o = new_buf(8);&#13;
	write_XLSBShortCell(ncell, o);&#13;
	o.write_shift(1, cell.v);&#13;
	o.write_shift(2, 0);&#13;
	o.write_shift(1, 0);&#13;
	return o;&#13;
}&#13;
&#13;
&#13;
/* [MS-XLSB] 2.4.311 BrtCellIsst */&#13;
function parse_BrtCellIsst(data) {&#13;
	var cell = parse_XLSBCell(data);&#13;
	var isst = data.read_shift(4);&#13;
	return [cell, isst, 's'];&#13;
}&#13;
function write_BrtCellIsst(cell, ncell, o) {&#13;
	if(o == null) o = new_buf(12);&#13;
	write_XLSBCell(ncell, o);&#13;
	o.write_shift(4, ncell.v);&#13;
	return o;&#13;
}&#13;
function parse_BrtShortIsst(data) {&#13;
	var cell = parse_XLSBShortCell(data);&#13;
	var isst = data.read_shift(4);&#13;
	return [cell, isst, 's'];&#13;
}&#13;
function write_BrtShortIsst(cell, ncell, o) {&#13;
	if(o == null) o = new_buf(8);&#13;
	write_XLSBShortCell(ncell, o);&#13;
	o.write_shift(4, ncell.v);&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.4.313 BrtCellReal */&#13;
function parse_BrtCellReal(data) {&#13;
	var cell = parse_XLSBCell(data);&#13;
	var value = parse_Xnum(data);&#13;
	return [cell, value, 'n'];&#13;
}&#13;
function write_BrtCellReal(cell, ncell, o) {&#13;
	if(o == null) o = new_buf(16);&#13;
	write_XLSBCell(ncell, o);&#13;
	write_Xnum(cell.v, o);&#13;
	return o;&#13;
}&#13;
function parse_BrtShortReal(data) {&#13;
	var cell = parse_XLSBShortCell(data);&#13;
	var value = parse_Xnum(data);&#13;
	return [cell, value, 'n'];&#13;
}&#13;
function write_BrtShortReal(cell, ncell, o) {&#13;
	if(o == null) o = new_buf(12);&#13;
	write_XLSBShortCell(ncell, o);&#13;
	write_Xnum(cell.v, o);&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.4.314 BrtCellRk */&#13;
function parse_BrtCellRk(data) {&#13;
	var cell = parse_XLSBCell(data);&#13;
	var value = parse_RkNumber(data);&#13;
	return [cell, value, 'n'];&#13;
}&#13;
function write_BrtCellRk(cell, ncell, o) {&#13;
	if(o == null) o = new_buf(12);&#13;
	write_XLSBCell(ncell, o);&#13;
	write_RkNumber(cell.v, o);&#13;
	return o;&#13;
}&#13;
function parse_BrtShortRk(data) {&#13;
	var cell = parse_XLSBShortCell(data);&#13;
	var value = parse_RkNumber(data);&#13;
	return [cell, value, 'n'];&#13;
}&#13;
function write_BrtShortRk(cell, ncell, o) {&#13;
	if(o == null) o = new_buf(8);&#13;
	write_XLSBShortCell(ncell, o);&#13;
	write_RkNumber(cell.v, o);&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.4.323 BrtCellRString */&#13;
function parse_BrtCellRString(data) {&#13;
	var cell = parse_XLSBCell(data);&#13;
	var value = parse_RichStr(data);&#13;
	return [cell, value, 'is'];&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.4.317 BrtCellSt */&#13;
function parse_BrtCellSt(data) {&#13;
	var cell = parse_XLSBCell(data);&#13;
	var value = parse_XLWideString(data);&#13;
	return [cell, value, 'str'];&#13;
}&#13;
function write_BrtCellSt(cell, ncell, o) {&#13;
	var data = cell.v == null ? "" : String(cell.v);&#13;
	if(o == null) o = new_buf(12 + 4 * cell.v.length);&#13;
	write_XLSBCell(ncell, o);&#13;
	write_XLWideString(data, o);&#13;
	return o.length &gt; o.l ? o.slice(0, o.l) : o;&#13;
}&#13;
function parse_BrtShortSt(data) {&#13;
	var cell = parse_XLSBShortCell(data);&#13;
	var value = parse_XLWideString(data);&#13;
	return [cell, value, 'str'];&#13;
}&#13;
function write_BrtShortSt(cell, ncell, o) {&#13;
	var data = cell.v == null ? "" : String(cell.v);&#13;
	if(o == null) o = new_buf(8 + 4 * data.length);&#13;
	write_XLSBShortCell(ncell, o);&#13;
	write_XLWideString(data, o);&#13;
	return o.length &gt; o.l ? o.slice(0, o.l) : o;&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.4.653 BrtFmlaBool */&#13;
function parse_BrtFmlaBool(data, length, opts) {&#13;
	var end = data.l + length;&#13;
	var cell = parse_XLSBCell(data);&#13;
	cell.r = opts['!row'];&#13;
	var value = data.read_shift(1);&#13;
	var o = [cell, value, 'b'];&#13;
	if(opts.cellFormula) {&#13;
		data.l += 2;&#13;
		var formula = parse_XLSBCellParsedFormula(data, end - data.l, opts);&#13;
		o[3] = stringify_formula(formula, null/*range*/, cell, opts.supbooks, opts);/* TODO */&#13;
	}&#13;
	else data.l = end;&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.4.654 BrtFmlaError */&#13;
function parse_BrtFmlaError(data, length, opts) {&#13;
	var end = data.l + length;&#13;
	var cell = parse_XLSBCell(data);&#13;
	cell.r = opts['!row'];&#13;
	var value = data.read_shift(1);&#13;
	var o = [cell, value, 'e'];&#13;
	if(opts.cellFormula) {&#13;
		data.l += 2;&#13;
		var formula = parse_XLSBCellParsedFormula(data, end - data.l, opts);&#13;
		o[3] = stringify_formula(formula, null/*range*/, cell, opts.supbooks, opts);/* TODO */&#13;
	}&#13;
	else data.l = end;&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.4.655 BrtFmlaNum */&#13;
function parse_BrtFmlaNum(data, length, opts) {&#13;
	var end = data.l + length;&#13;
	var cell = parse_XLSBCell(data);&#13;
	cell.r = opts['!row'];&#13;
	var value = parse_Xnum(data);&#13;
	var o = [cell, value, 'n'];&#13;
	if(opts.cellFormula) {&#13;
		data.l += 2;&#13;
		var formula = parse_XLSBCellParsedFormula(data, end - data.l, opts);&#13;
		o[3] = stringify_formula(formula, null/*range*/, cell, opts.supbooks, opts);/* TODO */&#13;
	}&#13;
	else data.l = end;&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.4.656 BrtFmlaString */&#13;
function parse_BrtFmlaString(data, length, opts) {&#13;
	var end = data.l + length;&#13;
	var cell = parse_XLSBCell(data);&#13;
	cell.r = opts['!row'];&#13;
	var value = parse_XLWideString(data);&#13;
	var o = [cell, value, 'str'];&#13;
	if(opts.cellFormula) {&#13;
		data.l += 2;&#13;
		var formula = parse_XLSBCellParsedFormula(data, end - data.l, opts);&#13;
		o[3] = stringify_formula(formula, null/*range*/, cell, opts.supbooks, opts);/* TODO */&#13;
	}&#13;
	else data.l = end;&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.4.682 BrtMergeCell */&#13;
var parse_BrtMergeCell = parse_UncheckedRfX;&#13;
var write_BrtMergeCell = write_UncheckedRfX;&#13;
/* [MS-XLSB] 2.4.107 BrtBeginMergeCells */&#13;
function write_BrtBeginMergeCells(cnt, o) {&#13;
	if(o == null) o = new_buf(4);&#13;
	o.write_shift(4, cnt);&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.4.662 BrtHLink */&#13;
function parse_BrtHLink(data, length) {&#13;
	var end = data.l + length;&#13;
	var rfx = parse_UncheckedRfX(data, 16);&#13;
	var relId = parse_XLNullableWideString(data);&#13;
	var loc = parse_XLWideString(data);&#13;
	var tooltip = parse_XLWideString(data);&#13;
	var display = parse_XLWideString(data);&#13;
	data.l = end;&#13;
	var o = ({rfx:rfx, relId:relId, loc:loc, display:display});&#13;
	if(tooltip) o.Tooltip = tooltip;&#13;
	return o;&#13;
}&#13;
function write_BrtHLink(l, rId) {&#13;
	var o = new_buf(50+4*(l[1].Target.length + (l[1].Tooltip || "").length));&#13;
	write_UncheckedRfX({s:decode_cell(l[0]), e:decode_cell(l[0])}, o);&#13;
	write_RelID("rId" + rId, o);&#13;
	var locidx = l[1].Target.indexOf("#");&#13;
	var loc = locidx == -1 ? "" : l[1].Target.slice(locidx+1);&#13;
	write_XLWideString(loc || "", o);&#13;
	write_XLWideString(l[1].Tooltip || "", o);&#13;
	write_XLWideString("", o);&#13;
	return o.slice(0, o.l);&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.4.692 BrtPane */&#13;
function parse_BrtPane(/*data, length, opts*/) {&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.4.6 BrtArrFmla */&#13;
function parse_BrtArrFmla(data, length, opts) {&#13;
	var end = data.l + length;&#13;
	var rfx = parse_RfX(data, 16);&#13;
	var fAlwaysCalc = data.read_shift(1);&#13;
	var o = [rfx]; o[2] = fAlwaysCalc;&#13;
	if(opts.cellFormula) {&#13;
		var formula = parse_XLSBArrayParsedFormula(data, end - data.l, opts);&#13;
		o[1] = formula;&#13;
	} else data.l = end;&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.4.750 BrtShrFmla */&#13;
function parse_BrtShrFmla(data, length, opts) {&#13;
	var end = data.l + length;&#13;
	var rfx = parse_UncheckedRfX(data, 16);&#13;
	var o = [rfx];&#13;
	if(opts.cellFormula) {&#13;
		var formula = parse_XLSBSharedParsedFormula(data, end - data.l, opts);&#13;
		o[1] = formula;&#13;
		data.l = end;&#13;
	} else data.l = end;&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.4.323 BrtColInfo */&#13;
/* TODO: once XLS ColInfo is set, combine the functions */&#13;
function write_BrtColInfo(C, col, o) {&#13;
	if(o == null) o = new_buf(18);&#13;
	var p = col_obj_w(C, col);&#13;
	o.write_shift(-4, C);&#13;
	o.write_shift(-4, C);&#13;
	o.write_shift(4, (p.width || 10) * 256);&#13;
	o.write_shift(4, 0/*ixfe*/); // style&#13;
	var flags = 0;&#13;
	if(col.hidden) flags |= 0x01;&#13;
	if(typeof p.width == 'number') flags |= 0x02;&#13;
	if(col.level) flags |= (col.level &lt;&lt; 8);&#13;
	o.write_shift(2, flags); // bit flag&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.4.678 BrtMargins */&#13;
var BrtMarginKeys = ["left","right","top","bottom","header","footer"];&#13;
function parse_BrtMargins(data) {&#13;
	var margins = ({});&#13;
	BrtMarginKeys.forEach(function(k) { margins[k] = parse_Xnum(data, 8); });&#13;
	return margins;&#13;
}&#13;
function write_BrtMargins(margins, o) {&#13;
	if(o == null) o = new_buf(6*8);&#13;
	default_margins(margins);&#13;
	BrtMarginKeys.forEach(function(k) { write_Xnum((margins)[k], o); });&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.4.299 BrtBeginWsView */&#13;
function parse_BrtBeginWsView(data) {&#13;
	var f = data.read_shift(2);&#13;
	data.l += 28;&#13;
	return { RTL: f &amp; 0x20 };&#13;
}&#13;
function write_BrtBeginWsView(ws, Workbook, o) {&#13;
	if(o == null) o = new_buf(30);&#13;
	var f = 0x39c;&#13;
	if((((Workbook||{}).Views||[])[0]||{}).RTL) f |= 0x20;&#13;
	o.write_shift(2, f); // bit flag&#13;
	o.write_shift(4, 0);&#13;
	o.write_shift(4, 0); // view first row&#13;
	o.write_shift(4, 0); // view first col&#13;
	o.write_shift(1, 0); // gridline color ICV&#13;
	o.write_shift(1, 0);&#13;
	o.write_shift(2, 0);&#13;
	o.write_shift(2, 100); // zoom scale&#13;
	o.write_shift(2, 0);&#13;
	o.write_shift(2, 0);&#13;
	o.write_shift(2, 0);&#13;
	o.write_shift(4, 0); // workbook view id&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.4.309 BrtCellIgnoreEC */&#13;
function write_BrtCellIgnoreEC(ref) {&#13;
	var o = new_buf(24);&#13;
	o.write_shift(4, 4);&#13;
	o.write_shift(4, 1);&#13;
	write_UncheckedRfX(ref, o);&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.4.748 BrtSheetProtection */&#13;
function write_BrtSheetProtection(sp, o) {&#13;
	if(o == null) o = new_buf(16*4+2);&#13;
	o.write_shift(2, sp.password ? crypto_CreatePasswordVerifier_Method1(sp.password) : 0);&#13;
	o.write_shift(4, 1); // this record should not be written if no protection&#13;
	[&#13;
		["objects",             false], // fObjects&#13;
		["scenarios",           false], // fScenarios&#13;
		["formatCells",          true], // fFormatCells&#13;
		["formatColumns",        true], // fFormatColumns&#13;
		["formatRows",           true], // fFormatRows&#13;
		["insertColumns",        true], // fInsertColumns&#13;
		["insertRows",           true], // fInsertRows&#13;
		["insertHyperlinks",     true], // fInsertHyperlinks&#13;
		["deleteColumns",        true], // fDeleteColumns&#13;
		["deleteRows",           true], // fDeleteRows&#13;
		["selectLockedCells",   false], // fSelLockedCells&#13;
		["sort",                 true], // fSort&#13;
		["autoFilter",           true], // fAutoFilter&#13;
		["pivotTables",          true], // fPivotTables&#13;
		["selectUnlockedCells", false]  // fSelUnlockedCells&#13;
	].forEach(function(n) {&#13;
if(n[1]) o.write_shift(4, sp[n[0]] != null &amp;&amp; !sp[n[0]] ? 1 : 0);&#13;
		else      o.write_shift(4, sp[n[0]] != null &amp;&amp; sp[n[0]] ? 0 : 1);&#13;
	});&#13;
	return o;&#13;
}&#13;
&#13;
function parse_BrtDVal(/*data, length, opts*/) {&#13;
}&#13;
function parse_BrtDVal14(/*data, length, opts*/) {&#13;
}&#13;
/* [MS-XLSB] 2.1.7.61 Worksheet */&#13;
function parse_ws_bin(data, _opts, idx, rels, wb, themes, styles) {&#13;
	if(!data) return data;&#13;
	var opts = _opts || {};&#13;
	if(!rels) rels = {'!id':{}};&#13;
	if(DENSE != null &amp;&amp; opts.dense == null) opts.dense = DENSE;&#13;
	var s = (opts.dense ? [] : {});&#13;
&#13;
	var ref;&#13;
	var refguess = {s: {r:2000000, c:2000000}, e: {r:0, c:0} };&#13;
&#13;
	var state = [];&#13;
	var pass = false, end = false;&#13;
	var row, p, cf, R, C, addr, sstr, rr, cell;&#13;
	var merges = [];&#13;
	opts.biff = 12;&#13;
	opts['!row'] = 0;&#13;
&#13;
	var ai = 0, af = false;&#13;
&#13;
	var arrayf = [];&#13;
	var sharedf = {};&#13;
	var supbooks = opts.supbooks || wb.supbooks || ([[]]);&#13;
	supbooks.sharedf = sharedf;&#13;
	supbooks.arrayf = arrayf;&#13;
	supbooks.SheetNames = wb.SheetNames || wb.Sheets.map(function(x) { return x.name; });&#13;
	if(!opts.supbooks) {&#13;
		opts.supbooks = supbooks;&#13;
		if(wb.Names) for(var i = 0; i &lt; wb.Names.length; ++i) supbooks[0][i+1] = wb.Names[i];&#13;
	}&#13;
&#13;
	var colinfo = [], rowinfo = [];&#13;
	var seencol = false;&#13;
&#13;
	XLSBRecordEnum[0x0010] = { n:"BrtShortReal", f:parse_BrtShortReal };&#13;
&#13;
	var cm, vm;&#13;
&#13;
	recordhopper(data, function ws_parse(val, RR, RT) {&#13;
		if(end) return;&#13;
		switch(RT) {&#13;
			case 0x0094: /* 'BrtWsDim' */&#13;
				ref = val; break;&#13;
			case 0x0000: /* 'BrtRowHdr' */&#13;
				row = val;&#13;
				if(opts.sheetRows &amp;&amp; opts.sheetRows &lt;= row.r) end=true;&#13;
				rr = encode_row(R = row.r);&#13;
				opts['!row'] = row.r;&#13;
				if(val.hidden || val.hpt || val.level != null) {&#13;
					if(val.hpt) val.hpx = pt2px(val.hpt);&#13;
					rowinfo[val.r] = val;&#13;
				}&#13;
				break;&#13;
&#13;
			case 0x0002: /* 'BrtCellRk' */&#13;
			case 0x0003: /* 'BrtCellError' */&#13;
			case 0x0004: /* 'BrtCellBool' */&#13;
			case 0x0005: /* 'BrtCellReal' */&#13;
			case 0x0006: /* 'BrtCellSt' */&#13;
			case 0x0007: /* 'BrtCellIsst' */&#13;
			case 0x0008: /* 'BrtFmlaString' */&#13;
			case 0x0009: /* 'BrtFmlaNum' */&#13;
			case 0x000A: /* 'BrtFmlaBool' */&#13;
			case 0x000B: /* 'BrtFmlaError' */&#13;
			case 0x000D: /* 'BrtShortRk' */&#13;
			case 0x000E: /* 'BrtShortError' */&#13;
			case 0x000F: /* 'BrtShortBool' */&#13;
			case 0x0010: /* 'BrtShortReal' */&#13;
			case 0x0011: /* 'BrtShortSt' */&#13;
			case 0x0012: /* 'BrtShortIsst' */&#13;
			case 0x003E: /* 'BrtCellRString' */&#13;
				p = ({t:val[2]});&#13;
				switch(val[2]) {&#13;
					case 'n': p.v = val[1]; break;&#13;
					case 's': sstr = strs[val[1]]; p.v = sstr.t; p.r = sstr.r; break;&#13;
					case 'b': p.v = val[1] ? true : false; break;&#13;
					case 'e': p.v = val[1]; if(opts.cellText !== false) p.w = BErr[p.v]; break;&#13;
					case 'str': p.t = 's'; p.v = val[1]; break;&#13;
					case 'is': p.t = 's'; p.v = val[1].t; break;&#13;
				}&#13;
				if((cf = styles.CellXf[val[0].iStyleRef])) safe_format(p,cf.numFmtId,null,opts, themes, styles);&#13;
				C = val[0].c == -1 ? C + 1 : val[0].c;&#13;
				if(opts.dense) { if(!s[R]) s[R] = []; s[R][C] = p; }&#13;
				else s[encode_col(C) + rr] = p;&#13;
				if(opts.cellFormula) {&#13;
					af = false;&#13;
					for(ai = 0; ai &lt; arrayf.length; ++ai) {&#13;
						var aii = arrayf[ai];&#13;
						if(row.r &gt;= aii[0].s.r &amp;&amp; row.r &lt;= aii[0].e.r)&#13;
							if(C &gt;= aii[0].s.c &amp;&amp; C &lt;= aii[0].e.c) {&#13;
								p.F = encode_range(aii[0]); af = true;&#13;
							}&#13;
					}&#13;
					if(!af &amp;&amp; val.length &gt; 3) p.f = val[3];&#13;
				}&#13;
&#13;
				if(refguess.s.r &gt; row.r) refguess.s.r = row.r;&#13;
				if(refguess.s.c &gt; C) refguess.s.c = C;&#13;
				if(refguess.e.r &lt; row.r) refguess.e.r = row.r;&#13;
				if(refguess.e.c &lt; C) refguess.e.c = C;&#13;
				if(opts.cellDates &amp;&amp; cf &amp;&amp; p.t == 'n' &amp;&amp; fmt_is_date(table_fmt[cf.numFmtId])) {&#13;
					var _d = SSF_parse_date_code(p.v); if(_d) { p.t = 'd'; p.v = new Date(_d.y, _d.m-1,_d.d,_d.H,_d.M,_d.S,_d.u); }&#13;
				}&#13;
				if(cm) {&#13;
					if(cm.type == 'XLDAPR') p.D = true;&#13;
					cm = void 0;&#13;
				}&#13;
				if(vm) vm = void 0;&#13;
				break;&#13;
&#13;
			case 0x0001: /* 'BrtCellBlank' */&#13;
			case 0x000C: /* 'BrtShortBlank' */&#13;
				if(!opts.sheetStubs || pass) break;&#13;
				p = ({t:'z',v:void 0});&#13;
				C = val[0].c == -1 ? C + 1 : val[0].c;&#13;
				if(opts.dense) { if(!s[R]) s[R] = []; s[R][C] = p; }&#13;
				else s[encode_col(C) + rr] = p;&#13;
				if(refguess.s.r &gt; row.r) refguess.s.r = row.r;&#13;
				if(refguess.s.c &gt; C) refguess.s.c = C;&#13;
				if(refguess.e.r &lt; row.r) refguess.e.r = row.r;&#13;
				if(refguess.e.c &lt; C) refguess.e.c = C;&#13;
				if(cm) {&#13;
					if(cm.type == 'XLDAPR') p.D = true;&#13;
					cm = void 0;&#13;
				}&#13;
				if(vm) vm = void 0;&#13;
				break;&#13;
&#13;
			case 0x00B0: /* 'BrtMergeCell' */&#13;
				merges.push(val); break;&#13;
&#13;
			case 0x0031: { /* 'BrtCellMeta' */&#13;
				cm = ((opts.xlmeta||{}).Cell||[])[val-1];&#13;
			} break;&#13;
&#13;
			case 0x01EE: /* 'BrtHLink' */&#13;
				var rel = rels['!id'][val.relId];&#13;
				if(rel) {&#13;
					val.Target = rel.Target;&#13;
					if(val.loc) val.Target += "#"+val.loc;&#13;
					val.Rel = rel;&#13;
				} else if(val.relId == '') {&#13;
					val.Target = "#" + val.loc;&#13;
				}&#13;
				for(R=val.rfx.s.r;R&lt;=val.rfx.e.r;++R) for(C=val.rfx.s.c;C&lt;=val.rfx.e.c;++C) {&#13;
					if(opts.dense) {&#13;
						if(!s[R]) s[R] = [];&#13;
						if(!s[R][C]) s[R][C] = {t:'z',v:undefined};&#13;
						s[R][C].l = val;&#13;
					} else {&#13;
						addr = encode_cell({c:C,r:R});&#13;
						if(!s[addr]) s[addr] = {t:'z',v:undefined};&#13;
						s[addr].l = val;&#13;
					}&#13;
				}&#13;
				break;&#13;
&#13;
			case 0x01AA: /* 'BrtArrFmla' */&#13;
				if(!opts.cellFormula) break;&#13;
				arrayf.push(val);&#13;
				cell = ((opts.dense ? s[R][C] : s[encode_col(C) + rr]));&#13;
				cell.f = stringify_formula(val[1], refguess, {r:row.r, c:C}, supbooks, opts);&#13;
				cell.F = encode_range(val[0]);&#13;
				break;&#13;
			case 0x01AB: /* 'BrtShrFmla' */&#13;
				if(!opts.cellFormula) break;&#13;
				sharedf[encode_cell(val[0].s)] = val[1];&#13;
				cell = (opts.dense ? s[R][C] : s[encode_col(C) + rr]);&#13;
				cell.f = stringify_formula(val[1], refguess, {r:row.r, c:C}, supbooks, opts);&#13;
				break;&#13;
&#13;
			/* identical to 'ColInfo' in XLS */&#13;
			case 0x003C: /* 'BrtColInfo' */&#13;
				if(!opts.cellStyles) break;&#13;
				while(val.e &gt;= val.s) {&#13;
					colinfo[val.e--] = { width: val.w/256, hidden: !!(val.flags &amp; 0x01), level: val.level };&#13;
					if(!seencol) { seencol = true; find_mdw_colw(val.w/256); }&#13;
					process_col(colinfo[val.e+1]);&#13;
				}&#13;
				break;&#13;
&#13;
			case 0x00A1: /* 'BrtBeginAFilter' */&#13;
				s['!autofilter'] = { ref:encode_range(val) };&#13;
				break;&#13;
&#13;
			case 0x01DC: /* 'BrtMargins' */&#13;
				s['!margins'] = val;&#13;
				break;&#13;
&#13;
			case 0x0093: /* 'BrtWsProp' */&#13;
				if(!wb.Sheets[idx]) wb.Sheets[idx] = {};&#13;
				if(val.name) wb.Sheets[idx].CodeName = val.name;&#13;
				if(val.above || val.left) s['!outline'] = { above: val.above, left: val.left };&#13;
				break;&#13;
&#13;
			case 0x0089: /* 'BrtBeginWsView' */&#13;
				if(!wb.Views) wb.Views = [{}];&#13;
				if(!wb.Views[0]) wb.Views[0] = {};&#13;
				if(val.RTL) wb.Views[0].RTL = true;&#13;
				break;&#13;
&#13;
			case 0x01E5: /* 'BrtWsFmtInfo' */&#13;
				break;&#13;
&#13;
			case 0x0040: /* 'BrtDVal' */&#13;
			case 0x041D: /* 'BrtDVal14' */&#13;
				break;&#13;
&#13;
			case 0x0097: /* 'BrtPane' */&#13;
				break;&#13;
			case 0x0098: /* 'BrtSel' */&#13;
			case 0x00AF: /* 'BrtAFilterDateGroupItem' */&#13;
			case 0x0284: /* 'BrtActiveX' */&#13;
			case 0x0271: /* 'BrtBigName' */&#13;
			case 0x0232: /* 'BrtBkHim' */&#13;
			case 0x018C: /* 'BrtBrk' */&#13;
			case 0x0458: /* 'BrtCFIcon' */&#13;
			case 0x047A: /* 'BrtCFRuleExt' */&#13;
			case 0x01D7: /* 'BrtCFVO' */&#13;
			case 0x041A: /* 'BrtCFVO14' */&#13;
			case 0x0289: /* 'BrtCellIgnoreEC' */&#13;
			case 0x0451: /* 'BrtCellIgnoreEC14' */&#13;
			case 0x024D: /* 'BrtCellSmartTagProperty' */&#13;
			case 0x025F: /* 'BrtCellWatch' */&#13;
			case 0x0234: /* 'BrtColor' */&#13;
			case 0x041F: /* 'BrtColor14' */&#13;
			case 0x00A8: /* 'BrtColorFilter' */&#13;
			case 0x00AE: /* 'BrtCustomFilter' */&#13;
			case 0x049C: /* 'BrtCustomFilter14' */&#13;
			case 0x01F3: /* 'BrtDRef' */&#13;
			case 0x01FB: /* 'BrtDXF' */&#13;
			case 0x0226: /* 'BrtDrawing' */&#13;
			case 0x00AB: /* 'BrtDynamicFilter' */&#13;
			case 0x00A7: /* 'BrtFilter' */&#13;
			case 0x0499: /* 'BrtFilter14' */&#13;
			case 0x00A9: /* 'BrtIconFilter' */&#13;
			case 0x049D: /* 'BrtIconFilter14' */&#13;
			case 0x0227: /* 'BrtLegacyDrawing' */&#13;
			case 0x0228: /* 'BrtLegacyDrawingHF' */&#13;
			case 0x0295: /* 'BrtListPart' */&#13;
			case 0x027F: /* 'BrtOleObject' */&#13;
			case 0x01DE: /* 'BrtPageSetup' */&#13;
			case 0x0219: /* 'BrtPhoneticInfo' */&#13;
			case 0x01DD: /* 'BrtPrintOptions' */&#13;
			case 0x0218: /* 'BrtRangeProtection' */&#13;
			case 0x044F: /* 'BrtRangeProtection14' */&#13;
			case 0x02A8: /* 'BrtRangeProtectionIso' */&#13;
			case 0x0450: /* 'BrtRangeProtectionIso14' */&#13;
			case 0x0400: /* 'BrtRwDescent' */&#13;
			case 0x0297: /* 'BrtSheetCalcProp' */&#13;
			case 0x0217: /* 'BrtSheetProtection' */&#13;
			case 0x02A6: /* 'BrtSheetProtectionIso' */&#13;
			case 0x01F8: /* 'BrtSlc' */&#13;
			case 0x0413: /* 'BrtSparkline' */&#13;
			case 0x01AC: /* 'BrtTable' */&#13;
			case 0x00AA: /* 'BrtTop10Filter' */&#13;
			case 0x0C00: /* 'BrtUid' */&#13;
			case 0x0032: /* 'BrtValueMeta' */&#13;
			case 0x0816: /* 'BrtWebExtension' */&#13;
			case 0x0415: /* 'BrtWsFmtInfoEx14' */&#13;
				break;&#13;
&#13;
			case 0x0023: /* 'BrtFRTBegin' */&#13;
				pass = true; break;&#13;
			case 0x0024: /* 'BrtFRTEnd' */&#13;
				pass = false; break;&#13;
			case 0x0025: /* 'BrtACBegin' */&#13;
				state.push(RT); pass = true; break;&#13;
			case 0x0026: /* 'BrtACEnd' */&#13;
				state.pop(); pass = false; break;&#13;
&#13;
			default:&#13;
				if(RR.T){/* empty */}&#13;
				else if(!pass || opts.WTF) throw new Error("Unexpected record 0x" + RT.toString(16));&#13;
		}&#13;
	}, opts);&#13;
&#13;
	delete opts.supbooks;&#13;
	delete opts['!row'];&#13;
&#13;
	if(!s["!ref"] &amp;&amp; (refguess.s.r &lt; 2000000 || ref &amp;&amp; (ref.e.r &gt; 0 || ref.e.c &gt; 0 || ref.s.r &gt; 0 || ref.s.c &gt; 0))) s["!ref"] = encode_range(ref || refguess);&#13;
	if(opts.sheetRows &amp;&amp; s["!ref"]) {&#13;
		var tmpref = safe_decode_range(s["!ref"]);&#13;
		if(opts.sheetRows &lt;= +tmpref.e.r) {&#13;
			tmpref.e.r = opts.sheetRows - 1;&#13;
			if(tmpref.e.r &gt; refguess.e.r) tmpref.e.r = refguess.e.r;&#13;
			if(tmpref.e.r &lt; tmpref.s.r) tmpref.s.r = tmpref.e.r;&#13;
			if(tmpref.e.c &gt; refguess.e.c) tmpref.e.c = refguess.e.c;&#13;
			if(tmpref.e.c &lt; tmpref.s.c) tmpref.s.c = tmpref.e.c;&#13;
			s["!fullref"] = s["!ref"];&#13;
			s["!ref"] = encode_range(tmpref);&#13;
		}&#13;
	}&#13;
	if(merges.length &gt; 0) s["!merges"] = merges;&#13;
	if(colinfo.length &gt; 0) s["!cols"] = colinfo;&#13;
	if(rowinfo.length &gt; 0) s["!rows"] = rowinfo;&#13;
	return s;&#13;
}&#13;
&#13;
/* TODO: something useful -- this is a stub */&#13;
function write_ws_bin_cell(ba, cell, R, C, opts, ws, last_seen) {&#13;
	var o = ({r:R, c:C});&#13;
	if(cell.c) ws['!comments'].push([encode_cell(o), cell.c]);&#13;
	if(cell.v === undefined) return false;&#13;
	var vv = "";&#13;
	switch(cell.t) {&#13;
		case 'b': vv = cell.v ? "1" : "0"; break;&#13;
		case 'd': // no BrtCellDate :(&#13;
			cell = dup(cell);&#13;
			cell.z = cell.z || table_fmt[14];&#13;
			cell.v = datenum(parseDate(cell.v)); cell.t = 'n';&#13;
			break;&#13;
		/* falls through */&#13;
		case 'n': case 'e': vv = ''+cell.v; break;&#13;
		default: vv = cell.v; break;&#13;
	}&#13;
	/* TODO: cell style */&#13;
	o.s = get_cell_style(opts.cellXfs, cell, opts);&#13;
	if(cell.l) ws['!links'].push([encode_cell(o), cell.l]);&#13;
	switch(cell.t) {&#13;
		case 's': case 'str':&#13;
			if(opts.bookSST) {&#13;
				vv = get_sst_id(opts.Strings, (cell.v == null ? "" : String(cell.v)), opts.revStrings);&#13;
				o.t = "s"; o.v = vv;&#13;
				if(last_seen) write_record(ba, 0x0012 /* BrtShortIsst */, write_BrtShortIsst(cell, o));&#13;
				else write_record(ba, 0x0007 /* BrtCellIsst */, write_BrtCellIsst(cell, o));&#13;
			} else {&#13;
				o.t = "str";&#13;
				if(last_seen) write_record(ba, 0x0011 /* BrtShortSt */, write_BrtShortSt(cell, o));&#13;
				else write_record(ba, 0x0006 /* BrtCellSt */, write_BrtCellSt(cell, o));&#13;
			}&#13;
			return true;&#13;
		case 'n':&#13;
			/* TODO: determine threshold for Real vs RK */&#13;
			if(cell.v == (cell.v | 0) &amp;&amp; cell.v &gt; -1000 &amp;&amp; cell.v &lt; 1000) {&#13;
				if(last_seen) write_record(ba, 0x000D /* BrtShortRk */, write_BrtShortRk(cell, o));&#13;
				else write_record(ba, 0x0002 /* BrtCellRk */, write_BrtCellRk(cell, o));&#13;
			} else {&#13;
				if(last_seen) write_record(ba, 0x0010 /* BrtShortReal */, write_BrtShortReal(cell, o));&#13;
				else write_record(ba, 0x0005 /* BrtCellReal */, write_BrtCellReal(cell, o));&#13;
			} return true;&#13;
		case 'b':&#13;
			o.t = "b";&#13;
			if(last_seen) write_record(ba, 0x000F /* BrtShortBool */, write_BrtShortBool(cell, o));&#13;
			else write_record(ba, 0x0004 /* BrtCellBool */, write_BrtCellBool(cell, o));&#13;
			return true;&#13;
		case 'e':&#13;
			o.t = "e";&#13;
			if(last_seen) write_record(ba, 0x000E /* BrtShortError */, write_BrtShortError(cell, o));&#13;
			else write_record(ba, 0x0003 /* BrtCellError */, write_BrtCellError(cell, o));&#13;
			return true;&#13;
	}&#13;
	if(last_seen) write_record(ba, 0x000C /* BrtShortBlank */, write_BrtShortBlank(cell, o));&#13;
	else write_record(ba, 0x0001 /* BrtCellBlank */, write_BrtCellBlank(cell, o));&#13;
	return true;&#13;
}&#13;
&#13;
function write_CELLTABLE(ba, ws, idx, opts) {&#13;
	var range = safe_decode_range(ws['!ref'] || "A1"), ref, rr = "", cols = [];&#13;
	write_record(ba, 0x0091 /* BrtBeginSheetData */);&#13;
	var dense = Array.isArray(ws);&#13;
	var cap = range.e.r;&#13;
	if(ws['!rows']) cap = Math.max(range.e.r, ws['!rows'].length - 1);&#13;
	for(var R = range.s.r; R &lt;= cap; ++R) {&#13;
		rr = encode_row(R);&#13;
		/* [ACCELLTABLE] */&#13;
		/* BrtRowHdr */&#13;
		write_row_header(ba, ws, range, R);&#13;
		var last_seen = false;&#13;
		if(R &lt;= range.e.r) for(var C = range.s.c; C &lt;= range.e.c; ++C) {&#13;
			/* *16384CELL */&#13;
			if(R === range.s.r) cols[C] = encode_col(C);&#13;
			ref = cols[C] + rr;&#13;
			var cell = dense ? (ws[R]||[])[C] : ws[ref];&#13;
			if(!cell) { last_seen = false; continue; }&#13;
			/* write cell */&#13;
			last_seen = write_ws_bin_cell(ba, cell, R, C, opts, ws, last_seen);&#13;
		}&#13;
	}&#13;
	write_record(ba, 0x0092 /* BrtEndSheetData */);&#13;
}&#13;
&#13;
function write_MERGECELLS(ba, ws) {&#13;
	if(!ws || !ws['!merges']) return;&#13;
	write_record(ba, 0x00B1 /* BrtBeginMergeCells */, write_BrtBeginMergeCells(ws['!merges'].length));&#13;
	ws['!merges'].forEach(function(m) { write_record(ba, 0x00B0 /* BrtMergeCell */, write_BrtMergeCell(m)); });&#13;
	write_record(ba, 0x00B2 /* BrtEndMergeCells */);&#13;
}&#13;
&#13;
function write_COLINFOS(ba, ws) {&#13;
	if(!ws || !ws['!cols']) return;&#13;
	write_record(ba, 0x0186 /* BrtBeginColInfos */);&#13;
	ws['!cols'].forEach(function(m, i) { if(m) write_record(ba, 0x003C /* 'BrtColInfo' */, write_BrtColInfo(i, m)); });&#13;
	write_record(ba, 0x0187 /* BrtEndColInfos */);&#13;
}&#13;
&#13;
function write_IGNOREECS(ba, ws) {&#13;
	if(!ws || !ws['!ref']) return;&#13;
	write_record(ba, 0x0288 /* BrtBeginCellIgnoreECs */);&#13;
	write_record(ba, 0x0289 /* BrtCellIgnoreEC */, write_BrtCellIgnoreEC(safe_decode_range(ws['!ref'])));&#13;
	write_record(ba, 0x028A /* BrtEndCellIgnoreECs */);&#13;
}&#13;
&#13;
function write_HLINKS(ba, ws, rels) {&#13;
	/* *BrtHLink */&#13;
	ws['!links'].forEach(function(l) {&#13;
		if(!l[1].Target) return;&#13;
		var rId = add_rels(rels, -1, l[1].Target.replace(/#.*$/, ""), RELS.HLINK);&#13;
		write_record(ba, 0x01EE /* BrtHLink */, write_BrtHLink(l, rId));&#13;
	});&#13;
	delete ws['!links'];&#13;
}&#13;
function write_LEGACYDRAWING(ba, ws, idx, rels) {&#13;
	/* [BrtLegacyDrawing] */&#13;
	if(ws['!comments'].length &gt; 0) {&#13;
		var rId = add_rels(rels, -1, "../drawings/vmlDrawing" + (idx+1) + ".vml", RELS.VML);&#13;
		write_record(ba, 0x0227 /* BrtLegacyDrawing */, write_RelID("rId" + rId));&#13;
		ws['!legacy'] = rId;&#13;
	}&#13;
}&#13;
&#13;
function write_AUTOFILTER(ba, ws, wb, idx) {&#13;
	if(!ws['!autofilter']) return;&#13;
	var data = ws['!autofilter'];&#13;
	var ref = typeof data.ref === "string" ? data.ref : encode_range(data.ref);&#13;
&#13;
	/* Update FilterDatabase defined name for the worksheet */&#13;
	if(!wb.Workbook) wb.Workbook = ({Sheets:[]});&#13;
	if(!wb.Workbook.Names) wb.Workbook.Names = [];&#13;
	var names = wb.Workbook.Names;&#13;
	var range = decode_range(ref);&#13;
	if(range.s.r == range.e.r) { range.e.r = decode_range(ws["!ref"]).e.r; ref = encode_range(range); }&#13;
	for(var i = 0; i &lt; names.length; ++i) {&#13;
		var name = names[i];&#13;
		if(name.Name != '_xlnm._FilterDatabase') continue;&#13;
		if(name.Sheet != idx) continue;&#13;
		name.Ref = formula_quote_sheet_name(wb.SheetNames[idx]) + "!" + fix_range(ref); break;&#13;
	}&#13;
	if(i == names.length) names.push({ Name: '_xlnm._FilterDatabase', Sheet: idx, Ref: formula_quote_sheet_name(wb.SheetNames[idx]) + "!" + fix_range(ref)  });&#13;
&#13;
	write_record(ba, 0x00A1 /* BrtBeginAFilter */, write_UncheckedRfX(safe_decode_range(ref)));&#13;
	/* *FILTERCOLUMN */&#13;
	/* [SORTSTATE] */&#13;
	/* BrtEndAFilter */&#13;
	write_record(ba, 0x00A2 /* BrtEndAFilter */);&#13;
}&#13;
&#13;
function write_WSVIEWS2(ba, ws, Workbook) {&#13;
	write_record(ba, 0x0085 /* BrtBeginWsViews */);&#13;
	{ /* 1*WSVIEW2 */&#13;
		/* [ACUID] */&#13;
		write_record(ba, 0x0089 /* BrtBeginWsView */, write_BrtBeginWsView(ws, Workbook));&#13;
		/* [BrtPane] */&#13;
		/* *4BrtSel */&#13;
		/* *4SXSELECT */&#13;
		/* *FRT */&#13;
		write_record(ba, 0x008A /* BrtEndWsView */);&#13;
	}&#13;
	/* *FRT */&#13;
	write_record(ba, 0x0086 /* BrtEndWsViews */);&#13;
}&#13;
&#13;
function write_WSFMTINFO() {&#13;
	/* [ACWSFMTINFO] */&#13;
	// write_record(ba, 0x01E5 /* BrtWsFmtInfo */, write_BrtWsFmtInfo(ws));&#13;
}&#13;
&#13;
function write_SHEETPROTECT(ba, ws) {&#13;
	if(!ws['!protect']) return;&#13;
	/* [BrtSheetProtectionIso] */&#13;
	write_record(ba, 0x0217 /* BrtSheetProtection */, write_BrtSheetProtection(ws['!protect']));&#13;
}&#13;
&#13;
function write_ws_bin(idx, opts, wb, rels) {&#13;
	var ba = buf_array();&#13;
	var s = wb.SheetNames[idx], ws = wb.Sheets[s] || {};&#13;
	var c = s; try { if(wb &amp;&amp; wb.Workbook) c = wb.Workbook.Sheets[idx].CodeName || c; } catch(e) {}&#13;
	var r = safe_decode_range(ws['!ref'] || "A1");&#13;
	if(r.e.c &gt; 0x3FFF || r.e.r &gt; 0xFFFFF) {&#13;
		if(opts.WTF) throw new Error("Range " + (ws['!ref'] || "A1") + " exceeds format limit A1:XFD1048576");&#13;
		r.e.c = Math.min(r.e.c, 0x3FFF);&#13;
		r.e.r = Math.min(r.e.c, 0xFFFFF);&#13;
	}&#13;
	ws['!links'] = [];&#13;
	/* passed back to write_zip and removed there */&#13;
	ws['!comments'] = [];&#13;
	write_record(ba, 0x0081 /* BrtBeginSheet */);&#13;
	if(wb.vbaraw || ws['!outline']) write_record(ba, 0x0093 /* BrtWsProp */, write_BrtWsProp(c, ws['!outline']));&#13;
	write_record(ba, 0x0094 /* BrtWsDim */, write_BrtWsDim(r));&#13;
	write_WSVIEWS2(ba, ws, wb.Workbook);&#13;
	write_WSFMTINFO(ba, ws);&#13;
	write_COLINFOS(ba, ws, idx, opts, wb);&#13;
	write_CELLTABLE(ba, ws, idx, opts, wb);&#13;
	/* [BrtSheetCalcProp] */&#13;
	write_SHEETPROTECT(ba, ws);&#13;
	/* *([BrtRangeProtectionIso] BrtRangeProtection) */&#13;
	/* [SCENMAN] */&#13;
	write_AUTOFILTER(ba, ws, wb, idx);&#13;
	/* [SORTSTATE] */&#13;
	/* [DCON] */&#13;
	/* [USERSHVIEWS] */&#13;
	write_MERGECELLS(ba, ws);&#13;
	/* [BrtPhoneticInfo] */&#13;
	/* *CONDITIONALFORMATTING */&#13;
	/* [DVALS] */&#13;
	write_HLINKS(ba, ws, rels);&#13;
	/* [BrtPrintOptions] */&#13;
	if(ws['!margins']) write_record(ba, 0x01DC /* BrtMargins */, write_BrtMargins(ws['!margins']));&#13;
	/* [BrtPageSetup] */&#13;
	/* [HEADERFOOTER] */&#13;
	/* [RWBRK] */&#13;
	/* [COLBRK] */&#13;
	/* *BrtBigName */&#13;
	/* [CELLWATCHES] */&#13;
	if(!opts || opts.ignoreEC || (opts.ignoreEC == (void 0))) write_IGNOREECS(ba, ws);&#13;
	/* [SMARTTAGS] */&#13;
	/* [BrtDrawing] */&#13;
	write_LEGACYDRAWING(ba, ws, idx, rels);&#13;
	/* [BrtLegacyDrawingHF] */&#13;
	/* [BrtBkHim] */&#13;
	/* [OLEOBJECTS] */&#13;
	/* [ACTIVEXCONTROLS] */&#13;
	/* [WEBPUBITEMS] */&#13;
	/* [LISTPARTS] */&#13;
	/* FRTWORKSHEET */&#13;
	write_record(ba, 0x0082 /* BrtEndSheet */);&#13;
	return ba.end();&#13;
}&#13;
function parse_Cache(data) {&#13;
	var col = [];&#13;
	var num = data.match(/^&lt;c:numCache&gt;/);&#13;
	var f;&#13;
&#13;
	/* 21.2.2.150 pt CT_NumVal */&#13;
	(data.match(/&lt;c:pt idx="(\d*)"&gt;(.*?)&lt;\/c:pt&gt;/mg)||[]).forEach(function(pt) {&#13;
		var q = pt.match(/&lt;c:pt idx="(\d*?)"&gt;&lt;c:v&gt;(.*)&lt;\/c:v&gt;&lt;\/c:pt&gt;/);&#13;
		if(!q) return;&#13;
		col[+q[1]] = num ? +q[2] : q[2];&#13;
	});&#13;
&#13;
	/* 21.2.2.71 formatCode CT_Xstring */&#13;
	var nf = unescapexml((data.match(/&lt;c:formatCode&gt;([\s\S]*?)&lt;\/c:formatCode&gt;/) || ["","General"])[1]);&#13;
&#13;
	(data.match(/&lt;c:f&gt;(.*?)&lt;\/c:f&gt;/mg)||[]).forEach(function(F) { f = F.replace(/&lt;.*?&gt;/g,""); });&#13;
&#13;
	return [col, nf, f];&#13;
}&#13;
&#13;
/* 21.2 DrawingML - Charts */&#13;
function parse_chart(data, name, opts, rels, wb, csheet) {&#13;
	var cs = ((csheet || {"!type":"chart"}));&#13;
	if(!data) return csheet;&#13;
	/* 21.2.2.27 chart CT_Chart */&#13;
&#13;
	var C = 0, R = 0, col = "A";&#13;
	var refguess = {s: {r:2000000, c:2000000}, e: {r:0, c:0} };&#13;
&#13;
	/* 21.2.2.120 numCache CT_NumData */&#13;
	(data.match(/&lt;c:numCache&gt;[\s\S]*?&lt;\/c:numCache&gt;/gm)||[]).forEach(function(nc) {&#13;
		var cache = parse_Cache(nc);&#13;
		refguess.s.r = refguess.s.c = 0;&#13;
		refguess.e.c = C;&#13;
		col = encode_col(C);&#13;
		cache[0].forEach(function(n,i) {&#13;
			cs[col + encode_row(i)] = {t:'n', v:n, z:cache[1] };&#13;
			R = i;&#13;
		});&#13;
		if(refguess.e.r &lt; R) refguess.e.r = R;&#13;
		++C;&#13;
	});&#13;
	if(C &gt; 0) cs["!ref"] = encode_range(refguess);&#13;
	return cs;&#13;
}&#13;
/* 18.3 Worksheets also covers Chartsheets */&#13;
function parse_cs_xml(data, opts, idx, rels, wb) {&#13;
	if(!data) return data;&#13;
	/* 18.3.1.12 chartsheet CT_ChartSheet */&#13;
	if(!rels) rels = {'!id':{}};&#13;
	var s = ({'!type':"chart", '!drawel':null, '!rel':""});&#13;
	var m;&#13;
&#13;
	/* 18.3.1.83 sheetPr CT_ChartsheetPr */&#13;
	var sheetPr = data.match(sheetprregex);&#13;
	if(sheetPr) parse_ws_xml_sheetpr(sheetPr[0], s, wb, idx);&#13;
&#13;
	/* 18.3.1.36 drawing CT_Drawing */&#13;
	if((m = data.match(/drawing r:id="(.*?)"/))) s['!rel'] = m[1];&#13;
&#13;
	if(rels['!id'][s['!rel']]) s['!drawel'] = rels['!id'][s['!rel']];&#13;
	return s;&#13;
}&#13;
//function write_cs_xml(idx, opts, wb, rels) {&#13;
//	var o = [XML_HEADER, writextag('chartsheet', null, {&#13;
//		'xmlns': XMLNS_main[0],&#13;
//		'xmlns:r': XMLNS.r&#13;
//	})];&#13;
//	o[o.length] = writextag("drawing", null, {"r:id": "rId1"});&#13;
//	add_rels(rels, -1, "../drawings/drawing" + (idx+1) + ".xml", RELS.DRAW);&#13;
//	if(o.length&gt;2) { o[o.length] = ('&lt;/chartsheet&gt;'); o[1]=o[1].replace("/&gt;","&gt;"); }&#13;
//	return o.join("");&#13;
//}&#13;
&#13;
/* [MS-XLSB] 2.4.331 BrtCsProp */&#13;
function parse_BrtCsProp(data, length) {&#13;
	data.l += 10;&#13;
	var name = parse_XLWideString(data, length - 10);&#13;
	return { name: name };&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.1.7.7 Chart Sheet */&#13;
function parse_cs_bin(data, opts, idx, rels, wb) {&#13;
	if(!data) return data;&#13;
	if(!rels) rels = {'!id':{}};&#13;
	var s = {'!type':"chart", '!drawel':null, '!rel':""};&#13;
	var state = [];&#13;
	var pass = false;&#13;
	recordhopper(data, function cs_parse(val, R, RT) {&#13;
		switch(RT) {&#13;
&#13;
			case 0x0226: /* 'BrtDrawing' */&#13;
				s['!rel'] = val; break;&#13;
&#13;
			case 0x028B: /* 'BrtCsProp' */&#13;
				if(!wb.Sheets[idx]) wb.Sheets[idx] = {};&#13;
				if(val.name) wb.Sheets[idx].CodeName = val.name;&#13;
				break;&#13;
&#13;
			case 0x0232: /* 'BrtBkHim' */&#13;
			case 0x028C: /* 'BrtCsPageSetup' */&#13;
			case 0x029D: /* 'BrtCsProtection' */&#13;
			case 0x02A7: /* 'BrtCsProtectionIso' */&#13;
			case 0x0227: /* 'BrtLegacyDrawing' */&#13;
			case 0x0228: /* 'BrtLegacyDrawingHF' */&#13;
			case 0x01DC: /* 'BrtMargins' */&#13;
			case 0x0C00: /* 'BrtUid' */&#13;
				break;&#13;
&#13;
			case 0x0023: /* 'BrtFRTBegin' */&#13;
				pass = true; break;&#13;
			case 0x0024: /* 'BrtFRTEnd' */&#13;
				pass = false; break;&#13;
			case 0x0025: /* 'BrtACBegin' */&#13;
				state.push(RT); break;&#13;
			case 0x0026: /* 'BrtACEnd' */&#13;
				state.pop(); break;&#13;
&#13;
			default:&#13;
				if(R.T &gt; 0) state.push(RT);&#13;
				else if(R.T &lt; 0) state.pop();&#13;
				else if(!pass || opts.WTF) throw new Error("Unexpected record 0x" + RT.toString(16));&#13;
		}&#13;
	}, opts);&#13;
&#13;
	if(rels['!id'][s['!rel']]) s['!drawel'] = rels['!id'][s['!rel']];&#13;
	return s;&#13;
}&#13;
//function write_cs_bin() {&#13;
//	var ba = buf_array();&#13;
//	write_record(ba, 0x0081 /* BrtBeginSheet */);&#13;
//	/* [BrtCsProp] */&#13;
//	/* CSVIEWS */&#13;
//	/* [[BrtCsProtectionIso] BrtCsProtection] */&#13;
//	/* [USERCSVIEWS] */&#13;
//	/* [BrtMargins] */&#13;
//	/* [BrtCsPageSetup] */&#13;
//	/* [HEADERFOOTER] */&#13;
//	/* BrtDrawing */&#13;
//	/* [BrtLegacyDrawing] */&#13;
//	/* [BrtLegacyDrawingHF] */&#13;
//	/* [BrtBkHim] */&#13;
//	/* [WEBPUBITEMS] */&#13;
//	/* FRTCHARTSHEET */&#13;
//	write_record(ba, 0x0082 /* BrtEndSheet */);&#13;
//	return ba.end();&#13;
//}&#13;
/* 18.2.28 (CT_WorkbookProtection) Defaults */&#13;
var WBPropsDef = [&#13;
	['allowRefreshQuery',           false, "bool"],&#13;
	['autoCompressPictures',        true,  "bool"],&#13;
	['backupFile',                  false, "bool"],&#13;
	['checkCompatibility',          false, "bool"],&#13;
	['CodeName',                    ''],&#13;
	['date1904',                    false, "bool"],&#13;
	['defaultThemeVersion',         0,      "int"],&#13;
	['filterPrivacy',               false, "bool"],&#13;
	['hidePivotFieldList',          false, "bool"],&#13;
	['promptedSolutions',           false, "bool"],&#13;
	['publishItems',                false, "bool"],&#13;
	['refreshAllConnections',       false, "bool"],&#13;
	['saveExternalLinkValues',      true,  "bool"],&#13;
	['showBorderUnselectedTables',  true,  "bool"],&#13;
	['showInkAnnotation',           true,  "bool"],&#13;
	['showObjects',                 'all'],&#13;
	['showPivotChartFilter',        false, "bool"],&#13;
	['updateLinks', 'userSet']&#13;
];&#13;
&#13;
/* 18.2.30 (CT_BookView) Defaults */&#13;
var WBViewDef = [&#13;
	['activeTab',                   0,      "int"],&#13;
	['autoFilterDateGrouping',      true,  "bool"],&#13;
	['firstSheet',                  0,      "int"],&#13;
	['minimized',                   false, "bool"],&#13;
	['showHorizontalScroll',        true,  "bool"],&#13;
	['showSheetTabs',               true,  "bool"],&#13;
	['showVerticalScroll',          true,  "bool"],&#13;
	['tabRatio',                    600,    "int"],&#13;
	['visibility',                  'visible']&#13;
	//window{Height,Width}, {x,y}Window&#13;
];&#13;
&#13;
/* 18.2.19 (CT_Sheet) Defaults */&#13;
var SheetDef = [&#13;
	//['state', 'visible']&#13;
];&#13;
&#13;
/* 18.2.2  (CT_CalcPr) Defaults */&#13;
var CalcPrDef = [&#13;
	['calcCompleted', 'true'],&#13;
	['calcMode', 'auto'],&#13;
	['calcOnSave', 'true'],&#13;
	['concurrentCalc', 'true'],&#13;
	['fullCalcOnLoad', 'false'],&#13;
	['fullPrecision', 'true'],&#13;
	['iterate', 'false'],&#13;
	['iterateCount', '100'],&#13;
	['iterateDelta', '0.001'],&#13;
	['refMode', 'A1']&#13;
];&#13;
&#13;
/* 18.2.3 (CT_CustomWorkbookView) Defaults */&#13;
/*var CustomWBViewDef = [&#13;
	['autoUpdate', 'false'],&#13;
	['changesSavedWin', 'false'],&#13;
	['includeHiddenRowCol', 'true'],&#13;
	['includePrintSettings', 'true'],&#13;
	['maximized', 'false'],&#13;
	['minimized', 'false'],&#13;
	['onlySync', 'false'],&#13;
	['personalView', 'false'],&#13;
	['showComments', 'commIndicator'],&#13;
	['showFormulaBar', 'true'],&#13;
	['showHorizontalScroll', 'true'],&#13;
	['showObjects', 'all'],&#13;
	['showSheetTabs', 'true'],&#13;
	['showStatusbar', 'true'],&#13;
	['showVerticalScroll', 'true'],&#13;
	['tabRatio', '600'],&#13;
	['xWindow', '0'],&#13;
	['yWindow', '0']&#13;
];*/&#13;
&#13;
function push_defaults_array(target, defaults) {&#13;
	for(var j = 0; j != target.length; ++j) { var w = target[j];&#13;
		for(var i=0; i != defaults.length; ++i) { var z = defaults[i];&#13;
			if(w[z[0]] == null) w[z[0]] = z[1];&#13;
			else switch(z[2]) {&#13;
			case "bool": if(typeof w[z[0]] == "string") w[z[0]] = parsexmlbool(w[z[0]]); break;&#13;
			case "int": if(typeof w[z[0]] == "string") w[z[0]] = parseInt(w[z[0]], 10); break;&#13;
			}&#13;
		}&#13;
	}&#13;
}&#13;
function push_defaults(target, defaults) {&#13;
	for(var i = 0; i != defaults.length; ++i) { var z = defaults[i];&#13;
		if(target[z[0]] == null) target[z[0]] = z[1];&#13;
		else switch(z[2]) {&#13;
			case "bool": if(typeof target[z[0]] == "string") target[z[0]] = parsexmlbool(target[z[0]]); break;&#13;
			case "int": if(typeof target[z[0]] == "string") target[z[0]] = parseInt(target[z[0]], 10); break;&#13;
		}&#13;
	}&#13;
}&#13;
&#13;
function parse_wb_defaults(wb) {&#13;
	push_defaults(wb.WBProps, WBPropsDef);&#13;
	push_defaults(wb.CalcPr, CalcPrDef);&#13;
&#13;
	push_defaults_array(wb.WBView, WBViewDef);&#13;
	push_defaults_array(wb.Sheets, SheetDef);&#13;
&#13;
	_ssfopts.date1904 = parsexmlbool(wb.WBProps.date1904);&#13;
}&#13;
&#13;
function safe1904(wb) {&#13;
	/* TODO: store date1904 somewhere else */&#13;
	if(!wb.Workbook) return "false";&#13;
	if(!wb.Workbook.WBProps) return "false";&#13;
	return parsexmlbool(wb.Workbook.WBProps.date1904) ? "true" : "false";&#13;
}&#13;
&#13;
var badchars = ":][*?\/\\".split("");&#13;
function check_ws_name(n, safe) {&#13;
	if(n.length &gt; 31) { if(safe) return false; throw new Error("Sheet names cannot exceed 31 chars"); }&#13;
	var _good = true;&#13;
	badchars.forEach(function(c) {&#13;
		if(n.indexOf(c) == -1) return;&#13;
		if(!safe) throw new Error("Sheet name cannot contain : \\ / ? * [ ]");&#13;
		_good = false;&#13;
	});&#13;
	return _good;&#13;
}&#13;
function check_wb_names(N, S, codes) {&#13;
	N.forEach(function(n,i) {&#13;
		check_ws_name(n);&#13;
		for(var j = 0; j &lt; i; ++j) if(n == N[j]) throw new Error("Duplicate Sheet Name: " + n);&#13;
		if(codes) {&#13;
			var cn = (S &amp;&amp; S[i] &amp;&amp; S[i].CodeName) || n;&#13;
			if(cn.charCodeAt(0) == 95 &amp;&amp; cn.length &gt; 22) throw new Error("Bad Code Name: Worksheet" + cn);&#13;
		}&#13;
	});&#13;
}&#13;
function check_wb(wb) {&#13;
	if(!wb || !wb.SheetNames || !wb.Sheets) throw new Error("Invalid Workbook");&#13;
	if(!wb.SheetNames.length) throw new Error("Workbook is empty");&#13;
	var Sheets = (wb.Workbook &amp;&amp; wb.Workbook.Sheets) || [];&#13;
	check_wb_names(wb.SheetNames, Sheets, !!wb.vbaraw);&#13;
	for(var i = 0; i &lt; wb.SheetNames.length; ++i) check_ws(wb.Sheets[wb.SheetNames[i]], wb.SheetNames[i], i);&#13;
	wb.SheetNames.forEach(function(n, i) {&#13;
		var ws = wb.Sheets[n];&#13;
		if(!ws || !ws["!autofilter"]) return;&#13;
		var DN;&#13;
		if(!wb.Workbook) wb.Workbook = {};&#13;
		if(!wb.Workbook.Names) wb.Workbook.Names = [];&#13;
		wb.Workbook.Names.forEach(function(dn) { if(dn.Name == "_xlnm._FilterDatabase" &amp;&amp; dn.Sheet == i) DN = dn; });&#13;
		var nn = formula_quote_sheet_name(n) + "!" + fix_range(ws["!autofilter"].ref);&#13;
		if(DN) DN.Ref = nn;&#13;
		else wb.Workbook.Names.push({Name: "_xlnm._FilterDatabase", Sheet: i, Ref: nn});&#13;
	});&#13;
	/* TODO: validate workbook */&#13;
}&#13;
/* 18.2 Workbook */&#13;
var wbnsregex = /&lt;\w+:workbook/;&#13;
function parse_wb_xml(data, opts) {&#13;
	if(!data) throw new Error("Could not find file");&#13;
	var wb = { AppVersion:{}, WBProps:{}, WBView:[], Sheets:[], CalcPr:{}, Names:[], xmlns: "" };&#13;
	var pass = false, xmlns = "xmlns";&#13;
	var dname = {}, dnstart = 0;&#13;
	data.replace(tagregex, function xml_wb(x, idx) {&#13;
		var y = parsexmltag(x);&#13;
		switch(strip_ns(y[0])) {&#13;
			case '&lt;?xml': break;&#13;
&#13;
			/* 18.2.27 workbook CT_Workbook 1 */&#13;
			case '&lt;workbook':&#13;
				if(x.match(wbnsregex)) xmlns = "xmlns" + x.match(/&lt;(\w+):/)[1];&#13;
				wb.xmlns = y[xmlns];&#13;
				break;&#13;
			case '&lt;/workbook&gt;': break;&#13;
&#13;
			/* 18.2.13 fileVersion CT_FileVersion ? */&#13;
			case '&lt;fileVersion': delete y[0]; wb.AppVersion = y; break;&#13;
			case '&lt;fileVersion/&gt;': case '&lt;/fileVersion&gt;': break;&#13;
&#13;
			/* 18.2.12 fileSharing CT_FileSharing ? */&#13;
			case '&lt;fileSharing':&#13;
				break;&#13;
			case '&lt;fileSharing/&gt;': break;&#13;
&#13;
			/* 18.2.28 workbookPr CT_WorkbookPr ? */&#13;
			case '&lt;workbookPr':&#13;
			case '&lt;workbookPr/&gt;':&#13;
				WBPropsDef.forEach(function(w) {&#13;
					if(y[w[0]] == null) return;&#13;
					switch(w[2]) {&#13;
						case "bool": wb.WBProps[w[0]] = parsexmlbool(y[w[0]]); break;&#13;
						case "int": wb.WBProps[w[0]] = parseInt(y[w[0]], 10); break;&#13;
						default: wb.WBProps[w[0]] = y[w[0]];&#13;
					}&#13;
				});&#13;
				if(y.codeName) wb.WBProps.CodeName = utf8read(y.codeName);&#13;
				break;&#13;
			case '&lt;/workbookPr&gt;': break;&#13;
&#13;
			/* 18.2.29 workbookProtection CT_WorkbookProtection ? */&#13;
			case '&lt;workbookProtection':&#13;
				break;&#13;
			case '&lt;workbookProtection/&gt;': break;&#13;
&#13;
			/* 18.2.1  bookViews CT_BookViews ? */&#13;
			case '&lt;bookViews': case '&lt;bookViews&gt;': case '&lt;/bookViews&gt;': break;&#13;
			/* 18.2.30   workbookView CT_BookView + */&#13;
			case '&lt;workbookView': case '&lt;workbookView/&gt;': delete y[0]; wb.WBView.push(y); break;&#13;
			case '&lt;/workbookView&gt;': break;&#13;
&#13;
			/* 18.2.20 sheets CT_Sheets 1 */&#13;
			case '&lt;sheets': case '&lt;sheets&gt;': case '&lt;/sheets&gt;': break; // aggregate sheet&#13;
			/* 18.2.19   sheet CT_Sheet + */&#13;
			case '&lt;sheet':&#13;
				switch(y.state) {&#13;
					case "hidden": y.Hidden = 1; break;&#13;
					case "veryHidden": y.Hidden = 2; break;&#13;
					default: y.Hidden = 0;&#13;
				}&#13;
				delete y.state;&#13;
				y.name = unescapexml(utf8read(y.name));&#13;
				delete y[0]; wb.Sheets.push(y); break;&#13;
			case '&lt;/sheet&gt;': break;&#13;
&#13;
			/* 18.2.15 functionGroups CT_FunctionGroups ? */&#13;
			case '&lt;functionGroups': case '&lt;functionGroups/&gt;': break;&#13;
			/* 18.2.14   functionGroup CT_FunctionGroup + */&#13;
			case '&lt;functionGroup': break;&#13;
&#13;
			/* 18.2.9  externalReferences CT_ExternalReferences ? */&#13;
			case '&lt;externalReferences': case '&lt;/externalReferences&gt;': case '&lt;externalReferences&gt;': break;&#13;
			/* 18.2.8    externalReference CT_ExternalReference + */&#13;
			case '&lt;externalReference': break;&#13;
&#13;
			/* 18.2.6  definedNames CT_DefinedNames ? */&#13;
			case '&lt;definedNames/&gt;': break;&#13;
			case '&lt;definedNames&gt;': case '&lt;definedNames': pass=true; break;&#13;
			case '&lt;/definedNames&gt;': pass=false; break;&#13;
			/* 18.2.5    definedName CT_DefinedName + */&#13;
			case '&lt;definedName': {&#13;
				dname = {};&#13;
				dname.Name = utf8read(y.name);&#13;
				if(y.comment) dname.Comment = y.comment;&#13;
				if(y.localSheetId) dname.Sheet = +y.localSheetId;&#13;
				if(parsexmlbool(y.hidden||"0")) dname.Hidden = true;&#13;
				dnstart = idx + x.length;&#13;
			}	break;&#13;
			case '&lt;/definedName&gt;': {&#13;
				dname.Ref = unescapexml(utf8read(data.slice(dnstart, idx)));&#13;
				wb.Names.push(dname);&#13;
			} break;&#13;
			case '&lt;definedName/&gt;': break;&#13;
&#13;
			/* 18.2.2  calcPr CT_CalcPr ? */&#13;
			case '&lt;calcPr': delete y[0]; wb.CalcPr = y; break;&#13;
			case '&lt;calcPr/&gt;': delete y[0]; wb.CalcPr = y; break;&#13;
			case '&lt;/calcPr&gt;': break;&#13;
&#13;
			/* 18.2.16 oleSize CT_OleSize ? (ref required) */&#13;
			case '&lt;oleSize': break;&#13;
&#13;
			/* 18.2.4  customWorkbookViews CT_CustomWorkbookViews ? */&#13;
			case '&lt;customWorkbookViews&gt;': case '&lt;/customWorkbookViews&gt;': case '&lt;customWorkbookViews': break;&#13;
			/* 18.2.3  customWorkbookView CT_CustomWorkbookView + */&#13;
			case '&lt;customWorkbookView': case '&lt;/customWorkbookView&gt;': break;&#13;
&#13;
			/* 18.2.18 pivotCaches CT_PivotCaches ? */&#13;
			case '&lt;pivotCaches&gt;': case '&lt;/pivotCaches&gt;': case '&lt;pivotCaches': break;&#13;
			/* 18.2.17 pivotCache CT_PivotCache ? */&#13;
			case '&lt;pivotCache': break;&#13;
&#13;
			/* 18.2.21 smartTagPr CT_SmartTagPr ? */&#13;
			case '&lt;smartTagPr': case '&lt;smartTagPr/&gt;': break;&#13;
&#13;
			/* 18.2.23 smartTagTypes CT_SmartTagTypes ? */&#13;
			case '&lt;smartTagTypes': case '&lt;smartTagTypes&gt;': case '&lt;/smartTagTypes&gt;': break;&#13;
			/* 18.2.22 smartTagType CT_SmartTagType ? */&#13;
			case '&lt;smartTagType': break;&#13;
&#13;
			/* 18.2.24 webPublishing CT_WebPublishing ? */&#13;
			case '&lt;webPublishing': case '&lt;webPublishing/&gt;': break;&#13;
&#13;
			/* 18.2.11 fileRecoveryPr CT_FileRecoveryPr ? */&#13;
			case '&lt;fileRecoveryPr': case '&lt;fileRecoveryPr/&gt;': break;&#13;
&#13;
			/* 18.2.26 webPublishObjects CT_WebPublishObjects ? */&#13;
			case '&lt;webPublishObjects&gt;': case '&lt;webPublishObjects': case '&lt;/webPublishObjects&gt;': break;&#13;
			/* 18.2.25 webPublishObject CT_WebPublishObject ? */&#13;
			case '&lt;webPublishObject': break;&#13;
&#13;
			/* 18.2.10 extLst CT_ExtensionList ? */&#13;
			case '&lt;extLst': case '&lt;extLst&gt;': case '&lt;/extLst&gt;': case '&lt;extLst/&gt;': break;&#13;
			/* 18.2.7  ext CT_Extension + */&#13;
			case '&lt;ext': pass=true; break; //TODO: check with versions of excel&#13;
			case '&lt;/ext&gt;': pass=false; break;&#13;
&#13;
			/* Others */&#13;
			case '&lt;ArchID': break;&#13;
			case '&lt;AlternateContent':&#13;
			case '&lt;AlternateContent&gt;': pass=true; break;&#13;
			case '&lt;/AlternateContent&gt;': pass=false; break;&#13;
&#13;
			/* TODO */&#13;
			case '&lt;revisionPtr': break;&#13;
&#13;
			default: if(!pass &amp;&amp; opts.WTF) throw new Error('unrecognized ' + y[0] + ' in workbook');&#13;
		}&#13;
		return x;&#13;
	});&#13;
	if(XMLNS_main.indexOf(wb.xmlns) === -1) throw new Error("Unknown Namespace: " + wb.xmlns);&#13;
&#13;
	parse_wb_defaults(wb);&#13;
&#13;
	return wb;&#13;
}&#13;
&#13;
function write_wb_xml(wb) {&#13;
	var o = [XML_HEADER];&#13;
	o[o.length] = writextag('workbook', null, {&#13;
		'xmlns': XMLNS_main[0],&#13;
		//'xmlns:mx': XMLNS.mx,&#13;
		//'xmlns:s': XMLNS_main[0],&#13;
		'xmlns:r': XMLNS.r&#13;
	});&#13;
&#13;
	var write_names = (wb.Workbook &amp;&amp; (wb.Workbook.Names||[]).length &gt; 0);&#13;
&#13;
	/* fileVersion */&#13;
	/* fileSharing */&#13;
&#13;
	var workbookPr = ({codeName:"ThisWorkbook"});&#13;
	if(wb.Workbook &amp;&amp; wb.Workbook.WBProps) {&#13;
		WBPropsDef.forEach(function(x) {&#13;
if((wb.Workbook.WBProps[x[0]]) == null) return;&#13;
			if((wb.Workbook.WBProps[x[0]]) == x[1]) return;&#13;
			workbookPr[x[0]] = (wb.Workbook.WBProps[x[0]]);&#13;
		});&#13;
if(wb.Workbook.WBProps.CodeName) { workbookPr.codeName = wb.Workbook.WBProps.CodeName; delete workbookPr.CodeName; }&#13;
	}&#13;
	o[o.length] = (writextag('workbookPr', null, workbookPr));&#13;
&#13;
	/* workbookProtection */&#13;
&#13;
	var sheets = wb.Workbook &amp;&amp; wb.Workbook.Sheets || [];&#13;
	var i = 0;&#13;
&#13;
	/* bookViews only written if first worksheet is hidden */&#13;
	if(sheets &amp;&amp; sheets[0] &amp;&amp; !!sheets[0].Hidden) {&#13;
		o[o.length] = "&lt;bookViews&gt;";&#13;
		for(i = 0; i != wb.SheetNames.length; ++i) {&#13;
			if(!sheets[i]) break;&#13;
			if(!sheets[i].Hidden) break;&#13;
		}&#13;
		if(i == wb.SheetNames.length) i = 0;&#13;
		o[o.length] = '&lt;workbookView firstSheet="' + i + '" activeTab="' + i + '"/&gt;';&#13;
		o[o.length] = "&lt;/bookViews&gt;";&#13;
	}&#13;
&#13;
	o[o.length] = "&lt;sheets&gt;";&#13;
	for(i = 0; i != wb.SheetNames.length; ++i) {&#13;
		var sht = ({name:escapexml(wb.SheetNames[i].slice(0,31))});&#13;
		sht.sheetId = ""+(i+1);&#13;
		sht["r:id"] = "rId"+(i+1);&#13;
		if(sheets[i]) switch(sheets[i].Hidden) {&#13;
			case 1: sht.state = "hidden"; break;&#13;
			case 2: sht.state = "veryHidden"; break;&#13;
		}&#13;
		o[o.length] = (writextag('sheet',null,sht));&#13;
	}&#13;
	o[o.length] = "&lt;/sheets&gt;";&#13;
&#13;
	/* functionGroups */&#13;
	/* externalReferences */&#13;
&#13;
	if(write_names) {&#13;
		o[o.length] = "&lt;definedNames&gt;";&#13;
		if(wb.Workbook &amp;&amp; wb.Workbook.Names) wb.Workbook.Names.forEach(function(n) {&#13;
			var d = {name:n.Name};&#13;
			if(n.Comment) d.comment = n.Comment;&#13;
			if(n.Sheet != null) d.localSheetId = ""+n.Sheet;&#13;
			if(n.Hidden) d.hidden = "1";&#13;
			if(!n.Ref) return;&#13;
			o[o.length] = writextag('definedName', escapexml(n.Ref), d);&#13;
		});&#13;
		o[o.length] = "&lt;/definedNames&gt;";&#13;
	}&#13;
&#13;
	/* calcPr */&#13;
	/* oleSize */&#13;
	/* customWorkbookViews */&#13;
	/* pivotCaches */&#13;
	/* smartTagPr */&#13;
	/* smartTagTypes */&#13;
	/* webPublishing */&#13;
	/* fileRecoveryPr */&#13;
	/* webPublishObjects */&#13;
	/* extLst */&#13;
&#13;
	if(o.length&gt;2){ o[o.length] = '&lt;/workbook&gt;'; o[1]=o[1].replace("/&gt;","&gt;"); }&#13;
	return o.join("");&#13;
}&#13;
/* [MS-XLSB] 2.4.304 BrtBundleSh */&#13;
function parse_BrtBundleSh(data, length) {&#13;
	var z = {};&#13;
	z.Hidden = data.read_shift(4); //hsState ST_SheetState&#13;
	z.iTabID = data.read_shift(4);&#13;
	z.strRelID = parse_RelID(data,length-8);&#13;
	z.name = parse_XLWideString(data);&#13;
	return z;&#13;
}&#13;
function write_BrtBundleSh(data, o) {&#13;
	if(!o) o = new_buf(127);&#13;
	o.write_shift(4, data.Hidden);&#13;
	o.write_shift(4, data.iTabID);&#13;
	write_RelID(data.strRelID, o);&#13;
	write_XLWideString(data.name.slice(0,31), o);&#13;
	return o.length &gt; o.l ? o.slice(0, o.l) : o;&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.4.815 BrtWbProp */&#13;
function parse_BrtWbProp(data, length) {&#13;
	var o = ({});&#13;
	var flags = data.read_shift(4);&#13;
	o.defaultThemeVersion = data.read_shift(4);&#13;
	var strName = (length &gt; 8) ? parse_XLWideString(data) : "";&#13;
	if(strName.length &gt; 0) o.CodeName = strName;&#13;
	o.autoCompressPictures = !!(flags &amp; 0x10000);&#13;
	o.backupFile = !!(flags &amp; 0x40);&#13;
	o.checkCompatibility = !!(flags &amp; 0x1000);&#13;
	o.date1904 = !!(flags &amp; 0x01);&#13;
	o.filterPrivacy = !!(flags &amp; 0x08);&#13;
	o.hidePivotFieldList = !!(flags &amp; 0x400);&#13;
	o.promptedSolutions = !!(flags &amp; 0x10);&#13;
	o.publishItems = !!(flags &amp; 0x800);&#13;
	o.refreshAllConnections = !!(flags &amp; 0x40000);&#13;
	o.saveExternalLinkValues = !!(flags &amp; 0x80);&#13;
	o.showBorderUnselectedTables = !!(flags &amp; 0x04);&#13;
	o.showInkAnnotation = !!(flags &amp; 0x20);&#13;
	o.showObjects = ["all", "placeholders", "none"][(flags &gt;&gt; 13) &amp; 0x03];&#13;
	o.showPivotChartFilter = !!(flags &amp; 0x8000);&#13;
	o.updateLinks = ["userSet", "never", "always"][(flags &gt;&gt; 8) &amp; 0x03];&#13;
	return o;&#13;
}&#13;
function write_BrtWbProp(data, o) {&#13;
	if(!o) o = new_buf(72);&#13;
	var flags = 0;&#13;
	if(data) {&#13;
		/* TODO: mirror parse_BrtWbProp fields */&#13;
		if(data.date1904) flags |= 0x01;&#13;
		if(data.filterPrivacy) flags |= 0x08;&#13;
	}&#13;
	o.write_shift(4, flags);&#13;
	o.write_shift(4, 0);&#13;
	write_XLSBCodeName(data &amp;&amp; data.CodeName || "ThisWorkbook", o);&#13;
	return o.slice(0, o.l);&#13;
}&#13;
&#13;
function parse_BrtFRTArchID$(data, length) {&#13;
	var o = {};&#13;
	data.read_shift(4);&#13;
	o.ArchID = data.read_shift(4);&#13;
	data.l += length - 8;&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.4.687 BrtName */&#13;
function parse_BrtName(data, length, opts) {&#13;
	var end = data.l + length;&#13;
	var flags = data.read_shift(4);&#13;
	data.l += 1; //var chKey = data.read_shift(1);&#13;
	var itab = data.read_shift(4);&#13;
	var name = parse_XLNameWideString(data);&#13;
	var formula = parse_XLSBNameParsedFormula(data, 0, opts);&#13;
	var comment = parse_XLNullableWideString(data);&#13;
	if(flags &amp; 0x20) name = "_xlnm." + name;&#13;
	//if(0 /* fProc */) {&#13;
		// unusedstring1: XLNullableWideString&#13;
		// description: XLNullableWideString&#13;
		// helpTopic: XLNullableWideString&#13;
		// unusedstring2: XLNullableWideString&#13;
	//}&#13;
	data.l = end;&#13;
	var out = ({Name:name, Ptg:formula, Flags: flags});&#13;
	if(itab &lt; 0xFFFFFFF) out.Sheet = itab;&#13;
	if(comment) out.Comment = comment;&#13;
	return out;&#13;
}&#13;
function write_BrtName(name, wb) {&#13;
	var o = new_buf(9);&#13;
	var flags = 0;&#13;
	var dname = name.Name;&#13;
	if(XLSLblBuiltIn.indexOf(dname) &gt; -1) { flags |= 0x20; dname = dname.slice(6); }&#13;
	o.write_shift(4, flags); // flags&#13;
	o.write_shift(1, 0); // chKey&#13;
	o.write_shift(4, name.Sheet == null ? 0xFFFFFFFF : name.Sheet);&#13;
&#13;
	var arr = [&#13;
		o,&#13;
		write_XLWideString(dname),&#13;
		write_XLSBNameParsedFormula(name.Ref, wb)&#13;
	];&#13;
	if(name.Comment) arr.push(write_XLNullableWideString(name.Comment));&#13;
	else {&#13;
		var x = new_buf(4);&#13;
		x.write_shift(4, 0xFFFFFFFF);&#13;
		arr.push(x);&#13;
	}&#13;
&#13;
	// if macro (flags &amp; 0x0F):&#13;
	// write_shift(4, 0xFFFFFFFF);&#13;
	// write_XLNullableWideString(description)&#13;
	// write_XLNullableWideString(helpTopic)&#13;
	// write_shift(4, 0xFFFFFFFF);&#13;
&#13;
	return bconcat(arr);&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.1.7.61 Workbook */&#13;
function parse_wb_bin(data, opts) {&#13;
	var wb = { AppVersion:{}, WBProps:{}, WBView:[], Sheets:[], CalcPr:{}, xmlns: "" };&#13;
	var state = [];&#13;
	var pass = false;&#13;
&#13;
	if(!opts) opts = {};&#13;
	opts.biff = 12;&#13;
&#13;
	var Names = [];&#13;
	var supbooks = ([[]]);&#13;
	supbooks.SheetNames = [];&#13;
	supbooks.XTI = [];&#13;
&#13;
	XLSBRecordEnum[0x0010] = { n:"BrtFRTArchID$", f:parse_BrtFRTArchID$ };&#13;
&#13;
	recordhopper(data, function hopper_wb(val, R, RT) {&#13;
		switch(RT) {&#13;
			case 0x009C: /* 'BrtBundleSh' */&#13;
				supbooks.SheetNames.push(val.name);&#13;
				wb.Sheets.push(val); break;&#13;
&#13;
			case 0x0099: /* 'BrtWbProp' */&#13;
				wb.WBProps = val; break;&#13;
&#13;
			case 0x0027: /* 'BrtName' */&#13;
				if(val.Sheet != null) opts.SID = val.Sheet;&#13;
				val.Ref = stringify_formula(val.Ptg, null, null, supbooks, opts);&#13;
				delete opts.SID;&#13;
				delete val.Ptg;&#13;
				Names.push(val);&#13;
				break;&#13;
			case 0x040C: /* 'BrtNameExt' */ break;&#13;
&#13;
			case 0x0165: /* 'BrtSupSelf' */&#13;
			case 0x0166: /* 'BrtSupSame' */&#13;
			case 0x0163: /* 'BrtSupBookSrc' */&#13;
			case 0x029B: /* 'BrtSupAddin' */&#13;
				if(!supbooks[0].length) supbooks[0] = [RT, val];&#13;
				else supbooks.push([RT, val]);&#13;
				supbooks[supbooks.length - 1].XTI = [];&#13;
				break;&#13;
			case 0x016A: /* 'BrtExternSheet' */&#13;
				if(supbooks.length === 0) { supbooks[0] = []; supbooks[0].XTI = []; }&#13;
				supbooks[supbooks.length - 1].XTI = supbooks[supbooks.length - 1].XTI.concat(val);&#13;
				supbooks.XTI = supbooks.XTI.concat(val);&#13;
				break;&#13;
			case 0x0169: /* 'BrtPlaceholderName' */&#13;
				break;&#13;
&#13;
			case 0x0817: /* 'BrtAbsPath15' */&#13;
			case 0x009E: /* 'BrtBookView' */&#13;
			case 0x008F: /* 'BrtBeginBundleShs' */&#13;
			case 0x0298: /* 'BrtBeginFnGroup' */&#13;
			case 0x0161: /* 'BrtBeginExternals' */&#13;
				break;&#13;
&#13;
			/* case 'BrtModelTimeGroupingCalcCol' */&#13;
			case 0x0C00: /* 'BrtUid' */&#13;
			case 0x0C01: /* 'BrtRevisionPtr' */&#13;
			case 0x0216: /* 'BrtBookProtection' */&#13;
			case 0x02A5: /* 'BrtBookProtectionIso' */&#13;
			case 0x009D: /* 'BrtCalcProp' */&#13;
			case 0x0262: /* 'BrtCrashRecErr' */&#13;
			case 0x0802: /* 'BrtDecoupledPivotCacheID' */&#13;
			case 0x009B: /* 'BrtFileRecover' */&#13;
			case 0x0224: /* 'BrtFileSharing' */&#13;
			case 0x02A4: /* 'BrtFileSharingIso' */&#13;
			case 0x0080: /* 'BrtFileVersion' */&#13;
			case 0x0299: /* 'BrtFnGroup' */&#13;
			case 0x0850: /* 'BrtModelRelationship' */&#13;
			case 0x084D: /* 'BrtModelTable' */&#13;
			case 0x0225: /* 'BrtOleSize' */&#13;
			case 0x0805: /* 'BrtPivotTableRef' */&#13;
			case 0x0254: /* 'BrtSmartTagType' */&#13;
			case 0x081C: /* 'BrtTableSlicerCacheID' */&#13;
			case 0x081B: /* 'BrtTableSlicerCacheIDs' */&#13;
			case 0x0822: /* 'BrtTimelineCachePivotCacheID' */&#13;
			case 0x018D: /* 'BrtUserBookView' */&#13;
			case 0x009A: /* 'BrtWbFactoid' */&#13;
			case 0x045D: /* 'BrtWbProp14' */&#13;
			case 0x0229: /* 'BrtWebOpt' */&#13;
			case 0x082B: /* 'BrtWorkBookPr15' */&#13;
				break;&#13;
&#13;
			case 0x0023: /* 'BrtFRTBegin' */&#13;
				state.push(RT); pass = true; break;&#13;
			case 0x0024: /* 'BrtFRTEnd' */&#13;
				state.pop(); pass = false; break;&#13;
			case 0x0025: /* 'BrtACBegin' */&#13;
				state.push(RT); pass = true; break;&#13;
			case 0x0026: /* 'BrtACEnd' */&#13;
				state.pop(); pass = false; break;&#13;
&#13;
			case 0x0010: /* 'BrtFRTArchID$' */ break;&#13;
&#13;
			default:&#13;
				if(R.T){/* empty */}&#13;
				else if(!pass || (opts.WTF &amp;&amp; state[state.length-1] != 0x0025 /* BrtACBegin */ &amp;&amp; state[state.length-1] != 0x0023 /* BrtFRTBegin */)) throw new Error("Unexpected record 0x" + RT.toString(16));&#13;
		}&#13;
	}, opts);&#13;
&#13;
	parse_wb_defaults(wb);&#13;
&#13;
	// $FlowIgnore&#13;
	wb.Names = Names;&#13;
&#13;
	(wb).supbooks = supbooks;&#13;
	return wb;&#13;
}&#13;
&#13;
function write_BUNDLESHS(ba, wb) {&#13;
	write_record(ba, 0x008F /* BrtBeginBundleShs */);&#13;
	for(var idx = 0; idx != wb.SheetNames.length; ++idx) {&#13;
		var viz = wb.Workbook &amp;&amp; wb.Workbook.Sheets &amp;&amp; wb.Workbook.Sheets[idx] &amp;&amp; wb.Workbook.Sheets[idx].Hidden || 0;&#13;
		var d = { Hidden: viz, iTabID: idx+1, strRelID: 'rId' + (idx+1), name: wb.SheetNames[idx] };&#13;
		write_record(ba, 0x009C /* BrtBundleSh */, write_BrtBundleSh(d));&#13;
	}&#13;
	write_record(ba, 0x0090 /* BrtEndBundleShs */);&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.4.649 BrtFileVersion */&#13;
function write_BrtFileVersion(data, o) {&#13;
	if(!o) o = new_buf(127);&#13;
	for(var i = 0; i != 4; ++i) o.write_shift(4, 0);&#13;
	write_XLWideString("xlsx", o);&#13;
	write_XLWideString(XLSX.version, o);&#13;
	write_XLWideString(XLSX.version, o);&#13;
	write_XLWideString("7262", o);&#13;
	return o.length &gt; o.l ? o.slice(0, o.l) : o;&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.4.301 BrtBookView */&#13;
function write_BrtBookView(idx, o) {&#13;
	if(!o) o = new_buf(29);&#13;
	o.write_shift(-4, 0);&#13;
	o.write_shift(-4, 460);&#13;
	o.write_shift(4,  28800);&#13;
	o.write_shift(4,  17600);&#13;
	o.write_shift(4,  500);&#13;
	o.write_shift(4,  idx);&#13;
	o.write_shift(4,  idx);&#13;
	var flags = 0x78;&#13;
	o.write_shift(1,  flags);&#13;
	return o.length &gt; o.l ? o.slice(0, o.l) : o;&#13;
}&#13;
&#13;
function write_BOOKVIEWS(ba, wb) {&#13;
	/* required if hidden tab appears before visible tab */&#13;
	if(!wb.Workbook || !wb.Workbook.Sheets) return;&#13;
	var sheets = wb.Workbook.Sheets;&#13;
	var i = 0, vistab = -1, hidden = -1;&#13;
	for(; i &lt; sheets.length; ++i) {&#13;
		if(!sheets[i] || !sheets[i].Hidden &amp;&amp; vistab == -1) vistab = i;&#13;
		else if(sheets[i].Hidden == 1 &amp;&amp; hidden == -1) hidden = i;&#13;
	}&#13;
	if(hidden &gt; vistab) return;&#13;
	write_record(ba, 0x0087 /* BrtBeginBookViews */);&#13;
	write_record(ba, 0x009E /* BrtBookView */, write_BrtBookView(vistab));&#13;
	/* 1*(BrtBookView *FRT) */&#13;
	write_record(ba, 0x0088 /* BrtEndBookViews */);&#13;
}&#13;
&#13;
function write_BRTNAMES(ba, wb) {&#13;
	if(!wb.Workbook || !wb.Workbook.Names) return;&#13;
	wb.Workbook.Names.forEach(function(name) { try {&#13;
		if(name.Flags &amp; 0x0e) return; // TODO: macro name write&#13;
		write_record(ba, 0x0027 /* BrtName */, write_BrtName(name, wb));&#13;
	} catch(e) {&#13;
		console.error("Could not serialize defined name " + JSON.stringify(name));&#13;
	} });&#13;
}&#13;
&#13;
function write_SELF_EXTERNS_xlsb(wb) {&#13;
	var L = wb.SheetNames.length;&#13;
	var o = new_buf(12 * L + 28);&#13;
	o.write_shift(4, L + 2);&#13;
	o.write_shift(4, 0); o.write_shift(4, -2); o.write_shift(4, -2); // workbook-level reference&#13;
	o.write_shift(4, 0); o.write_shift(4, -1); o.write_shift(4, -1); // #REF!...&#13;
	for(var i = 0; i &lt; L; ++i) {&#13;
		o.write_shift(4, 0); o.write_shift(4, i); o.write_shift(4, i);&#13;
	}&#13;
	return o;&#13;
}&#13;
function write_EXTERNALS_xlsb(ba, wb) {&#13;
	write_record(ba, 0x0161 /* BrtBeginExternals */);&#13;
	write_record(ba, 0x0165 /* BrtSupSelf */);&#13;
	write_record(ba, 0x016A /* BrtExternSheet */, write_SELF_EXTERNS_xlsb(wb, 0));&#13;
	write_record(ba, 0x0162 /* BrtEndExternals */);&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.4.305 BrtCalcProp */&#13;
/*function write_BrtCalcProp(data, o) {&#13;
	if(!o) o = new_buf(26);&#13;
	o.write_shift(4,0); // force recalc&#13;
	o.write_shift(4,1);&#13;
	o.write_shift(4,0);&#13;
	write_Xnum(0, o);&#13;
	o.write_shift(-4, 1023);&#13;
	o.write_shift(1, 0x33);&#13;
	o.write_shift(1, 0x00);&#13;
	return o;&#13;
}*/&#13;
&#13;
/* [MS-XLSB] 2.4.646 BrtFileRecover */&#13;
/*function write_BrtFileRecover(data, o) {&#13;
	if(!o) o = new_buf(1);&#13;
	o.write_shift(1,0);&#13;
	return o;&#13;
}*/&#13;
&#13;
/* [MS-XLSB] 2.1.7.61 Workbook */&#13;
function write_wb_bin(wb, opts) {&#13;
	var ba = buf_array();&#13;
	write_record(ba, 0x0083 /* BrtBeginBook */);&#13;
	write_record(ba, 0x0080 /* BrtFileVersion */, write_BrtFileVersion());&#13;
	/* [[BrtFileSharingIso] BrtFileSharing] */&#13;
	write_record(ba, 0x0099 /* BrtWbProp */, write_BrtWbProp(wb.Workbook &amp;&amp; wb.Workbook.WBProps || null));&#13;
	/* [ACABSPATH] */&#13;
	/* [[BrtBookProtectionIso] BrtBookProtection] */&#13;
	write_BOOKVIEWS(ba, wb, opts);&#13;
	write_BUNDLESHS(ba, wb, opts);&#13;
	/* [FNGROUP] */&#13;
	write_EXTERNALS_xlsb(ba, wb);&#13;
	if((wb.Workbook||{}).Names) write_BRTNAMES(ba, wb);&#13;
	/* write_record(ba, 0x009D BrtCalcProp, write_BrtCalcProp()); */&#13;
	/* [BrtOleSize] */&#13;
	/* *(BrtUserBookView *FRT) */&#13;
	/* [PIVOTCACHEIDS] */&#13;
	/* [BrtWbFactoid] */&#13;
	/* [SMARTTAGTYPES] */&#13;
	/* [BrtWebOpt] */&#13;
	/* write_record(ba, 0x009B BrtFileRecover, write_BrtFileRecover()); */&#13;
	/* [WEBPUBITEMS] */&#13;
	/* [CRERRS] */&#13;
	/* FRTWORKBOOK */&#13;
	write_record(ba, 0x0084 /* BrtEndBook */);&#13;
&#13;
	return ba.end();&#13;
}&#13;
function parse_wb(data, name, opts) {&#13;
	if(name.slice(-4)===".bin") return parse_wb_bin((data), opts);&#13;
	return parse_wb_xml((data), opts);&#13;
}&#13;
&#13;
function parse_ws(data, name, idx, opts, rels, wb, themes, styles) {&#13;
	if(name.slice(-4)===".bin") return parse_ws_bin((data), opts, idx, rels, wb, themes, styles);&#13;
	return parse_ws_xml((data), opts, idx, rels, wb, themes, styles);&#13;
}&#13;
&#13;
function parse_cs(data, name, idx, opts, rels, wb, themes, styles) {&#13;
	if(name.slice(-4)===".bin") return parse_cs_bin((data), opts, idx, rels, wb, themes, styles);&#13;
	return parse_cs_xml((data), opts, idx, rels, wb, themes, styles);&#13;
}&#13;
&#13;
function parse_ms(data, name, idx, opts, rels, wb, themes, styles) {&#13;
	if(name.slice(-4)===".bin") return parse_ms_bin((data), opts, idx, rels, wb, themes, styles);&#13;
	return parse_ms_xml((data), opts, idx, rels, wb, themes, styles);&#13;
}&#13;
&#13;
function parse_ds(data, name, idx, opts, rels, wb, themes, styles) {&#13;
	if(name.slice(-4)===".bin") return parse_ds_bin((data), opts, idx, rels, wb, themes, styles);&#13;
	return parse_ds_xml((data), opts, idx, rels, wb, themes, styles);&#13;
}&#13;
&#13;
function parse_sty(data, name, themes, opts) {&#13;
	if(name.slice(-4)===".bin") return parse_sty_bin((data), themes, opts);&#13;
	return parse_sty_xml((data), themes, opts);&#13;
}&#13;
&#13;
function parse_sst(data, name, opts) {&#13;
	if(name.slice(-4)===".bin") return parse_sst_bin((data), opts);&#13;
	return parse_sst_xml((data), opts);&#13;
}&#13;
&#13;
function parse_cmnt(data, name, opts) {&#13;
	if(name.slice(-4)===".bin") return parse_comments_bin((data), opts);&#13;
	return parse_comments_xml((data), opts);&#13;
}&#13;
&#13;
function parse_cc(data, name, opts) {&#13;
	if(name.slice(-4)===".bin") return parse_cc_bin((data), name, opts);&#13;
	return parse_cc_xml((data), name, opts);&#13;
}&#13;
&#13;
function parse_xlink(data, rel, name, opts) {&#13;
	if(name.slice(-4)===".bin") return parse_xlink_bin((data), rel, name, opts);&#13;
	return parse_xlink_xml((data), rel, name, opts);&#13;
}&#13;
&#13;
function parse_xlmeta(data, name, opts) {&#13;
	if(name.slice(-4)===".bin") return parse_xlmeta_bin((data), name, opts);&#13;
	return parse_xlmeta_xml((data), name, opts);&#13;
}&#13;
var attregexg2=/([\w:]+)=((?:")([^"]*)(?:")|(?:')([^']*)(?:'))/g;&#13;
var attregex2=/([\w:]+)=((?:")(?:[^"]*)(?:")|(?:')(?:[^']*)(?:'))/;&#13;
function xlml_parsexmltag(tag, skip_root) {&#13;
	var words = tag.split(/\s+/);&#13;
	var z = ([]); if(!skip_root) z[0] = words[0];&#13;
	if(words.length === 1) return z;&#13;
	var m = tag.match(attregexg2), y, j, w, i;&#13;
	if(m) for(i = 0; i != m.length; ++i) {&#13;
		y = m[i].match(attregex2);&#13;
if((j=y[1].indexOf(":")) === -1) z[y[1]] = y[2].slice(1,y[2].length-1);&#13;
		else {&#13;
			if(y[1].slice(0,6) === "xmlns:") w = "xmlns"+y[1].slice(6);&#13;
			else w = y[1].slice(j+1);&#13;
			z[w] = y[2].slice(1,y[2].length-1);&#13;
		}&#13;
	}&#13;
	return z;&#13;
}&#13;
function xlml_parsexmltagobj(tag) {&#13;
	var words = tag.split(/\s+/);&#13;
	var z = {};&#13;
	if(words.length === 1) return z;&#13;
	var m = tag.match(attregexg2), y, j, w, i;&#13;
	if(m) for(i = 0; i != m.length; ++i) {&#13;
		y = m[i].match(attregex2);&#13;
if((j=y[1].indexOf(":")) === -1) z[y[1]] = y[2].slice(1,y[2].length-1);&#13;
		else {&#13;
			if(y[1].slice(0,6) === "xmlns:") w = "xmlns"+y[1].slice(6);&#13;
			else w = y[1].slice(j+1);&#13;
			z[w] = y[2].slice(1,y[2].length-1);&#13;
		}&#13;
	}&#13;
	return z;&#13;
}&#13;
&#13;
// ----&#13;
&#13;
/* map from xlml named formats to SSF TODO: localize */&#13;
var XLMLFormatMap;&#13;
&#13;
function xlml_format(format, value) {&#13;
	var fmt = XLMLFormatMap[format] || unescapexml(format);&#13;
	if(fmt === "General") return SSF_general(value);&#13;
	return SSF_format(fmt, value);&#13;
}&#13;
&#13;
function xlml_set_custprop(Custprops, key, cp, val) {&#13;
	var oval = val;&#13;
	switch((cp[0].match(/dt:dt="([\w.]+)"/)||["",""])[1]) {&#13;
		case "boolean": oval = parsexmlbool(val); break;&#13;
		case "i2": case "int": oval = parseInt(val, 10); break;&#13;
		case "r4": case "float": oval = parseFloat(val); break;&#13;
		case "date": case "dateTime.tz": oval = parseDate(val); break;&#13;
		case "i8": case "string": case "fixed": case "uuid": case "bin.base64": break;&#13;
		default: throw new Error("bad custprop:" + cp[0]);&#13;
	}&#13;
	Custprops[unescapexml(key)] = oval;&#13;
}&#13;
&#13;
function safe_format_xlml(cell, nf, o) {&#13;
	if(cell.t === 'z') return;&#13;
	if(!o || o.cellText !== false) try {&#13;
		if(cell.t === 'e') { cell.w = cell.w || BErr[cell.v]; }&#13;
		else if(nf === "General") {&#13;
			if(cell.t === 'n') {&#13;
				if((cell.v|0) === cell.v) cell.w = cell.v.toString(10);&#13;
				else cell.w = SSF_general_num(cell.v);&#13;
			}&#13;
			else cell.w = SSF_general(cell.v);&#13;
		}&#13;
		else cell.w = xlml_format(nf||"General", cell.v);&#13;
	} catch(e) { if(o.WTF) throw e; }&#13;
	try {&#13;
		var z = XLMLFormatMap[nf]||nf||"General";&#13;
		if(o.cellNF) cell.z = z;&#13;
		if(o.cellDates &amp;&amp; cell.t == 'n' &amp;&amp; fmt_is_date(z)) {&#13;
			var _d = SSF_parse_date_code(cell.v); if(_d) { cell.t = 'd'; cell.v = new Date(_d.y, _d.m-1,_d.d,_d.H,_d.M,_d.S,_d.u); }&#13;
		}&#13;
	} catch(e) { if(o.WTF) throw e; }&#13;
}&#13;
&#13;
function process_style_xlml(styles, stag, opts) {&#13;
	if(opts.cellStyles) {&#13;
		if(stag.Interior) {&#13;
			var I = stag.Interior;&#13;
			if(I.Pattern) I.patternType = XLMLPatternTypeMap[I.Pattern] || I.Pattern;&#13;
		}&#13;
	}&#13;
	styles[stag.ID] = stag;&#13;
}&#13;
&#13;
/* TODO: there must exist some form of OSP-blessed spec */&#13;
function parse_xlml_data(xml, ss, data, cell, base, styles, csty, row, arrayf, o) {&#13;
	var nf = "General", sid = cell.StyleID, S = {}; o = o || {};&#13;
	var interiors = [];&#13;
	var i = 0;&#13;
	if(sid === undefined &amp;&amp; row) sid = row.StyleID;&#13;
	if(sid === undefined &amp;&amp; csty) sid = csty.StyleID;&#13;
	while(styles[sid] !== undefined) {&#13;
		if(styles[sid].nf) nf = styles[sid].nf;&#13;
		if(styles[sid].Interior) interiors.push(styles[sid].Interior);&#13;
		if(!styles[sid].Parent) break;&#13;
		sid = styles[sid].Parent;&#13;
	}&#13;
	switch(data.Type) {&#13;
		case 'Boolean':&#13;
			cell.t = 'b';&#13;
			cell.v = parsexmlbool(xml);&#13;
			break;&#13;
		case 'String':&#13;
			cell.t = 's'; cell.r = xlml_fixstr(unescapexml(xml));&#13;
			cell.v = (xml.indexOf("&lt;") &gt; -1 ? unescapexml(ss||xml).replace(/&lt;.*?&gt;/g, "") : cell.r); // todo: BR etc&#13;
			break;&#13;
		case 'DateTime':&#13;
			if(xml.slice(-1) != "Z") xml += "Z";&#13;
			cell.v = (parseDate(xml) - new Date(Date.UTC(1899, 11, 30))) / (24 * 60 * 60 * 1000);&#13;
			if(cell.v !== cell.v) cell.v = unescapexml(xml);&#13;
			else if(cell.v&lt;60) cell.v = cell.v -1;&#13;
			if(!nf || nf == "General") nf = "yyyy-mm-dd";&#13;
			/* falls through */&#13;
		case 'Number':&#13;
			if(cell.v === undefined) cell.v=+xml;&#13;
			if(!cell.t) cell.t = 'n';&#13;
			break;&#13;
		case 'Error': cell.t = 'e'; cell.v = RBErr[xml]; if(o.cellText !== false) cell.w = xml; break;&#13;
		default:&#13;
			if(xml == "" &amp;&amp; ss == "") { cell.t = 'z'; }&#13;
			else { cell.t = 's'; cell.v = xlml_fixstr(ss||xml); }&#13;
			break;&#13;
	}&#13;
	safe_format_xlml(cell, nf, o);&#13;
	if(o.cellFormula !== false) {&#13;
		if(cell.Formula) {&#13;
			var fstr = unescapexml(cell.Formula);&#13;
			/* strictly speaking, the leading = is required but some writers omit */&#13;
			if(fstr.charCodeAt(0) == 61 /* = */) fstr = fstr.slice(1);&#13;
			cell.f = rc_to_a1(fstr, base);&#13;
			delete cell.Formula;&#13;
			if(cell.ArrayRange == "RC") cell.F = rc_to_a1("RC:RC", base);&#13;
			else if(cell.ArrayRange) {&#13;
				cell.F = rc_to_a1(cell.ArrayRange, base);&#13;
				arrayf.push([safe_decode_range(cell.F), cell.F]);&#13;
			}&#13;
		} else {&#13;
			for(i = 0; i &lt; arrayf.length; ++i)&#13;
				if(base.r &gt;= arrayf[i][0].s.r &amp;&amp; base.r &lt;= arrayf[i][0].e.r)&#13;
					if(base.c &gt;= arrayf[i][0].s.c &amp;&amp; base.c &lt;= arrayf[i][0].e.c)&#13;
						cell.F = arrayf[i][1];&#13;
		}&#13;
	}&#13;
	if(o.cellStyles) {&#13;
		interiors.forEach(function(x) {&#13;
			if(!S.patternType &amp;&amp; x.patternType) S.patternType = x.patternType;&#13;
		});&#13;
		cell.s = S;&#13;
	}&#13;
	if(cell.StyleID !== undefined) cell.ixfe = cell.StyleID;&#13;
}&#13;
&#13;
function xlml_prefix_dname(dname) {&#13;
	return XLSLblBuiltIn.indexOf("_xlnm." + dname) &gt; -1 ? "_xlnm." + dname : dname;&#13;
}&#13;
&#13;
function xlml_clean_comment(comment) {&#13;
	comment.t = comment.v || "";&#13;
	comment.t = comment.t.replace(/\r\n/g,"\n").replace(/\r/g,"\n");&#13;
	comment.v = comment.w = comment.ixfe = undefined;&#13;
}&#13;
&#13;
/* TODO: Everything */&#13;
function parse_xlml_xml(d, _opts) {&#13;
	var opts = _opts || {};&#13;
	make_ssf();&#13;
	var str = debom(xlml_normalize(d));&#13;
	if(opts.type == 'binary' || opts.type == 'array' || opts.type == 'base64') {&#13;
		if(typeof $cptable !== 'undefined') str = $cptable.utils.decode(65001, char_codes(str));&#13;
		else str = utf8read(str);&#13;
	}&#13;
	var opening = str.slice(0, 1024).toLowerCase(), ishtml = false;&#13;
	opening = opening.replace(/".*?"/g, "");&#13;
	if((opening.indexOf("&gt;") &amp; 1023) &gt; Math.min((opening.indexOf(",") &amp; 1023), (opening.indexOf(";")&amp;1023))) { var _o = dup(opts); _o.type = "string"; return PRN.to_workbook(str, _o); }&#13;
	if(opening.indexOf("&lt;?xml") == -1) ["html", "table", "head", "meta", "script", "style", "div"].forEach(function(tag) { if(opening.indexOf("&lt;" + tag) &gt;= 0) ishtml = true; });&#13;
	if(ishtml) return html_to_workbook(str, opts);&#13;
&#13;
	XLMLFormatMap = ({&#13;
		"General Number": "General",&#13;
		"General Date": table_fmt[22],&#13;
		"Long Date": "dddd, mmmm dd, yyyy",&#13;
		"Medium Date": table_fmt[15],&#13;
		"Short Date": table_fmt[14],&#13;
		"Long Time": table_fmt[19],&#13;
		"Medium Time": table_fmt[18],&#13;
		"Short Time": table_fmt[20],&#13;
		"Currency": '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',&#13;
		"Fixed": table_fmt[2],&#13;
		"Standard": table_fmt[4],&#13;
		"Percent": table_fmt[10],&#13;
		"Scientific": table_fmt[11],&#13;
		"Yes/No": '"Yes";"Yes";"No";@',&#13;
		"True/False": '"True";"True";"False";@',&#13;
		"On/Off": '"Yes";"Yes";"No";@'&#13;
	});&#13;
&#13;
&#13;
	var Rn;&#13;
	var state = [], tmp;&#13;
	if(DENSE != null &amp;&amp; opts.dense == null) opts.dense = DENSE;&#13;
	var sheets = {}, sheetnames = [], cursheet = (opts.dense ? [] : {}), sheetname = "";&#13;
	var cell = ({}), row = {};// eslint-disable-line no-unused-vars&#13;
	var dtag = xlml_parsexmltag('&lt;Data ss:Type="String"&gt;'), didx = 0;&#13;
	var c = 0, r = 0;&#13;
	var refguess = {s: {r:2000000, c:2000000}, e: {r:0, c:0} };&#13;
	var styles = {}, stag = {};&#13;
	var ss = "", fidx = 0;&#13;
	var merges = [];&#13;
	var Props = {}, Custprops = {}, pidx = 0, cp = [];&#13;
	var comments = [], comment = ({});&#13;
	var cstys = [], csty, seencol = false;&#13;
	var arrayf = [];&#13;
	var rowinfo = [], rowobj = {}, cc = 0, rr = 0;&#13;
	var Workbook = ({ Sheets:[], WBProps:{date1904:false} }), wsprops = {};&#13;
	xlmlregex.lastIndex = 0;&#13;
	str = str.replace(/&lt;!--([\s\S]*?)--&gt;/mg,"");&#13;
	var raw_Rn3 = "";&#13;
	while((Rn = xlmlregex.exec(str))) switch((Rn[3] = (raw_Rn3 = Rn[3]).toLowerCase())) {&#13;
		case 'data' /*case 'Data'*/:&#13;
			if(raw_Rn3 == "data") {&#13;
				if(Rn[1]==='/'){if((tmp=state.pop())[0]!==Rn[3]) throw new Error("Bad state: "+tmp.join("|"));}&#13;
				else if(Rn[0].charAt(Rn[0].length-2) !== '/') state.push([Rn[3], true]);&#13;
				break;&#13;
			}&#13;
			if(state[state.length-1][1]) break;&#13;
			if(Rn[1]==='/') parse_xlml_data(str.slice(didx, Rn.index), ss, dtag, state[state.length-1][0]==/*"Comment"*/"comment"?comment:cell, {c:c,r:r}, styles, cstys[c], row, arrayf, opts);&#13;
			else { ss = ""; dtag = xlml_parsexmltag(Rn[0]); didx = Rn.index + Rn[0].length; }&#13;
			break;&#13;
		case 'cell' /*case 'Cell'*/:&#13;
			if(Rn[1]==='/'){&#13;
				if(comments.length &gt; 0) cell.c = comments;&#13;
				if((!opts.sheetRows || opts.sheetRows &gt; r) &amp;&amp; cell.v !== void 0) {&#13;
					if(opts.dense) {&#13;
						if(!cursheet[r]) cursheet[r] = [];&#13;
						cursheet[r][c] = cell;&#13;
					} else cursheet[encode_col(c) + encode_row(r)] = cell;&#13;
				}&#13;
				if(cell.HRef) {&#13;
					cell.l = ({Target:unescapexml(cell.HRef)});&#13;
					if(cell.HRefScreenTip) cell.l.Tooltip = cell.HRefScreenTip;&#13;
					delete cell.HRef; delete cell.HRefScreenTip;&#13;
				}&#13;
				if(cell.MergeAcross || cell.MergeDown) {&#13;
					cc = c + (parseInt(cell.MergeAcross,10)|0);&#13;
					rr = r + (parseInt(cell.MergeDown,10)|0);&#13;
					if(cc &gt; c || rr &gt; r) merges.push({s:{c:c,r:r},e:{c:cc,r:rr}});&#13;
				}&#13;
				if(!opts.sheetStubs) { if(cell.MergeAcross) c = cc + 1; else ++c; }&#13;
				else if(cell.MergeAcross || cell.MergeDown) {&#13;
for(var cma = c; cma &lt;= cc; ++cma) {&#13;
						for(var cmd = r; cmd &lt;= rr; ++cmd) {&#13;
							if(cma &gt; c || cmd &gt; r) {&#13;
								if(opts.dense) {&#13;
									if(!cursheet[cmd]) cursheet[cmd] = [];&#13;
									cursheet[cmd][cma] = {t:'z'};&#13;
								} else cursheet[encode_col(cma) + encode_row(cmd)] = {t:'z'};&#13;
							}&#13;
						}&#13;
					}&#13;
					c = cc + 1;&#13;
				}&#13;
				else ++c;&#13;
			} else {&#13;
				cell = xlml_parsexmltagobj(Rn[0]);&#13;
				if(cell.Index) c = +cell.Index - 1;&#13;
				if(c &lt; refguess.s.c) refguess.s.c = c;&#13;
				if(c &gt; refguess.e.c) refguess.e.c = c;&#13;
				if(Rn[0].slice(-2) === "/&gt;") ++c;&#13;
				comments = [];&#13;
			}&#13;
			break;&#13;
		case 'row' /*case 'Row'*/:&#13;
			if(Rn[1]==='/' || Rn[0].slice(-2) === "/&gt;") {&#13;
				if(r &lt; refguess.s.r) refguess.s.r = r;&#13;
				if(r &gt; refguess.e.r) refguess.e.r = r;&#13;
				if(Rn[0].slice(-2) === "/&gt;") {&#13;
					row = xlml_parsexmltag(Rn[0]);&#13;
					if(row.Index) r = +row.Index - 1;&#13;
				}&#13;
				c = 0; ++r;&#13;
			} else {&#13;
				row = xlml_parsexmltag(Rn[0]);&#13;
				if(row.Index) r = +row.Index - 1;&#13;
				rowobj = {};&#13;
				if(row.AutoFitHeight == "0" || row.Height) {&#13;
					rowobj.hpx = parseInt(row.Height, 10); rowobj.hpt = px2pt(rowobj.hpx);&#13;
					rowinfo[r] = rowobj;&#13;
				}&#13;
				if(row.Hidden == "1") { rowobj.hidden = true; rowinfo[r] = rowobj; }&#13;
			}&#13;
			break;&#13;
		case 'worksheet' /*case 'Worksheet'*/: /* TODO: read range from FullRows/FullColumns */&#13;
			if(Rn[1]==='/'){&#13;
				if((tmp=state.pop())[0]!==Rn[3]) throw new Error("Bad state: "+tmp.join("|"));&#13;
				sheetnames.push(sheetname);&#13;
				if(refguess.s.r &lt;= refguess.e.r &amp;&amp; refguess.s.c &lt;= refguess.e.c) {&#13;
					cursheet["!ref"] = encode_range(refguess);&#13;
					if(opts.sheetRows &amp;&amp; opts.sheetRows &lt;= refguess.e.r) {&#13;
						cursheet["!fullref"] = cursheet["!ref"];&#13;
						refguess.e.r = opts.sheetRows - 1;&#13;
						cursheet["!ref"] = encode_range(refguess);&#13;
					}&#13;
				}&#13;
				if(merges.length) cursheet["!merges"] = merges;&#13;
				if(cstys.length &gt; 0) cursheet["!cols"] = cstys;&#13;
				if(rowinfo.length &gt; 0) cursheet["!rows"] = rowinfo;&#13;
				sheets[sheetname] = cursheet;&#13;
			} else {&#13;
				refguess = {s: {r:2000000, c:2000000}, e: {r:0, c:0} };&#13;
				r = c = 0;&#13;
				state.push([Rn[3], false]);&#13;
				tmp = xlml_parsexmltag(Rn[0]);&#13;
				sheetname = unescapexml(tmp.Name);&#13;
				cursheet = (opts.dense ? [] : {});&#13;
				merges = [];&#13;
				arrayf = [];&#13;
				rowinfo = [];&#13;
				wsprops = {name:sheetname, Hidden:0};&#13;
				Workbook.Sheets.push(wsprops);&#13;
			}&#13;
			break;&#13;
		case 'table' /*case 'Table'*/:&#13;
			if(Rn[1]==='/'){if((tmp=state.pop())[0]!==Rn[3]) throw new Error("Bad state: "+tmp.join("|"));}&#13;
			else if(Rn[0].slice(-2) == "/&gt;") break;&#13;
			else {&#13;
				state.push([Rn[3], false]);&#13;
				cstys = []; seencol = false;&#13;
			}&#13;
			break;&#13;
&#13;
		case 'style' /*case 'Style'*/:&#13;
			if(Rn[1]==='/') process_style_xlml(styles, stag, opts);&#13;
			else stag = xlml_parsexmltag(Rn[0]);&#13;
			break;&#13;
&#13;
		case 'numberformat' /*case 'NumberFormat'*/:&#13;
			stag.nf = unescapexml(xlml_parsexmltag(Rn[0]).Format || "General");&#13;
			if(XLMLFormatMap[stag.nf]) stag.nf = XLMLFormatMap[stag.nf];&#13;
			for(var ssfidx = 0; ssfidx != 0x188; ++ssfidx) if(table_fmt[ssfidx] == stag.nf) break;&#13;
			if(ssfidx == 0x188) for(ssfidx = 0x39; ssfidx != 0x188; ++ssfidx) if(table_fmt[ssfidx] == null) { SSF__load(stag.nf, ssfidx); break; }&#13;
			break;&#13;
&#13;
		case 'column' /*case 'Column'*/:&#13;
			if(state[state.length-1][0] !== /*'Table'*/'table') break;&#13;
			if(Rn[1]==='/') break;&#13;
			csty = xlml_parsexmltag(Rn[0]);&#13;
			if(csty.Hidden) { csty.hidden = true; delete csty.Hidden; }&#13;
			if(csty.Width) csty.wpx = parseInt(csty.Width, 10);&#13;
			if(!seencol &amp;&amp; csty.wpx &gt; 10) {&#13;
				seencol = true; MDW = DEF_MDW; //find_mdw_wpx(csty.wpx);&#13;
				for(var _col = 0; _col &lt; cstys.length; ++_col) if(cstys[_col]) process_col(cstys[_col]);&#13;
			}&#13;
			if(seencol) process_col(csty);&#13;
			cstys[(csty.Index-1||cstys.length)] = csty;&#13;
			for(var i = 0; i &lt; +csty.Span; ++i) cstys[cstys.length] = dup(csty);&#13;
			break;&#13;
&#13;
		case 'namedrange' /*case 'NamedRange'*/:&#13;
			if(Rn[1]==='/') break;&#13;
			if(!Workbook.Names) Workbook.Names = [];&#13;
			var _NamedRange = parsexmltag(Rn[0]);&#13;
			var _DefinedName = ({&#13;
				Name: xlml_prefix_dname(_NamedRange.Name),&#13;
				Ref: rc_to_a1(_NamedRange.RefersTo.slice(1), {r:0, c:0})&#13;
			});&#13;
			if(Workbook.Sheets.length&gt;0) _DefinedName.Sheet=Workbook.Sheets.length-1;&#13;
Workbook.Names.push(_DefinedName);&#13;
			break;&#13;
&#13;
		case 'namedcell' /*case 'NamedCell'*/: break;&#13;
		case 'b' /*case 'B'*/: break;&#13;
		case 'i' /*case 'I'*/: break;&#13;
		case 'u' /*case 'U'*/: break;&#13;
		case 's' /*case 'S'*/: break;&#13;
		case 'em' /*case 'EM'*/: break;&#13;
		case 'h2' /*case 'H2'*/: break;&#13;
		case 'h3' /*case 'H3'*/: break;&#13;
		case 'sub' /*case 'Sub'*/: break;&#13;
		case 'sup' /*case 'Sup'*/: break;&#13;
		case 'span' /*case 'Span'*/: break;&#13;
		case 'alignment' /*case 'Alignment'*/:&#13;
			break;&#13;
		case 'borders' /*case 'Borders'*/: break;&#13;
		case 'border' /*case 'Border'*/: break;&#13;
		case 'font' /*case 'Font'*/:&#13;
			if(Rn[0].slice(-2) === "/&gt;") break;&#13;
			else if(Rn[1]==="/") ss += str.slice(fidx, Rn.index);&#13;
			else fidx = Rn.index + Rn[0].length;&#13;
			break;&#13;
		case 'interior' /*case 'Interior'*/:&#13;
			if(!opts.cellStyles) break;&#13;
			stag.Interior = xlml_parsexmltag(Rn[0]);&#13;
			break;&#13;
		case 'protection' /*case 'Protection'*/: break;&#13;
&#13;
		case 'author' /*case 'Author'*/:&#13;
		case 'title' /*case 'Title'*/:&#13;
		case 'description' /*case 'Description'*/:&#13;
		case 'created' /*case 'Created'*/:&#13;
		case 'keywords' /*case 'Keywords'*/:&#13;
		case 'subject' /*case 'Subject'*/:&#13;
		case 'category' /*case 'Category'*/:&#13;
		case 'company' /*case 'Company'*/:&#13;
		case 'lastauthor' /*case 'LastAuthor'*/:&#13;
		case 'lastsaved' /*case 'LastSaved'*/:&#13;
		case 'lastprinted' /*case 'LastPrinted'*/:&#13;
		case 'version' /*case 'Version'*/:&#13;
		case 'revision' /*case 'Revision'*/:&#13;
		case 'totaltime' /*case 'TotalTime'*/:&#13;
		case 'hyperlinkbase' /*case 'HyperlinkBase'*/:&#13;
		case 'manager' /*case 'Manager'*/:&#13;
		case 'contentstatus' /*case 'ContentStatus'*/:&#13;
		case 'identifier' /*case 'Identifier'*/:&#13;
		case 'language' /*case 'Language'*/:&#13;
		case 'appname' /*case 'AppName'*/:&#13;
			if(Rn[0].slice(-2) === "/&gt;") break;&#13;
			else if(Rn[1]==="/") xlml_set_prop(Props, raw_Rn3, str.slice(pidx, Rn.index));&#13;
			else pidx = Rn.index + Rn[0].length;&#13;
			break;&#13;
		case 'paragraphs' /*case 'Paragraphs'*/: break;&#13;
&#13;
		case 'styles' /*case 'Styles'*/:&#13;
		case 'workbook' /*case 'Workbook'*/:&#13;
			if(Rn[1]==='/'){if((tmp=state.pop())[0]!==Rn[3]) throw new Error("Bad state: "+tmp.join("|"));}&#13;
			else state.push([Rn[3], false]);&#13;
			break;&#13;
&#13;
		case 'comment' /*case 'Comment'*/:&#13;
			if(Rn[1]==='/'){&#13;
				if((tmp=state.pop())[0]!==Rn[3]) throw new Error("Bad state: "+tmp.join("|"));&#13;
				xlml_clean_comment(comment);&#13;
				comments.push(comment);&#13;
			} else {&#13;
				state.push([Rn[3], false]);&#13;
				tmp = xlml_parsexmltag(Rn[0]);&#13;
				comment = ({a:tmp.Author});&#13;
			}&#13;
			break;&#13;
&#13;
		case 'autofilter' /*case 'AutoFilter'*/:&#13;
			if(Rn[1]==='/'){if((tmp=state.pop())[0]!==Rn[3]) throw new Error("Bad state: "+tmp.join("|"));}&#13;
			else if(Rn[0].charAt(Rn[0].length-2) !== '/') {&#13;
				var AutoFilter = xlml_parsexmltag(Rn[0]);&#13;
				cursheet['!autofilter'] = { ref:rc_to_a1(AutoFilter.Range).replace(/\$/g,"") };&#13;
				state.push([Rn[3], true]);&#13;
			}&#13;
			break;&#13;
&#13;
		case 'name' /*case 'Name'*/: break;&#13;
&#13;
		case 'datavalidation' /*case 'DataValidation'*/:&#13;
			if(Rn[1]==='/'){&#13;
				if((tmp=state.pop())[0]!==Rn[3]) throw new Error("Bad state: "+tmp.join("|"));&#13;
			} else {&#13;
				if(Rn[0].charAt(Rn[0].length-2) !== '/') state.push([Rn[3], true]);&#13;
			}&#13;
			break;&#13;
&#13;
		case 'pixelsperinch' /*case 'PixelsPerInch'*/:&#13;
			break;&#13;
		case 'componentoptions' /*case 'ComponentOptions'*/:&#13;
		case 'documentproperties' /*case 'DocumentProperties'*/:&#13;
		case 'customdocumentproperties' /*case 'CustomDocumentProperties'*/:&#13;
		case 'officedocumentsettings' /*case 'OfficeDocumentSettings'*/:&#13;
		case 'pivottable' /*case 'PivotTable'*/:&#13;
		case 'pivotcache' /*case 'PivotCache'*/:&#13;
		case 'names' /*case 'Names'*/:&#13;
		case 'mapinfo' /*case 'MapInfo'*/:&#13;
		case 'pagebreaks' /*case 'PageBreaks'*/:&#13;
		case 'querytable' /*case 'QueryTable'*/:&#13;
		case 'sorting' /*case 'Sorting'*/:&#13;
		case 'schema' /*case 'Schema'*/: //case 'data' /*case 'data'*/:&#13;
		case 'conditionalformatting' /*case 'ConditionalFormatting'*/:&#13;
		case 'smarttagtype' /*case 'SmartTagType'*/:&#13;
		case 'smarttags' /*case 'SmartTags'*/:&#13;
		case 'excelworkbook' /*case 'ExcelWorkbook'*/:&#13;
		case 'workbookoptions' /*case 'WorkbookOptions'*/:&#13;
		case 'worksheetoptions' /*case 'WorksheetOptions'*/:&#13;
			if(Rn[1]==='/'){if((tmp=state.pop())[0]!==Rn[3]) throw new Error("Bad state: "+tmp.join("|"));}&#13;
			else if(Rn[0].charAt(Rn[0].length-2) !== '/') state.push([Rn[3], true]);&#13;
			break;&#13;
&#13;
		case 'null' /*case 'Null'*/: break;&#13;
&#13;
		default:&#13;
			/* FODS file root is &lt;office:document&gt; */&#13;
			if(state.length == 0 &amp;&amp; Rn[3] == "document") return parse_fods(str, opts);&#13;
			/* UOS file root is &lt;uof:UOF&gt; */&#13;
			if(state.length == 0 &amp;&amp; Rn[3] == "uof"/*"UOF"*/) return parse_fods(str, opts);&#13;
&#13;
			var seen = true;&#13;
			switch(state[state.length-1][0]) {&#13;
				/* OfficeDocumentSettings */&#13;
				case 'officedocumentsettings' /*case 'OfficeDocumentSettings'*/: switch(Rn[3]) {&#13;
					case 'allowpng' /*case 'AllowPNG'*/: break;&#13;
					case 'removepersonalinformation' /*case 'RemovePersonalInformation'*/: break;&#13;
					case 'downloadcomponents' /*case 'DownloadComponents'*/: break;&#13;
					case 'locationofcomponents' /*case 'LocationOfComponents'*/: break;&#13;
					case 'colors' /*case 'Colors'*/: break;&#13;
					case 'color' /*case 'Color'*/: break;&#13;
					case 'index' /*case 'Index'*/: break;&#13;
					case 'rgb' /*case 'RGB'*/: break;&#13;
					case 'targetscreensize' /*case 'TargetScreenSize'*/: break;&#13;
					case 'readonlyrecommended' /*case 'ReadOnlyRecommended'*/: break;&#13;
					default: seen = false;&#13;
				} break;&#13;
&#13;
				/* ComponentOptions */&#13;
				case 'componentoptions' /*case 'ComponentOptions'*/: switch(Rn[3]) {&#13;
					case 'toolbar' /*case 'Toolbar'*/: break;&#13;
					case 'hideofficelogo' /*case 'HideOfficeLogo'*/: break;&#13;
					case 'spreadsheetautofit' /*case 'SpreadsheetAutoFit'*/: break;&#13;
					case 'label' /*case 'Label'*/: break;&#13;
					case 'caption' /*case 'Caption'*/: break;&#13;
					case 'maxheight' /*case 'MaxHeight'*/: break;&#13;
					case 'maxwidth' /*case 'MaxWidth'*/: break;&#13;
					case 'nextsheetnumber' /*case 'NextSheetNumber'*/: break;&#13;
					default: seen = false;&#13;
				} break;&#13;
&#13;
				/* ExcelWorkbook */&#13;
				case 'excelworkbook' /*case 'ExcelWorkbook'*/: switch(Rn[3]) {&#13;
					case 'date1904' /*case 'Date1904'*/:&#13;
Workbook.WBProps.date1904 = true;&#13;
						break;&#13;
					case 'windowheight' /*case 'WindowHeight'*/: break;&#13;
					case 'windowwidth' /*case 'WindowWidth'*/: break;&#13;
					case 'windowtopx' /*case 'WindowTopX'*/: break;&#13;
					case 'windowtopy' /*case 'WindowTopY'*/: break;&#13;
					case 'tabratio' /*case 'TabRatio'*/: break;&#13;
					case 'protectstructure' /*case 'ProtectStructure'*/: break;&#13;
					case 'protectwindow' /*case 'ProtectWindow'*/: break;&#13;
					case 'protectwindows' /*case 'ProtectWindows'*/: break;&#13;
					case 'activesheet' /*case 'ActiveSheet'*/: break;&#13;
					case 'displayinknotes' /*case 'DisplayInkNotes'*/: break;&#13;
					case 'firstvisiblesheet' /*case 'FirstVisibleSheet'*/: break;&#13;
					case 'supbook' /*case 'SupBook'*/: break;&#13;
					case 'sheetname' /*case 'SheetName'*/: break;&#13;
					case 'sheetindex' /*case 'SheetIndex'*/: break;&#13;
					case 'sheetindexfirst' /*case 'SheetIndexFirst'*/: break;&#13;
					case 'sheetindexlast' /*case 'SheetIndexLast'*/: break;&#13;
					case 'dll' /*case 'Dll'*/: break;&#13;
					case 'acceptlabelsinformulas' /*case 'AcceptLabelsInFormulas'*/: break;&#13;
					case 'donotsavelinkvalues' /*case 'DoNotSaveLinkValues'*/: break;&#13;
					case 'iteration' /*case 'Iteration'*/: break;&#13;
					case 'maxiterations' /*case 'MaxIterations'*/: break;&#13;
					case 'maxchange' /*case 'MaxChange'*/: break;&#13;
					case 'path' /*case 'Path'*/: break;&#13;
					case 'xct' /*case 'Xct'*/: break;&#13;
					case 'count' /*case 'Count'*/: break;&#13;
					case 'selectedsheets' /*case 'SelectedSheets'*/: break;&#13;
					case 'calculation' /*case 'Calculation'*/: break;&#13;
					case 'uncalced' /*case 'Uncalced'*/: break;&#13;
					case 'startupprompt' /*case 'StartupPrompt'*/: break;&#13;
					case 'crn' /*case 'Crn'*/: break;&#13;
					case 'externname' /*case 'ExternName'*/: break;&#13;
					case 'formula' /*case 'Formula'*/: break;&#13;
					case 'colfirst' /*case 'ColFirst'*/: break;&#13;
					case 'collast' /*case 'ColLast'*/: break;&#13;
					case 'wantadvise' /*case 'WantAdvise'*/: break;&#13;
					case 'boolean' /*case 'Boolean'*/: break;&#13;
					case 'error' /*case 'Error'*/: break;&#13;
					case 'text' /*case 'Text'*/: break;&#13;
					case 'ole' /*case 'OLE'*/: break;&#13;
					case 'noautorecover' /*case 'NoAutoRecover'*/: break;&#13;
					case 'publishobjects' /*case 'PublishObjects'*/: break;&#13;
					case 'donotcalculatebeforesave' /*case 'DoNotCalculateBeforeSave'*/: break;&#13;
					case 'number' /*case 'Number'*/: break;&#13;
					case 'refmoder1c1' /*case 'RefModeR1C1'*/: break;&#13;
					case 'embedsavesmarttags' /*case 'EmbedSaveSmartTags'*/: break;&#13;
					default: seen = false;&#13;
				} break;&#13;
&#13;
				/* WorkbookOptions */&#13;
				case 'workbookoptions' /*case 'WorkbookOptions'*/: switch(Rn[3]) {&#13;
					case 'owcversion' /*case 'OWCVersion'*/: break;&#13;
					case 'height' /*case 'Height'*/: break;&#13;
					case 'width' /*case 'Width'*/: break;&#13;
					default: seen = false;&#13;
				} break;&#13;
&#13;
				/* WorksheetOptions */&#13;
				case 'worksheetoptions' /*case 'WorksheetOptions'*/: switch(Rn[3]) {&#13;
					case 'visible' /*case 'Visible'*/:&#13;
						if(Rn[0].slice(-2) === "/&gt;"){/* empty */}&#13;
						else if(Rn[1]==="/") switch(str.slice(pidx, Rn.index)) {&#13;
							case "SheetHidden": wsprops.Hidden = 1; break;&#13;
							case "SheetVeryHidden": wsprops.Hidden = 2; break;&#13;
						}&#13;
						else pidx = Rn.index + Rn[0].length;&#13;
						break;&#13;
					case 'header' /*case 'Header'*/:&#13;
						if(!cursheet['!margins']) default_margins(cursheet['!margins']={}, 'xlml');&#13;
						if(!isNaN(+parsexmltag(Rn[0]).Margin)) cursheet['!margins'].header = +parsexmltag(Rn[0]).Margin;&#13;
						break;&#13;
					case 'footer' /*case 'Footer'*/:&#13;
						if(!cursheet['!margins']) default_margins(cursheet['!margins']={}, 'xlml');&#13;
						if(!isNaN(+parsexmltag(Rn[0]).Margin)) cursheet['!margins'].footer = +parsexmltag(Rn[0]).Margin;&#13;
						break;&#13;
					case 'pagemargins' /*case 'PageMargins'*/:&#13;
						var pagemargins = parsexmltag(Rn[0]);&#13;
						if(!cursheet['!margins']) default_margins(cursheet['!margins']={},'xlml');&#13;
						if(!isNaN(+pagemargins.Top)) cursheet['!margins'].top = +pagemargins.Top;&#13;
						if(!isNaN(+pagemargins.Left)) cursheet['!margins'].left = +pagemargins.Left;&#13;
						if(!isNaN(+pagemargins.Right)) cursheet['!margins'].right = +pagemargins.Right;&#13;
						if(!isNaN(+pagemargins.Bottom)) cursheet['!margins'].bottom = +pagemargins.Bottom;&#13;
						break;&#13;
					case 'displayrighttoleft' /*case 'DisplayRightToLeft'*/:&#13;
						if(!Workbook.Views) Workbook.Views = [];&#13;
						if(!Workbook.Views[0]) Workbook.Views[0] = {};&#13;
						Workbook.Views[0].RTL = true;&#13;
						break;&#13;
&#13;
					case 'freezepanes' /*case 'FreezePanes'*/: break;&#13;
					case 'frozennosplit' /*case 'FrozenNoSplit'*/: break;&#13;
&#13;
					case 'splithorizontal' /*case 'SplitHorizontal'*/:&#13;
					case 'splitvertical' /*case 'SplitVertical'*/:&#13;
						break;&#13;
&#13;
					case 'donotdisplaygridlines' /*case 'DoNotDisplayGridlines'*/:&#13;
						break;&#13;
&#13;
					case 'activerow' /*case 'ActiveRow'*/: break;&#13;
					case 'activecol' /*case 'ActiveCol'*/: break;&#13;
					case 'toprowbottompane' /*case 'TopRowBottomPane'*/: break;&#13;
					case 'leftcolumnrightpane' /*case 'LeftColumnRightPane'*/: break;&#13;
&#13;
					case 'unsynced' /*case 'Unsynced'*/: break;&#13;
					case 'print' /*case 'Print'*/: break;&#13;
					case 'printerrors' /*case 'PrintErrors'*/: break;&#13;
					case 'panes' /*case 'Panes'*/: break;&#13;
					case 'scale' /*case 'Scale'*/: break;&#13;
					case 'pane' /*case 'Pane'*/: break;&#13;
					case 'number' /*case 'Number'*/: break;&#13;
					case 'layout' /*case 'Layout'*/: break;&#13;
					case 'pagesetup' /*case 'PageSetup'*/: break;&#13;
					case 'selected' /*case 'Selected'*/: break;&#13;
					case 'protectobjects' /*case 'ProtectObjects'*/: break;&#13;
					case 'enableselection' /*case 'EnableSelection'*/: break;&#13;
					case 'protectscenarios' /*case 'ProtectScenarios'*/: break;&#13;
					case 'validprinterinfo' /*case 'ValidPrinterInfo'*/: break;&#13;
					case 'horizontalresolution' /*case 'HorizontalResolution'*/: break;&#13;
					case 'verticalresolution' /*case 'VerticalResolution'*/: break;&#13;
					case 'numberofcopies' /*case 'NumberofCopies'*/: break;&#13;
					case 'activepane' /*case 'ActivePane'*/: break;&#13;
					case 'toprowvisible' /*case 'TopRowVisible'*/: break;&#13;
					case 'leftcolumnvisible' /*case 'LeftColumnVisible'*/: break;&#13;
					case 'fittopage' /*case 'FitToPage'*/: break;&#13;
					case 'rangeselection' /*case 'RangeSelection'*/: break;&#13;
					case 'papersizeindex' /*case 'PaperSizeIndex'*/: break;&#13;
					case 'pagelayoutzoom' /*case 'PageLayoutZoom'*/: break;&#13;
					case 'pagebreakzoom' /*case 'PageBreakZoom'*/: break;&#13;
					case 'filteron' /*case 'FilterOn'*/: break;&#13;
					case 'fitwidth' /*case 'FitWidth'*/: break;&#13;
					case 'fitheight' /*case 'FitHeight'*/: break;&#13;
					case 'commentslayout' /*case 'CommentsLayout'*/: break;&#13;
					case 'zoom' /*case 'Zoom'*/: break;&#13;
					case 'lefttoright' /*case 'LeftToRight'*/: break;&#13;
					case 'gridlines' /*case 'Gridlines'*/: break;&#13;
					case 'allowsort' /*case 'AllowSort'*/: break;&#13;
					case 'allowfilter' /*case 'AllowFilter'*/: break;&#13;
					case 'allowinsertrows' /*case 'AllowInsertRows'*/: break;&#13;
					case 'allowdeleterows' /*case 'AllowDeleteRows'*/: break;&#13;
					case 'allowinsertcols' /*case 'AllowInsertCols'*/: break;&#13;
					case 'allowdeletecols' /*case 'AllowDeleteCols'*/: break;&#13;
					case 'allowinserthyperlinks' /*case 'AllowInsertHyperlinks'*/: break;&#13;
					case 'allowformatcells' /*case 'AllowFormatCells'*/: break;&#13;
					case 'allowsizecols' /*case 'AllowSizeCols'*/: break;&#13;
					case 'allowsizerows' /*case 'AllowSizeRows'*/: break;&#13;
					case 'nosummaryrowsbelowdetail' /*case 'NoSummaryRowsBelowDetail'*/:&#13;
						if(!cursheet["!outline"]) cursheet["!outline"] = {};&#13;
						cursheet["!outline"].above = true;&#13;
						break;&#13;
					case 'tabcolorindex' /*case 'TabColorIndex'*/: break;&#13;
					case 'donotdisplayheadings' /*case 'DoNotDisplayHeadings'*/: break;&#13;
					case 'showpagelayoutzoom' /*case 'ShowPageLayoutZoom'*/: break;&#13;
					case 'nosummarycolumnsrightdetail' /*case 'NoSummaryColumnsRightDetail'*/:&#13;
						if(!cursheet["!outline"]) cursheet["!outline"] = {};&#13;
						cursheet["!outline"].left = true;&#13;
						break;&#13;
					case 'blackandwhite' /*case 'BlackAndWhite'*/: break;&#13;
					case 'donotdisplayzeros' /*case 'DoNotDisplayZeros'*/: break;&#13;
					case 'displaypagebreak' /*case 'DisplayPageBreak'*/: break;&#13;
					case 'rowcolheadings' /*case 'RowColHeadings'*/: break;&#13;
					case 'donotdisplayoutline' /*case 'DoNotDisplayOutline'*/: break;&#13;
					case 'noorientation' /*case 'NoOrientation'*/: break;&#13;
					case 'allowusepivottables' /*case 'AllowUsePivotTables'*/: break;&#13;
					case 'zeroheight' /*case 'ZeroHeight'*/: break;&#13;
					case 'viewablerange' /*case 'ViewableRange'*/: break;&#13;
					case 'selection' /*case 'Selection'*/: break;&#13;
					case 'protectcontents' /*case 'ProtectContents'*/: break;&#13;
					default: seen = false;&#13;
				} break;&#13;
&#13;
				/* PivotTable */&#13;
				case 'pivottable' /*case 'PivotTable'*/: case 'pivotcache' /*case 'PivotCache'*/: switch(Rn[3]) {&#13;
					case 'immediateitemsondrop' /*case 'ImmediateItemsOnDrop'*/: break;&#13;
					case 'showpagemultipleitemlabel' /*case 'ShowPageMultipleItemLabel'*/: break;&#13;
					case 'compactrowindent' /*case 'CompactRowIndent'*/: break;&#13;
					case 'location' /*case 'Location'*/: break;&#13;
					case 'pivotfield' /*case 'PivotField'*/: break;&#13;
					case 'orientation' /*case 'Orientation'*/: break;&#13;
					case 'layoutform' /*case 'LayoutForm'*/: break;&#13;
					case 'layoutsubtotallocation' /*case 'LayoutSubtotalLocation'*/: break;&#13;
					case 'layoutcompactrow' /*case 'LayoutCompactRow'*/: break;&#13;
					case 'position' /*case 'Position'*/: break;&#13;
					case 'pivotitem' /*case 'PivotItem'*/: break;&#13;
					case 'datatype' /*case 'DataType'*/: break;&#13;
					case 'datafield' /*case 'DataField'*/: break;&#13;
					case 'sourcename' /*case 'SourceName'*/: break;&#13;
					case 'parentfield' /*case 'ParentField'*/: break;&#13;
					case 'ptlineitems' /*case 'PTLineItems'*/: break;&#13;
					case 'ptlineitem' /*case 'PTLineItem'*/: break;&#13;
					case 'countofsameitems' /*case 'CountOfSameItems'*/: break;&#13;
					case 'item' /*case 'Item'*/: break;&#13;
					case 'itemtype' /*case 'ItemType'*/: break;&#13;
					case 'ptsource' /*case 'PTSource'*/: break;&#13;
					case 'cacheindex' /*case 'CacheIndex'*/: break;&#13;
					case 'consolidationreference' /*case 'ConsolidationReference'*/: break;&#13;
					case 'filename' /*case 'FileName'*/: break;&#13;
					case 'reference' /*case 'Reference'*/: break;&#13;
					case 'nocolumngrand' /*case 'NoColumnGrand'*/: break;&#13;
					case 'norowgrand' /*case 'NoRowGrand'*/: break;&#13;
					case 'blanklineafteritems' /*case 'BlankLineAfterItems'*/: break;&#13;
					case 'hidden' /*case 'Hidden'*/: break;&#13;
					case 'subtotal' /*case 'Subtotal'*/: break;&#13;
					case 'basefield' /*case 'BaseField'*/: break;&#13;
					case 'mapchilditems' /*case 'MapChildItems'*/: break;&#13;
					case 'function' /*case 'Function'*/: break;&#13;
					case 'refreshonfileopen' /*case 'RefreshOnFileOpen'*/: break;&#13;
					case 'printsettitles' /*case 'PrintSetTitles'*/: break;&#13;
					case 'mergelabels' /*case 'MergeLabels'*/: break;&#13;
					case 'defaultversion' /*case 'DefaultVersion'*/: break;&#13;
					case 'refreshname' /*case 'RefreshName'*/: break;&#13;
					case 'refreshdate' /*case 'RefreshDate'*/: break;&#13;
					case 'refreshdatecopy' /*case 'RefreshDateCopy'*/: break;&#13;
					case 'versionlastrefresh' /*case 'VersionLastRefresh'*/: break;&#13;
					case 'versionlastupdate' /*case 'VersionLastUpdate'*/: break;&#13;
					case 'versionupdateablemin' /*case 'VersionUpdateableMin'*/: break;&#13;
					case 'versionrefreshablemin' /*case 'VersionRefreshableMin'*/: break;&#13;
					case 'calculation' /*case 'Calculation'*/: break;&#13;
					default: seen = false;&#13;
				} break;&#13;
&#13;
				/* PageBreaks */&#13;
				case 'pagebreaks' /*case 'PageBreaks'*/: switch(Rn[3]) {&#13;
					case 'colbreaks' /*case 'ColBreaks'*/: break;&#13;
					case 'colbreak' /*case 'ColBreak'*/: break;&#13;
					case 'rowbreaks' /*case 'RowBreaks'*/: break;&#13;
					case 'rowbreak' /*case 'RowBreak'*/: break;&#13;
					case 'colstart' /*case 'ColStart'*/: break;&#13;
					case 'colend' /*case 'ColEnd'*/: break;&#13;
					case 'rowend' /*case 'RowEnd'*/: break;&#13;
					default: seen = false;&#13;
				} break;&#13;
&#13;
				/* AutoFilter */&#13;
				case 'autofilter' /*case 'AutoFilter'*/: switch(Rn[3]) {&#13;
					case 'autofiltercolumn' /*case 'AutoFilterColumn'*/: break;&#13;
					case 'autofiltercondition' /*case 'AutoFilterCondition'*/: break;&#13;
					case 'autofilterand' /*case 'AutoFilterAnd'*/: break;&#13;
					case 'autofilteror' /*case 'AutoFilterOr'*/: break;&#13;
					default: seen = false;&#13;
				} break;&#13;
&#13;
				/* QueryTable */&#13;
				case 'querytable' /*case 'QueryTable'*/: switch(Rn[3]) {&#13;
					case 'id' /*case 'Id'*/: break;&#13;
					case 'autoformatfont' /*case 'AutoFormatFont'*/: break;&#13;
					case 'autoformatpattern' /*case 'AutoFormatPattern'*/: break;&#13;
					case 'querysource' /*case 'QuerySource'*/: break;&#13;
					case 'querytype' /*case 'QueryType'*/: break;&#13;
					case 'enableredirections' /*case 'EnableRedirections'*/: break;&#13;
					case 'refreshedinxl9' /*case 'RefreshedInXl9'*/: break;&#13;
					case 'urlstring' /*case 'URLString'*/: break;&#13;
					case 'htmltables' /*case 'HTMLTables'*/: break;&#13;
					case 'connection' /*case 'Connection'*/: break;&#13;
					case 'commandtext' /*case 'CommandText'*/: break;&#13;
					case 'refreshinfo' /*case 'RefreshInfo'*/: break;&#13;
					case 'notitles' /*case 'NoTitles'*/: break;&#13;
					case 'nextid' /*case 'NextId'*/: break;&#13;
					case 'columninfo' /*case 'ColumnInfo'*/: break;&#13;
					case 'overwritecells' /*case 'OverwriteCells'*/: break;&#13;
					case 'donotpromptforfile' /*case 'DoNotPromptForFile'*/: break;&#13;
					case 'textwizardsettings' /*case 'TextWizardSettings'*/: break;&#13;
					case 'source' /*case 'Source'*/: break;&#13;
					case 'number' /*case 'Number'*/: break;&#13;
					case 'decimal' /*case 'Decimal'*/: break;&#13;
					case 'thousandseparator' /*case 'ThousandSeparator'*/: break;&#13;
					case 'trailingminusnumbers' /*case 'TrailingMinusNumbers'*/: break;&#13;
					case 'formatsettings' /*case 'FormatSettings'*/: break;&#13;
					case 'fieldtype' /*case 'FieldType'*/: break;&#13;
					case 'delimiters' /*case 'Delimiters'*/: break;&#13;
					case 'tab' /*case 'Tab'*/: break;&#13;
					case 'comma' /*case 'Comma'*/: break;&#13;
					case 'autoformatname' /*case 'AutoFormatName'*/: break;&#13;
					case 'versionlastedit' /*case 'VersionLastEdit'*/: break;&#13;
					case 'versionlastrefresh' /*case 'VersionLastRefresh'*/: break;&#13;
					default: seen = false;&#13;
				} break;&#13;
&#13;
				case 'datavalidation' /*case 'DataValidation'*/:&#13;
				switch(Rn[3]) {&#13;
					case 'range' /*case 'Range'*/: break;&#13;
&#13;
					case 'type' /*case 'Type'*/: break;&#13;
					case 'min' /*case 'Min'*/: break;&#13;
					case 'max' /*case 'Max'*/: break;&#13;
					case 'sort' /*case 'Sort'*/: break;&#13;
					case 'descending' /*case 'Descending'*/: break;&#13;
					case 'order' /*case 'Order'*/: break;&#13;
					case 'casesensitive' /*case 'CaseSensitive'*/: break;&#13;
					case 'value' /*case 'Value'*/: break;&#13;
					case 'errorstyle' /*case 'ErrorStyle'*/: break;&#13;
					case 'errormessage' /*case 'ErrorMessage'*/: break;&#13;
					case 'errortitle' /*case 'ErrorTitle'*/: break;&#13;
					case 'inputmessage' /*case 'InputMessage'*/: break;&#13;
					case 'inputtitle' /*case 'InputTitle'*/: break;&#13;
					case 'combohide' /*case 'ComboHide'*/: break;&#13;
					case 'inputhide' /*case 'InputHide'*/: break;&#13;
					case 'condition' /*case 'Condition'*/: break;&#13;
					case 'qualifier' /*case 'Qualifier'*/: break;&#13;
					case 'useblank' /*case 'UseBlank'*/: break;&#13;
					case 'value1' /*case 'Value1'*/: break;&#13;
					case 'value2' /*case 'Value2'*/: break;&#13;
					case 'format' /*case 'Format'*/: break;&#13;
&#13;
					case 'cellrangelist' /*case 'CellRangeList'*/: break;&#13;
					default: seen = false;&#13;
				} break;&#13;
&#13;
				case 'sorting' /*case 'Sorting'*/:&#13;
				case 'conditionalformatting' /*case 'ConditionalFormatting'*/:&#13;
				switch(Rn[3]) {&#13;
					case 'range' /*case 'Range'*/: break;&#13;
					case 'type' /*case 'Type'*/: break;&#13;
					case 'min' /*case 'Min'*/: break;&#13;
					case 'max' /*case 'Max'*/: break;&#13;
					case 'sort' /*case 'Sort'*/: break;&#13;
					case 'descending' /*case 'Descending'*/: break;&#13;
					case 'order' /*case 'Order'*/: break;&#13;
					case 'casesensitive' /*case 'CaseSensitive'*/: break;&#13;
					case 'value' /*case 'Value'*/: break;&#13;
					case 'errorstyle' /*case 'ErrorStyle'*/: break;&#13;
					case 'errormessage' /*case 'ErrorMessage'*/: break;&#13;
					case 'errortitle' /*case 'ErrorTitle'*/: break;&#13;
					case 'cellrangelist' /*case 'CellRangeList'*/: break;&#13;
					case 'inputmessage' /*case 'InputMessage'*/: break;&#13;
					case 'inputtitle' /*case 'InputTitle'*/: break;&#13;
					case 'combohide' /*case 'ComboHide'*/: break;&#13;
					case 'inputhide' /*case 'InputHide'*/: break;&#13;
					case 'condition' /*case 'Condition'*/: break;&#13;
					case 'qualifier' /*case 'Qualifier'*/: break;&#13;
					case 'useblank' /*case 'UseBlank'*/: break;&#13;
					case 'value1' /*case 'Value1'*/: break;&#13;
					case 'value2' /*case 'Value2'*/: break;&#13;
					case 'format' /*case 'Format'*/: break;&#13;
					default: seen = false;&#13;
				} break;&#13;
&#13;
				/* MapInfo (schema) */&#13;
				case 'mapinfo' /*case 'MapInfo'*/: case 'schema' /*case 'Schema'*/: case 'data' /*case 'data'*/: switch(Rn[3]) {&#13;
					case 'map' /*case 'Map'*/: break;&#13;
					case 'entry' /*case 'Entry'*/: break;&#13;
					case 'range' /*case 'Range'*/: break;&#13;
					case 'xpath' /*case 'XPath'*/: break;&#13;
					case 'field' /*case 'Field'*/: break;&#13;
					case 'xsdtype' /*case 'XSDType'*/: break;&#13;
					case 'filteron' /*case 'FilterOn'*/: break;&#13;
					case 'aggregate' /*case 'Aggregate'*/: break;&#13;
					case 'elementtype' /*case 'ElementType'*/: break;&#13;
					case 'attributetype' /*case 'AttributeType'*/: break;&#13;
				/* These are from xsd (XML Schema Definition) */&#13;
					case 'schema' /*case 'schema'*/:&#13;
					case 'element' /*case 'element'*/:&#13;
					case 'complextype' /*case 'complexType'*/:&#13;
					case 'datatype' /*case 'datatype'*/:&#13;
					case 'all' /*case 'all'*/:&#13;
					case 'attribute' /*case 'attribute'*/:&#13;
					case 'extends' /*case 'extends'*/: break;&#13;
&#13;
					case 'row' /*case 'row'*/: break;&#13;
					default: seen = false;&#13;
				} break;&#13;
&#13;
				/* SmartTags (can be anything) */&#13;
				case 'smarttags' /*case 'SmartTags'*/: break;&#13;
&#13;
				default: seen = false; break;&#13;
			}&#13;
			if(seen) break;&#13;
			/* CustomDocumentProperties */&#13;
			if(Rn[3].match(/!\[CDATA/)) break;&#13;
			if(!state[state.length-1][1]) throw 'Unrecognized tag: ' + Rn[3] + "|" + state.join("|");&#13;
			if(state[state.length-1][0]===/*'CustomDocumentProperties'*/'customdocumentproperties') {&#13;
				if(Rn[0].slice(-2) === "/&gt;") break;&#13;
				else if(Rn[1]==="/") xlml_set_custprop(Custprops, raw_Rn3, cp, str.slice(pidx, Rn.index));&#13;
				else { cp = Rn; pidx = Rn.index + Rn[0].length; }&#13;
				break;&#13;
			}&#13;
			if(opts.WTF) throw 'Unrecognized tag: ' + Rn[3] + "|" + state.join("|");&#13;
	}&#13;
	var out = ({});&#13;
	if(!opts.bookSheets &amp;&amp; !opts.bookProps) out.Sheets = sheets;&#13;
	out.SheetNames = sheetnames;&#13;
	out.Workbook = Workbook;&#13;
	out.SSF = dup(table_fmt);&#13;
	out.Props = Props;&#13;
	out.Custprops = Custprops;&#13;
	out.bookType = "xlml";&#13;
	return out;&#13;
}&#13;
&#13;
function parse_xlml(data, opts) {&#13;
	fix_read_opts(opts=opts||{});&#13;
	switch(opts.type||"base64") {&#13;
		case "base64": return parse_xlml_xml(Base64_decode(data), opts);&#13;
		case "binary": case "buffer": case "file": return parse_xlml_xml(data, opts);&#13;
		case "array": return parse_xlml_xml(a2s(data), opts);&#13;
	}&#13;
}&#13;
&#13;
/* TODO */&#13;
function write_props_xlml(wb, opts) {&#13;
	var o = [];&#13;
	/* DocumentProperties */&#13;
	if(wb.Props) o.push(xlml_write_docprops(wb.Props, opts));&#13;
	/* CustomDocumentProperties */&#13;
	if(wb.Custprops) o.push(xlml_write_custprops(wb.Props, wb.Custprops, opts));&#13;
	return o.join("");&#13;
}&#13;
/* TODO */&#13;
function write_wb_xlml(wb) {&#13;
	/* OfficeDocumentSettings */&#13;
	/* ExcelWorkbook */&#13;
	if((((wb||{}).Workbook||{}).WBProps||{}).date1904) return '&lt;ExcelWorkbook xmlns="urn:schemas-microsoft-com:office:excel"&gt;&lt;Date1904/&gt;&lt;/ExcelWorkbook&gt;';&#13;
	return "";&#13;
}&#13;
/* TODO */&#13;
function write_sty_xlml(wb, opts) {&#13;
	/* Styles */&#13;
	var styles = ['&lt;Style ss:ID="Default" ss:Name="Normal"&gt;&lt;NumberFormat/&gt;&lt;/Style&gt;'];&#13;
	opts.cellXfs.forEach(function(xf, id) {&#13;
		var payload = [];&#13;
		payload.push(writextag('NumberFormat', null, {"ss:Format": escapexml(table_fmt[xf.numFmtId])}));&#13;
&#13;
		var o = {"ss:ID": "s" + (21+id)};&#13;
		styles.push(writextag('Style', payload.join(""), o));&#13;
	});&#13;
	return writextag("Styles", styles.join(""));&#13;
}&#13;
function write_name_xlml(n) { return writextag("NamedRange", null, {"ss:Name": n.Name.slice(0,6) == "_xlnm." ? n.Name.slice(6) : n.Name, "ss:RefersTo":"=" + a1_to_rc(n.Ref, {r:0,c:0})}); }&#13;
function write_names_xlml(wb) {&#13;
	if(!((wb||{}).Workbook||{}).Names) return "";&#13;
var names = wb.Workbook.Names;&#13;
	var out = [];&#13;
	for(var i = 0; i &lt; names.length; ++i) {&#13;
		var n = names[i];&#13;
		if(n.Sheet != null) continue;&#13;
		if(n.Name.match(/^_xlfn\./)) continue;&#13;
		out.push(write_name_xlml(n));&#13;
	}&#13;
	return writextag("Names", out.join(""));&#13;
}&#13;
function write_ws_xlml_names(ws, opts, idx, wb) {&#13;
	if(!ws) return "";&#13;
	if(!((wb||{}).Workbook||{}).Names) return "";&#13;
var names = wb.Workbook.Names;&#13;
	var out = [];&#13;
	for(var i = 0; i &lt; names.length; ++i) {&#13;
		var n = names[i];&#13;
		if(n.Sheet != idx) continue;&#13;
		/*switch(n.Name) {&#13;
			case "_": continue;&#13;
		}*/&#13;
		if(n.Name.match(/^_xlfn\./)) continue;&#13;
		out.push(write_name_xlml(n));&#13;
	}&#13;
	return out.join("");&#13;
}&#13;
/* WorksheetOptions */&#13;
function write_ws_xlml_wsopts(ws, opts, idx, wb) {&#13;
	if(!ws) return "";&#13;
	var o = [];&#13;
	/* NOTE: spec technically allows any order, but stick with implied order */&#13;
&#13;
	/* FitToPage */&#13;
	/* DoNotDisplayColHeaders */&#13;
	/* DoNotDisplayRowHeaders */&#13;
	/* ViewableRange */&#13;
	/* Selection */&#13;
	/* GridlineColor */&#13;
	/* Name */&#13;
	/* ExcelWorksheetType */&#13;
	/* IntlMacro */&#13;
	/* Unsynced */&#13;
	/* Selected */&#13;
	/* CodeName */&#13;
&#13;
	if(ws['!margins']) {&#13;
		o.push("&lt;PageSetup&gt;");&#13;
		if(ws['!margins'].header) o.push(writextag("Header", null, {'x:Margin':ws['!margins'].header}));&#13;
		if(ws['!margins'].footer) o.push(writextag("Footer", null, {'x:Margin':ws['!margins'].footer}));&#13;
		o.push(writextag("PageMargins", null, {&#13;
			'x:Bottom': ws['!margins'].bottom || "0.75",&#13;
			'x:Left': ws['!margins'].left || "0.7",&#13;
			'x:Right': ws['!margins'].right || "0.7",&#13;
			'x:Top': ws['!margins'].top || "0.75"&#13;
		}));&#13;
		o.push("&lt;/PageSetup&gt;");&#13;
	}&#13;
&#13;
	/* PageSetup */&#13;
	/* DisplayPageBreak */&#13;
	/* TransitionExpressionEvaluation */&#13;
	/* TransitionFormulaEntry */&#13;
	/* Print */&#13;
	/* Zoom */&#13;
	/* PageLayoutZoom */&#13;
	/* PageBreakZoom */&#13;
	/* ShowPageBreakZoom */&#13;
	/* DefaultRowHeight */&#13;
	/* DefaultColumnWidth */&#13;
	/* StandardWidth */&#13;
&#13;
	if(wb &amp;&amp; wb.Workbook &amp;&amp; wb.Workbook.Sheets &amp;&amp; wb.Workbook.Sheets[idx]) {&#13;
		/* Visible */&#13;
		if(wb.Workbook.Sheets[idx].Hidden) o.push(writextag("Visible", (wb.Workbook.Sheets[idx].Hidden == 1 ? "SheetHidden" : "SheetVeryHidden"), {}));&#13;
		else {&#13;
			/* Selected */&#13;
			for(var i = 0; i &lt; idx; ++i) if(wb.Workbook.Sheets[i] &amp;&amp; !wb.Workbook.Sheets[i].Hidden) break;&#13;
			if(i == idx) o.push("&lt;Selected/&gt;");&#13;
		}&#13;
	}&#13;
&#13;
	/* LeftColumnVisible */&#13;
&#13;
	if(((((wb||{}).Workbook||{}).Views||[])[0]||{}).RTL) o.push("&lt;DisplayRightToLeft/&gt;");&#13;
&#13;
	/* GridlineColorIndex */&#13;
	/* DisplayFormulas */&#13;
	/* DoNotDisplayGridlines */&#13;
	/* DoNotDisplayHeadings */&#13;
	/* DoNotDisplayOutline */&#13;
	/* ApplyAutomaticOutlineStyles */&#13;
	/* NoSummaryRowsBelowDetail */&#13;
	/* NoSummaryColumnsRightDetail */&#13;
	/* DoNotDisplayZeros */&#13;
	/* ActiveRow */&#13;
	/* ActiveColumn */&#13;
	/* FilterOn */&#13;
	/* RangeSelection */&#13;
	/* TopRowVisible */&#13;
	/* TopRowBottomPane */&#13;
	/* LeftColumnRightPane */&#13;
	/* ActivePane */&#13;
	/* SplitHorizontal */&#13;
	/* SplitVertical */&#13;
	/* FreezePanes */&#13;
	/* FrozenNoSplit */&#13;
	/* TabColorIndex */&#13;
	/* Panes */&#13;
&#13;
	/* NOTE: Password not supported in XLML Format */&#13;
	if(ws['!protect']) {&#13;
		o.push(writetag("ProtectContents", "True"));&#13;
		if(ws['!protect'].objects) o.push(writetag("ProtectObjects", "True"));&#13;
		if(ws['!protect'].scenarios) o.push(writetag("ProtectScenarios", "True"));&#13;
		if(ws['!protect'].selectLockedCells != null &amp;&amp; !ws['!protect'].selectLockedCells) o.push(writetag("EnableSelection", "NoSelection"));&#13;
		else if(ws['!protect'].selectUnlockedCells != null &amp;&amp; !ws['!protect'].selectUnlockedCells) o.push(writetag("EnableSelection", "UnlockedCells"));&#13;
	[&#13;
		[ "formatCells", "AllowFormatCells" ],&#13;
		[ "formatColumns", "AllowSizeCols" ],&#13;
		[ "formatRows", "AllowSizeRows" ],&#13;
		[ "insertColumns", "AllowInsertCols" ],&#13;
		[ "insertRows", "AllowInsertRows" ],&#13;
		[ "insertHyperlinks", "AllowInsertHyperlinks" ],&#13;
		[ "deleteColumns", "AllowDeleteCols" ],&#13;
		[ "deleteRows", "AllowDeleteRows" ],&#13;
		[ "sort", "AllowSort" ],&#13;
		[ "autoFilter", "AllowFilter" ],&#13;
		[ "pivotTables", "AllowUsePivotTables" ]&#13;
	].forEach(function(x) { if(ws['!protect'][x[0]]) o.push("&lt;"+x[1]+"/&gt;"); });&#13;
	}&#13;
&#13;
	if(o.length == 0) return "";&#13;
	return writextag("WorksheetOptions", o.join(""), {xmlns:XLMLNS.x});&#13;
}&#13;
function write_ws_xlml_comment(comments) {&#13;
	return comments.map(function(c) {&#13;
		// TODO: formatted text&#13;
		var t = xlml_unfixstr(c.t||"");&#13;
		var d =writextag("ss:Data", t, {"xmlns":"http://www.w3.org/TR/REC-html40"});&#13;
		return writextag("Comment", d, {"ss:Author":c.a});&#13;
	}).join("");&#13;
}&#13;
function write_ws_xlml_cell(cell, ref, ws, opts, idx, wb, addr){&#13;
	if(!cell || (cell.v == undefined &amp;&amp; cell.f == undefined)) return "";&#13;
&#13;
	var attr = {};&#13;
	if(cell.f) attr["ss:Formula"] = "=" + escapexml(a1_to_rc(cell.f, addr));&#13;
	if(cell.F &amp;&amp; cell.F.slice(0, ref.length) == ref) {&#13;
		var end = decode_cell(cell.F.slice(ref.length + 1));&#13;
		attr["ss:ArrayRange"] = "RC:R" + (end.r == addr.r ? "" : "[" + (end.r - addr.r) + "]") + "C" + (end.c == addr.c ? "" : "[" + (end.c - addr.c) + "]");&#13;
	}&#13;
&#13;
	if(cell.l &amp;&amp; cell.l.Target) {&#13;
		attr["ss:HRef"] = escapexml(cell.l.Target);&#13;
		if(cell.l.Tooltip) attr["x:HRefScreenTip"] = escapexml(cell.l.Tooltip);&#13;
	}&#13;
&#13;
	if(ws['!merges']) {&#13;
		var marr = ws['!merges'];&#13;
		for(var mi = 0; mi != marr.length; ++mi) {&#13;
			if(marr[mi].s.c != addr.c || marr[mi].s.r != addr.r) continue;&#13;
			if(marr[mi].e.c &gt; marr[mi].s.c) attr['ss:MergeAcross'] = marr[mi].e.c - marr[mi].s.c;&#13;
			if(marr[mi].e.r &gt; marr[mi].s.r) attr['ss:MergeDown'] = marr[mi].e.r - marr[mi].s.r;&#13;
		}&#13;
	}&#13;
&#13;
	var t = "", p = "";&#13;
	switch(cell.t) {&#13;
		case 'z': if(!opts.sheetStubs) return ""; break;&#13;
		case 'n': t = 'Number'; p = String(cell.v); break;&#13;
		case 'b': t = 'Boolean'; p = (cell.v ? "1" : "0"); break;&#13;
		case 'e': t = 'Error'; p = BErr[cell.v]; break;&#13;
		case 'd': t = 'DateTime'; p = new Date(cell.v).toISOString(); if(cell.z == null) cell.z = cell.z || table_fmt[14]; break;&#13;
		case 's': t = 'String'; p = escapexlml(cell.v||""); break;&#13;
	}&#13;
	/* TODO: cell style */&#13;
	var os = get_cell_style(opts.cellXfs, cell, opts);&#13;
	attr["ss:StyleID"] = "s" + (21+os);&#13;
	attr["ss:Index"] = addr.c + 1;&#13;
	var _v = (cell.v != null ? p : "");&#13;
	var m = cell.t == 'z' ? "" : ('&lt;Data ss:Type="' + t + '"&gt;' + _v + '&lt;/Data&gt;');&#13;
&#13;
	if((cell.c||[]).length &gt; 0) m += write_ws_xlml_comment(cell.c);&#13;
&#13;
	return writextag("Cell", m, attr);&#13;
}&#13;
function write_ws_xlml_row(R, row) {&#13;
	var o = '&lt;Row ss:Index="' + (R+1) + '"';&#13;
	if(row) {&#13;
		if(row.hpt &amp;&amp; !row.hpx) row.hpx = pt2px(row.hpt);&#13;
		if(row.hpx) o += ' ss:AutoFitHeight="0" ss:Height="' + row.hpx + '"';&#13;
		if(row.hidden) o += ' ss:Hidden="1"';&#13;
	}&#13;
	return o + '&gt;';&#13;
}&#13;
/* TODO */&#13;
function write_ws_xlml_table(ws, opts, idx, wb) {&#13;
	if(!ws['!ref']) return "";&#13;
	var range = safe_decode_range(ws['!ref']);&#13;
	var marr = ws['!merges'] || [], mi = 0;&#13;
	var o = [];&#13;
	if(ws['!cols']) ws['!cols'].forEach(function(n, i) {&#13;
		process_col(n);&#13;
		var w = !!n.width;&#13;
		var p = col_obj_w(i, n);&#13;
		var k = {"ss:Index":i+1};&#13;
		if(w) k['ss:Width'] = width2px(p.width);&#13;
		if(n.hidden) k['ss:Hidden']="1";&#13;
		o.push(writextag("Column",null,k));&#13;
	});&#13;
	var dense = Array.isArray(ws);&#13;
	for(var R = range.s.r; R &lt;= range.e.r; ++R) {&#13;
		var row = [write_ws_xlml_row(R, (ws['!rows']||[])[R])];&#13;
		for(var C = range.s.c; C &lt;= range.e.c; ++C) {&#13;
			var skip = false;&#13;
			for(mi = 0; mi != marr.length; ++mi) {&#13;
				if(marr[mi].s.c &gt; C) continue;&#13;
				if(marr[mi].s.r &gt; R) continue;&#13;
				if(marr[mi].e.c &lt; C) continue;&#13;
				if(marr[mi].e.r &lt; R) continue;&#13;
				if(marr[mi].s.c != C || marr[mi].s.r != R) skip = true;&#13;
				break;&#13;
			}&#13;
			if(skip) continue;&#13;
			var addr = {r:R,c:C};&#13;
			var ref = encode_cell(addr), cell = dense ? (ws[R]||[])[C] : ws[ref];&#13;
			row.push(write_ws_xlml_cell(cell, ref, ws, opts, idx, wb, addr));&#13;
		}&#13;
		row.push("&lt;/Row&gt;");&#13;
		if(row.length &gt; 2) o.push(row.join(""));&#13;
	}&#13;
	return o.join("");&#13;
}&#13;
function write_ws_xlml(idx, opts, wb) {&#13;
	var o = [];&#13;
	var s = wb.SheetNames[idx];&#13;
	var ws = wb.Sheets[s];&#13;
&#13;
	var t = ws ? write_ws_xlml_names(ws, opts, idx, wb) : "";&#13;
	if(t.length &gt; 0) o.push("&lt;Names&gt;" + t + "&lt;/Names&gt;");&#13;
&#13;
	/* Table */&#13;
	t = ws ? write_ws_xlml_table(ws, opts, idx, wb) : "";&#13;
	if(t.length &gt; 0) o.push("&lt;Table&gt;" + t + "&lt;/Table&gt;");&#13;
&#13;
	/* WorksheetOptions */&#13;
	o.push(write_ws_xlml_wsopts(ws, opts, idx, wb));&#13;
&#13;
	if(ws["!autofilter"]) o.push('&lt;AutoFilter x:Range="' + a1_to_rc(fix_range(ws["!autofilter"].ref), {r:0,c:0}) + '" xmlns="urn:schemas-microsoft-com:office:excel"&gt;&lt;/AutoFilter&gt;');&#13;
&#13;
	return o.join("");&#13;
}&#13;
function write_xlml(wb, opts) {&#13;
	if(!opts) opts = {};&#13;
	if(!wb.SSF) wb.SSF = dup(table_fmt);&#13;
	if(wb.SSF) {&#13;
		make_ssf(); SSF_load_table(wb.SSF);&#13;
		// $FlowIgnore&#13;
		opts.revssf = evert_num(wb.SSF); opts.revssf[wb.SSF[65535]] = 0;&#13;
		opts.ssf = wb.SSF;&#13;
		opts.cellXfs = [];&#13;
		get_cell_style(opts.cellXfs, {}, {revssf:{"General":0}});&#13;
	}&#13;
	var d = [];&#13;
	d.push(write_props_xlml(wb, opts));&#13;
	d.push(write_wb_xlml(wb, opts));&#13;
	d.push("");&#13;
	d.push("");&#13;
	for(var i = 0; i &lt; wb.SheetNames.length; ++i)&#13;
		d.push(writextag("Worksheet", write_ws_xlml(i, opts, wb), {"ss:Name":escapexml(wb.SheetNames[i])}));&#13;
	d[2] = write_sty_xlml(wb, opts);&#13;
	d[3] = write_names_xlml(wb, opts);&#13;
	return XML_HEADER + writextag("Workbook", d.join(""), {&#13;
		'xmlns':      XLMLNS.ss,&#13;
		'xmlns:o':    XLMLNS.o,&#13;
		'xmlns:x':    XLMLNS.x,&#13;
		'xmlns:ss':   XLMLNS.ss,&#13;
		'xmlns:dt':   XLMLNS.dt,&#13;
		'xmlns:html': XLMLNS.html&#13;
	});&#13;
}&#13;
/* [MS-OLEDS] 2.3.8 CompObjStream */&#13;
function parse_compobj(obj) {&#13;
	var v = {};&#13;
	var o = obj.content;&#13;
/* [MS-OLEDS] 2.3.7 CompObjHeader -- All fields MUST be ignored */&#13;
	o.l = 28;&#13;
&#13;
	v.AnsiUserType = o.read_shift(0, "lpstr-ansi");&#13;
	v.AnsiClipboardFormat = parse_ClipboardFormatOrAnsiString(o);&#13;
&#13;
	if(o.length - o.l &lt;= 4) return v;&#13;
&#13;
	var m = o.read_shift(4);&#13;
	if(m == 0 || m &gt; 40) return v;&#13;
	o.l-=4; v.Reserved1 = o.read_shift(0, "lpstr-ansi");&#13;
&#13;
	if(o.length - o.l &lt;= 4) return v;&#13;
	m = o.read_shift(4);&#13;
	if(m !== 0x71b239f4) return v;&#13;
	v.UnicodeClipboardFormat = parse_ClipboardFormatOrUnicodeString(o);&#13;
&#13;
	m = o.read_shift(4);&#13;
	if(m == 0 || m &gt; 40) return v;&#13;
	o.l-=4; v.Reserved2 = o.read_shift(0, "lpwstr");&#13;
}&#13;
&#13;
/*&#13;
	Continue logic for:&#13;
	- 2.4.58 Continue          0x003c&#13;
	- 2.4.59 ContinueBigName   0x043c&#13;
	- 2.4.60 ContinueFrt       0x0812&#13;
	- 2.4.61 ContinueFrt11     0x0875&#13;
	- 2.4.62 ContinueFrt12     0x087f&#13;
*/&#13;
var CONTINUE_RT = [ 0x003c, 0x043c, 0x0812, 0x0875, 0x087f ];&#13;
function slurp(RecordType, R, blob, length, opts) {&#13;
	var l = length;&#13;
	var bufs = [];&#13;
	var d = blob.slice(blob.l,blob.l+l);&#13;
	if(opts &amp;&amp; opts.enc &amp;&amp; opts.enc.insitu &amp;&amp; d.length &gt; 0) switch(RecordType) {&#13;
	case 0x0009: case 0x0209: case 0x0409: case 0x0809/* BOF */: case 0x002F /* FilePass */: case 0x0195 /* FileLock */: case 0x00E1 /* InterfaceHdr */: case 0x0196 /* RRDInfo */: case 0x0138 /* RRDHead */: case 0x0194 /* UsrExcl */: case 0x000a /* EOF */:&#13;
		break;&#13;
	case 0x0085 /* BoundSheet8 */:&#13;
		break;&#13;
	default:&#13;
		opts.enc.insitu(d);&#13;
	}&#13;
	bufs.push(d);&#13;
	blob.l += l;&#13;
	var nextrt = __readUInt16LE(blob,blob.l), next = XLSRecordEnum[nextrt];&#13;
	var start = 0;&#13;
	while(next != null &amp;&amp; CONTINUE_RT.indexOf(nextrt) &gt; -1) {&#13;
		l = __readUInt16LE(blob,blob.l+2);&#13;
		start = blob.l + 4;&#13;
		if(nextrt == 0x0812 /* ContinueFrt */) start += 4;&#13;
		else if(nextrt == 0x0875 || nextrt == 0x087f) {&#13;
			start += 12;&#13;
		}&#13;
		d = blob.slice(start,blob.l+4+l);&#13;
		bufs.push(d);&#13;
		blob.l += 4+l;&#13;
		next = (XLSRecordEnum[nextrt = __readUInt16LE(blob, blob.l)]);&#13;
	}&#13;
	var b = (bconcat(bufs));&#13;
	prep_blob(b, 0);&#13;
	var ll = 0; b.lens = [];&#13;
	for(var j = 0; j &lt; bufs.length; ++j) { b.lens.push(ll); ll += bufs[j].length; }&#13;
	if(b.length &lt; length) throw "XLS Record 0x" + RecordType.toString(16) + " Truncated: " + b.length + " &lt; " + length;&#13;
	return R.f(b, b.length, opts);&#13;
}&#13;
&#13;
function safe_format_xf(p, opts, date1904) {&#13;
	if(p.t === 'z') return;&#13;
	if(!p.XF) return;&#13;
	var fmtid = 0;&#13;
	try {&#13;
		fmtid = p.z || p.XF.numFmtId || 0;&#13;
		if(opts.cellNF) p.z = table_fmt[fmtid];&#13;
	} catch(e) { if(opts.WTF) throw e; }&#13;
	if(!opts || opts.cellText !== false) try {&#13;
		if(p.t === 'e') { p.w = p.w || BErr[p.v]; }&#13;
		else if(fmtid === 0 || fmtid == "General") {&#13;
			if(p.t === 'n') {&#13;
				if((p.v|0) === p.v) p.w = p.v.toString(10);&#13;
				else p.w = SSF_general_num(p.v);&#13;
			}&#13;
			else p.w = SSF_general(p.v);&#13;
		}&#13;
		else p.w = SSF_format(fmtid,p.v, {date1904:!!date1904, dateNF: opts &amp;&amp; opts.dateNF});&#13;
	} catch(e) { if(opts.WTF) throw e; }&#13;
	if(opts.cellDates &amp;&amp; fmtid &amp;&amp; p.t == 'n' &amp;&amp; fmt_is_date(table_fmt[fmtid] || String(fmtid))) {&#13;
		var _d = SSF_parse_date_code(p.v); if(_d) { p.t = 'd'; p.v = new Date(_d.y, _d.m-1,_d.d,_d.H,_d.M,_d.S,_d.u); }&#13;
	}&#13;
}&#13;
&#13;
function make_cell(val, ixfe, t) {&#13;
	return ({v:val, ixfe:ixfe, t:t});&#13;
}&#13;
&#13;
// 2.3.2&#13;
function parse_workbook(blob, options) {&#13;
	var wb = ({opts:{}});&#13;
	var Sheets = {};&#13;
	if(DENSE != null &amp;&amp; options.dense == null) options.dense = DENSE;&#13;
	var out = ((options.dense ? [] : {}));&#13;
	var Directory = {};&#13;
	var range = ({});&#13;
	var last_formula = null;&#13;
	var sst = ([]);&#13;
	var cur_sheet = "";&#13;
	var Preamble = {};&#13;
	var lastcell, last_cell = "", cc, cmnt, rngC, rngR;&#13;
	var sharedf = {};&#13;
	var arrayf = [];&#13;
	var temp_val;&#13;
	var country;&#13;
	var XFs = []; /* XF records */&#13;
	var palette = [];&#13;
	var Workbook = ({ Sheets:[], WBProps:{date1904:false}, Views:[{}] }), wsprops = {};&#13;
	var get_rgb = function getrgb(icv) {&#13;
		if(icv &lt; 8) return XLSIcv[icv];&#13;
		if(icv &lt; 64) return palette[icv-8] || XLSIcv[icv];&#13;
		return XLSIcv[icv];&#13;
	};&#13;
	var process_cell_style = function pcs(cell, line, options) {&#13;
		var xfd = line.XF.data;&#13;
		if(!xfd || !xfd.patternType || !options || !options.cellStyles) return;&#13;
		line.s = ({});&#13;
		line.s.patternType = xfd.patternType;&#13;
		var t;&#13;
		if((t = rgb2Hex(get_rgb(xfd.icvFore)))) { line.s.fgColor = {rgb:t}; }&#13;
		if((t = rgb2Hex(get_rgb(xfd.icvBack)))) { line.s.bgColor = {rgb:t}; }&#13;
	};&#13;
	var addcell = function addcell(cell, line, options) {&#13;
		if(file_depth &gt; 1) return;&#13;
		if(options.sheetRows &amp;&amp; cell.r &gt;= options.sheetRows) return;&#13;
		if(options.cellStyles &amp;&amp; line.XF &amp;&amp; line.XF.data) process_cell_style(cell, line, options);&#13;
		delete line.ixfe; delete line.XF;&#13;
		lastcell = cell;&#13;
		last_cell = encode_cell(cell);&#13;
		if(!range || !range.s || !range.e) range = {s:{r:0,c:0},e:{r:0,c:0}};&#13;
		if(cell.r &lt; range.s.r) range.s.r = cell.r;&#13;
		if(cell.c &lt; range.s.c) range.s.c = cell.c;&#13;
		if(cell.r + 1 &gt; range.e.r) range.e.r = cell.r + 1;&#13;
		if(cell.c + 1 &gt; range.e.c) range.e.c = cell.c + 1;&#13;
		if(options.cellFormula &amp;&amp; line.f) {&#13;
			for(var afi = 0; afi &lt; arrayf.length; ++afi) {&#13;
				if(arrayf[afi][0].s.c &gt; cell.c || arrayf[afi][0].s.r &gt; cell.r) continue;&#13;
				if(arrayf[afi][0].e.c &lt; cell.c || arrayf[afi][0].e.r &lt; cell.r) continue;&#13;
				line.F = encode_range(arrayf[afi][0]);&#13;
				if(arrayf[afi][0].s.c != cell.c || arrayf[afi][0].s.r != cell.r) delete line.f;&#13;
				if(line.f) line.f = "" + stringify_formula(arrayf[afi][1], range, cell, supbooks, opts);&#13;
				break;&#13;
			}&#13;
		}&#13;
		{&#13;
			if(options.dense) {&#13;
				if(!out[cell.r]) out[cell.r] = [];&#13;
				out[cell.r][cell.c] = line;&#13;
			} else out[last_cell] = line;&#13;
		}&#13;
	};&#13;
	var opts = ({&#13;
		enc: false, // encrypted&#13;
		sbcch: 0, // cch in the preceding SupBook&#13;
		snames: [], // sheetnames&#13;
		sharedf: sharedf, // shared formulae by address&#13;
		arrayf: arrayf, // array formulae array&#13;
		rrtabid: [], // RRTabId&#13;
		lastuser: "", // Last User from WriteAccess&#13;
		biff: 8, // BIFF version&#13;
		codepage: 0, // CP from CodePage record&#13;
		winlocked: 0, // fLockWn from WinProtect&#13;
		cellStyles: !!options &amp;&amp; !!options.cellStyles,&#13;
		WTF: !!options &amp;&amp; !!options.wtf&#13;
	});&#13;
	if(options.password) opts.password = options.password;&#13;
	var themes;&#13;
	var merges = [];&#13;
	var objects = [];&#13;
	var colinfo = [], rowinfo = [];&#13;
	var seencol = false;&#13;
	var supbooks = ([]); // 1-indexed, will hold extern names&#13;
	supbooks.SheetNames = opts.snames;&#13;
	supbooks.sharedf = opts.sharedf;&#13;
	supbooks.arrayf = opts.arrayf;&#13;
	supbooks.names = [];&#13;
	supbooks.XTI = [];&#13;
	var last_RT = 0;&#13;
	var file_depth = 0; /* TODO: make a real stack */&#13;
	var BIFF2Fmt = 0, BIFF2FmtTable = [];&#13;
	var FilterDatabases = []; /* TODO: sort out supbooks and process elsewhere */&#13;
	var last_lbl;&#13;
&#13;
	/* explicit override for some broken writers */&#13;
	opts.codepage = 1200;&#13;
	set_cp(1200);&#13;
	var seen_codepage = false;&#13;
	while(blob.l &lt; blob.length - 1) {&#13;
		var s = blob.l;&#13;
		var RecordType = blob.read_shift(2);&#13;
		if(RecordType === 0 &amp;&amp; last_RT === 0x000a /* EOF */) break;&#13;
		var length = (blob.l === blob.length ? 0 : blob.read_shift(2));&#13;
		var R = XLSRecordEnum[RecordType];&#13;
		if(file_depth == 0 &amp;&amp; [0x0009, 0x0209, 0x0409, 0x0809].indexOf(RecordType) == -1 /* BOF */) break;&#13;
		//console.log(RecordType.toString(16), RecordType, R, blob.l, length, blob.length);&#13;
		//if(!R) console.log(blob.slice(blob.l, blob.l + length));&#13;
		if(R &amp;&amp; R.f) {&#13;
			if(options.bookSheets) {&#13;
				if(last_RT === 0x0085 /* BoundSheet8 */ &amp;&amp; RecordType !== 0x0085 /* R.n !== 'BoundSheet8' */) break;&#13;
			}&#13;
			last_RT = RecordType;&#13;
			if(R.r === 2 || R.r == 12) {&#13;
				var rt = blob.read_shift(2); length -= 2;&#13;
				if(!opts.enc &amp;&amp; rt !== RecordType &amp;&amp; (((rt&amp;0xFF)&lt;&lt;8)|(rt&gt;&gt;8)) !== RecordType) throw new Error("rt mismatch: " + rt + "!=" + RecordType);&#13;
				if(R.r == 12){&#13;
					blob.l += 10; length -= 10;&#13;
				} // skip FRT&#13;
			}&#13;
			//console.error(R,blob.l,length,blob.length);&#13;
			var val = ({});&#13;
			if(RecordType === 0x000a /* EOF */) val = R.f(blob, length, opts);&#13;
			else val = slurp(RecordType, R, blob, length, opts);&#13;
if(file_depth == 0 &amp;&amp; [0x0009, 0x0209, 0x0409, 0x0809].indexOf(last_RT) === -1 /* BOF */) continue;&#13;
			switch(RecordType) {&#13;
				case 0x0022 /* Date1904 */:&#13;
wb.opts.Date1904 = Workbook.WBProps.date1904 = val; break;&#13;
				case 0x0086 /* WriteProtect */: wb.opts.WriteProtect = true; break;&#13;
				case 0x002f /* FilePass */:&#13;
					if(!opts.enc) blob.l = 0;&#13;
					opts.enc = val;&#13;
					if(!options.password) throw new Error("File is password-protected");&#13;
					if(val.valid == null) throw new Error("Encryption scheme unsupported");&#13;
					if(!val.valid) throw new Error("Password is incorrect");&#13;
					break;&#13;
				case 0x005c /* WriteAccess */: opts.lastuser = val; break;&#13;
				case 0x0042 /* CodePage */:&#13;
					var cpval = Number(val);&#13;
					/* overrides based on test cases */&#13;
					switch(cpval) {&#13;
						case 0x5212: cpval =  1200; break;&#13;
						case 0x8000: cpval = 10000; break;&#13;
						case 0x8001: cpval =  1252; break;&#13;
					}&#13;
					set_cp(opts.codepage = cpval);&#13;
					seen_codepage = true;&#13;
					break;&#13;
				case 0x013d /* RRTabId */: opts.rrtabid = val; break;&#13;
				case 0x0019 /* WinProtect */: opts.winlocked = val; break;&#13;
				case 0x01b7 /* RefreshAll */: wb.opts["RefreshAll"] = val; break;&#13;
				case 0x000c /* CalcCount */: wb.opts["CalcCount"] = val; break;&#13;
				case 0x0010 /* CalcDelta */: wb.opts["CalcDelta"] = val; break;&#13;
				case 0x0011 /* CalcIter */: wb.opts["CalcIter"] = val; break;&#13;
				case 0x000d /* CalcMode */: wb.opts["CalcMode"] = val; break;&#13;
				case 0x000e /* CalcPrecision */: wb.opts["CalcPrecision"] = val; break;&#13;
				case 0x005f /* CalcSaveRecalc */: wb.opts["CalcSaveRecalc"] = val; break;&#13;
				case 0x000f /* CalcRefMode */: opts.CalcRefMode = val; break; // TODO: implement R1C1&#13;
				case 0x08a3 /* ForceFullCalculation */: wb.opts.FullCalc = val; break;&#13;
				case 0x0081 /* WsBool */:&#13;
					if(val.fDialog) out["!type"] = "dialog";&#13;
					if(!val.fBelow) (out["!outline"] || (out["!outline"] = {})).above = true;&#13;
					if(!val.fRight) (out["!outline"] || (out["!outline"] = {})).left = true;&#13;
					break; // TODO&#13;
				case 0x00e0 /* XF */:&#13;
					XFs.push(val); break;&#13;
				case 0x01ae /* SupBook */:&#13;
					supbooks.push([val]);&#13;
					supbooks[supbooks.length-1].XTI = [];&#13;
					break;&#13;
				case 0x0023: case 0x0223 /* ExternName */:&#13;
					supbooks[supbooks.length-1].push(val);&#13;
					break;&#13;
				case 0x0018: case 0x0218 /* Lbl */:&#13;
					last_lbl = ({&#13;
						Name: val.Name,&#13;
						Ref: stringify_formula(val.rgce,range,null,supbooks,opts)&#13;
					});&#13;
					if(val.itab &gt; 0) last_lbl.Sheet = val.itab - 1;&#13;
					supbooks.names.push(last_lbl);&#13;
					if(!supbooks[0]) { supbooks[0] = []; supbooks[0].XTI = []; }&#13;
					supbooks[supbooks.length-1].push(val);&#13;
					if(val.Name == "_xlnm._FilterDatabase" &amp;&amp; val.itab &gt; 0)&#13;
						if(val.rgce &amp;&amp; val.rgce[0] &amp;&amp; val.rgce[0][0] &amp;&amp; val.rgce[0][0][0] == 'PtgArea3d')&#13;
							FilterDatabases[val.itab - 1] = { ref: encode_range(val.rgce[0][0][1][2]) };&#13;
					break;&#13;
				case 0x0016 /* ExternCount */: opts.ExternCount = val; break;&#13;
				case 0x0017 /* ExternSheet */:&#13;
					if(supbooks.length == 0) { supbooks[0] = []; supbooks[0].XTI = []; }&#13;
					supbooks[supbooks.length - 1].XTI = supbooks[supbooks.length - 1].XTI.concat(val); supbooks.XTI = supbooks.XTI.concat(val); break;&#13;
				case 0x0894 /* NameCmt */:&#13;
					/* TODO: search for correct name */&#13;
					if(opts.biff &lt; 8) break;&#13;
					if(last_lbl != null) last_lbl.Comment = val[1];&#13;
					break;&#13;
				case 0x0012 /* Protect */: out["!protect"] = val; break; /* for sheet or book */&#13;
				case 0x0013 /* Password */: if(val !== 0 &amp;&amp; opts.WTF) console.error("Password verifier: " + val); break;&#13;
				case 0x0085 /* BoundSheet8 */: {&#13;
					Directory[val.pos] = val;&#13;
					opts.snames.push(val.name);&#13;
				} break;&#13;
				case 0x000a /* EOF */: {&#13;
					if(--file_depth) break;&#13;
					if(range.e) {&#13;
						if(range.e.r &gt; 0 &amp;&amp; range.e.c &gt; 0) {&#13;
							range.e.r--; range.e.c--;&#13;
							out["!ref"] = encode_range(range);&#13;
							if(options.sheetRows &amp;&amp; options.sheetRows &lt;= range.e.r) {&#13;
								var tmpri = range.e.r;&#13;
								range.e.r = options.sheetRows - 1;&#13;
								out["!fullref"] = out["!ref"];&#13;
								out["!ref"] = encode_range(range);&#13;
								range.e.r = tmpri;&#13;
							}&#13;
							range.e.r++; range.e.c++;&#13;
						}&#13;
						if(merges.length &gt; 0) out["!merges"] = merges;&#13;
						if(objects.length &gt; 0) out["!objects"] = objects;&#13;
						if(colinfo.length &gt; 0) out["!cols"] = colinfo;&#13;
						if(rowinfo.length &gt; 0) out["!rows"] = rowinfo;&#13;
						Workbook.Sheets.push(wsprops);&#13;
					}&#13;
					if(cur_sheet === "") Preamble = out; else Sheets[cur_sheet] = out;&#13;
					out = ((options.dense ? [] : {}));&#13;
				} break;&#13;
				case 0x0009: case 0x0209: case 0x0409: case 0x0809 /* BOF */: {&#13;
					if(opts.biff === 8) opts.biff = {&#13;
0x0009:2,&#13;
0x0209:3,&#13;
0x0409:4&#13;
					}[RecordType] || {&#13;
0x0200:2,&#13;
0x0300:3,&#13;
0x0400:4,&#13;
0x0500:5,&#13;
0x0600:8,&#13;
0x0002:2,&#13;
0x0007:2&#13;
					}[val.BIFFVer] || 8;&#13;
					opts.biffguess = val.BIFFVer == 0;&#13;
					if(val.BIFFVer == 0 &amp;&amp; val.dt == 0x1000) { opts.biff = 5; seen_codepage = true; set_cp(opts.codepage = 28591); }&#13;
					if(opts.biff == 8 &amp;&amp; val.BIFFVer == 0 &amp;&amp; val.dt == 16) opts.biff = 2;&#13;
					if(file_depth++) break;&#13;
					out = ((options.dense ? [] : {}));&#13;
&#13;
					if(opts.biff &lt; 8 &amp;&amp; !seen_codepage) { seen_codepage = true; set_cp(opts.codepage = options.codepage || 1252); }&#13;
&#13;
					if(opts.biff &lt; 5 || val.BIFFVer == 0 &amp;&amp; val.dt == 0x1000) {&#13;
						if(cur_sheet === "") cur_sheet = "Sheet1";&#13;
						range = {s:{r:0,c:0},e:{r:0,c:0}};&#13;
						/* fake BoundSheet8 */&#13;
						var fakebs8 = {pos: blob.l - length, name:cur_sheet};&#13;
						Directory[fakebs8.pos] = fakebs8;&#13;
						opts.snames.push(cur_sheet);&#13;
					}&#13;
					else cur_sheet = (Directory[s] || {name:""}).name;&#13;
					if(val.dt == 0x20) out["!type"] = "chart";&#13;
					if(val.dt == 0x40) out["!type"] = "macro";&#13;
					merges = [];&#13;
					objects = [];&#13;
					opts.arrayf = arrayf = [];&#13;
					colinfo = []; rowinfo = [];&#13;
					seencol = false;&#13;
					wsprops = {Hidden:(Directory[s]||{hs:0}).hs, name:cur_sheet };&#13;
				} break;&#13;
				case 0x0203 /* Number */: case 0x0003 /* BIFF2NUM */: case 0x0002 /* BIFF2INT */: {&#13;
					if(out["!type"] == "chart") if(options.dense ? (out[val.r]||[])[val.c]: out[encode_cell({c:val.c, r:val.r})]) ++val.c;&#13;
					temp_val = ({ixfe: val.ixfe, XF: XFs[val.ixfe]||{}, v:val.val, t:'n'});&#13;
					if(BIFF2Fmt &gt; 0) temp_val.z = BIFF2FmtTable[(temp_val.ixfe&gt;&gt;8) &amp; 0x3F];&#13;
					safe_format_xf(temp_val, options, wb.opts.Date1904);&#13;
					addcell({c:val.c, r:val.r}, temp_val, options);&#13;
				} break;&#13;
				case 0x0005: case 0x0205 /* BoolErr */: {&#13;
					temp_val = ({ixfe: val.ixfe, XF: XFs[val.ixfe], v:val.val, t:val.t});&#13;
					if(BIFF2Fmt &gt; 0) temp_val.z = BIFF2FmtTable[(temp_val.ixfe&gt;&gt;8) &amp; 0x3F];&#13;
					safe_format_xf(temp_val, options, wb.opts.Date1904);&#13;
					addcell({c:val.c, r:val.r}, temp_val, options);&#13;
				} break;&#13;
				case 0x027e /* RK */: {&#13;
					temp_val = ({ixfe: val.ixfe, XF: XFs[val.ixfe], v:val.rknum, t:'n'});&#13;
					if(BIFF2Fmt &gt; 0) temp_val.z = BIFF2FmtTable[(temp_val.ixfe&gt;&gt;8) &amp; 0x3F];&#13;
					safe_format_xf(temp_val, options, wb.opts.Date1904);&#13;
					addcell({c:val.c, r:val.r}, temp_val, options);&#13;
				} break;&#13;
				case 0x00bd /* MulRk */: {&#13;
					for(var j = val.c; j &lt;= val.C; ++j) {&#13;
						var ixfe = val.rkrec[j-val.c][0];&#13;
						temp_val= ({ixfe:ixfe, XF:XFs[ixfe], v:val.rkrec[j-val.c][1], t:'n'});&#13;
						if(BIFF2Fmt &gt; 0) temp_val.z = BIFF2FmtTable[(temp_val.ixfe&gt;&gt;8) &amp; 0x3F];&#13;
						safe_format_xf(temp_val, options, wb.opts.Date1904);&#13;
						addcell({c:j, r:val.r}, temp_val, options);&#13;
					}&#13;
				} break;&#13;
				case 0x0006: case 0x0206: case 0x0406 /* Formula */: {&#13;
					if(val.val == 'String') { last_formula = val; break; }&#13;
					temp_val = make_cell(val.val, val.cell.ixfe, val.tt);&#13;
					temp_val.XF = XFs[temp_val.ixfe];&#13;
					if(options.cellFormula) {&#13;
						var _f = val.formula;&#13;
						if(_f &amp;&amp; _f[0] &amp;&amp; _f[0][0] &amp;&amp; _f[0][0][0] == 'PtgExp') {&#13;
							var _fr = _f[0][0][1][0], _fc = _f[0][0][1][1];&#13;
							var _fe = encode_cell({r:_fr, c:_fc});&#13;
							if(sharedf[_fe]) temp_val.f = ""+stringify_formula(val.formula,range,val.cell,supbooks, opts);&#13;
							else temp_val.F = ((options.dense ? (out[_fr]||[])[_fc]: out[_fe]) || {}).F;&#13;
						} else temp_val.f = ""+stringify_formula(val.formula,range,val.cell,supbooks, opts);&#13;
					}&#13;
					if(BIFF2Fmt &gt; 0) temp_val.z = BIFF2FmtTable[(temp_val.ixfe&gt;&gt;8) &amp; 0x3F];&#13;
					safe_format_xf(temp_val, options, wb.opts.Date1904);&#13;
					addcell(val.cell, temp_val, options);&#13;
					last_formula = val;&#13;
				} break;&#13;
				case 0x0007: case 0x0207 /* String */: {&#13;
					if(last_formula) { /* technically always true */&#13;
						last_formula.val = val;&#13;
						temp_val = make_cell(val, last_formula.cell.ixfe, 's');&#13;
						temp_val.XF = XFs[temp_val.ixfe];&#13;
						if(options.cellFormula) {&#13;
							temp_val.f = ""+stringify_formula(last_formula.formula, range, last_formula.cell, supbooks, opts);&#13;
						}&#13;
						if(BIFF2Fmt &gt; 0) temp_val.z = BIFF2FmtTable[(temp_val.ixfe&gt;&gt;8) &amp; 0x3F];&#13;
						safe_format_xf(temp_val, options, wb.opts.Date1904);&#13;
						addcell(last_formula.cell, temp_val, options);&#13;
						last_formula = null;&#13;
					} else throw new Error("String record expects Formula");&#13;
				} break;&#13;
				case 0x0021: case 0x0221 /* Array */: {&#13;
					arrayf.push(val);&#13;
					var _arraystart = encode_cell(val[0].s);&#13;
					cc = options.dense ? (out[val[0].s.r]||[])[val[0].s.c] : out[_arraystart];&#13;
					if(options.cellFormula &amp;&amp; cc) {&#13;
						if(!last_formula) break; /* technically unreachable */&#13;
						if(!_arraystart || !cc) break;&#13;
						cc.f = ""+stringify_formula(val[1], range, val[0], supbooks, opts);&#13;
						cc.F = encode_range(val[0]);&#13;
					}&#13;
				} break;&#13;
				case 0x04bc /* ShrFmla */: {&#13;
					if(!options.cellFormula) break;&#13;
					if(last_cell) {&#13;
						/* TODO: capture range */&#13;
						if(!last_formula) break; /* technically unreachable */&#13;
						sharedf[encode_cell(last_formula.cell)]= val[0];&#13;
						cc = options.dense ? (out[last_formula.cell.r]||[])[last_formula.cell.c] : out[encode_cell(last_formula.cell)];&#13;
						(cc||{}).f = ""+stringify_formula(val[0], range, lastcell, supbooks, opts);&#13;
					}&#13;
				} break;&#13;
				case 0x00fd /* LabelSst */:&#13;
					temp_val=make_cell(sst[val.isst].t, val.ixfe, 's');&#13;
					if(sst[val.isst].h) temp_val.h = sst[val.isst].h;&#13;
					temp_val.XF = XFs[temp_val.ixfe];&#13;
					if(BIFF2Fmt &gt; 0) temp_val.z = BIFF2FmtTable[(temp_val.ixfe&gt;&gt;8) &amp; 0x3F];&#13;
					safe_format_xf(temp_val, options, wb.opts.Date1904);&#13;
					addcell({c:val.c, r:val.r}, temp_val, options);&#13;
					break;&#13;
				case 0x0201 /* Blank */: if(options.sheetStubs) {&#13;
					temp_val = ({ixfe: val.ixfe, XF: XFs[val.ixfe], t:'z'});&#13;
					if(BIFF2Fmt &gt; 0) temp_val.z = BIFF2FmtTable[(temp_val.ixfe&gt;&gt;8) &amp; 0x3F];&#13;
					safe_format_xf(temp_val, options, wb.opts.Date1904);&#13;
					addcell({c:val.c, r:val.r}, temp_val, options);&#13;
				} break;&#13;
				case 0x00be /* MulBlank */: if(options.sheetStubs) {&#13;
					for(var _j = val.c; _j &lt;= val.C; ++_j) {&#13;
						var _ixfe = val.ixfe[_j-val.c];&#13;
						temp_val= ({ixfe:_ixfe, XF:XFs[_ixfe], t:'z'});&#13;
						if(BIFF2Fmt &gt; 0) temp_val.z = BIFF2FmtTable[(temp_val.ixfe&gt;&gt;8) &amp; 0x3F];&#13;
						safe_format_xf(temp_val, options, wb.opts.Date1904);&#13;
						addcell({c:_j, r:val.r}, temp_val, options);&#13;
					}&#13;
				} break;&#13;
				case 0x00d6 /* RString */:&#13;
				case 0x0204 /* Label */: case 0x0004 /* BIFF2STR */:&#13;
					temp_val=make_cell(val.val, val.ixfe, 's');&#13;
					temp_val.XF = XFs[temp_val.ixfe];&#13;
					if(BIFF2Fmt &gt; 0) temp_val.z = BIFF2FmtTable[(temp_val.ixfe&gt;&gt;8) &amp; 0x3F];&#13;
					safe_format_xf(temp_val, options, wb.opts.Date1904);&#13;
					addcell({c:val.c, r:val.r}, temp_val, options);&#13;
					break;&#13;
&#13;
				case 0x0000: case 0x0200 /* Dimensions */: {&#13;
					if(file_depth === 1) range = val; /* TODO: stack */&#13;
				} break;&#13;
				case 0x00fc /* SST */: {&#13;
					sst = val;&#13;
				} break;&#13;
				case 0x041e /* Format */: { /* val = [id, fmt] */&#13;
					if(opts.biff == 4) {&#13;
						BIFF2FmtTable[BIFF2Fmt++] = val[1];&#13;
						for(var b4idx = 0; b4idx &lt; BIFF2Fmt + 163; ++b4idx) if(table_fmt[b4idx] == val[1]) break;&#13;
						if(b4idx &gt;= 163) SSF__load(val[1], BIFF2Fmt + 163);&#13;
					}&#13;
					else SSF__load(val[1], val[0]);&#13;
				} break;&#13;
				case 0x001e /* BIFF2FORMAT */: {&#13;
					BIFF2FmtTable[BIFF2Fmt++] = val;&#13;
					for(var b2idx = 0; b2idx &lt; BIFF2Fmt + 163; ++b2idx) if(table_fmt[b2idx] == val) break;&#13;
					if(b2idx &gt;= 163) SSF__load(val, BIFF2Fmt + 163);&#13;
				} break;&#13;
&#13;
				case 0x00e5 /* MergeCells */: merges = merges.concat(val); break;&#13;
&#13;
				case 0x005d /* Obj */: objects[val.cmo[0]] = opts.lastobj = val; break;&#13;
				case 0x01b6 /* TxO */: opts.lastobj.TxO = val; break;&#13;
				case 0x007f /* ImData */: opts.lastobj.ImData = val; break;&#13;
&#13;
				case 0x01b8 /* HLink */: {&#13;
					for(rngR = val[0].s.r; rngR &lt;= val[0].e.r; ++rngR)&#13;
						for(rngC = val[0].s.c; rngC &lt;= val[0].e.c; ++rngC) {&#13;
							cc = options.dense ? (out[rngR]||[])[rngC] : out[encode_cell({c:rngC,r:rngR})];&#13;
							if(cc) cc.l = val[1];&#13;
						}&#13;
				} break;&#13;
				case 0x0800 /* HLinkTooltip */: {&#13;
					for(rngR = val[0].s.r; rngR &lt;= val[0].e.r; ++rngR)&#13;
						for(rngC = val[0].s.c; rngC &lt;= val[0].e.c; ++rngC) {&#13;
							cc = options.dense ? (out[rngR]||[])[rngC] : out[encode_cell({c:rngC,r:rngR})];&#13;
							if(cc &amp;&amp; cc.l) cc.l.Tooltip = val[1];&#13;
							}&#13;
				} break;&#13;
				case 0x001c /* Note */: {&#13;
					if(opts.biff &lt;= 5 &amp;&amp; opts.biff &gt;= 2) break; /* TODO: BIFF5 */&#13;
					cc = options.dense ? (out[val[0].r]||[])[val[0].c] : out[encode_cell(val[0])];&#13;
					var noteobj = objects[val[2]];&#13;
					if(!cc) {&#13;
						if(options.dense) {&#13;
							if(!out[val[0].r]) out[val[0].r] = [];&#13;
							cc = out[val[0].r][val[0].c] = ({t:"z"});&#13;
						} else {&#13;
							cc = out[encode_cell(val[0])] = ({t:"z"});&#13;
						}&#13;
						range.e.r = Math.max(range.e.r, val[0].r);&#13;
						range.s.r = Math.min(range.s.r, val[0].r);&#13;
						range.e.c = Math.max(range.e.c, val[0].c);&#13;
						range.s.c = Math.min(range.s.c, val[0].c);&#13;
					}&#13;
					if(!cc.c) cc.c = [];&#13;
					cmnt = {a:val[1],t:noteobj.TxO.t};&#13;
					cc.c.push(cmnt);&#13;
				} break;&#13;
				case 0x087d /* XFExt */: update_xfext(XFs[val.ixfe], val.ext); break;&#13;
				case 0x007d /* ColInfo */: {&#13;
					if(!opts.cellStyles) break;&#13;
					while(val.e &gt;= val.s) {&#13;
						colinfo[val.e--] = { width: val.w/256, level: (val.level || 0), hidden: !!(val.flags &amp; 1) };&#13;
						if(!seencol) { seencol = true; find_mdw_colw(val.w/256); }&#13;
						process_col(colinfo[val.e+1]);&#13;
					}&#13;
				} break;&#13;
				case 0x0208 /* Row */: {&#13;
					var rowobj = {};&#13;
					if(val.level != null) { rowinfo[val.r] = rowobj; rowobj.level = val.level; }&#13;
					if(val.hidden) { rowinfo[val.r] = rowobj; rowobj.hidden = true; }&#13;
					if(val.hpt) {&#13;
						rowinfo[val.r] = rowobj;&#13;
						rowobj.hpt = val.hpt; rowobj.hpx = pt2px(val.hpt);&#13;
					}&#13;
				} break;&#13;
				case 0x0026 /* LeftMargin */:&#13;
				case 0x0027 /* RightMargin */:&#13;
				case 0x0028 /* TopMargin */:&#13;
				case 0x0029 /* BottomMargin */:&#13;
					if(!out['!margins']) default_margins(out['!margins'] = {});&#13;
					out['!margins'][({0x26: "left", 0x27:"right", 0x28:"top", 0x29:"bottom"})[RecordType]] = val;&#13;
					break;&#13;
				case 0x00a1 /* Setup */: // TODO&#13;
					if(!out['!margins']) default_margins(out['!margins'] = {});&#13;
					out['!margins'].header = val.header;&#13;
					out['!margins'].footer = val.footer;&#13;
					break;&#13;
				case 0x023e /* Window2 */: // TODO&#13;
					// $FlowIgnore&#13;
					if(val.RTL) Workbook.Views[0].RTL = true;&#13;
					break;&#13;
				case 0x0092 /* Palette */: palette = val; break;&#13;
				case 0x0896 /* Theme */: themes = val; break;&#13;
				case 0x008c /* Country */: country = val; break;&#13;
				case 0x01ba /* CodeName */: {&#13;
if(!cur_sheet) Workbook.WBProps.CodeName = val || "ThisWorkbook";&#13;
					else wsprops.CodeName = val || wsprops.name;&#13;
				} break;&#13;
			}&#13;
		} else {&#13;
			if(!R) console.error("Missing Info for XLS Record 0x" + RecordType.toString(16));&#13;
			blob.l += length;&#13;
		}&#13;
	}&#13;
	wb.SheetNames=keys(Directory).sort(function(a,b) { return Number(a) - Number(b); }).map(function(x){return Directory[x].name;});&#13;
	if(!options.bookSheets) wb.Sheets=Sheets;&#13;
	if(!wb.SheetNames.length &amp;&amp; Preamble["!ref"]) {&#13;
		wb.SheetNames.push("Sheet1");&#13;
		/*jshint -W069 */&#13;
		if(wb.Sheets) wb.Sheets["Sheet1"] = Preamble;&#13;
		/*jshint +W069 */&#13;
	} else wb.Preamble=Preamble;&#13;
	if(wb.Sheets) FilterDatabases.forEach(function(r,i) { wb.Sheets[wb.SheetNames[i]]['!autofilter'] = r; });&#13;
	wb.Strings = sst;&#13;
	wb.SSF = dup(table_fmt);&#13;
	if(opts.enc) wb.Encryption = opts.enc;&#13;
	if(themes) wb.Themes = themes;&#13;
	wb.Metadata = {};&#13;
	if(country !== undefined) wb.Metadata.Country = country;&#13;
	if(supbooks.names.length &gt; 0) Workbook.Names = supbooks.names;&#13;
	wb.Workbook = Workbook;&#13;
	return wb;&#13;
}&#13;
&#13;
/* TODO: split props*/&#13;
var PSCLSID = {&#13;
	SI: "e0859ff2f94f6810ab9108002b27b3d9",&#13;
	DSI: "02d5cdd59c2e1b10939708002b2cf9ae",&#13;
	UDI: "05d5cdd59c2e1b10939708002b2cf9ae"&#13;
};&#13;
function parse_xls_props(cfb, props, o) {&#13;
	/* [MS-OSHARED] 2.3.3.2.2 Document Summary Information Property Set */&#13;
	var DSI = CFB.find(cfb, '/!DocumentSummaryInformation');&#13;
	if(DSI &amp;&amp; DSI.size &gt; 0) try {&#13;
		var DocSummary = parse_PropertySetStream(DSI, DocSummaryPIDDSI, PSCLSID.DSI);&#13;
		for(var d in DocSummary) props[d] = DocSummary[d];&#13;
	} catch(e) {if(o.WTF) throw e;/* empty */}&#13;
&#13;
	/* [MS-OSHARED] 2.3.3.2.1 Summary Information Property Set*/&#13;
	var SI = CFB.find(cfb, '/!SummaryInformation');&#13;
	if(SI &amp;&amp; SI.size &gt; 0) try {&#13;
		var Summary = parse_PropertySetStream(SI, SummaryPIDSI, PSCLSID.SI);&#13;
		for(var s in Summary) if(props[s] == null) props[s] = Summary[s];&#13;
	} catch(e) {if(o.WTF) throw e;/* empty */}&#13;
&#13;
	if(props.HeadingPairs &amp;&amp; props.TitlesOfParts) {&#13;
		load_props_pairs(props.HeadingPairs, props.TitlesOfParts, props, o);&#13;
		delete props.HeadingPairs; delete props.TitlesOfParts;&#13;
	}&#13;
}&#13;
function write_xls_props(wb, cfb) {&#13;
	var DSEntries = [], SEntries = [], CEntries = [];&#13;
	var i = 0, Keys;&#13;
	var DocSummaryRE = evert_key(DocSummaryPIDDSI, "n");&#13;
	var SummaryRE = evert_key(SummaryPIDSI, "n");&#13;
	if(wb.Props) {&#13;
		Keys = keys(wb.Props);&#13;
		// $FlowIgnore&#13;
		for(i = 0; i &lt; Keys.length; ++i) (Object.prototype.hasOwnProperty.call(DocSummaryRE, Keys[i]) ? DSEntries : Object.prototype.hasOwnProperty.call(SummaryRE, Keys[i]) ? SEntries : CEntries).push([Keys[i], wb.Props[Keys[i]]]);&#13;
	}&#13;
	if(wb.Custprops) {&#13;
		Keys = keys(wb.Custprops);&#13;
		// $FlowIgnore&#13;
		for(i = 0; i &lt; Keys.length; ++i) if(!Object.prototype.hasOwnProperty.call((wb.Props||{}), Keys[i])) (Object.prototype.hasOwnProperty.call(DocSummaryRE, Keys[i]) ? DSEntries : Object.prototype.hasOwnProperty.call(SummaryRE, Keys[i]) ? SEntries : CEntries).push([Keys[i], wb.Custprops[Keys[i]]]);&#13;
	}&#13;
	var CEntries2 = [];&#13;
	for(i = 0; i &lt; CEntries.length; ++i) {&#13;
		if(XLSPSSkip.indexOf(CEntries[i][0]) &gt; -1 || PseudoPropsPairs.indexOf(CEntries[i][0]) &gt; -1) continue;&#13;
		if(CEntries[i][1] == null) continue;&#13;
		CEntries2.push(CEntries[i]);&#13;
	}&#13;
	if(SEntries.length) CFB.utils.cfb_add(cfb, "/\u0005SummaryInformation", write_PropertySetStream(SEntries, PSCLSID.SI, SummaryRE, SummaryPIDSI));&#13;
	if(DSEntries.length || CEntries2.length) CFB.utils.cfb_add(cfb, "/\u0005DocumentSummaryInformation", write_PropertySetStream(DSEntries, PSCLSID.DSI, DocSummaryRE, DocSummaryPIDDSI, CEntries2.length ? CEntries2 : null, PSCLSID.UDI));&#13;
}&#13;
&#13;
function parse_xlscfb(cfb, options) {&#13;
if(!options) options = {};&#13;
fix_read_opts(options);&#13;
reset_cp();&#13;
if(options.codepage) set_ansi(options.codepage);&#13;
var CompObj, WB;&#13;
if(cfb.FullPaths) {&#13;
	if(CFB.find(cfb, '/encryption')) throw new Error("File is password-protected");&#13;
	CompObj = CFB.find(cfb, '!CompObj');&#13;
	WB = CFB.find(cfb, '/Workbook') || CFB.find(cfb, '/Book');&#13;
} else {&#13;
	switch(options.type) {&#13;
		case 'base64': cfb = s2a(Base64_decode(cfb)); break;&#13;
		case 'binary': cfb = s2a(cfb); break;&#13;
		case 'buffer': break;&#13;
		case 'array': if(!Array.isArray(cfb)) cfb = Array.prototype.slice.call(cfb); break;&#13;
	}&#13;
	prep_blob(cfb, 0);&#13;
	WB = ({content: cfb});&#13;
}&#13;
var WorkbookP;&#13;
&#13;
var _data;&#13;
if(CompObj) parse_compobj(CompObj);&#13;
if(options.bookProps &amp;&amp; !options.bookSheets) WorkbookP = ({});&#13;
else {&#13;
	var T = has_buf ? 'buffer' : 'array';&#13;
	if(WB &amp;&amp; WB.content) WorkbookP = parse_workbook(WB.content, options);&#13;
	/* Quattro Pro 7-8 */&#13;
	else if((_data=CFB.find(cfb, 'PerfectOffice_MAIN')) &amp;&amp; _data.content) WorkbookP = WK_.to_workbook(_data.content, (options.type = T, options));&#13;
	/* Quattro Pro 9 */&#13;
	else if((_data=CFB.find(cfb, 'NativeContent_MAIN')) &amp;&amp; _data.content) WorkbookP = WK_.to_workbook(_data.content, (options.type = T, options));&#13;
	/* Works 4 for Mac */&#13;
	else if((_data=CFB.find(cfb, 'MN0')) &amp;&amp; _data.content) throw new Error("Unsupported Works 4 for Mac file");&#13;
	else throw new Error("Cannot find Workbook stream");&#13;
	if(options.bookVBA &amp;&amp; cfb.FullPaths &amp;&amp; CFB.find(cfb, '/_VBA_PROJECT_CUR/VBA/dir')) WorkbookP.vbaraw = make_vba_xls(cfb);&#13;
}&#13;
&#13;
var props = {};&#13;
if(cfb.FullPaths) parse_xls_props(cfb, props, options);&#13;
&#13;
WorkbookP.Props = WorkbookP.Custprops = props; /* TODO: split up properties */&#13;
if(options.bookFiles) WorkbookP.cfb = cfb;&#13;
/*WorkbookP.CompObjP = CompObjP; // TODO: storage? */&#13;
return WorkbookP;&#13;
}&#13;
&#13;
&#13;
function write_xlscfb(wb, opts) {&#13;
	var o = opts || {};&#13;
	var cfb = CFB.utils.cfb_new({root:"R"});&#13;
	var wbpath = "/Workbook";&#13;
	switch(o.bookType || "xls") {&#13;
		case "xls": o.bookType = "biff8";&#13;
		/* falls through */&#13;
		case "xla": if(!o.bookType) o.bookType = "xla";&#13;
		/* falls through */&#13;
		case "biff8": wbpath = "/Workbook"; o.biff = 8; break;&#13;
		case "biff5": wbpath = "/Book"; o.biff = 5; break;&#13;
		default: throw new Error("invalid type " + o.bookType + " for XLS CFB");&#13;
	}&#13;
	CFB.utils.cfb_add(cfb, wbpath, write_biff_buf(wb, o));&#13;
	if(o.biff == 8 &amp;&amp; (wb.Props || wb.Custprops)) write_xls_props(wb, cfb);&#13;
	// TODO: SI, DSI, CO&#13;
	if(o.biff == 8 &amp;&amp; wb.vbaraw) fill_vba_xls(cfb, CFB.read(wb.vbaraw, {type: typeof wb.vbaraw == "string" ? "binary" : "buffer"}));&#13;
	return cfb;&#13;
}&#13;
/* [MS-XLSB] 2.3 Record Enumeration */&#13;
var XLSBRecordEnum = {&#13;
0x0000: { /* n:"BrtRowHdr", */ f:parse_BrtRowHdr },&#13;
0x0001: { /* n:"BrtCellBlank", */ f:parse_BrtCellBlank },&#13;
0x0002: { /* n:"BrtCellRk", */ f:parse_BrtCellRk },&#13;
0x0003: { /* n:"BrtCellError", */ f:parse_BrtCellError },&#13;
0x0004: { /* n:"BrtCellBool", */ f:parse_BrtCellBool },&#13;
0x0005: { /* n:"BrtCellReal", */ f:parse_BrtCellReal },&#13;
0x0006: { /* n:"BrtCellSt", */ f:parse_BrtCellSt },&#13;
0x0007: { /* n:"BrtCellIsst", */ f:parse_BrtCellIsst },&#13;
0x0008: { /* n:"BrtFmlaString", */ f:parse_BrtFmlaString },&#13;
0x0009: { /* n:"BrtFmlaNum", */ f:parse_BrtFmlaNum },&#13;
0x000A: { /* n:"BrtFmlaBool", */ f:parse_BrtFmlaBool },&#13;
0x000B: { /* n:"BrtFmlaError", */ f:parse_BrtFmlaError },&#13;
0x000C: { /* n:"BrtShortBlank", */ f:parse_BrtShortBlank },&#13;
0x000D: { /* n:"BrtShortRk", */ f:parse_BrtShortRk },&#13;
0x000E: { /* n:"BrtShortError", */ f:parse_BrtShortError },&#13;
0x000F: { /* n:"BrtShortBool", */ f:parse_BrtShortBool },&#13;
0x0010: { /* n:"BrtShortReal", */ f:parse_BrtShortReal },&#13;
0x0011: { /* n:"BrtShortSt", */ f:parse_BrtShortSt },&#13;
0x0012: { /* n:"BrtShortIsst", */ f:parse_BrtShortIsst },&#13;
0x0013: { /* n:"BrtSSTItem", */ f:parse_RichStr },&#13;
0x0014: { /* n:"BrtPCDIMissing" */ },&#13;
0x0015: { /* n:"BrtPCDINumber" */ },&#13;
0x0016: { /* n:"BrtPCDIBoolean" */ },&#13;
0x0017: { /* n:"BrtPCDIError" */ },&#13;
0x0018: { /* n:"BrtPCDIString" */ },&#13;
0x0019: { /* n:"BrtPCDIDatetime" */ },&#13;
0x001A: { /* n:"BrtPCDIIndex" */ },&#13;
0x001B: { /* n:"BrtPCDIAMissing" */ },&#13;
0x001C: { /* n:"BrtPCDIANumber" */ },&#13;
0x001D: { /* n:"BrtPCDIABoolean" */ },&#13;
0x001E: { /* n:"BrtPCDIAError" */ },&#13;
0x001F: { /* n:"BrtPCDIAString" */ },&#13;
0x0020: { /* n:"BrtPCDIADatetime" */ },&#13;
0x0021: { /* n:"BrtPCRRecord" */ },&#13;
0x0022: { /* n:"BrtPCRRecordDt" */ },&#13;
0x0023: { /* n:"BrtFRTBegin", */ T:1 },&#13;
0x0024: { /* n:"BrtFRTEnd", */ T:-1 },&#13;
0x0025: { /* n:"BrtACBegin", */ T:1 },&#13;
0x0026: { /* n:"BrtACEnd", */ T:-1 },&#13;
0x0027: { /* n:"BrtName", */ f:parse_BrtName },&#13;
0x0028: { /* n:"BrtIndexRowBlock" */ },&#13;
0x002A: { /* n:"BrtIndexBlock" */ },&#13;
0x002B: { /* n:"BrtFont", */ f:parse_BrtFont },&#13;
0x002C: { /* n:"BrtFmt", */ f:parse_BrtFmt },&#13;
0x002D: { /* n:"BrtFill", */ f:parse_BrtFill },&#13;
0x002E: { /* n:"BrtBorder", */ f:parse_BrtBorder },&#13;
0x002F: { /* n:"BrtXF", */ f:parse_BrtXF },&#13;
0x0030: { /* n:"BrtStyle" */ },&#13;
0x0031: { /* n:"BrtCellMeta", */ f:parse_Int32LE },&#13;
0x0032: { /* n:"BrtValueMeta" */ },&#13;
0x0033: { /* n:"BrtMdb" */ f:parse_BrtMdb },&#13;
0x0034: { /* n:"BrtBeginFmd", */ T:1 },&#13;
0x0035: { /* n:"BrtEndFmd", */ T:-1 },&#13;
0x0036: { /* n:"BrtBeginMdx", */ T:1 },&#13;
0x0037: { /* n:"BrtEndMdx", */ T:-1 },&#13;
0x0038: { /* n:"BrtBeginMdxTuple", */ T:1 },&#13;
0x0039: { /* n:"BrtEndMdxTuple", */ T:-1 },&#13;
0x003A: { /* n:"BrtMdxMbrIstr" */ },&#13;
0x003B: { /* n:"BrtStr" */ },&#13;
0x003C: { /* n:"BrtColInfo", */ f:parse_ColInfo },&#13;
0x003E: { /* n:"BrtCellRString", */ f:parse_BrtCellRString },&#13;
0x003F: { /* n:"BrtCalcChainItem$", */ f:parse_BrtCalcChainItem$ },&#13;
0x0040: { /* n:"BrtDVal", */ f:parse_BrtDVal },&#13;
0x0041: { /* n:"BrtSxvcellNum" */ },&#13;
0x0042: { /* n:"BrtSxvcellStr" */ },&#13;
0x0043: { /* n:"BrtSxvcellBool" */ },&#13;
0x0044: { /* n:"BrtSxvcellErr" */ },&#13;
0x0045: { /* n:"BrtSxvcellDate" */ },&#13;
0x0046: { /* n:"BrtSxvcellNil" */ },&#13;
0x0080: { /* n:"BrtFileVersion" */ },&#13;
0x0081: { /* n:"BrtBeginSheet", */ T:1 },&#13;
0x0082: { /* n:"BrtEndSheet", */ T:-1 },&#13;
0x0083: { /* n:"BrtBeginBook", */ T:1, f:parsenoop, p:0 },&#13;
0x0084: { /* n:"BrtEndBook", */ T:-1 },&#13;
0x0085: { /* n:"BrtBeginWsViews", */ T:1 },&#13;
0x0086: { /* n:"BrtEndWsViews", */ T:-1 },&#13;
0x0087: { /* n:"BrtBeginBookViews", */ T:1 },&#13;
0x0088: { /* n:"BrtEndBookViews", */ T:-1 },&#13;
0x0089: { /* n:"BrtBeginWsView", */ T:1, f:parse_BrtBeginWsView },&#13;
0x008A: { /* n:"BrtEndWsView", */ T:-1 },&#13;
0x008B: { /* n:"BrtBeginCsViews", */ T:1 },&#13;
0x008C: { /* n:"BrtEndCsViews", */ T:-1 },&#13;
0x008D: { /* n:"BrtBeginCsView", */ T:1 },&#13;
0x008E: { /* n:"BrtEndCsView", */ T:-1 },&#13;
0x008F: { /* n:"BrtBeginBundleShs", */ T:1 },&#13;
0x0090: { /* n:"BrtEndBundleShs", */ T:-1 },&#13;
0x0091: { /* n:"BrtBeginSheetData", */ T:1 },&#13;
0x0092: { /* n:"BrtEndSheetData", */ T:-1 },&#13;
0x0093: { /* n:"BrtWsProp", */ f:parse_BrtWsProp },&#13;
0x0094: { /* n:"BrtWsDim", */ f:parse_BrtWsDim, p:16 },&#13;
0x0097: { /* n:"BrtPane", */ f:parse_BrtPane },&#13;
0x0098: { /* n:"BrtSel" */ },&#13;
0x0099: { /* n:"BrtWbProp", */ f:parse_BrtWbProp },&#13;
0x009A: { /* n:"BrtWbFactoid" */ },&#13;
0x009B: { /* n:"BrtFileRecover" */ },&#13;
0x009C: { /* n:"BrtBundleSh", */ f:parse_BrtBundleSh },&#13;
0x009D: { /* n:"BrtCalcProp" */ },&#13;
0x009E: { /* n:"BrtBookView" */ },&#13;
0x009F: { /* n:"BrtBeginSst", */ T:1, f:parse_BrtBeginSst },&#13;
0x00A0: { /* n:"BrtEndSst", */ T:-1 },&#13;
0x00A1: { /* n:"BrtBeginAFilter", */ T:1, f:parse_UncheckedRfX },&#13;
0x00A2: { /* n:"BrtEndAFilter", */ T:-1 },&#13;
0x00A3: { /* n:"BrtBeginFilterColumn", */ T:1 },&#13;
0x00A4: { /* n:"BrtEndFilterColumn", */ T:-1 },&#13;
0x00A5: { /* n:"BrtBeginFilters", */ T:1 },&#13;
0x00A6: { /* n:"BrtEndFilters", */ T:-1 },&#13;
0x00A7: { /* n:"BrtFilter" */ },&#13;
0x00A8: { /* n:"BrtColorFilter" */ },&#13;
0x00A9: { /* n:"BrtIconFilter" */ },&#13;
0x00AA: { /* n:"BrtTop10Filter" */ },&#13;
0x00AB: { /* n:"BrtDynamicFilter" */ },&#13;
0x00AC: { /* n:"BrtBeginCustomFilters", */ T:1 },&#13;
0x00AD: { /* n:"BrtEndCustomFilters", */ T:-1 },&#13;
0x00AE: { /* n:"BrtCustomFilter" */ },&#13;
0x00AF: { /* n:"BrtAFilterDateGroupItem" */ },&#13;
0x00B0: { /* n:"BrtMergeCell", */ f:parse_BrtMergeCell },&#13;
0x00B1: { /* n:"BrtBeginMergeCells", */ T:1 },&#13;
0x00B2: { /* n:"BrtEndMergeCells", */ T:-1 },&#13;
0x00B3: { /* n:"BrtBeginPivotCacheDef", */ T:1 },&#13;
0x00B4: { /* n:"BrtEndPivotCacheDef", */ T:-1 },&#13;
0x00B5: { /* n:"BrtBeginPCDFields", */ T:1 },&#13;
0x00B6: { /* n:"BrtEndPCDFields", */ T:-1 },&#13;
0x00B7: { /* n:"BrtBeginPCDField", */ T:1 },&#13;
0x00B8: { /* n:"BrtEndPCDField", */ T:-1 },&#13;
0x00B9: { /* n:"BrtBeginPCDSource", */ T:1 },&#13;
0x00BA: { /* n:"BrtEndPCDSource", */ T:-1 },&#13;
0x00BB: { /* n:"BrtBeginPCDSRange", */ T:1 },&#13;
0x00BC: { /* n:"BrtEndPCDSRange", */ T:-1 },&#13;
0x00BD: { /* n:"BrtBeginPCDFAtbl", */ T:1 },&#13;
0x00BE: { /* n:"BrtEndPCDFAtbl", */ T:-1 },&#13;
0x00BF: { /* n:"BrtBeginPCDIRun", */ T:1 },&#13;
0x00C0: { /* n:"BrtEndPCDIRun", */ T:-1 },&#13;
0x00C1: { /* n:"BrtBeginPivotCacheRecords", */ T:1 },&#13;
0x00C2: { /* n:"BrtEndPivotCacheRecords", */ T:-1 },&#13;
0x00C3: { /* n:"BrtBeginPCDHierarchies", */ T:1 },&#13;
0x00C4: { /* n:"BrtEndPCDHierarchies", */ T:-1 },&#13;
0x00C5: { /* n:"BrtBeginPCDHierarchy", */ T:1 },&#13;
0x00C6: { /* n:"BrtEndPCDHierarchy", */ T:-1 },&#13;
0x00C7: { /* n:"BrtBeginPCDHFieldsUsage", */ T:1 },&#13;
0x00C8: { /* n:"BrtEndPCDHFieldsUsage", */ T:-1 },&#13;
0x00C9: { /* n:"BrtBeginExtConnection", */ T:1 },&#13;
0x00CA: { /* n:"BrtEndExtConnection", */ T:-1 },&#13;
0x00CB: { /* n:"BrtBeginECDbProps", */ T:1 },&#13;
0x00CC: { /* n:"BrtEndECDbProps", */ T:-1 },&#13;
0x00CD: { /* n:"BrtBeginECOlapProps", */ T:1 },&#13;
0x00CE: { /* n:"BrtEndECOlapProps", */ T:-1 },&#13;
0x00CF: { /* n:"BrtBeginPCDSConsol", */ T:1 },&#13;
0x00D0: { /* n:"BrtEndPCDSConsol", */ T:-1 },&#13;
0x00D1: { /* n:"BrtBeginPCDSCPages", */ T:1 },&#13;
0x00D2: { /* n:"BrtEndPCDSCPages", */ T:-1 },&#13;
0x00D3: { /* n:"BrtBeginPCDSCPage", */ T:1 },&#13;
0x00D4: { /* n:"BrtEndPCDSCPage", */ T:-1 },&#13;
0x00D5: { /* n:"BrtBeginPCDSCPItem", */ T:1 },&#13;
0x00D6: { /* n:"BrtEndPCDSCPItem", */ T:-1 },&#13;
0x00D7: { /* n:"BrtBeginPCDSCSets", */ T:1 },&#13;
0x00D8: { /* n:"BrtEndPCDSCSets", */ T:-1 },&#13;
0x00D9: { /* n:"BrtBeginPCDSCSet", */ T:1 },&#13;
0x00DA: { /* n:"BrtEndPCDSCSet", */ T:-1 },&#13;
0x00DB: { /* n:"BrtBeginPCDFGroup", */ T:1 },&#13;
0x00DC: { /* n:"BrtEndPCDFGroup", */ T:-1 },&#13;
0x00DD: { /* n:"BrtBeginPCDFGItems", */ T:1 },&#13;
0x00DE: { /* n:"BrtEndPCDFGItems", */ T:-1 },&#13;
0x00DF: { /* n:"BrtBeginPCDFGRange", */ T:1 },&#13;
0x00E0: { /* n:"BrtEndPCDFGRange", */ T:-1 },&#13;
0x00E1: { /* n:"BrtBeginPCDFGDiscrete", */ T:1 },&#13;
0x00E2: { /* n:"BrtEndPCDFGDiscrete", */ T:-1 },&#13;
0x00E3: { /* n:"BrtBeginPCDSDTupleCache", */ T:1 },&#13;
0x00E4: { /* n:"BrtEndPCDSDTupleCache", */ T:-1 },&#13;
0x00E5: { /* n:"BrtBeginPCDSDTCEntries", */ T:1 },&#13;
0x00E6: { /* n:"BrtEndPCDSDTCEntries", */ T:-1 },&#13;
0x00E7: { /* n:"BrtBeginPCDSDTCEMembers", */ T:1 },&#13;
0x00E8: { /* n:"BrtEndPCDSDTCEMembers", */ T:-1 },&#13;
0x00E9: { /* n:"BrtBeginPCDSDTCEMember", */ T:1 },&#13;
0x00EA: { /* n:"BrtEndPCDSDTCEMember", */ T:-1 },&#13;
0x00EB: { /* n:"BrtBeginPCDSDTCQueries", */ T:1 },&#13;
0x00EC: { /* n:"BrtEndPCDSDTCQueries", */ T:-1 },&#13;
0x00ED: { /* n:"BrtBeginPCDSDTCQuery", */ T:1 },&#13;
0x00EE: { /* n:"BrtEndPCDSDTCQuery", */ T:-1 },&#13;
0x00EF: { /* n:"BrtBeginPCDSDTCSets", */ T:1 },&#13;
0x00F0: { /* n:"BrtEndPCDSDTCSets", */ T:-1 },&#13;
0x00F1: { /* n:"BrtBeginPCDSDTCSet", */ T:1 },&#13;
0x00F2: { /* n:"BrtEndPCDSDTCSet", */ T:-1 },&#13;
0x00F3: { /* n:"BrtBeginPCDCalcItems", */ T:1 },&#13;
0x00F4: { /* n:"BrtEndPCDCalcItems", */ T:-1 },&#13;
0x00F5: { /* n:"BrtBeginPCDCalcItem", */ T:1 },&#13;
0x00F6: { /* n:"BrtEndPCDCalcItem", */ T:-1 },&#13;
0x00F7: { /* n:"BrtBeginPRule", */ T:1 },&#13;
0x00F8: { /* n:"BrtEndPRule", */ T:-1 },&#13;
0x00F9: { /* n:"BrtBeginPRFilters", */ T:1 },&#13;
0x00FA: { /* n:"BrtEndPRFilters", */ T:-1 },&#13;
0x00FB: { /* n:"BrtBeginPRFilter", */ T:1 },&#13;
0x00FC: { /* n:"BrtEndPRFilter", */ T:-1 },&#13;
0x00FD: { /* n:"BrtBeginPNames", */ T:1 },&#13;
0x00FE: { /* n:"BrtEndPNames", */ T:-1 },&#13;
0x00FF: { /* n:"BrtBeginPName", */ T:1 },&#13;
0x0100: { /* n:"BrtEndPName", */ T:-1 },&#13;
0x0101: { /* n:"BrtBeginPNPairs", */ T:1 },&#13;
0x0102: { /* n:"BrtEndPNPairs", */ T:-1 },&#13;
0x0103: { /* n:"BrtBeginPNPair", */ T:1 },&#13;
0x0104: { /* n:"BrtEndPNPair", */ T:-1 },&#13;
0x0105: { /* n:"BrtBeginECWebProps", */ T:1 },&#13;
0x0106: { /* n:"BrtEndECWebProps", */ T:-1 },&#13;
0x0107: { /* n:"BrtBeginEcWpTables", */ T:1 },&#13;
0x0108: { /* n:"BrtEndECWPTables", */ T:-1 },&#13;
0x0109: { /* n:"BrtBeginECParams", */ T:1 },&#13;
0x010A: { /* n:"BrtEndECParams", */ T:-1 },&#13;
0x010B: { /* n:"BrtBeginECParam", */ T:1 },&#13;
0x010C: { /* n:"BrtEndECParam", */ T:-1 },&#13;
0x010D: { /* n:"BrtBeginPCDKPIs", */ T:1 },&#13;
0x010E: { /* n:"BrtEndPCDKPIs", */ T:-1 },&#13;
0x010F: { /* n:"BrtBeginPCDKPI", */ T:1 },&#13;
0x0110: { /* n:"BrtEndPCDKPI", */ T:-1 },&#13;
0x0111: { /* n:"BrtBeginDims", */ T:1 },&#13;
0x0112: { /* n:"BrtEndDims", */ T:-1 },&#13;
0x0113: { /* n:"BrtBeginDim", */ T:1 },&#13;
0x0114: { /* n:"BrtEndDim", */ T:-1 },&#13;
0x0115: { /* n:"BrtIndexPartEnd" */ },&#13;
0x0116: { /* n:"BrtBeginStyleSheet", */ T:1 },&#13;
0x0117: { /* n:"BrtEndStyleSheet", */ T:-1 },&#13;
0x0118: { /* n:"BrtBeginSXView", */ T:1 },&#13;
0x0119: { /* n:"BrtEndSXVI", */ T:-1 },&#13;
0x011A: { /* n:"BrtBeginSXVI", */ T:1 },&#13;
0x011B: { /* n:"BrtBeginSXVIs", */ T:1 },&#13;
0x011C: { /* n:"BrtEndSXVIs", */ T:-1 },&#13;
0x011D: { /* n:"BrtBeginSXVD", */ T:1 },&#13;
0x011E: { /* n:"BrtEndSXVD", */ T:-1 },&#13;
0x011F: { /* n:"BrtBeginSXVDs", */ T:1 },&#13;
0x0120: { /* n:"BrtEndSXVDs", */ T:-1 },&#13;
0x0121: { /* n:"BrtBeginSXPI", */ T:1 },&#13;
0x0122: { /* n:"BrtEndSXPI", */ T:-1 },&#13;
0x0123: { /* n:"BrtBeginSXPIs", */ T:1 },&#13;
0x0124: { /* n:"BrtEndSXPIs", */ T:-1 },&#13;
0x0125: { /* n:"BrtBeginSXDI", */ T:1 },&#13;
0x0126: { /* n:"BrtEndSXDI", */ T:-1 },&#13;
0x0127: { /* n:"BrtBeginSXDIs", */ T:1 },&#13;
0x0128: { /* n:"BrtEndSXDIs", */ T:-1 },&#13;
0x0129: { /* n:"BrtBeginSXLI", */ T:1 },&#13;
0x012A: { /* n:"BrtEndSXLI", */ T:-1 },&#13;
0x012B: { /* n:"BrtBeginSXLIRws", */ T:1 },&#13;
0x012C: { /* n:"BrtEndSXLIRws", */ T:-1 },&#13;
0x012D: { /* n:"BrtBeginSXLICols", */ T:1 },&#13;
0x012E: { /* n:"BrtEndSXLICols", */ T:-1 },&#13;
0x012F: { /* n:"BrtBeginSXFormat", */ T:1 },&#13;
0x0130: { /* n:"BrtEndSXFormat", */ T:-1 },&#13;
0x0131: { /* n:"BrtBeginSXFormats", */ T:1 },&#13;
0x0132: { /* n:"BrtEndSxFormats", */ T:-1 },&#13;
0x0133: { /* n:"BrtBeginSxSelect", */ T:1 },&#13;
0x0134: { /* n:"BrtEndSxSelect", */ T:-1 },&#13;
0x0135: { /* n:"BrtBeginISXVDRws", */ T:1 },&#13;
0x0136: { /* n:"BrtEndISXVDRws", */ T:-1 },&#13;
0x0137: { /* n:"BrtBeginISXVDCols", */ T:1 },&#13;
0x0138: { /* n:"BrtEndISXVDCols", */ T:-1 },&#13;
0x0139: { /* n:"BrtEndSXLocation", */ T:-1 },&#13;
0x013A: { /* n:"BrtBeginSXLocation", */ T:1 },&#13;
0x013B: { /* n:"BrtEndSXView", */ T:-1 },&#13;
0x013C: { /* n:"BrtBeginSXTHs", */ T:1 },&#13;
0x013D: { /* n:"BrtEndSXTHs", */ T:-1 },&#13;
0x013E: { /* n:"BrtBeginSXTH", */ T:1 },&#13;
0x013F: { /* n:"BrtEndSXTH", */ T:-1 },&#13;
0x0140: { /* n:"BrtBeginISXTHRws", */ T:1 },&#13;
0x0141: { /* n:"BrtEndISXTHRws", */ T:-1 },&#13;
0x0142: { /* n:"BrtBeginISXTHCols", */ T:1 },&#13;
0x0143: { /* n:"BrtEndISXTHCols", */ T:-1 },&#13;
0x0144: { /* n:"BrtBeginSXTDMPS", */ T:1 },&#13;
0x0145: { /* n:"BrtEndSXTDMPs", */ T:-1 },&#13;
0x0146: { /* n:"BrtBeginSXTDMP", */ T:1 },&#13;
0x0147: { /* n:"BrtEndSXTDMP", */ T:-1 },&#13;
0x0148: { /* n:"BrtBeginSXTHItems", */ T:1 },&#13;
0x0149: { /* n:"BrtEndSXTHItems", */ T:-1 },&#13;
0x014A: { /* n:"BrtBeginSXTHItem", */ T:1 },&#13;
0x014B: { /* n:"BrtEndSXTHItem", */ T:-1 },&#13;
0x014C: { /* n:"BrtBeginMetadata", */ T:1 },&#13;
0x014D: { /* n:"BrtEndMetadata", */ T:-1 },&#13;
0x014E: { /* n:"BrtBeginEsmdtinfo", */ T:1 },&#13;
0x014F: { /* n:"BrtMdtinfo", */ f:parse_BrtMdtinfo },&#13;
0x0150: { /* n:"BrtEndEsmdtinfo", */ T:-1 },&#13;
0x0151: { /* n:"BrtBeginEsmdb", */ f:parse_BrtBeginEsmdb, T:1 },&#13;
0x0152: { /* n:"BrtEndEsmdb", */ T:-1 },&#13;
0x0153: { /* n:"BrtBeginEsfmd", */ T:1 },&#13;
0x0154: { /* n:"BrtEndEsfmd", */ T:-1 },&#13;
0x0155: { /* n:"BrtBeginSingleCells", */ T:1 },&#13;
0x0156: { /* n:"BrtEndSingleCells", */ T:-1 },&#13;
0x0157: { /* n:"BrtBeginList", */ T:1 },&#13;
0x0158: { /* n:"BrtEndList", */ T:-1 },&#13;
0x0159: { /* n:"BrtBeginListCols", */ T:1 },&#13;
0x015A: { /* n:"BrtEndListCols", */ T:-1 },&#13;
0x015B: { /* n:"BrtBeginListCol", */ T:1 },&#13;
0x015C: { /* n:"BrtEndListCol", */ T:-1 },&#13;
0x015D: { /* n:"BrtBeginListXmlCPr", */ T:1 },&#13;
0x015E: { /* n:"BrtEndListXmlCPr", */ T:-1 },&#13;
0x015F: { /* n:"BrtListCCFmla" */ },&#13;
0x0160: { /* n:"BrtListTrFmla" */ },&#13;
0x0161: { /* n:"BrtBeginExternals", */ T:1 },&#13;
0x0162: { /* n:"BrtEndExternals", */ T:-1 },&#13;
0x0163: { /* n:"BrtSupBookSrc", */ f:parse_RelID},&#13;
0x0165: { /* n:"BrtSupSelf" */ },&#13;
0x0166: { /* n:"BrtSupSame" */ },&#13;
0x0167: { /* n:"BrtSupTabs" */ },&#13;
0x0168: { /* n:"BrtBeginSupBook", */ T:1 },&#13;
0x0169: { /* n:"BrtPlaceholderName" */ },&#13;
0x016A: { /* n:"BrtExternSheet", */ f:parse_ExternSheet },&#13;
0x016B: { /* n:"BrtExternTableStart" */ },&#13;
0x016C: { /* n:"BrtExternTableEnd" */ },&#13;
0x016E: { /* n:"BrtExternRowHdr" */ },&#13;
0x016F: { /* n:"BrtExternCellBlank" */ },&#13;
0x0170: { /* n:"BrtExternCellReal" */ },&#13;
0x0171: { /* n:"BrtExternCellBool" */ },&#13;
0x0172: { /* n:"BrtExternCellError" */ },&#13;
0x0173: { /* n:"BrtExternCellString" */ },&#13;
0x0174: { /* n:"BrtBeginEsmdx", */ T:1 },&#13;
0x0175: { /* n:"BrtEndEsmdx", */ T:-1 },&#13;
0x0176: { /* n:"BrtBeginMdxSet", */ T:1 },&#13;
0x0177: { /* n:"BrtEndMdxSet", */ T:-1 },&#13;
0x0178: { /* n:"BrtBeginMdxMbrProp", */ T:1 },&#13;
0x0179: { /* n:"BrtEndMdxMbrProp", */ T:-1 },&#13;
0x017A: { /* n:"BrtBeginMdxKPI", */ T:1 },&#13;
0x017B: { /* n:"BrtEndMdxKPI", */ T:-1 },&#13;
0x017C: { /* n:"BrtBeginEsstr", */ T:1 },&#13;
0x017D: { /* n:"BrtEndEsstr", */ T:-1 },&#13;
0x017E: { /* n:"BrtBeginPRFItem", */ T:1 },&#13;
0x017F: { /* n:"BrtEndPRFItem", */ T:-1 },&#13;
0x0180: { /* n:"BrtBeginPivotCacheIDs", */ T:1 },&#13;
0x0181: { /* n:"BrtEndPivotCacheIDs", */ T:-1 },&#13;
0x0182: { /* n:"BrtBeginPivotCacheID", */ T:1 },&#13;
0x0183: { /* n:"BrtEndPivotCacheID", */ T:-1 },&#13;
0x0184: { /* n:"BrtBeginISXVIs", */ T:1 },&#13;
0x0185: { /* n:"BrtEndISXVIs", */ T:-1 },&#13;
0x0186: { /* n:"BrtBeginColInfos", */ T:1 },&#13;
0x0187: { /* n:"BrtEndColInfos", */ T:-1 },&#13;
0x0188: { /* n:"BrtBeginRwBrk", */ T:1 },&#13;
0x0189: { /* n:"BrtEndRwBrk", */ T:-1 },&#13;
0x018A: { /* n:"BrtBeginColBrk", */ T:1 },&#13;
0x018B: { /* n:"BrtEndColBrk", */ T:-1 },&#13;
0x018C: { /* n:"BrtBrk" */ },&#13;
0x018D: { /* n:"BrtUserBookView" */ },&#13;
0x018E: { /* n:"BrtInfo" */ },&#13;
0x018F: { /* n:"BrtCUsr" */ },&#13;
0x0190: { /* n:"BrtUsr" */ },&#13;
0x0191: { /* n:"BrtBeginUsers", */ T:1 },&#13;
0x0193: { /* n:"BrtEOF" */ },&#13;
0x0194: { /* n:"BrtUCR" */ },&#13;
0x0195: { /* n:"BrtRRInsDel" */ },&#13;
0x0196: { /* n:"BrtRREndInsDel" */ },&#13;
0x0197: { /* n:"BrtRRMove" */ },&#13;
0x0198: { /* n:"BrtRREndMove" */ },&#13;
0x0199: { /* n:"BrtRRChgCell" */ },&#13;
0x019A: { /* n:"BrtRREndChgCell" */ },&#13;
0x019B: { /* n:"BrtRRHeader" */ },&#13;
0x019C: { /* n:"BrtRRUserView" */ },&#13;
0x019D: { /* n:"BrtRRRenSheet" */ },&#13;
0x019E: { /* n:"BrtRRInsertSh" */ },&#13;
0x019F: { /* n:"BrtRRDefName" */ },&#13;
0x01A0: { /* n:"BrtRRNote" */ },&#13;
0x01A1: { /* n:"BrtRRConflict" */ },&#13;
0x01A2: { /* n:"BrtRRTQSIF" */ },&#13;
0x01A3: { /* n:"BrtRRFormat" */ },&#13;
0x01A4: { /* n:"BrtRREndFormat" */ },&#13;
0x01A5: { /* n:"BrtRRAutoFmt" */ },&#13;
0x01A6: { /* n:"BrtBeginUserShViews", */ T:1 },&#13;
0x01A7: { /* n:"BrtBeginUserShView", */ T:1 },&#13;
0x01A8: { /* n:"BrtEndUserShView", */ T:-1 },&#13;
0x01A9: { /* n:"BrtEndUserShViews", */ T:-1 },&#13;
0x01AA: { /* n:"BrtArrFmla", */ f:parse_BrtArrFmla },&#13;
0x01AB: { /* n:"BrtShrFmla", */ f:parse_BrtShrFmla },&#13;
0x01AC: { /* n:"BrtTable" */ },&#13;
0x01AD: { /* n:"BrtBeginExtConnections", */ T:1 },&#13;
0x01AE: { /* n:"BrtEndExtConnections", */ T:-1 },&#13;
0x01AF: { /* n:"BrtBeginPCDCalcMems", */ T:1 },&#13;
0x01B0: { /* n:"BrtEndPCDCalcMems", */ T:-1 },&#13;
0x01B1: { /* n:"BrtBeginPCDCalcMem", */ T:1 },&#13;
0x01B2: { /* n:"BrtEndPCDCalcMem", */ T:-1 },&#13;
0x01B3: { /* n:"BrtBeginPCDHGLevels", */ T:1 },&#13;
0x01B4: { /* n:"BrtEndPCDHGLevels", */ T:-1 },&#13;
0x01B5: { /* n:"BrtBeginPCDHGLevel", */ T:1 },&#13;
0x01B6: { /* n:"BrtEndPCDHGLevel", */ T:-1 },&#13;
0x01B7: { /* n:"BrtBeginPCDHGLGroups", */ T:1 },&#13;
0x01B8: { /* n:"BrtEndPCDHGLGroups", */ T:-1 },&#13;
0x01B9: { /* n:"BrtBeginPCDHGLGroup", */ T:1 },&#13;
0x01BA: { /* n:"BrtEndPCDHGLGroup", */ T:-1 },&#13;
0x01BB: { /* n:"BrtBeginPCDHGLGMembers", */ T:1 },&#13;
0x01BC: { /* n:"BrtEndPCDHGLGMembers", */ T:-1 },&#13;
0x01BD: { /* n:"BrtBeginPCDHGLGMember", */ T:1 },&#13;
0x01BE: { /* n:"BrtEndPCDHGLGMember", */ T:-1 },&#13;
0x01BF: { /* n:"BrtBeginQSI", */ T:1 },&#13;
0x01C0: { /* n:"BrtEndQSI", */ T:-1 },&#13;
0x01C1: { /* n:"BrtBeginQSIR", */ T:1 },&#13;
0x01C2: { /* n:"BrtEndQSIR", */ T:-1 },&#13;
0x01C3: { /* n:"BrtBeginDeletedNames", */ T:1 },&#13;
0x01C4: { /* n:"BrtEndDeletedNames", */ T:-1 },&#13;
0x01C5: { /* n:"BrtBeginDeletedName", */ T:1 },&#13;
0x01C6: { /* n:"BrtEndDeletedName", */ T:-1 },&#13;
0x01C7: { /* n:"BrtBeginQSIFs", */ T:1 },&#13;
0x01C8: { /* n:"BrtEndQSIFs", */ T:-1 },&#13;
0x01C9: { /* n:"BrtBeginQSIF", */ T:1 },&#13;
0x01CA: { /* n:"BrtEndQSIF", */ T:-1 },&#13;
0x01CB: { /* n:"BrtBeginAutoSortScope", */ T:1 },&#13;
0x01CC: { /* n:"BrtEndAutoSortScope", */ T:-1 },&#13;
0x01CD: { /* n:"BrtBeginConditionalFormatting", */ T:1 },&#13;
0x01CE: { /* n:"BrtEndConditionalFormatting", */ T:-1 },&#13;
0x01CF: { /* n:"BrtBeginCFRule", */ T:1 },&#13;
0x01D0: { /* n:"BrtEndCFRule", */ T:-1 },&#13;
0x01D1: { /* n:"BrtBeginIconSet", */ T:1 },&#13;
0x01D2: { /* n:"BrtEndIconSet", */ T:-1 },&#13;
0x01D3: { /* n:"BrtBeginDatabar", */ T:1 },&#13;
0x01D4: { /* n:"BrtEndDatabar", */ T:-1 },&#13;
0x01D5: { /* n:"BrtBeginColorScale", */ T:1 },&#13;
0x01D6: { /* n:"BrtEndColorScale", */ T:-1 },&#13;
0x01D7: { /* n:"BrtCFVO" */ },&#13;
0x01D8: { /* n:"BrtExternValueMeta" */ },&#13;
0x01D9: { /* n:"BrtBeginColorPalette", */ T:1 },&#13;
0x01DA: { /* n:"BrtEndColorPalette", */ T:-1 },&#13;
0x01DB: { /* n:"BrtIndexedColor" */ },&#13;
0x01DC: { /* n:"BrtMargins", */ f:parse_BrtMargins },&#13;
0x01DD: { /* n:"BrtPrintOptions" */ },&#13;
0x01DE: { /* n:"BrtPageSetup" */ },&#13;
0x01DF: { /* n:"BrtBeginHeaderFooter", */ T:1 },&#13;
0x01E0: { /* n:"BrtEndHeaderFooter", */ T:-1 },&#13;
0x01E1: { /* n:"BrtBeginSXCrtFormat", */ T:1 },&#13;
0x01E2: { /* n:"BrtEndSXCrtFormat", */ T:-1 },&#13;
0x01E3: { /* n:"BrtBeginSXCrtFormats", */ T:1 },&#13;
0x01E4: { /* n:"BrtEndSXCrtFormats", */ T:-1 },&#13;
0x01E5: { /* n:"BrtWsFmtInfo", */ f:parse_BrtWsFmtInfo },&#13;
0x01E6: { /* n:"BrtBeginMgs", */ T:1 },&#13;
0x01E7: { /* n:"BrtEndMGs", */ T:-1 },&#13;
0x01E8: { /* n:"BrtBeginMGMaps", */ T:1 },&#13;
0x01E9: { /* n:"BrtEndMGMaps", */ T:-1 },&#13;
0x01EA: { /* n:"BrtBeginMG", */ T:1 },&#13;
0x01EB: { /* n:"BrtEndMG", */ T:-1 },&#13;
0x01EC: { /* n:"BrtBeginMap", */ T:1 },&#13;
0x01ED: { /* n:"BrtEndMap", */ T:-1 },&#13;
0x01EE: { /* n:"BrtHLink", */ f:parse_BrtHLink },&#13;
0x01EF: { /* n:"BrtBeginDCon", */ T:1 },&#13;
0x01F0: { /* n:"BrtEndDCon", */ T:-1 },&#13;
0x01F1: { /* n:"BrtBeginDRefs", */ T:1 },&#13;
0x01F2: { /* n:"BrtEndDRefs", */ T:-1 },&#13;
0x01F3: { /* n:"BrtDRef" */ },&#13;
0x01F4: { /* n:"BrtBeginScenMan", */ T:1 },&#13;
0x01F5: { /* n:"BrtEndScenMan", */ T:-1 },&#13;
0x01F6: { /* n:"BrtBeginSct", */ T:1 },&#13;
0x01F7: { /* n:"BrtEndSct", */ T:-1 },&#13;
0x01F8: { /* n:"BrtSlc" */ },&#13;
0x01F9: { /* n:"BrtBeginDXFs", */ T:1 },&#13;
0x01FA: { /* n:"BrtEndDXFs", */ T:-1 },&#13;
0x01FB: { /* n:"BrtDXF" */ },&#13;
0x01FC: { /* n:"BrtBeginTableStyles", */ T:1 },&#13;
0x01FD: { /* n:"BrtEndTableStyles", */ T:-1 },&#13;
0x01FE: { /* n:"BrtBeginTableStyle", */ T:1 },&#13;
0x01FF: { /* n:"BrtEndTableStyle", */ T:-1 },&#13;
0x0200: { /* n:"BrtTableStyleElement" */ },&#13;
0x0201: { /* n:"BrtTableStyleClient" */ },&#13;
0x0202: { /* n:"BrtBeginVolDeps", */ T:1 },&#13;
0x0203: { /* n:"BrtEndVolDeps", */ T:-1 },&#13;
0x0204: { /* n:"BrtBeginVolType", */ T:1 },&#13;
0x0205: { /* n:"BrtEndVolType", */ T:-1 },&#13;
0x0206: { /* n:"BrtBeginVolMain", */ T:1 },&#13;
0x0207: { /* n:"BrtEndVolMain", */ T:-1 },&#13;
0x0208: { /* n:"BrtBeginVolTopic", */ T:1 },&#13;
0x0209: { /* n:"BrtEndVolTopic", */ T:-1 },&#13;
0x020A: { /* n:"BrtVolSubtopic" */ },&#13;
0x020B: { /* n:"BrtVolRef" */ },&#13;
0x020C: { /* n:"BrtVolNum" */ },&#13;
0x020D: { /* n:"BrtVolErr" */ },&#13;
0x020E: { /* n:"BrtVolStr" */ },&#13;
0x020F: { /* n:"BrtVolBool" */ },&#13;
0x0210: { /* n:"BrtBeginCalcChain$", */ T:1 },&#13;
0x0211: { /* n:"BrtEndCalcChain$", */ T:-1 },&#13;
0x0212: { /* n:"BrtBeginSortState", */ T:1 },&#13;
0x0213: { /* n:"BrtEndSortState", */ T:-1 },&#13;
0x0214: { /* n:"BrtBeginSortCond", */ T:1 },&#13;
0x0215: { /* n:"BrtEndSortCond", */ T:-1 },&#13;
0x0216: { /* n:"BrtBookProtection" */ },&#13;
0x0217: { /* n:"BrtSheetProtection" */ },&#13;
0x0218: { /* n:"BrtRangeProtection" */ },&#13;
0x0219: { /* n:"BrtPhoneticInfo" */ },&#13;
0x021A: { /* n:"BrtBeginECTxtWiz", */ T:1 },&#13;
0x021B: { /* n:"BrtEndECTxtWiz", */ T:-1 },&#13;
0x021C: { /* n:"BrtBeginECTWFldInfoLst", */ T:1 },&#13;
0x021D: { /* n:"BrtEndECTWFldInfoLst", */ T:-1 },&#13;
0x021E: { /* n:"BrtBeginECTwFldInfo", */ T:1 },&#13;
0x0224: { /* n:"BrtFileSharing" */ },&#13;
0x0225: { /* n:"BrtOleSize" */ },&#13;
0x0226: { /* n:"BrtDrawing", */ f:parse_RelID },&#13;
0x0227: { /* n:"BrtLegacyDrawing" */ },&#13;
0x0228: { /* n:"BrtLegacyDrawingHF" */ },&#13;
0x0229: { /* n:"BrtWebOpt" */ },&#13;
0x022A: { /* n:"BrtBeginWebPubItems", */ T:1 },&#13;
0x022B: { /* n:"BrtEndWebPubItems", */ T:-1 },&#13;
0x022C: { /* n:"BrtBeginWebPubItem", */ T:1 },&#13;
0x022D: { /* n:"BrtEndWebPubItem", */ T:-1 },&#13;
0x022E: { /* n:"BrtBeginSXCondFmt", */ T:1 },&#13;
0x022F: { /* n:"BrtEndSXCondFmt", */ T:-1 },&#13;
0x0230: { /* n:"BrtBeginSXCondFmts", */ T:1 },&#13;
0x0231: { /* n:"BrtEndSXCondFmts", */ T:-1 },&#13;
0x0232: { /* n:"BrtBkHim" */ },&#13;
0x0234: { /* n:"BrtColor" */ },&#13;
0x0235: { /* n:"BrtBeginIndexedColors", */ T:1 },&#13;
0x0236: { /* n:"BrtEndIndexedColors", */ T:-1 },&#13;
0x0239: { /* n:"BrtBeginMRUColors", */ T:1 },&#13;
0x023A: { /* n:"BrtEndMRUColors", */ T:-1 },&#13;
0x023C: { /* n:"BrtMRUColor" */ },&#13;
0x023D: { /* n:"BrtBeginDVals", */ T:1 },&#13;
0x023E: { /* n:"BrtEndDVals", */ T:-1 },&#13;
0x0241: { /* n:"BrtSupNameStart" */ },&#13;
0x0242: { /* n:"BrtSupNameValueStart" */ },&#13;
0x0243: { /* n:"BrtSupNameValueEnd" */ },&#13;
0x0244: { /* n:"BrtSupNameNum" */ },&#13;
0x0245: { /* n:"BrtSupNameErr" */ },&#13;
0x0246: { /* n:"BrtSupNameSt" */ },&#13;
0x0247: { /* n:"BrtSupNameNil" */ },&#13;
0x0248: { /* n:"BrtSupNameBool" */ },&#13;
0x0249: { /* n:"BrtSupNameFmla" */ },&#13;
0x024A: { /* n:"BrtSupNameBits" */ },&#13;
0x024B: { /* n:"BrtSupNameEnd" */ },&#13;
0x024C: { /* n:"BrtEndSupBook", */ T:-1 },&#13;
0x024D: { /* n:"BrtCellSmartTagProperty" */ },&#13;
0x024E: { /* n:"BrtBeginCellSmartTag", */ T:1 },&#13;
0x024F: { /* n:"BrtEndCellSmartTag", */ T:-1 },&#13;
0x0250: { /* n:"BrtBeginCellSmartTags", */ T:1 },&#13;
0x0251: { /* n:"BrtEndCellSmartTags", */ T:-1 },&#13;
0x0252: { /* n:"BrtBeginSmartTags", */ T:1 },&#13;
0x0253: { /* n:"BrtEndSmartTags", */ T:-1 },&#13;
0x0254: { /* n:"BrtSmartTagType" */ },&#13;
0x0255: { /* n:"BrtBeginSmartTagTypes", */ T:1 },&#13;
0x0256: { /* n:"BrtEndSmartTagTypes", */ T:-1 },&#13;
0x0257: { /* n:"BrtBeginSXFilters", */ T:1 },&#13;
0x0258: { /* n:"BrtEndSXFilters", */ T:-1 },&#13;
0x0259: { /* n:"BrtBeginSXFILTER", */ T:1 },&#13;
0x025A: { /* n:"BrtEndSXFilter", */ T:-1 },&#13;
0x025B: { /* n:"BrtBeginFills", */ T:1 },&#13;
0x025C: { /* n:"BrtEndFills", */ T:-1 },&#13;
0x025D: { /* n:"BrtBeginCellWatches", */ T:1 },&#13;
0x025E: { /* n:"BrtEndCellWatches", */ T:-1 },&#13;
0x025F: { /* n:"BrtCellWatch" */ },&#13;
0x0260: { /* n:"BrtBeginCRErrs", */ T:1 },&#13;
0x0261: { /* n:"BrtEndCRErrs", */ T:-1 },&#13;
0x0262: { /* n:"BrtCrashRecErr" */ },&#13;
0x0263: { /* n:"BrtBeginFonts", */ T:1 },&#13;
0x0264: { /* n:"BrtEndFonts", */ T:-1 },&#13;
0x0265: { /* n:"BrtBeginBorders", */ T:1 },&#13;
0x0266: { /* n:"BrtEndBorders", */ T:-1 },&#13;
0x0267: { /* n:"BrtBeginFmts", */ T:1 },&#13;
0x0268: { /* n:"BrtEndFmts", */ T:-1 },&#13;
0x0269: { /* n:"BrtBeginCellXFs", */ T:1 },&#13;
0x026A: { /* n:"BrtEndCellXFs", */ T:-1 },&#13;
0x026B: { /* n:"BrtBeginStyles", */ T:1 },&#13;
0x026C: { /* n:"BrtEndStyles", */ T:-1 },&#13;
0x0271: { /* n:"BrtBigName" */ },&#13;
0x0272: { /* n:"BrtBeginCellStyleXFs", */ T:1 },&#13;
0x0273: { /* n:"BrtEndCellStyleXFs", */ T:-1 },&#13;
0x0274: { /* n:"BrtBeginComments", */ T:1 },&#13;
0x0275: { /* n:"BrtEndComments", */ T:-1 },&#13;
0x0276: { /* n:"BrtBeginCommentAuthors", */ T:1 },&#13;
0x0277: { /* n:"BrtEndCommentAuthors", */ T:-1 },&#13;
0x0278: { /* n:"BrtCommentAuthor", */ f:parse_BrtCommentAuthor },&#13;
0x0279: { /* n:"BrtBeginCommentList", */ T:1 },&#13;
0x027A: { /* n:"BrtEndCommentList", */ T:-1 },&#13;
0x027B: { /* n:"BrtBeginComment", */ T:1, f:parse_BrtBeginComment},&#13;
0x027C: { /* n:"BrtEndComment", */ T:-1 },&#13;
0x027D: { /* n:"BrtCommentText", */ f:parse_BrtCommentText },&#13;
0x027E: { /* n:"BrtBeginOleObjects", */ T:1 },&#13;
0x027F: { /* n:"BrtOleObject" */ },&#13;
0x0280: { /* n:"BrtEndOleObjects", */ T:-1 },&#13;
0x0281: { /* n:"BrtBeginSxrules", */ T:1 },&#13;
0x0282: { /* n:"BrtEndSxRules", */ T:-1 },&#13;
0x0283: { /* n:"BrtBeginActiveXControls", */ T:1 },&#13;
0x0284: { /* n:"BrtActiveX" */ },&#13;
0x0285: { /* n:"BrtEndActiveXControls", */ T:-1 },&#13;
0x0286: { /* n:"BrtBeginPCDSDTCEMembersSortBy", */ T:1 },&#13;
0x0288: { /* n:"BrtBeginCellIgnoreECs", */ T:1 },&#13;
0x0289: { /* n:"BrtCellIgnoreEC" */ },&#13;
0x028A: { /* n:"BrtEndCellIgnoreECs", */ T:-1 },&#13;
0x028B: { /* n:"BrtCsProp", */ f:parse_BrtCsProp },&#13;
0x028C: { /* n:"BrtCsPageSetup" */ },&#13;
0x028D: { /* n:"BrtBeginUserCsViews", */ T:1 },&#13;
0x028E: { /* n:"BrtEndUserCsViews", */ T:-1 },&#13;
0x028F: { /* n:"BrtBeginUserCsView", */ T:1 },&#13;
0x0290: { /* n:"BrtEndUserCsView", */ T:-1 },&#13;
0x0291: { /* n:"BrtBeginPcdSFCIEntries", */ T:1 },&#13;
0x0292: { /* n:"BrtEndPCDSFCIEntries", */ T:-1 },&#13;
0x0293: { /* n:"BrtPCDSFCIEntry" */ },&#13;
0x0294: { /* n:"BrtBeginListParts", */ T:1 },&#13;
0x0295: { /* n:"BrtListPart" */ },&#13;
0x0296: { /* n:"BrtEndListParts", */ T:-1 },&#13;
0x0297: { /* n:"BrtSheetCalcProp" */ },&#13;
0x0298: { /* n:"BrtBeginFnGroup", */ T:1 },&#13;
0x0299: { /* n:"BrtFnGroup" */ },&#13;
0x029A: { /* n:"BrtEndFnGroup", */ T:-1 },&#13;
0x029B: { /* n:"BrtSupAddin" */ },&#13;
0x029C: { /* n:"BrtSXTDMPOrder" */ },&#13;
0x029D: { /* n:"BrtCsProtection" */ },&#13;
0x029F: { /* n:"BrtBeginWsSortMap", */ T:1 },&#13;
0x02A0: { /* n:"BrtEndWsSortMap", */ T:-1 },&#13;
0x02A1: { /* n:"BrtBeginRRSort", */ T:1 },&#13;
0x02A2: { /* n:"BrtEndRRSort", */ T:-1 },&#13;
0x02A3: { /* n:"BrtRRSortItem" */ },&#13;
0x02A4: { /* n:"BrtFileSharingIso" */ },&#13;
0x02A5: { /* n:"BrtBookProtectionIso" */ },&#13;
0x02A6: { /* n:"BrtSheetProtectionIso" */ },&#13;
0x02A7: { /* n:"BrtCsProtectionIso" */ },&#13;
0x02A8: { /* n:"BrtRangeProtectionIso" */ },&#13;
0x02A9: { /* n:"BrtDValList" */ },&#13;
0x0400: { /* n:"BrtRwDescent" */ },&#13;
0x0401: { /* n:"BrtKnownFonts" */ },&#13;
0x0402: { /* n:"BrtBeginSXTupleSet", */ T:1 },&#13;
0x0403: { /* n:"BrtEndSXTupleSet", */ T:-1 },&#13;
0x0404: { /* n:"BrtBeginSXTupleSetHeader", */ T:1 },&#13;
0x0405: { /* n:"BrtEndSXTupleSetHeader", */ T:-1 },&#13;
0x0406: { /* n:"BrtSXTupleSetHeaderItem" */ },&#13;
0x0407: { /* n:"BrtBeginSXTupleSetData", */ T:1 },&#13;
0x0408: { /* n:"BrtEndSXTupleSetData", */ T:-1 },&#13;
0x0409: { /* n:"BrtBeginSXTupleSetRow", */ T:1 },&#13;
0x040A: { /* n:"BrtEndSXTupleSetRow", */ T:-1 },&#13;
0x040B: { /* n:"BrtSXTupleSetRowItem" */ },&#13;
0x040C: { /* n:"BrtNameExt" */ },&#13;
0x040D: { /* n:"BrtPCDH14" */ },&#13;
0x040E: { /* n:"BrtBeginPCDCalcMem14", */ T:1 },&#13;
0x040F: { /* n:"BrtEndPCDCalcMem14", */ T:-1 },&#13;
0x0410: { /* n:"BrtSXTH14" */ },&#13;
0x0411: { /* n:"BrtBeginSparklineGroup", */ T:1 },&#13;
0x0412: { /* n:"BrtEndSparklineGroup", */ T:-1 },&#13;
0x0413: { /* n:"BrtSparkline" */ },&#13;
0x0414: { /* n:"BrtSXDI14" */ },&#13;
0x0415: { /* n:"BrtWsFmtInfoEx14" */ },&#13;
0x0416: { /* n:"BrtBeginConditionalFormatting14", */ T:1 },&#13;
0x0417: { /* n:"BrtEndConditionalFormatting14", */ T:-1 },&#13;
0x0418: { /* n:"BrtBeginCFRule14", */ T:1 },&#13;
0x0419: { /* n:"BrtEndCFRule14", */ T:-1 },&#13;
0x041A: { /* n:"BrtCFVO14" */ },&#13;
0x041B: { /* n:"BrtBeginDatabar14", */ T:1 },&#13;
0x041C: { /* n:"BrtBeginIconSet14", */ T:1 },&#13;
0x041D: { /* n:"BrtDVal14", */ f: parse_BrtDVal14 },&#13;
0x041E: { /* n:"BrtBeginDVals14", */ T:1 },&#13;
0x041F: { /* n:"BrtColor14" */ },&#13;
0x0420: { /* n:"BrtBeginSparklines", */ T:1 },&#13;
0x0421: { /* n:"BrtEndSparklines", */ T:-1 },&#13;
0x0422: { /* n:"BrtBeginSparklineGroups", */ T:1 },&#13;
0x0423: { /* n:"BrtEndSparklineGroups", */ T:-1 },&#13;
0x0425: { /* n:"BrtSXVD14" */ },&#13;
0x0426: { /* n:"BrtBeginSXView14", */ T:1 },&#13;
0x0427: { /* n:"BrtEndSXView14", */ T:-1 },&#13;
0x0428: { /* n:"BrtBeginSXView16", */ T:1 },&#13;
0x0429: { /* n:"BrtEndSXView16", */ T:-1 },&#13;
0x042A: { /* n:"BrtBeginPCD14", */ T:1 },&#13;
0x042B: { /* n:"BrtEndPCD14", */ T:-1 },&#13;
0x042C: { /* n:"BrtBeginExtConn14", */ T:1 },&#13;
0x042D: { /* n:"BrtEndExtConn14", */ T:-1 },&#13;
0x042E: { /* n:"BrtBeginSlicerCacheIDs", */ T:1 },&#13;
0x042F: { /* n:"BrtEndSlicerCacheIDs", */ T:-1 },&#13;
0x0430: { /* n:"BrtBeginSlicerCacheID", */ T:1 },&#13;
0x0431: { /* n:"BrtEndSlicerCacheID", */ T:-1 },&#13;
0x0433: { /* n:"BrtBeginSlicerCache", */ T:1 },&#13;
0x0434: { /* n:"BrtEndSlicerCache", */ T:-1 },&#13;
0x0435: { /* n:"BrtBeginSlicerCacheDef", */ T:1 },&#13;
0x0436: { /* n:"BrtEndSlicerCacheDef", */ T:-1 },&#13;
0x0437: { /* n:"BrtBeginSlicersEx", */ T:1 },&#13;
0x0438: { /* n:"BrtEndSlicersEx", */ T:-1 },&#13;
0x0439: { /* n:"BrtBeginSlicerEx", */ T:1 },&#13;
0x043A: { /* n:"BrtEndSlicerEx", */ T:-1 },&#13;
0x043B: { /* n:"BrtBeginSlicer", */ T:1 },&#13;
0x043C: { /* n:"BrtEndSlicer", */ T:-1 },&#13;
0x043D: { /* n:"BrtSlicerCachePivotTables" */ },&#13;
0x043E: { /* n:"BrtBeginSlicerCacheOlapImpl", */ T:1 },&#13;
0x043F: { /* n:"BrtEndSlicerCacheOlapImpl", */ T:-1 },&#13;
0x0440: { /* n:"BrtBeginSlicerCacheLevelsData", */ T:1 },&#13;
0x0441: { /* n:"BrtEndSlicerCacheLevelsData", */ T:-1 },&#13;
0x0442: { /* n:"BrtBeginSlicerCacheLevelData", */ T:1 },&#13;
0x0443: { /* n:"BrtEndSlicerCacheLevelData", */ T:-1 },&#13;
0x0444: { /* n:"BrtBeginSlicerCacheSiRanges", */ T:1 },&#13;
0x0445: { /* n:"BrtEndSlicerCacheSiRanges", */ T:-1 },&#13;
0x0446: { /* n:"BrtBeginSlicerCacheSiRange", */ T:1 },&#13;
0x0447: { /* n:"BrtEndSlicerCacheSiRange", */ T:-1 },&#13;
0x0448: { /* n:"BrtSlicerCacheOlapItem" */ },&#13;
0x0449: { /* n:"BrtBeginSlicerCacheSelections", */ T:1 },&#13;
0x044A: { /* n:"BrtSlicerCacheSelection" */ },&#13;
0x044B: { /* n:"BrtEndSlicerCacheSelections", */ T:-1 },&#13;
0x044C: { /* n:"BrtBeginSlicerCacheNative", */ T:1 },&#13;
0x044D: { /* n:"BrtEndSlicerCacheNative", */ T:-1 },&#13;
0x044E: { /* n:"BrtSlicerCacheNativeItem" */ },&#13;
0x044F: { /* n:"BrtRangeProtection14" */ },&#13;
0x0450: { /* n:"BrtRangeProtectionIso14" */ },&#13;
0x0451: { /* n:"BrtCellIgnoreEC14" */ },&#13;
0x0457: { /* n:"BrtList14" */ },&#13;
0x0458: { /* n:"BrtCFIcon" */ },&#13;
0x0459: { /* n:"BrtBeginSlicerCachesPivotCacheIDs", */ T:1 },&#13;
0x045A: { /* n:"BrtEndSlicerCachesPivotCacheIDs", */ T:-1 },&#13;
0x045B: { /* n:"BrtBeginSlicers", */ T:1 },&#13;
0x045C: { /* n:"BrtEndSlicers", */ T:-1 },&#13;
0x045D: { /* n:"BrtWbProp14" */ },&#13;
0x045E: { /* n:"BrtBeginSXEdit", */ T:1 },&#13;
0x045F: { /* n:"BrtEndSXEdit", */ T:-1 },&#13;
0x0460: { /* n:"BrtBeginSXEdits", */ T:1 },&#13;
0x0461: { /* n:"BrtEndSXEdits", */ T:-1 },&#13;
0x0462: { /* n:"BrtBeginSXChange", */ T:1 },&#13;
0x0463: { /* n:"BrtEndSXChange", */ T:-1 },&#13;
0x0464: { /* n:"BrtBeginSXChanges", */ T:1 },&#13;
0x0465: { /* n:"BrtEndSXChanges", */ T:-1 },&#13;
0x0466: { /* n:"BrtSXTupleItems" */ },&#13;
0x0468: { /* n:"BrtBeginSlicerStyle", */ T:1 },&#13;
0x0469: { /* n:"BrtEndSlicerStyle", */ T:-1 },&#13;
0x046A: { /* n:"BrtSlicerStyleElement" */ },&#13;
0x046B: { /* n:"BrtBeginStyleSheetExt14", */ T:1 },&#13;
0x046C: { /* n:"BrtEndStyleSheetExt14", */ T:-1 },&#13;
0x046D: { /* n:"BrtBeginSlicerCachesPivotCacheID", */ T:1 },&#13;
0x046E: { /* n:"BrtEndSlicerCachesPivotCacheID", */ T:-1 },&#13;
0x046F: { /* n:"BrtBeginConditionalFormattings", */ T:1 },&#13;
0x0470: { /* n:"BrtEndConditionalFormattings", */ T:-1 },&#13;
0x0471: { /* n:"BrtBeginPCDCalcMemExt", */ T:1 },&#13;
0x0472: { /* n:"BrtEndPCDCalcMemExt", */ T:-1 },&#13;
0x0473: { /* n:"BrtBeginPCDCalcMemsExt", */ T:1 },&#13;
0x0474: { /* n:"BrtEndPCDCalcMemsExt", */ T:-1 },&#13;
0x0475: { /* n:"BrtPCDField14" */ },&#13;
0x0476: { /* n:"BrtBeginSlicerStyles", */ T:1 },&#13;
0x0477: { /* n:"BrtEndSlicerStyles", */ T:-1 },&#13;
0x0478: { /* n:"BrtBeginSlicerStyleElements", */ T:1 },&#13;
0x0479: { /* n:"BrtEndSlicerStyleElements", */ T:-1 },&#13;
0x047A: { /* n:"BrtCFRuleExt" */ },&#13;
0x047B: { /* n:"BrtBeginSXCondFmt14", */ T:1 },&#13;
0x047C: { /* n:"BrtEndSXCondFmt14", */ T:-1 },&#13;
0x047D: { /* n:"BrtBeginSXCondFmts14", */ T:1 },&#13;
0x047E: { /* n:"BrtEndSXCondFmts14", */ T:-1 },&#13;
0x0480: { /* n:"BrtBeginSortCond14", */ T:1 },&#13;
0x0481: { /* n:"BrtEndSortCond14", */ T:-1 },&#13;
0x0482: { /* n:"BrtEndDVals14", */ T:-1 },&#13;
0x0483: { /* n:"BrtEndIconSet14", */ T:-1 },&#13;
0x0484: { /* n:"BrtEndDatabar14", */ T:-1 },&#13;
0x0485: { /* n:"BrtBeginColorScale14", */ T:1 },&#13;
0x0486: { /* n:"BrtEndColorScale14", */ T:-1 },&#13;
0x0487: { /* n:"BrtBeginSxrules14", */ T:1 },&#13;
0x0488: { /* n:"BrtEndSxrules14", */ T:-1 },&#13;
0x0489: { /* n:"BrtBeginPRule14", */ T:1 },&#13;
0x048A: { /* n:"BrtEndPRule14", */ T:-1 },&#13;
0x048B: { /* n:"BrtBeginPRFilters14", */ T:1 },&#13;
0x048C: { /* n:"BrtEndPRFilters14", */ T:-1 },&#13;
0x048D: { /* n:"BrtBeginPRFilter14", */ T:1 },&#13;
0x048E: { /* n:"BrtEndPRFilter14", */ T:-1 },&#13;
0x048F: { /* n:"BrtBeginPRFItem14", */ T:1 },&#13;
0x0490: { /* n:"BrtEndPRFItem14", */ T:-1 },&#13;
0x0491: { /* n:"BrtBeginCellIgnoreECs14", */ T:1 },&#13;
0x0492: { /* n:"BrtEndCellIgnoreECs14", */ T:-1 },&#13;
0x0493: { /* n:"BrtDxf14" */ },&#13;
0x0494: { /* n:"BrtBeginDxF14s", */ T:1 },&#13;
0x0495: { /* n:"BrtEndDxf14s", */ T:-1 },&#13;
0x0499: { /* n:"BrtFilter14" */ },&#13;
0x049A: { /* n:"BrtBeginCustomFilters14", */ T:1 },&#13;
0x049C: { /* n:"BrtCustomFilter14" */ },&#13;
0x049D: { /* n:"BrtIconFilter14" */ },&#13;
0x049E: { /* n:"BrtPivotCacheConnectionName" */ },&#13;
0x0800: { /* n:"BrtBeginDecoupledPivotCacheIDs", */ T:1 },&#13;
0x0801: { /* n:"BrtEndDecoupledPivotCacheIDs", */ T:-1 },&#13;
0x0802: { /* n:"BrtDecoupledPivotCacheID" */ },&#13;
0x0803: { /* n:"BrtBeginPivotTableRefs", */ T:1 },&#13;
0x0804: { /* n:"BrtEndPivotTableRefs", */ T:-1 },&#13;
0x0805: { /* n:"BrtPivotTableRef" */ },&#13;
0x0806: { /* n:"BrtSlicerCacheBookPivotTables" */ },&#13;
0x0807: { /* n:"BrtBeginSxvcells", */ T:1 },&#13;
0x0808: { /* n:"BrtEndSxvcells", */ T:-1 },&#13;
0x0809: { /* n:"BrtBeginSxRow", */ T:1 },&#13;
0x080A: { /* n:"BrtEndSxRow", */ T:-1 },&#13;
0x080C: { /* n:"BrtPcdCalcMem15" */ },&#13;
0x0813: { /* n:"BrtQsi15" */ },&#13;
0x0814: { /* n:"BrtBeginWebExtensions", */ T:1 },&#13;
0x0815: { /* n:"BrtEndWebExtensions", */ T:-1 },&#13;
0x0816: { /* n:"BrtWebExtension" */ },&#13;
0x0817: { /* n:"BrtAbsPath15" */ },&#13;
0x0818: { /* n:"BrtBeginPivotTableUISettings", */ T:1 },&#13;
0x0819: { /* n:"BrtEndPivotTableUISettings", */ T:-1 },&#13;
0x081B: { /* n:"BrtTableSlicerCacheIDs" */ },&#13;
0x081C: { /* n:"BrtTableSlicerCacheID" */ },&#13;
0x081D: { /* n:"BrtBeginTableSlicerCache", */ T:1 },&#13;
0x081E: { /* n:"BrtEndTableSlicerCache", */ T:-1 },&#13;
0x081F: { /* n:"BrtSxFilter15" */ },&#13;
0x0820: { /* n:"BrtBeginTimelineCachePivotCacheIDs", */ T:1 },&#13;
0x0821: { /* n:"BrtEndTimelineCachePivotCacheIDs", */ T:-1 },&#13;
0x0822: { /* n:"BrtTimelineCachePivotCacheID" */ },&#13;
0x0823: { /* n:"BrtBeginTimelineCacheIDs", */ T:1 },&#13;
0x0824: { /* n:"BrtEndTimelineCacheIDs", */ T:-1 },&#13;
0x0825: { /* n:"BrtBeginTimelineCacheID", */ T:1 },&#13;
0x0826: { /* n:"BrtEndTimelineCacheID", */ T:-1 },&#13;
0x0827: { /* n:"BrtBeginTimelinesEx", */ T:1 },&#13;
0x0828: { /* n:"BrtEndTimelinesEx", */ T:-1 },&#13;
0x0829: { /* n:"BrtBeginTimelineEx", */ T:1 },&#13;
0x082A: { /* n:"BrtEndTimelineEx", */ T:-1 },&#13;
0x082B: { /* n:"BrtWorkBookPr15" */ },&#13;
0x082C: { /* n:"BrtPCDH15" */ },&#13;
0x082D: { /* n:"BrtBeginTimelineStyle", */ T:1 },&#13;
0x082E: { /* n:"BrtEndTimelineStyle", */ T:-1 },&#13;
0x082F: { /* n:"BrtTimelineStyleElement" */ },&#13;
0x0830: { /* n:"BrtBeginTimelineStylesheetExt15", */ T:1 },&#13;
0x0831: { /* n:"BrtEndTimelineStylesheetExt15", */ T:-1 },&#13;
0x0832: { /* n:"BrtBeginTimelineStyles", */ T:1 },&#13;
0x0833: { /* n:"BrtEndTimelineStyles", */ T:-1 },&#13;
0x0834: { /* n:"BrtBeginTimelineStyleElements", */ T:1 },&#13;
0x0835: { /* n:"BrtEndTimelineStyleElements", */ T:-1 },&#13;
0x0836: { /* n:"BrtDxf15" */ },&#13;
0x0837: { /* n:"BrtBeginDxfs15", */ T:1 },&#13;
0x0838: { /* n:"BrtEndDxfs15", */ T:-1 },&#13;
0x0839: { /* n:"BrtSlicerCacheHideItemsWithNoData" */ },&#13;
0x083A: { /* n:"BrtBeginItemUniqueNames", */ T:1 },&#13;
0x083B: { /* n:"BrtEndItemUniqueNames", */ T:-1 },&#13;
0x083C: { /* n:"BrtItemUniqueName" */ },&#13;
0x083D: { /* n:"BrtBeginExtConn15", */ T:1 },&#13;
0x083E: { /* n:"BrtEndExtConn15", */ T:-1 },&#13;
0x083F: { /* n:"BrtBeginOledbPr15", */ T:1 },&#13;
0x0840: { /* n:"BrtEndOledbPr15", */ T:-1 },&#13;
0x0841: { /* n:"BrtBeginDataFeedPr15", */ T:1 },&#13;
0x0842: { /* n:"BrtEndDataFeedPr15", */ T:-1 },&#13;
0x0843: { /* n:"BrtTextPr15" */ },&#13;
0x0844: { /* n:"BrtRangePr15" */ },&#13;
0x0845: { /* n:"BrtDbCommand15" */ },&#13;
0x0846: { /* n:"BrtBeginDbTables15", */ T:1 },&#13;
0x0847: { /* n:"BrtEndDbTables15", */ T:-1 },&#13;
0x0848: { /* n:"BrtDbTable15" */ },&#13;
0x0849: { /* n:"BrtBeginDataModel", */ T:1 },&#13;
0x084A: { /* n:"BrtEndDataModel", */ T:-1 },&#13;
0x084B: { /* n:"BrtBeginModelTables", */ T:1 },&#13;
0x084C: { /* n:"BrtEndModelTables", */ T:-1 },&#13;
0x084D: { /* n:"BrtModelTable" */ },&#13;
0x084E: { /* n:"BrtBeginModelRelationships", */ T:1 },&#13;
0x084F: { /* n:"BrtEndModelRelationships", */ T:-1 },&#13;
0x0850: { /* n:"BrtModelRelationship" */ },&#13;
0x0851: { /* n:"BrtBeginECTxtWiz15", */ T:1 },&#13;
0x0852: { /* n:"BrtEndECTxtWiz15", */ T:-1 },&#13;
0x0853: { /* n:"BrtBeginECTWFldInfoLst15", */ T:1 },&#13;
0x0854: { /* n:"BrtEndECTWFldInfoLst15", */ T:-1 },&#13;
0x0855: { /* n:"BrtBeginECTWFldInfo15", */ T:1 },&#13;
0x0856: { /* n:"BrtFieldListActiveItem" */ },&#13;
0x0857: { /* n:"BrtPivotCacheIdVersion" */ },&#13;
0x0858: { /* n:"BrtSXDI15" */ },&#13;
0x0859: { /* n:"BrtBeginModelTimeGroupings", */ T:1 },&#13;
0x085A: { /* n:"BrtEndModelTimeGroupings", */ T:-1 },&#13;
0x085B: { /* n:"BrtBeginModelTimeGrouping", */ T:1 },&#13;
0x085C: { /* n:"BrtEndModelTimeGrouping", */ T:-1 },&#13;
0x085D: { /* n:"BrtModelTimeGroupingCalcCol" */ },&#13;
0x0C00: { /* n:"BrtUid" */ },&#13;
0x0C01: { /* n:"BrtRevisionPtr" */ },&#13;
0x1000: { /* n:"BrtBeginDynamicArrayPr", */ T:1 },&#13;
0x1001: { /* n:"BrtEndDynamicArrayPr", */ T:-1 },&#13;
0x138A: { /* n:"BrtBeginRichValueBlock", */ T:1 },&#13;
0x138B: { /* n:"BrtEndRichValueBlock", */ T:-1 },&#13;
0x13D9: { /* n:"BrtBeginRichFilters", */ T:1 },&#13;
0x13DA: { /* n:"BrtEndRichFilters", */ T:-1 },&#13;
0x13DB: { /* n:"BrtRichFilter" */ },&#13;
0x13DC: { /* n:"BrtBeginRichFilterColumn", */ T:1 },&#13;
0x13DD: { /* n:"BrtEndRichFilterColumn", */ T:-1 },&#13;
0x13DE: { /* n:"BrtBeginCustomRichFilters", */ T:1 },&#13;
0x13DF: { /* n:"BrtEndCustomRichFilters", */ T:-1 },&#13;
0x13E0: { /* n:"BrtCustomRichFilter" */ },&#13;
0x13E1: { /* n:"BrtTop10RichFilter" */ },&#13;
0x13E2: { /* n:"BrtDynamicRichFilter" */ },&#13;
0x13E4: { /* n:"BrtBeginRichSortCondition", */ T:1 },&#13;
0x13E5: { /* n:"BrtEndRichSortCondition", */ T:-1 },&#13;
0x13E6: { /* n:"BrtRichFilterDateGroupItem" */ },&#13;
0x13E7: { /* n:"BrtBeginCalcFeatures", */ T:1 },&#13;
0x13E8: { /* n:"BrtEndCalcFeatures", */ T:-1 },&#13;
0x13E9: { /* n:"BrtCalcFeature" */ },&#13;
0x13EB: { /* n:"BrtExternalLinksPr" */ },&#13;
0xFFFF: { n:"" }&#13;
};&#13;
&#13;
/* [MS-XLS] 2.3 Record Enumeration (and other sources) */&#13;
var XLSRecordEnum = {&#13;
	/* [MS-XLS] 2.3 Record Enumeration 2021-08-17 */&#13;
0x0006: { /* n:"Formula", */ f:parse_Formula },&#13;
0x000a: { /* n:"EOF", */ f:parsenoop2 },&#13;
0x000c: { /* n:"CalcCount", */ f:parseuint16 }, //&#13;
0x000d: { /* n:"CalcMode", */ f:parseuint16 }, //&#13;
0x000e: { /* n:"CalcPrecision", */ f:parsebool }, //&#13;
0x000f: { /* n:"CalcRefMode", */ f:parsebool }, //&#13;
0x0010: { /* n:"CalcDelta", */ f:parse_Xnum }, //&#13;
0x0011: { /* n:"CalcIter", */ f:parsebool }, //&#13;
0x0012: { /* n:"Protect", */ f:parsebool },&#13;
0x0013: { /* n:"Password", */ f:parseuint16 },&#13;
0x0014: { /* n:"Header", */ f:parse_XLHeaderFooter },&#13;
0x0015: { /* n:"Footer", */ f:parse_XLHeaderFooter },&#13;
0x0017: { /* n:"ExternSheet", */ f:parse_ExternSheet },&#13;
0x0018: { /* n:"Lbl", */ f:parse_Lbl },&#13;
0x0019: { /* n:"WinProtect", */ f:parsebool },&#13;
0x001a: { /* n:"VerticalPageBreaks", */ },&#13;
0x001b: { /* n:"HorizontalPageBreaks", */ },&#13;
0x001c: { /* n:"Note", */ f:parse_Note },&#13;
0x001d: { /* n:"Selection", */ },&#13;
0x0022: { /* n:"Date1904", */ f:parsebool },&#13;
0x0023: { /* n:"ExternName", */ f:parse_ExternName },&#13;
0x0026: { /* n:"LeftMargin", */ f:parse_Xnum }, // *&#13;
0x0027: { /* n:"RightMargin", */ f:parse_Xnum }, // *&#13;
0x0028: { /* n:"TopMargin", */ f:parse_Xnum }, // *&#13;
0x0029: { /* n:"BottomMargin", */ f:parse_Xnum }, // *&#13;
0x002a: { /* n:"PrintRowCol", */ f:parsebool },&#13;
0x002b: { /* n:"PrintGrid", */ f:parsebool },&#13;
0x002f: { /* n:"FilePass", */ f:parse_FilePass },&#13;
0x0031: { /* n:"Font", */ f:parse_Font },&#13;
0x0033: { /* n:"PrintSize", */ f:parseuint16 },&#13;
0x003c: { /* n:"Continue", */ },&#13;
0x003d: { /* n:"Window1", */ f:parse_Window1 },&#13;
0x0040: { /* n:"Backup", */ f:parsebool },&#13;
0x0041: { /* n:"Pane", */ f:parse_Pane },&#13;
0x0042: { /* n:"CodePage", */ f:parseuint16 },&#13;
0x004d: { /* n:"Pls", */ },&#13;
0x0050: { /* n:"DCon", */ },&#13;
0x0051: { /* n:"DConRef", */ },&#13;
0x0052: { /* n:"DConName", */ },&#13;
0x0055: { /* n:"DefColWidth", */ f:parseuint16 },&#13;
0x0059: { /* n:"XCT", */ },&#13;
0x005a: { /* n:"CRN", */ },&#13;
0x005b: { /* n:"FileSharing", */ },&#13;
0x005c: { /* n:"WriteAccess", */ f:parse_WriteAccess },&#13;
0x005d: { /* n:"Obj", */ f:parse_Obj },&#13;
0x005e: { /* n:"Uncalced", */ },&#13;
0x005f: { /* n:"CalcSaveRecalc", */ f:parsebool }, //&#13;
0x0060: { /* n:"Template", */ },&#13;
0x0061: { /* n:"Intl", */ },&#13;
0x0063: { /* n:"ObjProtect", */ f:parsebool },&#13;
0x007d: { /* n:"ColInfo", */ f:parse_ColInfo },&#13;
0x0080: { /* n:"Guts", */ f:parse_Guts },&#13;
0x0081: { /* n:"WsBool", */ f:parse_WsBool },&#13;
0x0082: { /* n:"GridSet", */ f:parseuint16 },&#13;
0x0083: { /* n:"HCenter", */ f:parsebool },&#13;
0x0084: { /* n:"VCenter", */ f:parsebool },&#13;
0x0085: { /* n:"BoundSheet8", */ f:parse_BoundSheet8 },&#13;
0x0086: { /* n:"WriteProtect", */ },&#13;
0x008c: { /* n:"Country", */ f:parse_Country },&#13;
0x008d: { /* n:"HideObj", */ f:parseuint16 },&#13;
0x0090: { /* n:"Sort", */ },&#13;
0x0092: { /* n:"Palette", */ f:parse_Palette },&#13;
0x0097: { /* n:"Sync", */ },&#13;
0x0098: { /* n:"LPr", */ },&#13;
0x0099: { /* n:"DxGCol", */ },&#13;
0x009a: { /* n:"FnGroupName", */ },&#13;
0x009b: { /* n:"FilterMode", */ },&#13;
0x009c: { /* n:"BuiltInFnGroupCount", */ f:parseuint16 },&#13;
0x009d: { /* n:"AutoFilterInfo", */ },&#13;
0x009e: { /* n:"AutoFilter", */ },&#13;
0x00a0: { /* n:"Scl", */ f:parse_Scl },&#13;
0x00a1: { /* n:"Setup", */ f:parse_Setup },&#13;
0x00ae: { /* n:"ScenMan", */ },&#13;
0x00af: { /* n:"SCENARIO", */ },&#13;
0x00b0: { /* n:"SxView", */ },&#13;
0x00b1: { /* n:"Sxvd", */ },&#13;
0x00b2: { /* n:"SXVI", */ },&#13;
0x00b4: { /* n:"SxIvd", */ },&#13;
0x00b5: { /* n:"SXLI", */ },&#13;
0x00b6: { /* n:"SXPI", */ },&#13;
0x00b8: { /* n:"DocRoute", */ },&#13;
0x00b9: { /* n:"RecipName", */ },&#13;
0x00bd: { /* n:"MulRk", */ f:parse_MulRk },&#13;
0x00be: { /* n:"MulBlank", */ f:parse_MulBlank },&#13;
0x00c1: { /* n:"Mms", */ f:parsenoop2 },&#13;
0x00c5: { /* n:"SXDI", */ },&#13;
0x00c6: { /* n:"SXDB", */ },&#13;
0x00c7: { /* n:"SXFDB", */ },&#13;
0x00c8: { /* n:"SXDBB", */ },&#13;
0x00c9: { /* n:"SXNum", */ },&#13;
0x00ca: { /* n:"SxBool", */ f:parsebool },&#13;
0x00cb: { /* n:"SxErr", */ },&#13;
0x00cc: { /* n:"SXInt", */ },&#13;
0x00cd: { /* n:"SXString", */ },&#13;
0x00ce: { /* n:"SXDtr", */ },&#13;
0x00cf: { /* n:"SxNil", */ },&#13;
0x00d0: { /* n:"SXTbl", */ },&#13;
0x00d1: { /* n:"SXTBRGIITM", */ },&#13;
0x00d2: { /* n:"SxTbpg", */ },&#13;
0x00d3: { /* n:"ObProj", */ },&#13;
0x00d5: { /* n:"SXStreamID", */ },&#13;
0x00d7: { /* n:"DBCell", */ },&#13;
0x00d8: { /* n:"SXRng", */ },&#13;
0x00d9: { /* n:"SxIsxoper", */ },&#13;
0x00da: { /* n:"BookBool", */ f:parseuint16 },&#13;
0x00dc: { /* n:"DbOrParamQry", */ },&#13;
0x00dd: { /* n:"ScenarioProtect", */ f:parsebool },&#13;
0x00de: { /* n:"OleObjectSize", */ },&#13;
0x00e0: { /* n:"XF", */ f:parse_XF },&#13;
0x00e1: { /* n:"InterfaceHdr", */ f:parse_InterfaceHdr },&#13;
0x00e2: { /* n:"InterfaceEnd", */ f:parsenoop2 },&#13;
0x00e3: { /* n:"SXVS", */ },&#13;
0x00e5: { /* n:"MergeCells", */ f:parse_MergeCells },&#13;
0x00e9: { /* n:"BkHim", */ },&#13;
0x00eb: { /* n:"MsoDrawingGroup", */ },&#13;
0x00ec: { /* n:"MsoDrawing", */ },&#13;
0x00ed: { /* n:"MsoDrawingSelection", */ },&#13;
0x00ef: { /* n:"PhoneticInfo", */ },&#13;
0x00f0: { /* n:"SxRule", */ },&#13;
0x00f1: { /* n:"SXEx", */ },&#13;
0x00f2: { /* n:"SxFilt", */ },&#13;
0x00f4: { /* n:"SxDXF", */ },&#13;
0x00f5: { /* n:"SxItm", */ },&#13;
0x00f6: { /* n:"SxName", */ },&#13;
0x00f7: { /* n:"SxSelect", */ },&#13;
0x00f8: { /* n:"SXPair", */ },&#13;
0x00f9: { /* n:"SxFmla", */ },&#13;
0x00fb: { /* n:"SxFormat", */ },&#13;
0x00fc: { /* n:"SST", */ f:parse_SST },&#13;
0x00fd: { /* n:"LabelSst", */ f:parse_LabelSst },&#13;
0x00ff: { /* n:"ExtSST", */ f:parse_ExtSST },&#13;
0x0100: { /* n:"SXVDEx", */ },&#13;
0x0103: { /* n:"SXFormula", */ },&#13;
0x0122: { /* n:"SXDBEx", */ },&#13;
0x0137: { /* n:"RRDInsDel", */ },&#13;
0x0138: { /* n:"RRDHead", */ },&#13;
0x013b: { /* n:"RRDChgCell", */ },&#13;
0x013d: { /* n:"RRTabId", */ f:parseuint16a },&#13;
0x013e: { /* n:"RRDRenSheet", */ },&#13;
0x013f: { /* n:"RRSort", */ },&#13;
0x0140: { /* n:"RRDMove", */ },&#13;
0x014a: { /* n:"RRFormat", */ },&#13;
0x014b: { /* n:"RRAutoFmt", */ },&#13;
0x014d: { /* n:"RRInsertSh", */ },&#13;
0x014e: { /* n:"RRDMoveBegin", */ },&#13;
0x014f: { /* n:"RRDMoveEnd", */ },&#13;
0x0150: { /* n:"RRDInsDelBegin", */ },&#13;
0x0151: { /* n:"RRDInsDelEnd", */ },&#13;
0x0152: { /* n:"RRDConflict", */ },&#13;
0x0153: { /* n:"RRDDefName", */ },&#13;
0x0154: { /* n:"RRDRstEtxp", */ },&#13;
0x015f: { /* n:"LRng", */ },&#13;
0x0160: { /* n:"UsesELFs", */ f:parsebool },&#13;
0x0161: { /* n:"DSF", */ f:parsenoop2 },&#13;
0x0191: { /* n:"CUsr", */ },&#13;
0x0192: { /* n:"CbUsr", */ },&#13;
0x0193: { /* n:"UsrInfo", */ },&#13;
0x0194: { /* n:"UsrExcl", */ },&#13;
0x0195: { /* n:"FileLock", */ },&#13;
0x0196: { /* n:"RRDInfo", */ },&#13;
0x0197: { /* n:"BCUsrs", */ },&#13;
0x0198: { /* n:"UsrChk", */ },&#13;
0x01a9: { /* n:"UserBView", */ },&#13;
0x01aa: { /* n:"UserSViewBegin", */ },&#13;
0x01ab: { /* n:"UserSViewEnd", */ },&#13;
0x01ac: { /* n:"RRDUserView", */ },&#13;
0x01ad: { /* n:"Qsi", */ },&#13;
0x01ae: { /* n:"SupBook", */ f:parse_SupBook },&#13;
0x01af: { /* n:"Prot4Rev", */ f:parsebool },&#13;
0x01b0: { /* n:"CondFmt", */ },&#13;
0x01b1: { /* n:"CF", */ },&#13;
0x01b2: { /* n:"DVal", */ },&#13;
0x01b5: { /* n:"DConBin", */ },&#13;
0x01b6: { /* n:"TxO", */ f:parse_TxO },&#13;
0x01b7: { /* n:"RefreshAll", */ f:parsebool }, //&#13;
0x01b8: { /* n:"HLink", */ f:parse_HLink },&#13;
0x01b9: { /* n:"Lel", */ },&#13;
0x01ba: { /* n:"CodeName", */ f:parse_XLUnicodeString },&#13;
0x01bb: { /* n:"SXFDBType", */ },&#13;
0x01bc: { /* n:"Prot4RevPass", */ f:parseuint16 },&#13;
0x01bd: { /* n:"ObNoMacros", */ },&#13;
0x01be: { /* n:"Dv", */ },&#13;
0x01c0: { /* n:"Excel9File", */ f:parsenoop2 },&#13;
0x01c1: { /* n:"RecalcId", */ f:parse_RecalcId, r:2},&#13;
0x01c2: { /* n:"EntExU2", */ f:parsenoop2 },&#13;
0x0200: { /* n:"Dimensions", */ f:parse_Dimensions },&#13;
0x0201: { /* n:"Blank", */ f:parse_Blank },&#13;
0x0203: { /* n:"Number", */ f:parse_Number },&#13;
0x0204: { /* n:"Label", */ f:parse_Label },&#13;
0x0205: { /* n:"BoolErr", */ f:parse_BoolErr },&#13;
0x0207: { /* n:"String", */ f:parse_String },&#13;
0x0208: { /* n:"Row", */ f:parse_Row },&#13;
0x020b: { /* n:"Index", */ },&#13;
0x0221: { /* n:"Array", */ f:parse_Array },&#13;
0x0225: { /* n:"DefaultRowHeight", */ f:parse_DefaultRowHeight },&#13;
0x0236: { /* n:"Table", */ },&#13;
0x023e: { /* n:"Window2", */ f:parse_Window2 },&#13;
0x027e: { /* n:"RK", */ f:parse_RK },&#13;
0x0293: { /* n:"Style", */ },&#13;
0x0418: { /* n:"BigName", */ },&#13;
0x041e: { /* n:"Format", */ f:parse_Format },&#13;
0x043c: { /* n:"ContinueBigName", */ },&#13;
0x04bc: { /* n:"ShrFmla", */ f:parse_ShrFmla },&#13;
0x0800: { /* n:"HLinkTooltip", */ f:parse_HLinkTooltip },&#13;
0x0801: { /* n:"WebPub", */ },&#13;
0x0802: { /* n:"QsiSXTag", */ },&#13;
0x0803: { /* n:"DBQueryExt", */ },&#13;
0x0804: { /* n:"ExtString", */ },&#13;
0x0805: { /* n:"TxtQry", */ },&#13;
0x0806: { /* n:"Qsir", */ },&#13;
0x0807: { /* n:"Qsif", */ },&#13;
0x0808: { /* n:"RRDTQSIF", */ },&#13;
0x0809: { /* n:"BOF", */ f:parse_BOF },&#13;
0x080a: { /* n:"OleDbConn", */ },&#13;
0x080b: { /* n:"WOpt", */ },&#13;
0x080c: { /* n:"SXViewEx", */ },&#13;
0x080d: { /* n:"SXTH", */ },&#13;
0x080e: { /* n:"SXPIEx", */ },&#13;
0x080f: { /* n:"SXVDTEx", */ },&#13;
0x0810: { /* n:"SXViewEx9", */ },&#13;
0x0812: { /* n:"ContinueFrt", */ },&#13;
0x0813: { /* n:"RealTimeData", */ },&#13;
0x0850: { /* n:"ChartFrtInfo", */ },&#13;
0x0851: { /* n:"FrtWrapper", */ },&#13;
0x0852: { /* n:"StartBlock", */ },&#13;
0x0853: { /* n:"EndBlock", */ },&#13;
0x0854: { /* n:"StartObject", */ },&#13;
0x0855: { /* n:"EndObject", */ },&#13;
0x0856: { /* n:"CatLab", */ },&#13;
0x0857: { /* n:"YMult", */ },&#13;
0x0858: { /* n:"SXViewLink", */ },&#13;
0x0859: { /* n:"PivotChartBits", */ },&#13;
0x085a: { /* n:"FrtFontList", */ },&#13;
0x0862: { /* n:"SheetExt", */ },&#13;
0x0863: { /* n:"BookExt", */ r:12},&#13;
0x0864: { /* n:"SXAddl", */ },&#13;
0x0865: { /* n:"CrErr", */ },&#13;
0x0866: { /* n:"HFPicture", */ },&#13;
0x0867: { /* n:"FeatHdr", */ f:parsenoop2 },&#13;
0x0868: { /* n:"Feat", */ },&#13;
0x086a: { /* n:"DataLabExt", */ },&#13;
0x086b: { /* n:"DataLabExtContents", */ },&#13;
0x086c: { /* n:"CellWatch", */ },&#13;
0x0871: { /* n:"FeatHdr11", */ },&#13;
0x0872: { /* n:"Feature11", */ },&#13;
0x0874: { /* n:"DropDownObjIds", */ },&#13;
0x0875: { /* n:"ContinueFrt11", */ },&#13;
0x0876: { /* n:"DConn", */ },&#13;
0x0877: { /* n:"List12", */ },&#13;
0x0878: { /* n:"Feature12", */ },&#13;
0x0879: { /* n:"CondFmt12", */ },&#13;
0x087a: { /* n:"CF12", */ },&#13;
0x087b: { /* n:"CFEx", */ },&#13;
0x087c: { /* n:"XFCRC", */ f:parse_XFCRC, r:12 },&#13;
0x087d: { /* n:"XFExt", */ f:parse_XFExt, r:12 },&#13;
0x087e: { /* n:"AutoFilter12", */ },&#13;
0x087f: { /* n:"ContinueFrt12", */ },&#13;
0x0884: { /* n:"MDTInfo", */ },&#13;
0x0885: { /* n:"MDXStr", */ },&#13;
0x0886: { /* n:"MDXTuple", */ },&#13;
0x0887: { /* n:"MDXSet", */ },&#13;
0x0888: { /* n:"MDXProp", */ },&#13;
0x0889: { /* n:"MDXKPI", */ },&#13;
0x088a: { /* n:"MDB", */ },&#13;
0x088b: { /* n:"PLV", */ },&#13;
0x088c: { /* n:"Compat12", */ f:parsebool, r:12 },&#13;
0x088d: { /* n:"DXF", */ },&#13;
0x088e: { /* n:"TableStyles", */ r:12 },&#13;
0x088f: { /* n:"TableStyle", */ },&#13;
0x0890: { /* n:"TableStyleElement", */ },&#13;
0x0892: { /* n:"StyleExt", */ },&#13;
0x0893: { /* n:"NamePublish", */ },&#13;
0x0894: { /* n:"NameCmt", */ f:parse_NameCmt, r:12 },&#13;
0x0895: { /* n:"SortData", */ },&#13;
0x0896: { /* n:"Theme", */ f:parse_Theme, r:12 },&#13;
0x0897: { /* n:"GUIDTypeLib", */ },&#13;
0x0898: { /* n:"FnGrp12", */ },&#13;
0x0899: { /* n:"NameFnGrp12", */ },&#13;
0x089a: { /* n:"MTRSettings", */ f:parse_MTRSettings, r:12 },&#13;
0x089b: { /* n:"CompressPictures", */ f:parsenoop2 },&#13;
0x089c: { /* n:"HeaderFooter", */ },&#13;
0x089d: { /* n:"CrtLayout12", */ },&#13;
0x089e: { /* n:"CrtMlFrt", */ },&#13;
0x089f: { /* n:"CrtMlFrtContinue", */ },&#13;
0x08a3: { /* n:"ForceFullCalculation", */ f:parse_ForceFullCalculation },&#13;
0x08a4: { /* n:"ShapePropsStream", */ },&#13;
0x08a5: { /* n:"TextPropsStream", */ },&#13;
0x08a6: { /* n:"RichTextStream", */ },&#13;
0x08a7: { /* n:"CrtLayout12A", */ },&#13;
0x1001: { /* n:"Units", */ },&#13;
0x1002: { /* n:"Chart", */ },&#13;
0x1003: { /* n:"Series", */ },&#13;
0x1006: { /* n:"DataFormat", */ },&#13;
0x1007: { /* n:"LineFormat", */ },&#13;
0x1009: { /* n:"MarkerFormat", */ },&#13;
0x100a: { /* n:"AreaFormat", */ },&#13;
0x100b: { /* n:"PieFormat", */ },&#13;
0x100c: { /* n:"AttachedLabel", */ },&#13;
0x100d: { /* n:"SeriesText", */ },&#13;
0x1014: { /* n:"ChartFormat", */ },&#13;
0x1015: { /* n:"Legend", */ },&#13;
0x1016: { /* n:"SeriesList", */ },&#13;
0x1017: { /* n:"Bar", */ },&#13;
0x1018: { /* n:"Line", */ },&#13;
0x1019: { /* n:"Pie", */ },&#13;
0x101a: { /* n:"Area", */ },&#13;
0x101b: { /* n:"Scatter", */ },&#13;
0x101c: { /* n:"CrtLine", */ },&#13;
0x101d: { /* n:"Axis", */ },&#13;
0x101e: { /* n:"Tick", */ },&#13;
0x101f: { /* n:"ValueRange", */ },&#13;
0x1020: { /* n:"CatSerRange", */ },&#13;
0x1021: { /* n:"AxisLine", */ },&#13;
0x1022: { /* n:"CrtLink", */ },&#13;
0x1024: { /* n:"DefaultText", */ },&#13;
0x1025: { /* n:"Text", */ },&#13;
0x1026: { /* n:"FontX", */ f:parseuint16 },&#13;
0x1027: { /* n:"ObjectLink", */ },&#13;
0x1032: { /* n:"Frame", */ },&#13;
0x1033: { /* n:"Begin", */ },&#13;
0x1034: { /* n:"End", */ },&#13;
0x1035: { /* n:"PlotArea", */ },&#13;
0x103a: { /* n:"Chart3d", */ },&#13;
0x103c: { /* n:"PicF", */ },&#13;
0x103d: { /* n:"DropBar", */ },&#13;
0x103e: { /* n:"Radar", */ },&#13;
0x103f: { /* n:"Surf", */ },&#13;
0x1040: { /* n:"RadarArea", */ },&#13;
0x1041: { /* n:"AxisParent", */ },&#13;
0x1043: { /* n:"LegendException", */ },&#13;
0x1044: { /* n:"ShtProps", */ f:parse_ShtProps },&#13;
0x1045: { /* n:"SerToCrt", */ },&#13;
0x1046: { /* n:"AxesUsed", */ },&#13;
0x1048: { /* n:"SBaseRef", */ },&#13;
0x104a: { /* n:"SerParent", */ },&#13;
0x104b: { /* n:"SerAuxTrend", */ },&#13;
0x104e: { /* n:"IFmtRecord", */ },&#13;
0x104f: { /* n:"Pos", */ },&#13;
0x1050: { /* n:"AlRuns", */ },&#13;
0x1051: { /* n:"BRAI", */ },&#13;
0x105b: { /* n:"SerAuxErrBar", */ },&#13;
0x105c: { /* n:"ClrtClient", */ f:parse_ClrtClient },&#13;
0x105d: { /* n:"SerFmt", */ },&#13;
0x105f: { /* n:"Chart3DBarShape", */ },&#13;
0x1060: { /* n:"Fbi", */ },&#13;
0x1061: { /* n:"BopPop", */ },&#13;
0x1062: { /* n:"AxcExt", */ },&#13;
0x1063: { /* n:"Dat", */ },&#13;
0x1064: { /* n:"PlotGrowth", */ },&#13;
0x1065: { /* n:"SIIndex", */ },&#13;
0x1066: { /* n:"GelFrame", */ },&#13;
0x1067: { /* n:"BopPopCustom", */ },&#13;
0x1068: { /* n:"Fbi2", */ },&#13;
&#13;
0x0000: { /* n:"Dimensions", */ f:parse_Dimensions },&#13;
0x0001: { /* n:"BIFF2BLANK", */ },&#13;
0x0002: { /* n:"BIFF2INT", */ f:parse_BIFF2INT },&#13;
0x0003: { /* n:"BIFF2NUM", */ f:parse_BIFF2NUM },&#13;
0x0004: { /* n:"BIFF2STR", */ f:parse_BIFF2STR },&#13;
0x0005: { /* n:"BoolErr", */ f:parse_BoolErr },&#13;
0x0007: { /* n:"String", */ f:parse_BIFF2STRING },&#13;
0x0008: { /* n:"BIFF2ROW", */ },&#13;
0x0009: { /* n:"BOF", */ f:parse_BOF },&#13;
0x000b: { /* n:"Index", */ },&#13;
0x0016: { /* n:"ExternCount", */ f:parseuint16 },&#13;
0x001e: { /* n:"BIFF2FORMAT", */ f:parse_BIFF2Format },&#13;
0x001f: { /* n:"BIFF2FMTCNT", */ }, /* 16-bit cnt of BIFF2FORMAT records */&#13;
0x0020: { /* n:"BIFF2COLINFO", */ },&#13;
0x0021: { /* n:"Array", */ f:parse_Array },&#13;
0x0024: { /* n:"COLWIDTH", */ },&#13;
0x0025: { /* n:"DefaultRowHeight", */ f:parse_DefaultRowHeight },&#13;
	// 0x2c ??&#13;
	// 0x2d ??&#13;
	// 0x2e ??&#13;
	// 0x30 FONTCOUNT: number of fonts&#13;
0x0032: { /* n:"BIFF2FONTXTRA", */ f:parse_BIFF2FONTXTRA },&#13;
	// 0x35: INFOOPTS&#13;
	// 0x36: TABLE (BIFF2 only)&#13;
	// 0x37: TABLE2 (BIFF2 only)&#13;
	// 0x38: WNDESK&#13;
	// 0x39 ??&#13;
	// 0x3a: BEGINPREF&#13;
	// 0x3b: ENDPREF&#13;
0x003e: { /* n:"BIFF2WINDOW2", */ },&#13;
	// 0x3f ??&#13;
	// 0x46: SHOWSCROLL&#13;
	// 0x47: SHOWFORMULA&#13;
	// 0x48: STATUSBAR&#13;
	// 0x49: SHORTMENUS&#13;
	// 0x4A:&#13;
	// 0x4B:&#13;
	// 0x4C:&#13;
	// 0x4E:&#13;
	// 0x4F:&#13;
	// 0x58: TOOLBAR (BIFF3)&#13;
&#13;
	/* - - - */&#13;
0x0034: { /* n:"DDEObjName", */ },&#13;
0x0043: { /* n:"BIFF2XF", */ },&#13;
0x0044: { /* n:"BIFF2XFINDEX", */ f:parseuint16 },&#13;
0x0045: { /* n:"BIFF2FONTCLR", */ },&#13;
0x0056: { /* n:"BIFF4FMTCNT", */ }, /* 16-bit cnt, similar to BIFF2 */&#13;
0x007e: { /* n:"RK", */ }, /* Not necessarily same as 0x027e */&#13;
0x007f: { /* n:"ImData", */ f:parse_ImData },&#13;
0x0087: { /* n:"Addin", */ },&#13;
0x0088: { /* n:"Edg", */ },&#13;
0x0089: { /* n:"Pub", */ },&#13;
	// 0x8A&#13;
	// 0x8B LH: alternate menu key flag (BIFF3/4)&#13;
	// 0x8E&#13;
	// 0x8F&#13;
0x0091: { /* n:"Sub", */ },&#13;
	// 0x93 STYLE&#13;
0x0094: { /* n:"LHRecord", */ },&#13;
0x0095: { /* n:"LHNGraph", */ },&#13;
0x0096: { /* n:"Sound", */ },&#13;
	// 0xA2 FNPROTO: function prototypes (BIFF4)&#13;
	// 0xA3&#13;
	// 0xA8&#13;
0x00a9: { /* n:"CoordList", */ },&#13;
0x00ab: { /* n:"GCW", */ },&#13;
0x00bc: { /* n:"ShrFmla", */ }, /* Not necessarily same as 0x04bc */&#13;
0x00bf: { /* n:"ToolbarHdr", */ },&#13;
0x00c0: { /* n:"ToolbarEnd", */ },&#13;
0x00c2: { /* n:"AddMenu", */ },&#13;
0x00c3: { /* n:"DelMenu", */ },&#13;
0x00d6: { /* n:"RString", */ f:parse_RString },&#13;
0x00df: { /* n:"UDDesc", */ },&#13;
0x00ea: { /* n:"TabIdConf", */ },&#13;
0x0162: { /* n:"XL5Modify", */ },&#13;
0x01a5: { /* n:"FileSharing2", */ },&#13;
0x0206: { /* n:"Formula", */ f:parse_Formula },&#13;
0x0209: { /* n:"BOF", */ f:parse_BOF },&#13;
0x0218: { /* n:"Lbl", */ f:parse_Lbl },&#13;
0x0223: { /* n:"ExternName", */ f:parse_ExternName },&#13;
0x0231: { /* n:"Font", */ },&#13;
0x0243: { /* n:"BIFF3XF", */ },&#13;
0x0406: { /* n:"Formula", */ f:parse_Formula },&#13;
0x0409: { /* n:"BOF", */ f:parse_BOF },&#13;
0x0443: { /* n:"BIFF4XF", */ },&#13;
0x086d: { /* n:"FeatInfo", */ },&#13;
0x0873: { /* n:"FeatInfo11", */ },&#13;
0x0881: { /* n:"SXAddl12", */ },&#13;
0x08c0: { /* n:"AutoWebPub", */ },&#13;
0x08c1: { /* n:"ListObj", */ },&#13;
0x08c2: { /* n:"ListField", */ },&#13;
0x08c3: { /* n:"ListDV", */ },&#13;
0x08c4: { /* n:"ListCondFmt", */ },&#13;
0x08c5: { /* n:"ListCF", */ },&#13;
0x08c6: { /* n:"FMQry", */ },&#13;
0x08c7: { /* n:"FMSQry", */ },&#13;
0x08c8: { /* n:"PLV", */ },&#13;
0x08c9: { /* n:"LnExt", */ },&#13;
0x08ca: { /* n:"MkrExt", */ },&#13;
0x08cb: { /* n:"CrtCoopt", */ },&#13;
0x08d6: { /* n:"FRTArchId$", */ r:12 },&#13;
&#13;
	/* --- multiplan 4 records --- */&#13;
0x0065: { /* n:"", */ }, // one per window&#13;
0x0066: { /* n:"", */ }, // calc settings&#13;
0x0069: { /* n:"", */ }, // print header&#13;
0x006a: { /* n:"", */ }, // print footer&#13;
0x006b: { /* n:"", */ }, // print settings&#13;
0x006d: { /* n:"", */ }, // one per window&#13;
0x0070: { /* n:"", */ }, // includes default col width&#13;
0x0072: { /* n:"", */ }, // includes selected cell&#13;
&#13;
0x7262: {}&#13;
};&#13;
&#13;
function write_biff_rec(ba, type, payload, length) {&#13;
	var t = type;&#13;
	if(isNaN(t)) return;&#13;
	var len = length || (payload||[]).length || 0;&#13;
	var o = ba.next(4);&#13;
	o.write_shift(2, t);&#13;
	o.write_shift(2, len);&#13;
	if(len &gt; 0 &amp;&amp; is_buf(payload)) ba.push(payload);&#13;
}&#13;
&#13;
function write_biff_continue(ba, type, payload, length) {&#13;
	var len = length || (payload||[]).length || 0;&#13;
	if(len &lt;= 8224) return write_biff_rec(ba, type, payload, len);&#13;
	var t = type;&#13;
	if(isNaN(t)) return;&#13;
	var parts = payload.parts || [], sidx = 0;&#13;
	var i = 0, w = 0;&#13;
	while(w + (parts[sidx] || 8224) &lt;= 8224) { w+= (parts[sidx] || 8224); sidx++; }&#13;
	var o = ba.next(4);&#13;
	o.write_shift(2, t);&#13;
	o.write_shift(2, w);&#13;
	ba.push(payload.slice(i, i + w));&#13;
	i += w;&#13;
	while(i &lt; len) {&#13;
		o = ba.next(4);&#13;
		o.write_shift(2, 0x3c); // TODO: figure out correct continue type&#13;
		w = 0;&#13;
		while(w + (parts[sidx] || 8224) &lt;= 8224) { w+= (parts[sidx] || 8224); sidx++; }&#13;
		o.write_shift(2, w);&#13;
		ba.push(payload.slice(i, i+w)); i+= w;&#13;
	}&#13;
}&#13;
&#13;
function write_BIFF2Cell(out, r, c) {&#13;
	if(!out) out = new_buf(7);&#13;
	out.write_shift(2, r);&#13;
	out.write_shift(2, c);&#13;
	out.write_shift(2, 0);&#13;
	out.write_shift(1, 0);&#13;
	return out;&#13;
}&#13;
&#13;
function write_BIFF2BERR(r, c, val, t) {&#13;
	var out = new_buf(9);&#13;
	write_BIFF2Cell(out, r, c);&#13;
	write_Bes(val, t || 'b', out);&#13;
	return out;&#13;
}&#13;
&#13;
/* TODO: codepage, large strings */&#13;
function write_BIFF2LABEL(r, c, val) {&#13;
	var out = new_buf(8 + 2*val.length);&#13;
	write_BIFF2Cell(out, r, c);&#13;
	out.write_shift(1, val.length);&#13;
	out.write_shift(val.length, val, 'sbcs');&#13;
	return out.l &lt; out.length ? out.slice(0, out.l) : out;&#13;
}&#13;
&#13;
function write_ws_biff2_cell(ba, cell, R, C) {&#13;
	if(cell.v != null) switch(cell.t) {&#13;
		case 'd': case 'n':&#13;
			var v = cell.t == 'd' ? datenum(parseDate(cell.v)) : cell.v;&#13;
			if((v == (v|0)) &amp;&amp; (v &gt;= 0) &amp;&amp; (v &lt; 65536))&#13;
				write_biff_rec(ba, 0x0002, write_BIFF2INT(R, C, v));&#13;
			else&#13;
				write_biff_rec(ba, 0x0003, write_BIFF2NUM(R,C, v));&#13;
			return;&#13;
		case 'b': case 'e': write_biff_rec(ba, 0x0005, write_BIFF2BERR(R, C, cell.v, cell.t)); return;&#13;
		/* TODO: codepage, sst */&#13;
		case 's': case 'str':&#13;
			write_biff_rec(ba, 0x0004, write_BIFF2LABEL(R, C, cell.v == null ? "" : String(cell.v).slice(0,255)));&#13;
			return;&#13;
	}&#13;
	write_biff_rec(ba, 0x0001, write_BIFF2Cell(null, R, C));&#13;
}&#13;
&#13;
function write_ws_biff2(ba, ws, idx, opts) {&#13;
	var dense = Array.isArray(ws);&#13;
	var range = safe_decode_range(ws['!ref'] || "A1"), ref, rr = "", cols = [];&#13;
	if(range.e.c &gt; 0xFF || range.e.r &gt; 0x3FFF) {&#13;
		if(opts.WTF) throw new Error("Range " + (ws['!ref'] || "A1") + " exceeds format limit A1:IV16384");&#13;
		range.e.c = Math.min(range.e.c, 0xFF);&#13;
		range.e.r = Math.min(range.e.c, 0x3FFF);&#13;
		ref = encode_range(range);&#13;
	}&#13;
	for(var R = range.s.r; R &lt;= range.e.r; ++R) {&#13;
		rr = encode_row(R);&#13;
		for(var C = range.s.c; C &lt;= range.e.c; ++C) {&#13;
			if(R === range.s.r) cols[C] = encode_col(C);&#13;
			ref = cols[C] + rr;&#13;
			var cell = dense ? (ws[R]||[])[C] : ws[ref];&#13;
			if(!cell) continue;&#13;
			/* write cell */&#13;
			write_ws_biff2_cell(ba, cell, R, C, opts);&#13;
		}&#13;
	}&#13;
}&#13;
&#13;
/* Based on test files */&#13;
function write_biff2_buf(wb, opts) {&#13;
	var o = opts || {};&#13;
	if(DENSE != null &amp;&amp; o.dense == null) o.dense = DENSE;&#13;
	var ba = buf_array();&#13;
	var idx = 0;&#13;
	for(var i=0;i&lt;wb.SheetNames.length;++i) if(wb.SheetNames[i] == o.sheet) idx=i;&#13;
	if(idx == 0 &amp;&amp; !!o.sheet &amp;&amp; wb.SheetNames[0] != o.sheet) throw new Error("Sheet not found: " + o.sheet);&#13;
	write_biff_rec(ba, (o.biff == 4 ? 0x0409 : (o.biff == 3 ? 0x0209 : 0x0009)), write_BOF(wb, 0x10, o));&#13;
	/* ... */&#13;
	write_ws_biff2(ba, wb.Sheets[wb.SheetNames[idx]], idx, o, wb);&#13;
	/* ... */&#13;
	write_biff_rec(ba, 0x000A);&#13;
	return ba.end();&#13;
}&#13;
&#13;
function write_FONTS_biff8(ba, data, opts) {&#13;
	write_biff_rec(ba, 0x0031 /* Font */, write_Font({&#13;
		sz:12,&#13;
		color: {theme:1},&#13;
		name: "Arial",&#13;
		family: 2,&#13;
		scheme: "minor"&#13;
	}, opts));&#13;
}&#13;
&#13;
&#13;
function write_FMTS_biff8(ba, NF, opts) {&#13;
	if(!NF) return;&#13;
	[[5,8],[23,26],[41,44],[/*63*/50,/*66],[164,*/392]].forEach(function(r) {&#13;
for(var i = r[0]; i &lt;= r[1]; ++i) if(NF[i] != null) write_biff_rec(ba, 0x041E /* Format */, write_Format(i, NF[i], opts));&#13;
	});&#13;
}&#13;
&#13;
function write_FEAT(ba, ws) {&#13;
	/* [MS-XLS] 2.4.112 */&#13;
	var o = new_buf(19);&#13;
	o.write_shift(4, 0x867); o.write_shift(4, 0); o.write_shift(4, 0);&#13;
	o.write_shift(2, 3); o.write_shift(1, 1); o.write_shift(4, 0);&#13;
	write_biff_rec(ba, 0x0867 /* FeatHdr */, o);&#13;
	/* [MS-XLS] 2.4.111 */&#13;
	o = new_buf(39);&#13;
	o.write_shift(4, 0x868); o.write_shift(4, 0); o.write_shift(4, 0);&#13;
	o.write_shift(2, 3); o.write_shift(1, 0); o.write_shift(4, 0);&#13;
	o.write_shift(2, 1); o.write_shift(4, 4); o.write_shift(2, 0);&#13;
	write_Ref8U(safe_decode_range(ws['!ref']||"A1"), o);&#13;
	o.write_shift(4, 4);&#13;
	write_biff_rec(ba, 0x0868 /* Feat */, o);&#13;
}&#13;
&#13;
function write_CELLXFS_biff8(ba, opts) {&#13;
	for(var i = 0; i &lt; 16; ++i) write_biff_rec(ba, 0x00e0 /* XF */, write_XF({numFmtId:0, style:true}, 0, opts));&#13;
	opts.cellXfs.forEach(function(c) {&#13;
		write_biff_rec(ba, 0x00e0 /* XF */, write_XF(c, 0, opts));&#13;
	});&#13;
}&#13;
&#13;
function write_ws_biff8_hlinks(ba, ws) {&#13;
	for(var R=0; R&lt;ws['!links'].length; ++R) {&#13;
		var HL = ws['!links'][R];&#13;
		write_biff_rec(ba, 0x01b8 /* HLink */, write_HLink(HL));&#13;
		if(HL[1].Tooltip) write_biff_rec(ba, 0x0800 /* HLinkTooltip */, write_HLinkTooltip(HL));&#13;
	}&#13;
	delete ws['!links'];&#13;
}&#13;
&#13;
function write_ws_cols_biff8(ba, cols) {&#13;
	if(!cols) return;&#13;
	var cnt = 0;&#13;
	cols.forEach(function(col, idx) {&#13;
		if(++cnt &lt;= 256 &amp;&amp; col) {&#13;
			write_biff_rec(ba, 0x007d /* ColInfo */, write_ColInfo(col_obj_w(idx, col), idx));&#13;
		}&#13;
	});&#13;
}&#13;
&#13;
function write_ws_biff8_cell(ba, cell, R, C, opts) {&#13;
	var os = 16 + get_cell_style(opts.cellXfs, cell, opts);&#13;
	if(cell.v == null &amp;&amp; !cell.bf) {&#13;
		write_biff_rec(ba, 0x0201 /* Blank */, write_XLSCell(R, C, os));&#13;
		return;&#13;
	}&#13;
	if(cell.bf) write_biff_rec(ba, 0x0006 /* Formula */, write_Formula(cell, R, C, opts, os));&#13;
	else switch(cell.t) {&#13;
		case 'd': case 'n':&#13;
			var v = cell.t == 'd' ? datenum(parseDate(cell.v)) : cell.v;&#13;
			/* TODO: emit RK as appropriate */&#13;
			write_biff_rec(ba, 0x0203 /* Number */, write_Number(R, C, v, os, opts));&#13;
			break;&#13;
		case 'b': case 'e':&#13;
			write_biff_rec(ba, 0x0205 /* BoolErr */, write_BoolErr(R, C, cell.v, os, opts, cell.t));&#13;
			break;&#13;
		/* TODO: codepage, sst */&#13;
		case 's': case 'str':&#13;
			if(opts.bookSST) {&#13;
				var isst = get_sst_id(opts.Strings, cell.v == null ? "" : String(cell.v), opts.revStrings);&#13;
				write_biff_rec(ba, 0x00fd /* LabelSst */, write_LabelSst(R, C, isst, os, opts));&#13;
			} else write_biff_rec(ba, 0x0204 /* Label */, write_Label(R, C, (cell.v == null ? "" : String(cell.v)).slice(0,255), os, opts));&#13;
			break;&#13;
		default:&#13;
			write_biff_rec(ba, 0x0201 /* Blank */, write_XLSCell(R, C, os));&#13;
	}&#13;
}&#13;
&#13;
/* [MS-XLS] 2.1.7.20.5 */&#13;
function write_ws_biff8(idx, opts, wb) {&#13;
	var ba = buf_array();&#13;
	var s = wb.SheetNames[idx], ws = wb.Sheets[s] || {};&#13;
	var _WB = ((wb||{}).Workbook||{});&#13;
	var _sheet = ((_WB.Sheets||[])[idx]||{});&#13;
	var dense = Array.isArray(ws);&#13;
	var b8 = opts.biff == 8;&#13;
	var ref, rr = "", cols = [];&#13;
	var range = safe_decode_range(ws['!ref'] || "A1");&#13;
	var MAX_ROWS = b8 ? 65536 : 16384;&#13;
	if(range.e.c &gt; 0xFF || range.e.r &gt;= MAX_ROWS) {&#13;
		if(opts.WTF) throw new Error("Range " + (ws['!ref'] || "A1") + " exceeds format limit A1:IV16384");&#13;
		range.e.c = Math.min(range.e.c, 0xFF);&#13;
		range.e.r = Math.min(range.e.c, MAX_ROWS-1);&#13;
	}&#13;
&#13;
	write_biff_rec(ba, 0x0809, write_BOF(wb, 0x10, opts));&#13;
	/* [Uncalced] Index */&#13;
	write_biff_rec(ba, 0x000d /* CalcMode */, writeuint16(1));&#13;
	write_biff_rec(ba, 0x000c /* CalcCount */, writeuint16(100));&#13;
	write_biff_rec(ba, 0x000f /* CalcRefMode */, writebool(true));&#13;
	write_biff_rec(ba, 0x0011 /* CalcIter */, writebool(false));&#13;
	write_biff_rec(ba, 0x0010 /* CalcDelta */, write_Xnum(0.001));&#13;
	write_biff_rec(ba, 0x005f /* CalcSaveRecalc */, writebool(true));&#13;
	write_biff_rec(ba, 0x002a /* PrintRowCol */, writebool(false));&#13;
	write_biff_rec(ba, 0x002b /* PrintGrid */, writebool(false));&#13;
	write_biff_rec(ba, 0x0082 /* GridSet */, writeuint16(1));&#13;
	write_biff_rec(ba, 0x0080 /* Guts */, write_Guts([0,0]));&#13;
	/* DefaultRowHeight WsBool [Sync] [LPr] [HorizontalPageBreaks] [VerticalPageBreaks] */&#13;
	/* Header (string) */&#13;
	/* Footer (string) */&#13;
	write_biff_rec(ba, 0x0083 /* HCenter */, writebool(false));&#13;
	write_biff_rec(ba, 0x0084 /* VCenter */, writebool(false));&#13;
	/* ... */&#13;
	if(b8) write_ws_cols_biff8(ba, ws["!cols"]);&#13;
	/* ... */&#13;
	write_biff_rec(ba, 0x0200 /* Dimensions */, write_Dimensions(range, opts));&#13;
	/* ... */&#13;
&#13;
	if(b8) ws['!links'] = [];&#13;
	var comments = [];&#13;
	for(var R = range.s.r; R &lt;= range.e.r; ++R) {&#13;
		rr = encode_row(R);&#13;
		for(var C = range.s.c; C &lt;= range.e.c; ++C) {&#13;
			if(R === range.s.r) cols[C] = encode_col(C);&#13;
			ref = cols[C] + rr;&#13;
			var cell = dense ? (ws[R]||[])[C] : ws[ref];&#13;
			if(!cell) continue;&#13;
			/* write cell */&#13;
			write_ws_biff8_cell(ba, cell, R, C, opts);&#13;
			if(b8 &amp;&amp; cell.l) ws['!links'].push([ref, cell.l]);&#13;
			if(b8 &amp;&amp; cell.c) comments.push([ref, cell.c]);&#13;
		}&#13;
	}&#13;
	var cname = _sheet.CodeName || _sheet.name || s;&#13;
	/* ... */&#13;
	// if(b8) comments.forEach(function(comment) { write_biff_rec(ba, 0x001c /* Note */, write_NoteSh(comment)); });&#13;
	/* ... */&#13;
	if(b8) write_biff_rec(ba, 0x023e /* Window2 */, write_Window2((_WB.Views||[])[0]));&#13;
	/* ... */&#13;
	if(b8 &amp;&amp; (ws['!merges']||[]).length) write_biff_rec(ba, 0x00e5 /* MergeCells */, write_MergeCells(ws['!merges']));&#13;
	/* [LRng] *QUERYTABLE [PHONETICINFO] CONDFMTS */&#13;
	if(b8) write_ws_biff8_hlinks(ba, ws);&#13;
	/* [DVAL] */&#13;
	write_biff_rec(ba, 0x01ba /* CodeName */, write_XLUnicodeString(cname, opts));&#13;
	/* *WebPub *CellWatch [SheetExt] */&#13;
	if(b8) write_FEAT(ba, ws);&#13;
	/* *FEAT11 *RECORD12 */&#13;
	write_biff_rec(ba, 0x000a /* EOF */);&#13;
	return ba.end();&#13;
}&#13;
&#13;
/* [MS-XLS] 2.1.7.20.3 */&#13;
function write_biff8_global(wb, bufs, opts) {&#13;
	var A = buf_array();&#13;
	var _WB = ((wb||{}).Workbook||{});&#13;
	var _sheets = (_WB.Sheets||[]);&#13;
	var _wb = _WB.WBProps||{};&#13;
	var b8 = opts.biff == 8, b5 = opts.biff == 5;&#13;
	write_biff_rec(A, 0x0809, write_BOF(wb, 0x05, opts));&#13;
	if(opts.bookType == "xla") write_biff_rec(A, 0x0087 /* Addin */);&#13;
	write_biff_rec(A, 0x00e1 /* InterfaceHdr */, b8 ? writeuint16(0x04b0) : null);&#13;
	write_biff_rec(A, 0x00c1 /* Mms */, writezeroes(2));&#13;
	if(b5) write_biff_rec(A, 0x00bf /* ToolbarHdr */);&#13;
	if(b5) write_biff_rec(A, 0x00c0 /* ToolbarEnd */);&#13;
	write_biff_rec(A, 0x00e2 /* InterfaceEnd */);&#13;
	write_biff_rec(A, 0x005c /* WriteAccess */, write_WriteAccess("xlsx", opts));&#13;
	/* [FileSharing] */&#13;
	write_biff_rec(A, 0x0042 /* CodePage */, writeuint16(b8 ? 0x04b0 : 0x04E4));&#13;
	/* *2047 Lel */&#13;
	if(b8) write_biff_rec(A, 0x0161 /* DSF */, writeuint16(0));&#13;
	if(b8) write_biff_rec(A, 0x01c0 /* Excel9File */);&#13;
	write_biff_rec(A, 0x013d /* RRTabId */, write_RRTabId(wb.SheetNames.length));&#13;
	if(b8 &amp;&amp; wb.vbaraw) write_biff_rec(A, 0x00d3 /* ObProj */);&#13;
	/* [ObNoMacros] */&#13;
	if(b8 &amp;&amp; wb.vbaraw) {&#13;
		var cname = _wb.CodeName || "ThisWorkbook";&#13;
		write_biff_rec(A, 0x01ba /* CodeName */, write_XLUnicodeString(cname, opts));&#13;
	}&#13;
	write_biff_rec(A, 0x009c /* BuiltInFnGroupCount */, writeuint16(0x11));&#13;
	/* *FnGroupName *FnGrp12 */&#13;
	/* *Lbl */&#13;
	/* [OleObjectSize] */&#13;
	write_biff_rec(A, 0x0019 /* WinProtect */, writebool(false));&#13;
	write_biff_rec(A, 0x0012 /* Protect */, writebool(false));&#13;
	write_biff_rec(A, 0x0013 /* Password */, writeuint16(0));&#13;
	if(b8) write_biff_rec(A, 0x01af /* Prot4Rev */, writebool(false));&#13;
	if(b8) write_biff_rec(A, 0x01bc /* Prot4RevPass */, writeuint16(0));&#13;
	write_biff_rec(A, 0x003d /* Window1 */, write_Window1(opts));&#13;
	write_biff_rec(A, 0x0040 /* Backup */, writebool(false));&#13;
	write_biff_rec(A, 0x008d /* HideObj */, writeuint16(0));&#13;
	write_biff_rec(A, 0x0022 /* Date1904 */, writebool(safe1904(wb)=="true"));&#13;
	write_biff_rec(A, 0x000e /* CalcPrecision */, writebool(true));&#13;
	if(b8) write_biff_rec(A, 0x01b7 /* RefreshAll */, writebool(false));&#13;
	write_biff_rec(A, 0x00DA /* BookBool */, writeuint16(0));&#13;
	/* ... */&#13;
	write_FONTS_biff8(A, wb, opts);&#13;
	write_FMTS_biff8(A, wb.SSF, opts);&#13;
	write_CELLXFS_biff8(A, opts);&#13;
	/* ... */&#13;
	if(b8) write_biff_rec(A, 0x0160 /* UsesELFs */, writebool(false));&#13;
	var a = A.end();&#13;
&#13;
	var C = buf_array();&#13;
	/* METADATA [MTRSettings] [ForceFullCalculation] */&#13;
	if(b8) write_biff_rec(C, 0x008C /* Country */, write_Country());&#13;
	/* *SUPBOOK *LBL *RTD [RecalcId] *HFPicture *MSODRAWINGGROUP */&#13;
&#13;
	/* BIFF8: [SST *Continue] ExtSST */&#13;
	if(b8 &amp;&amp; opts.Strings) write_biff_continue(C, 0x00FC /* SST */, write_SST(opts.Strings, opts));&#13;
&#13;
	/* *WebPub [WOpt] [CrErr] [BookExt] *FeatHdr *DConn [THEME] [CompressPictures] [Compat12] [GUIDTypeLib] */&#13;
	write_biff_rec(C, 0x000A /* EOF */);&#13;
	var c = C.end();&#13;
&#13;
	var B = buf_array();&#13;
	var blen = 0, j = 0;&#13;
	for(j = 0; j &lt; wb.SheetNames.length; ++j) blen += (b8 ? 12 : 11) + (b8 ? 2 : 1) * wb.SheetNames[j].length;&#13;
	var start = a.length + blen + c.length;&#13;
	for(j = 0; j &lt; wb.SheetNames.length; ++j) {&#13;
		var _sheet = _sheets[j] || ({});&#13;
		write_biff_rec(B, 0x0085 /* BoundSheet8 */, write_BoundSheet8({pos:start, hs:_sheet.Hidden||0, dt:0, name:wb.SheetNames[j]}, opts));&#13;
		start += bufs[j].length;&#13;
	}&#13;
	/* 1*BoundSheet8 */&#13;
	var b = B.end();&#13;
	if(blen != b.length) throw new Error("BS8 " + blen + " != " + b.length);&#13;
&#13;
	var out = [];&#13;
	if(a.length) out.push(a);&#13;
	if(b.length) out.push(b);&#13;
	if(c.length) out.push(c);&#13;
	return bconcat(out);&#13;
}&#13;
&#13;
/* [MS-XLS] 2.1.7.20 Workbook Stream */&#13;
function write_biff8_buf(wb, opts) {&#13;
	var o = opts || {};&#13;
	var bufs = [];&#13;
&#13;
	if(wb &amp;&amp; !wb.SSF) {&#13;
		wb.SSF = dup(table_fmt);&#13;
	}&#13;
	if(wb &amp;&amp; wb.SSF) {&#13;
		make_ssf(); SSF_load_table(wb.SSF);&#13;
		// $FlowIgnore&#13;
		o.revssf = evert_num(wb.SSF); o.revssf[wb.SSF[65535]] = 0;&#13;
		o.ssf = wb.SSF;&#13;
	}&#13;
&#13;
	o.Strings = []; o.Strings.Count = 0; o.Strings.Unique = 0;&#13;
	fix_write_opts(o);&#13;
&#13;
	o.cellXfs = [];&#13;
	get_cell_style(o.cellXfs, {}, {revssf:{"General":0}});&#13;
&#13;
	if(!wb.Props) wb.Props = {};&#13;
&#13;
	for(var i = 0; i &lt; wb.SheetNames.length; ++i) bufs[bufs.length] = write_ws_biff8(i, o, wb);&#13;
	bufs.unshift(write_biff8_global(wb, bufs, o));&#13;
	return bconcat(bufs);&#13;
}&#13;
&#13;
function write_biff_buf(wb, opts) {&#13;
	for(var i = 0; i &lt;= wb.SheetNames.length; ++i) {&#13;
		var ws = wb.Sheets[wb.SheetNames[i]];&#13;
		if(!ws || !ws["!ref"]) continue;&#13;
		var range = decode_range(ws["!ref"]);&#13;
		if(range.e.c &gt; 255) { // note: 255 is IV&#13;
			if(typeof console != "undefined" &amp;&amp; console.error) console.error("Worksheet '" + wb.SheetNames[i] + "' extends beyond column IV (255).  Data may be lost.");&#13;
		}&#13;
	}&#13;
&#13;
	var o = opts || {};&#13;
	switch(o.biff || 2) {&#13;
		case 8: case 5: return write_biff8_buf(wb, opts);&#13;
		case 4: case 3: case 2: return write_biff2_buf(wb, opts);&#13;
	}&#13;
	throw new Error("invalid type " + o.bookType + " for BIFF");&#13;
}&#13;
/* note: browser DOM element cannot see mso- style attrs, must parse */&#13;
function html_to_sheet(str, _opts) {&#13;
	var opts = _opts || {};&#13;
	if(DENSE != null &amp;&amp; opts.dense == null) opts.dense = DENSE;&#13;
	var ws = opts.dense ? ([]) : ({});&#13;
	str = str.replace(/&lt;!--.*?--&gt;/g, "");&#13;
	var mtch = str.match(/&lt;table/i);&#13;
	if(!mtch) throw new Error("Invalid HTML: could not find &lt;table&gt;");&#13;
	var mtch2 = str.match(/&lt;\/table/i);&#13;
	var i = mtch.index, j = mtch2 &amp;&amp; mtch2.index || str.length;&#13;
	var rows = split_regex(str.slice(i, j), /(:?&lt;tr[^&gt;]*&gt;)/i, "&lt;tr&gt;");&#13;
	var R = -1, C = 0, RS = 0, CS = 0;&#13;
	var range = {s:{r:10000000, c:10000000},e:{r:0,c:0}};&#13;
	var merges = [];&#13;
	for(i = 0; i &lt; rows.length; ++i) {&#13;
		var row = rows[i].trim();&#13;
		var hd = row.slice(0,3).toLowerCase();&#13;
		if(hd == "&lt;tr") { ++R; if(opts.sheetRows &amp;&amp; opts.sheetRows &lt;= R) { --R; break; } C = 0; continue; }&#13;
		if(hd != "&lt;td" &amp;&amp; hd != "&lt;th") continue;&#13;
		var cells = row.split(/&lt;\/t[dh]&gt;/i);&#13;
		for(j = 0; j &lt; cells.length; ++j) {&#13;
			var cell = cells[j].trim();&#13;
			if(!cell.match(/&lt;t[dh]/i)) continue;&#13;
			var m = cell, cc = 0;&#13;
			/* TODO: parse styles etc */&#13;
			while(m.charAt(0) == "&lt;" &amp;&amp; (cc = m.indexOf("&gt;")) &gt; -1) m = m.slice(cc+1);&#13;
			for(var midx = 0; midx &lt; merges.length; ++midx) {&#13;
				var _merge = merges[midx];&#13;
				if(_merge.s.c == C &amp;&amp; _merge.s.r &lt; R &amp;&amp; R &lt;= _merge.e.r) { C = _merge.e.c + 1; midx = -1; }&#13;
			}&#13;
			var tag = parsexmltag(cell.slice(0, cell.indexOf("&gt;")));&#13;
			CS = tag.colspan ? +tag.colspan : 1;&#13;
			if((RS = +tag.rowspan)&gt;1 || CS&gt;1) merges.push({s:{r:R,c:C},e:{r:R + (RS||1) - 1, c:C + CS - 1}});&#13;
			var _t = tag.t || tag["data-t"] || "";&#13;
			/* TODO: generate stub cells */&#13;
			if(!m.length) { C += CS; continue; }&#13;
			m = htmldecode(m);&#13;
			if(range.s.r &gt; R) range.s.r = R; if(range.e.r &lt; R) range.e.r = R;&#13;
			if(range.s.c &gt; C) range.s.c = C; if(range.e.c &lt; C) range.e.c = C;&#13;
			if(!m.length) { C += CS; continue; }&#13;
			var o = {t:'s', v:m};&#13;
			if(opts.raw || !m.trim().length || _t == 's'){}&#13;
			else if(m === 'TRUE') o = {t:'b', v:true};&#13;
			else if(m === 'FALSE') o = {t:'b', v:false};&#13;
			else if(!isNaN(fuzzynum(m))) o = {t:'n', v:fuzzynum(m)};&#13;
			else if(!isNaN(fuzzydate(m).getDate())) {&#13;
				o = ({t:'d', v:parseDate(m)});&#13;
				if(!opts.cellDates) o = ({t:'n', v:datenum(o.v)});&#13;
				o.z = opts.dateNF || table_fmt[14];&#13;
			}&#13;
			if(opts.dense) { if(!ws[R]) ws[R] = []; ws[R][C] = o; }&#13;
			else ws[encode_cell({r:R, c:C})] = o;&#13;
			C += CS;&#13;
		}&#13;
	}&#13;
	ws['!ref'] = encode_range(range);&#13;
	if(merges.length) ws["!merges"] = merges;&#13;
	return ws;&#13;
}&#13;
function make_html_row(ws, r, R, o) {&#13;
	var M = (ws['!merges'] ||[]);&#13;
	var oo = [];&#13;
	var sp = ({});&#13;
	for(var C = r.s.c; C &lt;= r.e.c; ++C) {&#13;
		var RS = 0, CS = 0;&#13;
		for(var j = 0; j &lt; M.length; ++j) {&#13;
			if(M[j].s.r &gt; R || M[j].s.c &gt; C) continue;&#13;
			if(M[j].e.r &lt; R || M[j].e.c &lt; C) continue;&#13;
			if(M[j].s.r &lt; R || M[j].s.c &lt; C) { RS = -1; break; }&#13;
			RS = M[j].e.r - M[j].s.r + 1; CS = M[j].e.c - M[j].s.c + 1; break;&#13;
		}&#13;
		if(RS &lt; 0) continue;&#13;
		var coord = encode_cell({r:R,c:C});&#13;
		var cell = o.dense ? (ws[R]||[])[C] : ws[coord];&#13;
		/* TODO: html entities */&#13;
		var w = (cell &amp;&amp; cell.v != null) &amp;&amp; (cell.h || escapehtml(cell.w || (format_cell(cell), cell.w) || "")) || "";&#13;
		sp = ({});&#13;
		if(RS &gt; 1) sp.rowspan = RS;&#13;
		if(CS &gt; 1) sp.colspan = CS;&#13;
		if(o.editable) w = '&lt;span contenteditable="true"&gt;' + w + '&lt;/span&gt;';&#13;
		else if(cell) {&#13;
			sp["data-t"] = cell &amp;&amp; cell.t || 'z';&#13;
			if(cell.v != null) sp["data-v"] = cell.v;&#13;
			if(cell.z != null) sp["data-z"] = cell.z;&#13;
			if(cell.l &amp;&amp; (cell.l.Target || "#").charAt(0) != "#") w = '&lt;a href="' + cell.l.Target +'"&gt;' + w + '&lt;/a&gt;';&#13;
		}&#13;
		sp.id = (o.id || "sjs") + "-" + coord;&#13;
		oo.push(writextag('td', w, sp));&#13;
	}&#13;
	var preamble = "&lt;tr&gt;";&#13;
	return preamble + oo.join("") + "&lt;/tr&gt;";&#13;
}&#13;
&#13;
var HTML_BEGIN = '&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"/&gt;&lt;title&gt;xlsx Table Export&lt;/title&gt;&lt;/head&gt;&lt;body&gt;';&#13;
var HTML_END = '&lt;/body&gt;&lt;/html&gt;';&#13;
&#13;
function html_to_workbook(str, opts) {&#13;
	var mtch = str.match(/&lt;table[\s\S]*?&gt;[\s\S]*?&lt;\/table&gt;/gi);&#13;
	if(!mtch || mtch.length == 0) throw new Error("Invalid HTML: could not find &lt;table&gt;");&#13;
	if(mtch.length == 1) {&#13;
		var w = sheet_to_workbook(html_to_sheet(mtch[0], opts), opts);&#13;
		w.bookType = "html";&#13;
		return w;&#13;
	}&#13;
	var wb = book_new();&#13;
	mtch.forEach(function(s, idx) { book_append_sheet(wb, html_to_sheet(s, opts), "Sheet" + (idx+1)); });&#13;
	wb.bookType = "html";&#13;
	return wb;&#13;
}&#13;
&#13;
function make_html_preamble(ws, R, o) {&#13;
	var out = [];&#13;
	return out.join("") + '&lt;table' + (o &amp;&amp; o.id ? ' id="' + o.id + '"' : "") + '&gt;';&#13;
}&#13;
&#13;
function sheet_to_html(ws, opts/*, wb:?Workbook*/) {&#13;
	var o = opts || {};&#13;
	var header = o.header != null ? o.header : HTML_BEGIN;&#13;
	var footer = o.footer != null ? o.footer : HTML_END;&#13;
	var out = [header];&#13;
	var r = decode_range(ws['!ref']);&#13;
	o.dense = Array.isArray(ws);&#13;
	out.push(make_html_preamble(ws, r, o));&#13;
	for(var R = r.s.r; R &lt;= r.e.r; ++R) out.push(make_html_row(ws, r, R, o));&#13;
	out.push("&lt;/table&gt;" + footer);&#13;
	return out.join("");&#13;
}&#13;
&#13;
function sheet_add_dom(ws, table, _opts) {&#13;
	var rows = table.rows;&#13;
	if(!rows) {&#13;
		/* not an HTML TABLE */&#13;
		throw "Unsupported origin when " + table.tagName + " is not a TABLE";&#13;
	}&#13;
&#13;
	var opts = _opts || {};&#13;
	if(DENSE != null) opts.dense = DENSE;&#13;
	var or_R = 0, or_C = 0;&#13;
	if(opts.origin != null) {&#13;
		if(typeof opts.origin == 'number') or_R = opts.origin;&#13;
		else {&#13;
			var _origin = typeof opts.origin == "string" ? decode_cell(opts.origin) : opts.origin;&#13;
			or_R = _origin.r; or_C = _origin.c;&#13;
		}&#13;
	}&#13;
&#13;
	var sheetRows = Math.min(opts.sheetRows||10000000, rows.length);&#13;
	var range = {s:{r:0,c:0},e:{r:or_R,c:or_C}};&#13;
	if(ws["!ref"]) {&#13;
		var _range = decode_range(ws["!ref"]);&#13;
		range.s.r = Math.min(range.s.r, _range.s.r);&#13;
		range.s.c = Math.min(range.s.c, _range.s.c);&#13;
		range.e.r = Math.max(range.e.r, _range.e.r);&#13;
		range.e.c = Math.max(range.e.c, _range.e.c);&#13;
		if(or_R == -1) range.e.r = or_R = _range.e.r + 1;&#13;
	}&#13;
	var merges = [], midx = 0;&#13;
	var rowinfo = ws["!rows"] || (ws["!rows"] = []);&#13;
	var _R = 0, R = 0, _C = 0, C = 0, RS = 0, CS = 0;&#13;
	if(!ws["!cols"]) ws['!cols'] = [];&#13;
	for(; _R &lt; rows.length &amp;&amp; R &lt; sheetRows; ++_R) {&#13;
		var row = rows[_R];&#13;
		if (is_dom_element_hidden(row)) {&#13;
			if (opts.display) continue;&#13;
			rowinfo[R] = {hidden: true};&#13;
		}&#13;
		var elts = (row.cells);&#13;
		for(_C = C = 0; _C &lt; elts.length; ++_C) {&#13;
			var elt = elts[_C];&#13;
			if (opts.display &amp;&amp; is_dom_element_hidden(elt)) continue;&#13;
			var v = elt.hasAttribute('data-v') ? elt.getAttribute('data-v') : elt.hasAttribute('v') ? elt.getAttribute('v') : htmldecode(elt.innerHTML);&#13;
			var z = elt.getAttribute('data-z') || elt.getAttribute('z');&#13;
			for(midx = 0; midx &lt; merges.length; ++midx) {&#13;
				var m = merges[midx];&#13;
				if(m.s.c == C + or_C &amp;&amp; m.s.r &lt; R + or_R &amp;&amp; R + or_R &lt;= m.e.r) { C = m.e.c+1 - or_C; midx = -1; }&#13;
			}&#13;
			/* TODO: figure out how to extract nonstandard mso- style */&#13;
			CS = +elt.getAttribute("colspan") || 1;&#13;
			if( ((RS = (+elt.getAttribute("rowspan") || 1)))&gt;1 || CS&gt;1) merges.push({s:{r:R + or_R,c:C + or_C},e:{r:R + or_R + (RS||1) - 1, c:C + or_C + (CS||1) - 1}});&#13;
			var o = {t:'s', v:v};&#13;
			var _t = elt.getAttribute("data-t") || elt.getAttribute("t") || "";&#13;
			if(v != null) {&#13;
				if(v.length == 0) o.t = _t || 'z';&#13;
				else if(opts.raw || v.trim().length == 0 || _t == "s"){}&#13;
				else if(v === 'TRUE') o = {t:'b', v:true};&#13;
				else if(v === 'FALSE') o = {t:'b', v:false};&#13;
				else if(!isNaN(fuzzynum(v))) o = {t:'n', v:fuzzynum(v)};&#13;
				else if(!isNaN(fuzzydate(v).getDate())) {&#13;
					o = ({t:'d', v:parseDate(v)});&#13;
					if(!opts.cellDates) o = ({t:'n', v:datenum(o.v)});&#13;
					o.z = opts.dateNF || table_fmt[14];&#13;
				}&#13;
			}&#13;
			if(o.z === undefined &amp;&amp; z != null) o.z = z;&#13;
			/* The first link is used.  Links are assumed to be fully specified.&#13;
			 * TODO: The right way to process relative links is to make a new &lt;a&gt; */&#13;
			var l = "", Aelts = elt.getElementsByTagName("A");&#13;
			if(Aelts &amp;&amp; Aelts.length) for(var Aelti = 0; Aelti &lt; Aelts.length; ++Aelti)	if(Aelts[Aelti].hasAttribute("href")) {&#13;
				l = Aelts[Aelti].getAttribute("href"); if(l.charAt(0) != "#") break;&#13;
			}&#13;
			if(l &amp;&amp; l.charAt(0) != "#" &amp;&amp;	l.slice(0, 11).toLowerCase() != 'javascript:') o.l = ({ Target: l });&#13;
			if(opts.dense) { if(!ws[R + or_R]) ws[R + or_R] = []; ws[R + or_R][C + or_C] = o; }&#13;
			else ws[encode_cell({c:C + or_C, r:R + or_R})] = o;&#13;
			if(range.e.c &lt; C + or_C) range.e.c = C + or_C;&#13;
			C += CS;&#13;
		}&#13;
		++R;&#13;
	}&#13;
	if(merges.length) ws['!merges'] = (ws["!merges"] || []).concat(merges);&#13;
	range.e.r = Math.max(range.e.r, R - 1 + or_R);&#13;
	ws['!ref'] = encode_range(range);&#13;
	if(R &gt;= sheetRows) ws['!fullref'] = encode_range((range.e.r = rows.length-_R+R-1 + or_R,range)); // We can count the real number of rows to parse but we don't to improve the performance&#13;
	return ws;&#13;
}&#13;
&#13;
function parse_dom_table(table, _opts) {&#13;
	var opts = _opts || {};&#13;
	var ws = opts.dense ? ([]) : ({});&#13;
	return sheet_add_dom(ws, table, _opts);&#13;
}&#13;
&#13;
function table_to_book(table, opts) {&#13;
	var o = sheet_to_workbook(parse_dom_table(table, opts), opts);&#13;
	//o.bookType = "dom"; // TODO: define a type for this&#13;
	return o;&#13;
}&#13;
&#13;
function is_dom_element_hidden(element) {&#13;
	var display = '';&#13;
	var get_computed_style = get_get_computed_style_function(element);&#13;
	if(get_computed_style) display = get_computed_style(element).getPropertyValue('display');&#13;
	if(!display) display = element.style &amp;&amp; element.style.display;&#13;
	return display === 'none';&#13;
}&#13;
&#13;
/* global getComputedStyle */&#13;
function get_get_computed_style_function(element) {&#13;
	// The proper getComputedStyle implementation is the one defined in the element window&#13;
	if(element.ownerDocument.defaultView &amp;&amp; typeof element.ownerDocument.defaultView.getComputedStyle === 'function') return element.ownerDocument.defaultView.getComputedStyle;&#13;
	// If it is not available, try to get one from the global namespace&#13;
	if(typeof getComputedStyle === 'function') return getComputedStyle;&#13;
	return null;&#13;
}&#13;
/* OpenDocument */&#13;
function parse_text_p(text) {&#13;
	/* 6.1.2 White Space Characters */&#13;
	var fixed = text&#13;
		.replace(/[\t\r\n]/g, " ").trim().replace(/ +/g, " ")&#13;
		.replace(/&lt;text:s\/&gt;/g," ")&#13;
		.replace(/&lt;text:s text:c="(\d+)"\/&gt;/g, function($$,$1) { return Array(parseInt($1,10)+1).join(" "); })&#13;
		.replace(/&lt;text:tab[^&gt;]*\/&gt;/g,"\t")&#13;
		.replace(/&lt;text:line-break\/&gt;/g,"\n");&#13;
	var v = unescapexml(fixed.replace(/&lt;[^&gt;]*&gt;/g,""));&#13;
&#13;
	return [v];&#13;
}&#13;
&#13;
/* Note: ODS can stick styles in content.xml or styles.xml, FODS blurs lines */&#13;
function parse_ods_styles(d, _opts, _nfm) {&#13;
	var number_format_map = _nfm || {};&#13;
	var str = xlml_normalize(d);&#13;
	xlmlregex.lastIndex = 0;&#13;
	str = str.replace(/&lt;!--([\s\S]*?)--&gt;/mg,"").replace(/&lt;!DOCTYPE[^\[]*\[[^\]]*\]&gt;/gm,"");&#13;
	var Rn, NFtag, NF = "", tNF = "", y, etpos = 0, tidx = -1, infmt = false, payload = "";&#13;
	while((Rn = xlmlregex.exec(str))) {&#13;
		switch((Rn[3]=Rn[3].replace(/_.*$/,""))) {&#13;
		/* Number Format Definitions */&#13;
		case 'number-style': // &lt;number:number-style&gt; 16.29.2&#13;
		case 'currency-style': // &lt;number:currency-style&gt; 16.29.8&#13;
		case 'percentage-style': // &lt;number:percentage-style&gt; 16.29.10&#13;
		case 'date-style': // &lt;number:date-style&gt; 16.29.11&#13;
		case 'time-style': // &lt;number:time-style&gt; 16.29.19&#13;
		case 'text-style': // &lt;number:text-style&gt; 16.29.26&#13;
			if(Rn[1]==='/') {&#13;
				infmt = false;&#13;
				if(NFtag['truncate-on-overflow'] == "false") {&#13;
					if(NF.match(/h/)) NF = NF.replace(/h+/, "[$&amp;]");&#13;
					else if(NF.match(/m/)) NF = NF.replace(/m+/, "[$&amp;]");&#13;
					else if(NF.match(/s/)) NF = NF.replace(/s+/, "[$&amp;]");&#13;
				}&#13;
				number_format_map[NFtag.name] = NF;&#13;
				NF = "";&#13;
			} else if(Rn[0].charAt(Rn[0].length-2) !== '/') {&#13;
				infmt = true;&#13;
				NF = "";&#13;
				NFtag = parsexmltag(Rn[0], false);&#13;
			} break;&#13;
&#13;
		// LibreOffice bug https://bugs.documentfoundation.org/show_bug.cgi?id=149484&#13;
		case 'boolean-style': // &lt;number:boolean-style&gt; 16.29.24&#13;
			if(Rn[1]==='/') {&#13;
				infmt = false;&#13;
				number_format_map[NFtag.name] = "General";&#13;
				NF = "";&#13;
			} else if(Rn[0].charAt(Rn[0].length-2) !== '/') {&#13;
				infmt = true;&#13;
				NF = "";&#13;
				NFtag = parsexmltag(Rn[0], false);&#13;
			} break;&#13;
&#13;
		/* Number Format Elements */&#13;
		case 'boolean': // &lt;number:boolean&gt; 16.29.25&#13;
			NF += "General"; // ODF spec is unfortunately underspecified here&#13;
			break;&#13;
&#13;
		case 'text': // &lt;number:text&gt; 16.29.27&#13;
			if(Rn[1]==='/') {&#13;
				payload = str.slice(tidx, xlmlregex.lastIndex - Rn[0].length);&#13;
				// NOTE: Excel has a different interpretation of "%%" and friends&#13;
				if(payload == "%" &amp;&amp; NFtag[0] == '&lt;number:percentage-style') NF += "%";&#13;
				else NF += '"' + payload.replace(/"/g, '""') + '"';&#13;
			} else if(Rn[0].charAt(Rn[0].length-2) !== '/') {&#13;
				tidx = xlmlregex.lastIndex;&#13;
			} break;&#13;
&#13;
&#13;
		case 'day': { // &lt;number:day&gt; 16.29.12&#13;
			y = parsexmltag(Rn[0], false);&#13;
			switch(y["style"]) {&#13;
				case "short": NF += "d"; break;&#13;
				case "long": NF += "dd"; break;&#13;
				default: NF += "dd"; break; // TODO: error condition&#13;
			}&#13;
		} break;&#13;
&#13;
		case 'day-of-week': { // &lt;number:day-of-week&gt; 16.29.16&#13;
			y = parsexmltag(Rn[0], false);&#13;
			switch(y["style"]) {&#13;
				case "short": NF += "ddd"; break;&#13;
				case "long": NF += "dddd"; break;&#13;
				default: NF += "ddd"; break;&#13;
			}&#13;
		} break;&#13;
&#13;
		case 'era': { // &lt;number:era&gt; 16.29.15 TODO: proper mapping&#13;
			y = parsexmltag(Rn[0], false);&#13;
			switch(y["style"]) {&#13;
				case "short": NF += "ee"; break;&#13;
				case "long": NF += "eeee"; break;&#13;
				default: NF += "eeee"; break; // TODO: error condition&#13;
			}&#13;
		} break;&#13;
&#13;
		case 'hours': { // &lt;number:hours&gt; 16.29.20&#13;
			y = parsexmltag(Rn[0], false);&#13;
			switch(y["style"]) {&#13;
				case "short": NF += "h"; break;&#13;
				case "long": NF += "hh"; break;&#13;
				default: NF += "hh"; break; // TODO: error condition&#13;
			}&#13;
		} break;&#13;
&#13;
		case 'minutes': { // &lt;number:minutes&gt; 16.29.21&#13;
			y = parsexmltag(Rn[0], false);&#13;
			switch(y["style"]) {&#13;
				case "short": NF += "m"; break;&#13;
				case "long": NF += "mm"; break;&#13;
				default: NF += "mm"; break; // TODO: error condition&#13;
			}&#13;
		} break;&#13;
&#13;
		case 'month': { // &lt;number:month&gt; 16.29.13&#13;
			y = parsexmltag(Rn[0], false);&#13;
			if(y["textual"]) NF += "mm";&#13;
			switch(y["style"]) {&#13;
				case "short": NF += "m"; break;&#13;
				case "long": NF += "mm"; break;&#13;
				default: NF += "m"; break;&#13;
			}&#13;
		} break;&#13;
&#13;
		case 'seconds': { // &lt;number:seconds&gt; 16.29.22&#13;
			y = parsexmltag(Rn[0], false);&#13;
			switch(y["style"]) {&#13;
				case "short": NF += "s"; break;&#13;
				case "long": NF += "ss"; break;&#13;
				default: NF += "ss"; break; // TODO: error condition&#13;
			}&#13;
			if(y["decimal-places"]) NF += "." + fill("0", +y["decimal-places"]);&#13;
		} break;&#13;
&#13;
		case 'year': { // &lt;number:year&gt; 16.29.14&#13;
			y = parsexmltag(Rn[0], false);&#13;
			switch(y["style"]) {&#13;
				case "short": NF += "yy"; break;&#13;
				case "long": NF += "yyyy"; break;&#13;
				default: NF += "yy"; break; // TODO: error condition&#13;
			}&#13;
		} break;&#13;
&#13;
		case 'am-pm': // &lt;number:am-pm&gt; 16.29.23&#13;
			NF += "AM/PM"; // LO autocorrects A/P -&gt; AM/PM&#13;
			break;&#13;
&#13;
		case 'week-of-year': // &lt;number:week-of-year&gt; 16.29.17&#13;
		case 'quarter': // &lt;number:quarter&gt; 16.29.18&#13;
			console.error("Excel does not support ODS format token " + Rn[3]);&#13;
			break;&#13;
&#13;
		case 'fill-character': // &lt;number:fill-character&gt; 16.29.5&#13;
			if(Rn[1]==='/') {&#13;
				payload = str.slice(tidx, xlmlregex.lastIndex - Rn[0].length);&#13;
				// NOTE: Excel has a different interpretation of "%%" and friends&#13;
				NF += '"' + payload.replace(/"/g, '""') + '"*';&#13;
			} else if(Rn[0].charAt(Rn[0].length-2) !== '/') {&#13;
				tidx = xlmlregex.lastIndex;&#13;
			} break;&#13;
&#13;
		case 'scientific-number': // &lt;number:scientific-number&gt; 16.29.6&#13;
			// TODO: find a mapping for all parameters&#13;
			y = parsexmltag(Rn[0], false);&#13;
			NF += "0." + fill("0", +y["min-decimal-places"] || +y["decimal-places"] || 2) + fill("?", +y["decimal-places"] - +y["min-decimal-places"] || 0) + "E" + (parsexmlbool(y["forced-exponent-sign"]) ? "+" : "") + fill("0", +y["min-exponent-digits"] || 2);&#13;
			break;&#13;
&#13;
		case 'fraction': // &lt;number:fraction&gt; 16.29.7&#13;
			// TODO: find a mapping for all parameters&#13;
			y = parsexmltag(Rn[0], false);&#13;
			if(!+y["min-integer-digits"]) NF += "#";&#13;
			else NF += fill("0", +y["min-integer-digits"]);&#13;
			NF += " ";&#13;
			NF += fill("?", +y["min-numerator-digits"] || 1);&#13;
			NF += "/";&#13;
			if(+y["denominator-value"]) NF += y["denominator-value"];&#13;
			else NF += fill("?", +y["min-denominator-digits"] || 1);&#13;
			break;&#13;
&#13;
		case 'currency-symbol': // &lt;number:currency-symbol&gt; 16.29.9&#13;
			// TODO: localization with [$-...]&#13;
			if(Rn[1]==='/') {&#13;
				NF += '"' + str.slice(tidx, xlmlregex.lastIndex - Rn[0].length).replace(/"/g, '""') + '"';&#13;
			} else if(Rn[0].charAt(Rn[0].length-2) !== '/') {&#13;
				tidx = xlmlregex.lastIndex;&#13;
			} else NF += "$";&#13;
			break;&#13;
&#13;
		case 'text-properties': // &lt;style:text-properties&gt; 16.29.29&#13;
			y = parsexmltag(Rn[0], false);&#13;
			switch((y["color"]||"").toLowerCase().replace("#", "")) {&#13;
				case "ff0000": case "red": NF = "[Red]" + NF; break;&#13;
			}&#13;
			break;&#13;
&#13;
		case 'text-content': // &lt;number:text-content&gt; 16.29.28&#13;
			NF += "@";&#13;
			break;&#13;
&#13;
		case 'map': // &lt;style:map&gt; 16.3&#13;
			// TODO: handle more complex maps&#13;
			y = parsexmltag(Rn[0], false);&#13;
			if(unescapexml(y["condition"]) == "value()&gt;=0") NF = number_format_map[y["apply-style-name"]] + ";" + NF;&#13;
			else console.error("ODS number format may be incorrect: " + y["condition"]);&#13;
			break;&#13;
&#13;
		case 'number': // &lt;number:number&gt; 16.29.3&#13;
			// TODO: handle all the attributes&#13;
			if(Rn[1]==='/') break;&#13;
			y = parsexmltag(Rn[0], false);&#13;
			tNF = "";&#13;
			tNF += fill("0", +y["min-integer-digits"] || 1);&#13;
			if(parsexmlbool(y["grouping"])) tNF = commaify(fill("#", Math.max(0, 4 - tNF.length)) + tNF);&#13;
			if(+y["min-decimal-places"] || +y["decimal-places"]) tNF += ".";&#13;
			if(+y["min-decimal-places"]) tNF += fill("0", +y["min-decimal-places"] || 1);&#13;
			if(+y["decimal-places"] - (+y["min-decimal-places"]||0)) tNF += fill("0", +y["decimal-places"] - (+y["min-decimal-places"]||0)); // TODO: should this be "#" ?&#13;
			NF += tNF;&#13;
			break;&#13;
&#13;
		case 'embedded-text': // &lt;number:embedded-text&gt; 16.29.4&#13;
			// TODO: verify interplay with grouping et al&#13;
			if(Rn[1]==='/') {&#13;
				if(etpos == 0) NF += '"' + str.slice(tidx, xlmlregex.lastIndex - Rn[0].length).replace(/"/g, '""') + '"';&#13;
				else NF = NF.slice(0, etpos) + '"' + str.slice(tidx, xlmlregex.lastIndex - Rn[0].length).replace(/"/g, '""') + '"' + NF.slice(etpos);&#13;
			} else if(Rn[0].charAt(Rn[0].length-2) !== '/') {&#13;
				tidx = xlmlregex.lastIndex;&#13;
				etpos = -+parsexmltag(Rn[0], false)["position"] || 0;&#13;
			} break;&#13;
&#13;
	}}&#13;
	return number_format_map;&#13;
}&#13;
&#13;
function parse_content_xml(d, _opts, _nfm) {&#13;
		var opts = _opts || {};&#13;
		if(DENSE != null &amp;&amp; opts.dense == null) opts.dense = DENSE;&#13;
		var str = xlml_normalize(d);&#13;
		var state = [], tmp;&#13;
		var tag;&#13;
		var nfidx, NF = "", pidx = 0;&#13;
		var sheetag;&#13;
		var rowtag;&#13;
		var Sheets = {}, SheetNames = [];&#13;
		var ws = opts.dense ? ([]) : ({});&#13;
		var Rn, q;&#13;
		var ctag = ({value:""});&#13;
		var textp = "", textpidx = 0, textptag;&#13;
		var textR = [];&#13;
		var R = -1, C = -1, range = {s: {r:1000000,c:10000000}, e: {r:0, c:0}};&#13;
		var row_ol = 0;&#13;
		var number_format_map = _nfm || {}, styles = {};&#13;
		var merges = [], mrange = {}, mR = 0, mC = 0;&#13;
		var rowinfo = [], rowpeat = 1, colpeat = 1;&#13;
		var arrayf = [];&#13;
		var WB = {Names:[], WBProps:{}};&#13;
		var atag = ({});&#13;
		var _Ref = ["", ""];&#13;
		var comments = [], comment = ({});&#13;
		var creator = "", creatoridx = 0;&#13;
		var isstub = false, intable = false;&#13;
		var i = 0;&#13;
		var baddate = 0;&#13;
		xlmlregex.lastIndex = 0;&#13;
		str = str.replace(/&lt;!--([\s\S]*?)--&gt;/mg,"").replace(/&lt;!DOCTYPE[^\[]*\[[^\]]*\]&gt;/gm,"");&#13;
		while((Rn = xlmlregex.exec(str))) switch((Rn[3]=Rn[3].replace(/_.*$/,""))) {&#13;
&#13;
			case 'table': case '工作表': // 9.1.2 &lt;table:table&gt;&#13;
				if(Rn[1]==='/') {&#13;
					if(range.e.c &gt;= range.s.c &amp;&amp; range.e.r &gt;= range.s.r) ws['!ref'] = encode_range(range);&#13;
					else ws['!ref'] = "A1:A1";&#13;
					if(opts.sheetRows &gt; 0 &amp;&amp; opts.sheetRows &lt;= range.e.r) {&#13;
						ws['!fullref'] = ws['!ref'];&#13;
						range.e.r = opts.sheetRows - 1;&#13;
						ws['!ref'] = encode_range(range);&#13;
					}&#13;
					if(merges.length) ws['!merges'] = merges;&#13;
					if(rowinfo.length) ws["!rows"] = rowinfo;&#13;
					sheetag.name = sheetag['名称'] || sheetag.name;&#13;
					if(typeof JSON !== 'undefined') JSON.stringify(sheetag);&#13;
					SheetNames.push(sheetag.name);&#13;
					Sheets[sheetag.name] = ws;&#13;
					intable = false;&#13;
				}&#13;
				else if(Rn[0].charAt(Rn[0].length-2) !== '/') {&#13;
					sheetag = parsexmltag(Rn[0], false);&#13;
					R = C = -1;&#13;
					range.s.r = range.s.c = 10000000; range.e.r = range.e.c = 0;&#13;
					ws = opts.dense ? ([]) : ({}); merges = [];&#13;
					rowinfo = [];&#13;
					intable = true;&#13;
				}&#13;
				break;&#13;
&#13;
			case 'table-row-group': // 9.1.9 &lt;table:table-row-group&gt;&#13;
				if(Rn[1] === "/") --row_ol; else ++row_ol;&#13;
				break;&#13;
			case 'table-row': case '行': // 9.1.3 &lt;table:table-row&gt;&#13;
				if(Rn[1] === '/') { R+=rowpeat; rowpeat = 1; break; }&#13;
				rowtag = parsexmltag(Rn[0], false);&#13;
				if(rowtag['行号']) R = rowtag['行号'] - 1; else if(R == -1) R = 0;&#13;
				rowpeat = +rowtag['number-rows-repeated'] || 1;&#13;
				/* TODO: remove magic */&#13;
				if(rowpeat &lt; 10) for(i = 0; i &lt; rowpeat; ++i) if(row_ol &gt; 0) rowinfo[R + i] = {level: row_ol};&#13;
				C = -1; break;&#13;
			case 'covered-table-cell': // 9.1.5 &lt;table:covered-table-cell&gt;&#13;
				if(Rn[1] !== '/') ++C;&#13;
				if(opts.sheetStubs) {&#13;
					if(opts.dense) { if(!ws[R]) ws[R] = []; ws[R][C] = {t:'z'}; }&#13;
					else ws[encode_cell({r:R,c:C})] = {t:'z'};&#13;
				}&#13;
				textp = ""; textR = [];&#13;
				break; /* stub */&#13;
			case 'table-cell': case '数据':&#13;
				if(Rn[0].charAt(Rn[0].length-2) === '/') {&#13;
					++C;&#13;
					ctag = parsexmltag(Rn[0], false);&#13;
					colpeat = parseInt(ctag['number-columns-repeated']||"1", 10);&#13;
					q = ({t:'z', v:null});&#13;
					if(ctag.formula &amp;&amp; opts.cellFormula != false) q.f = ods_to_csf_formula(unescapexml(ctag.formula));&#13;
					if(ctag["style-name"] &amp;&amp; styles[ctag["style-name"]]) q.z = styles[ctag["style-name"]];&#13;
					if((ctag['数据类型'] || ctag['value-type']) == "string") {&#13;
						q.t = "s"; q.v = unescapexml(ctag['string-value'] || "");&#13;
						if(opts.dense) {&#13;
							if(!ws[R]) ws[R] = [];&#13;
							ws[R][C] = q;&#13;
						} else {&#13;
							ws[encode_cell({r:R,c:C})] = q;&#13;
						}&#13;
					}&#13;
					C+= colpeat-1;&#13;
				} else if(Rn[1]!=='/') {&#13;
					++C;&#13;
					textp = ""; textpidx = 0; textR = [];&#13;
					colpeat = 1;&#13;
					var rptR = rowpeat ? R + rowpeat - 1 : R;&#13;
					if(C &gt; range.e.c) range.e.c = C;&#13;
					if(C &lt; range.s.c) range.s.c = C;&#13;
					if(R &lt; range.s.r) range.s.r = R;&#13;
					if(rptR &gt; range.e.r) range.e.r = rptR;&#13;
					ctag = parsexmltag(Rn[0], false);&#13;
					comments = []; comment = ({});&#13;
					q = ({t:ctag['数据类型'] || ctag['value-type'], v:null});&#13;
					if(ctag["style-name"] &amp;&amp; styles[ctag["style-name"]]) q.z = styles[ctag["style-name"]];&#13;
					if(opts.cellFormula) {&#13;
						if(ctag.formula) ctag.formula = unescapexml(ctag.formula);&#13;
						if(ctag['number-matrix-columns-spanned'] &amp;&amp; ctag['number-matrix-rows-spanned']) {&#13;
							mR = parseInt(ctag['number-matrix-rows-spanned'],10) || 0;&#13;
							mC = parseInt(ctag['number-matrix-columns-spanned'],10) || 0;&#13;
							mrange = {s: {r:R,c:C}, e:{r:R + mR-1,c:C + mC-1}};&#13;
							q.F = encode_range(mrange);&#13;
							arrayf.push([mrange, q.F]);&#13;
						}&#13;
						if(ctag.formula) q.f = ods_to_csf_formula(ctag.formula);&#13;
						else for(i = 0; i &lt; arrayf.length; ++i)&#13;
							if(R &gt;= arrayf[i][0].s.r &amp;&amp; R &lt;= arrayf[i][0].e.r)&#13;
								if(C &gt;= arrayf[i][0].s.c &amp;&amp; C &lt;= arrayf[i][0].e.c)&#13;
									q.F = arrayf[i][1];&#13;
					}&#13;
					if(ctag['number-columns-spanned'] || ctag['number-rows-spanned']) {&#13;
						mR = parseInt(ctag['number-rows-spanned'],10) || 0;&#13;
						mC = parseInt(ctag['number-columns-spanned'],10) || 0;&#13;
						mrange = {s: {r:R,c:C}, e:{r:R + mR-1,c:C + mC-1}};&#13;
						merges.push(mrange);&#13;
					}&#13;
&#13;
					/* 19.675.2 table:number-columns-repeated */&#13;
					if(ctag['number-columns-repeated']) colpeat = parseInt(ctag['number-columns-repeated'], 10);&#13;
&#13;
					/* 19.385 office:value-type */&#13;
					switch(q.t) {&#13;
						case 'boolean': q.t = 'b'; q.v = parsexmlbool(ctag['boolean-value']) || (+ctag['boolean-value'] &gt;= 1); break;&#13;
						case 'float': q.t = 'n'; q.v = parseFloat(ctag.value); break;&#13;
						case 'percentage': q.t = 'n'; q.v = parseFloat(ctag.value); break;&#13;
						case 'currency': q.t = 'n'; q.v = parseFloat(ctag.value); break;&#13;
						case 'date': q.t = 'd'; q.v = parseDate(ctag['date-value']);&#13;
							if(!opts.cellDates) { q.t = 'n'; q.v = datenum(q.v, WB.WBProps.date1904) - baddate; }&#13;
							if(!q.z) q.z = 'm/d/yy'; break;&#13;
						case 'time': q.t = 'n'; q.v = parse_isodur(ctag['time-value'])/86400;&#13;
							if(opts.cellDates) { q.t = 'd'; q.v = numdate(q.v); }&#13;
							if(!q.z) q.z = 'HH:MM:SS'; break;&#13;
						case 'number': q.t = 'n'; q.v = parseFloat(ctag['数据数值']); break;&#13;
						default:&#13;
							if(q.t === 'string' || q.t === 'text' || !q.t) {&#13;
								q.t = 's';&#13;
								if(ctag['string-value'] != null) { textp = unescapexml(ctag['string-value']); textR = []; }&#13;
							} else throw new Error('Unsupported value type ' + q.t);&#13;
					}&#13;
				} else {&#13;
					isstub = false;&#13;
					if(q.t === 's') {&#13;
						q.v = textp || '';&#13;
						if(textR.length) q.R = textR;&#13;
						isstub = textpidx == 0;&#13;
					}&#13;
					if(atag.Target) q.l = atag;&#13;
					if(comments.length &gt; 0) { q.c = comments; comments = []; }&#13;
					if(textp &amp;&amp; opts.cellText !== false) q.w = textp;&#13;
					if(isstub) { q.t = "z"; delete q.v; }&#13;
					if(!isstub || opts.sheetStubs) {&#13;
						if(!(opts.sheetRows &amp;&amp; opts.sheetRows &lt;= R)) {&#13;
							for(var rpt = 0; rpt &lt; rowpeat; ++rpt) {&#13;
								colpeat = parseInt(ctag['number-columns-repeated']||"1", 10);&#13;
								if(opts.dense) {&#13;
									if(!ws[R + rpt]) ws[R + rpt] = [];&#13;
									ws[R + rpt][C] = rpt == 0 ? q : dup(q);&#13;
									while(--colpeat &gt; 0) ws[R + rpt][C + colpeat] = dup(q);&#13;
								} else {&#13;
									ws[encode_cell({r:R + rpt,c:C})] = q;&#13;
									while(--colpeat &gt; 0) ws[encode_cell({r:R + rpt,c:C + colpeat})] = dup(q);&#13;
								}&#13;
								if(range.e.c &lt;= C) range.e.c = C;&#13;
							}&#13;
						}&#13;
					}&#13;
					colpeat = parseInt(ctag['number-columns-repeated']||"1", 10);&#13;
					C += colpeat-1; colpeat = 0;&#13;
					q = {};&#13;
					textp = ""; textR = [];&#13;
				}&#13;
				atag = ({});&#13;
				break; // 9.1.4 &lt;table:table-cell&gt;&#13;
&#13;
			/* pure state */&#13;
			case 'document': // TODO: &lt;office:document&gt; is the root for FODS&#13;
			case 'document-content': case '电子表格文档': // 3.1.3.2 &lt;office:document-content&gt;&#13;
			case 'spreadsheet': case '主体': // 3.7 &lt;office:spreadsheet&gt;&#13;
			case 'scripts': // 3.12 &lt;office:scripts&gt;&#13;
			case 'styles': // TODO &lt;office:styles&gt;&#13;
			case 'font-face-decls': // 3.14 &lt;office:font-face-decls&gt;&#13;
			case 'master-styles': // 3.15.4 &lt;office:master-styles&gt; -- relevant for FODS&#13;
				if(Rn[1]==='/'){if((tmp=state.pop())[0]!==Rn[3]) throw "Bad state: "+tmp;}&#13;
				else if(Rn[0].charAt(Rn[0].length-2) !== '/') state.push([Rn[3], true]);&#13;
				break;&#13;
&#13;
			case 'annotation': // 14.1 &lt;office:annotation&gt;&#13;
				if(Rn[1]==='/'){&#13;
					if((tmp=state.pop())[0]!==Rn[3]) throw "Bad state: "+tmp;&#13;
					comment.t = textp;&#13;
					if(textR.length) comment.R = textR;&#13;
					comment.a = creator;&#13;
					comments.push(comment);&#13;
				}&#13;
				else if(Rn[0].charAt(Rn[0].length-2) !== '/') {state.push([Rn[3], false]);}&#13;
				creator = ""; creatoridx = 0;&#13;
				textp = ""; textpidx = 0; textR = [];&#13;
				break;&#13;
&#13;
			case 'creator': // 4.3.2.7 &lt;dc:creator&gt;&#13;
				if(Rn[1]==='/') { creator = str.slice(creatoridx,Rn.index); }&#13;
				else creatoridx = Rn.index + Rn[0].length;&#13;
				break;&#13;
&#13;
			/* ignore state */&#13;
			case 'meta': case '元数据': // TODO: &lt;office:meta&gt; &lt;uof:元数据&gt; FODS/UOF&#13;
			case 'settings': // TODO: &lt;office:settings&gt;&#13;
			case 'config-item-set': // TODO: &lt;office:config-item-set&gt;&#13;
			case 'config-item-map-indexed': // TODO: &lt;office:config-item-map-indexed&gt;&#13;
			case 'config-item-map-entry': // TODO: &lt;office:config-item-map-entry&gt;&#13;
			case 'config-item-map-named': // TODO: &lt;office:config-item-map-entry&gt;&#13;
			case 'shapes': // 9.2.8 &lt;table:shapes&gt;&#13;
			case 'frame': // 10.4.2 &lt;draw:frame&gt;&#13;
			case 'text-box': // 10.4.3 &lt;draw:text-box&gt;&#13;
			case 'image': // 10.4.4 &lt;draw:image&gt;&#13;
			case 'data-pilot-tables': // 9.6.2 &lt;table:data-pilot-tables&gt;&#13;
			case 'list-style': // 16.30 &lt;text:list-style&gt;&#13;
			case 'form': // 13.13 &lt;form:form&gt;&#13;
			case 'dde-links': // 9.8 &lt;table:dde-links&gt;&#13;
			case 'event-listeners': // TODO&#13;
			case 'chart': // TODO&#13;
				if(Rn[1]==='/'){if((tmp=state.pop())[0]!==Rn[3]) throw "Bad state: "+tmp;}&#13;
				else if(Rn[0].charAt(Rn[0].length-2) !== '/') state.push([Rn[3], false]);&#13;
				textp = ""; textpidx = 0; textR = [];&#13;
				break;&#13;
&#13;
			case 'scientific-number': // &lt;number:scientific-number&gt;&#13;
			case 'currency-symbol': // &lt;number:currency-symbol&gt;&#13;
			case 'fill-character': // 16.29.5 &lt;number:fill-character&gt;&#13;
				break;&#13;
&#13;
			case 'text-style': // 16.27.25 &lt;number:text-style&gt;&#13;
			case 'boolean-style': // 16.27.23 &lt;number:boolean-style&gt;&#13;
			case 'number-style': // 16.27.2 &lt;number:number-style&gt;&#13;
			case 'currency-style': // 16.29.8 &lt;number:currency-style&gt;&#13;
			case 'percentage-style': // 16.27.9 &lt;number:percentage-style&gt;&#13;
			case 'date-style': // 16.27.10 &lt;number:date-style&gt;&#13;
			case 'time-style': // 16.27.18 &lt;number:time-style&gt;&#13;
				if(Rn[1]==='/'){&#13;
					var xlmlidx = xlmlregex.lastIndex;&#13;
					parse_ods_styles(str.slice(nfidx, xlmlregex.lastIndex), _opts, number_format_map);&#13;
					xlmlregex.lastIndex = xlmlidx;&#13;
				} else if(Rn[0].charAt(Rn[0].length-2) !== '/') {&#13;
					nfidx = xlmlregex.lastIndex - Rn[0].length;&#13;
				} break;&#13;
&#13;
			case 'script': break; // 3.13 &lt;office:script&gt;&#13;
			case 'libraries': break; // TODO: &lt;ooo:libraries&gt;&#13;
			case 'automatic-styles': break; // 3.15.3 &lt;office:automatic-styles&gt;&#13;
&#13;
			case 'default-style': // TODO: &lt;style:default-style&gt;&#13;
			case 'page-layout': break; // TODO: &lt;style:page-layout&gt;&#13;
			case 'style': { // 16.2 &lt;style:style&gt;&#13;
				var styletag = parsexmltag(Rn[0], false);&#13;
				if(styletag["family"] == "table-cell" &amp;&amp; number_format_map[styletag["data-style-name"]]) styles[styletag["name"]] = number_format_map[styletag["data-style-name"]];&#13;
			} break;&#13;
			case 'map': break; // 16.3 &lt;style:map&gt;&#13;
			case 'font-face': break; // 16.21 &lt;style:font-face&gt;&#13;
&#13;
			case 'paragraph-properties': break; // 17.6 &lt;style:paragraph-properties&gt;&#13;
			case 'table-properties': break; // 17.15 &lt;style:table-properties&gt;&#13;
			case 'table-column-properties': break; // 17.16 &lt;style:table-column-properties&gt;&#13;
			case 'table-row-properties': break; // 17.17 &lt;style:table-row-properties&gt;&#13;
			case 'table-cell-properties': break; // 17.18 &lt;style:table-cell-properties&gt;&#13;
&#13;
			case 'number': // 16.27.3 &lt;number:number&gt;&#13;
				break;&#13;
&#13;
			case 'fraction': break; // TODO 16.27.6 &lt;number:fraction&gt;&#13;
&#13;
			case 'day': // 16.27.11 &lt;number:day&gt;&#13;
			case 'month': // 16.27.12 &lt;number:month&gt;&#13;
			case 'year': // 16.27.13 &lt;number:year&gt;&#13;
			case 'era': // 16.27.14 &lt;number:era&gt;&#13;
			case 'day-of-week': // 16.27.15 &lt;number:day-of-week&gt;&#13;
			case 'week-of-year': // 16.27.16 &lt;number:week-of-year&gt;&#13;
			case 'quarter': // 16.27.17 &lt;number:quarter&gt;&#13;
			case 'hours': // 16.27.19 &lt;number:hours&gt;&#13;
			case 'minutes': // 16.27.20 &lt;number:minutes&gt;&#13;
			case 'seconds': // 16.27.21 &lt;number:seconds&gt;&#13;
			case 'am-pm': // 16.27.22 &lt;number:am-pm&gt;&#13;
				break;&#13;
&#13;
			case 'boolean': break; // 16.27.24 &lt;number:boolean&gt;&#13;
			case 'text': // 16.27.26 &lt;number:text&gt;&#13;
				if(Rn[0].slice(-2) === "/&gt;") break;&#13;
				else if(Rn[1]==="/") switch(state[state.length-1][0]) {&#13;
					case 'number-style':&#13;
					case 'date-style':&#13;
					case 'time-style':&#13;
						NF += str.slice(pidx, Rn.index);&#13;
						break;&#13;
				}&#13;
				else pidx = Rn.index + Rn[0].length;&#13;
				break;&#13;
&#13;
			case 'named-range': // 9.4.12 &lt;table:named-range&gt;&#13;
				tag = parsexmltag(Rn[0], false);&#13;
				_Ref = ods_to_csf_3D(tag['cell-range-address']);&#13;
				var nrange = ({Name:tag.name, Ref:_Ref[0] + '!' + _Ref[1]});&#13;
				if(intable) nrange.Sheet = SheetNames.length;&#13;
				WB.Names.push(nrange);&#13;
				break;&#13;
&#13;
			case 'text-content': break; // 16.27.27 &lt;number:text-content&gt;&#13;
			case 'text-properties': break; // 16.27.27 &lt;style:text-properties&gt;&#13;
			case 'embedded-text': break; // 16.27.4 &lt;number:embedded-text&gt;&#13;
&#13;
			case 'body': case '电子表格': break; // 3.3 16.9.6 19.726.3&#13;
&#13;
			case 'forms': break; // 12.25.2 13.2&#13;
			case 'table-column': break; // 9.1.6 &lt;table:table-column&gt;&#13;
			case 'table-header-rows': break; // 9.1.7 &lt;table:table-header-rows&gt;&#13;
			case 'table-rows': break; // 9.1.12 &lt;table:table-rows&gt;&#13;
			/* TODO: outline levels */&#13;
			case 'table-column-group': break; // 9.1.10 &lt;table:table-column-group&gt;&#13;
			case 'table-header-columns': break; // 9.1.11 &lt;table:table-header-columns&gt;&#13;
			case 'table-columns': break; // 9.1.12 &lt;table:table-columns&gt;&#13;
&#13;
			case 'null-date': // 9.4.2 &lt;table:null-date&gt;&#13;
				tag = parsexmltag(Rn[0], false);&#13;
				switch(tag["date-value"]) {&#13;
					case "1904-01-01": WB.WBProps.date1904 = true;&#13;
					/* falls through */&#13;
					case "1900-01-01": baddate = 0;&#13;
				}&#13;
				break;&#13;
&#13;
			case 'graphic-properties': break; // 17.21 &lt;style:graphic-properties&gt;&#13;
			case 'calculation-settings': break; // 9.4.1 &lt;table:calculation-settings&gt;&#13;
			case 'named-expressions': break; // 9.4.11 &lt;table:named-expressions&gt;&#13;
			case 'label-range': break; // 9.4.9 &lt;table:label-range&gt;&#13;
			case 'label-ranges': break; // 9.4.10 &lt;table:label-ranges&gt;&#13;
			case 'named-expression': break; // 9.4.13 &lt;table:named-expression&gt;&#13;
			case 'sort': break; // 9.4.19 &lt;table:sort&gt;&#13;
			case 'sort-by': break; // 9.4.20 &lt;table:sort-by&gt;&#13;
			case 'sort-groups': break; // 9.4.22 &lt;table:sort-groups&gt;&#13;
&#13;
			case 'tab': break; // 6.1.4 &lt;text:tab&gt;&#13;
			case 'line-break': break; // 6.1.5 &lt;text:line-break&gt;&#13;
			case 'span': break; // 6.1.7 &lt;text:span&gt;&#13;
			case 'p': case '文本串': // 5.1.3 &lt;text:p&gt;&#13;
				if(['master-styles'].indexOf(state[state.length-1][0]) &gt; -1) break;&#13;
				if(Rn[1]==='/' &amp;&amp; (!ctag || !ctag['string-value'])) {&#13;
					var ptp = parse_text_p(str.slice(textpidx,Rn.index), textptag);&#13;
					textp = (textp.length &gt; 0 ? textp + "\n" : "") + ptp[0];&#13;
				} else { textptag = parsexmltag(Rn[0], false); textpidx = Rn.index + Rn[0].length; }&#13;
				break; // &lt;text:p&gt;&#13;
			case 's': break; // &lt;text:s&gt;&#13;
&#13;
			case 'database-range': // 9.4.15 &lt;table:database-range&gt;&#13;
				if(Rn[1]==='/') break;&#13;
				try {&#13;
					_Ref = ods_to_csf_3D(parsexmltag(Rn[0])['target-range-address']);&#13;
					Sheets[_Ref[0]]['!autofilter'] = { ref:_Ref[1] };&#13;
				} catch(e) {/* empty */}&#13;
				break;&#13;
&#13;
			case 'date': break; // &lt;*:date&gt;&#13;
&#13;
			case 'object': break; // 10.4.6.2 &lt;draw:object&gt;&#13;
			case 'title': case '标题': break; // &lt;*:title&gt; OR &lt;uof:标题&gt;&#13;
			case 'desc': break; // &lt;*:desc&gt;&#13;
			case 'binary-data': break; // 10.4.5 TODO: b64 blob&#13;
&#13;
			/* 9.2 Advanced Tables */&#13;
			case 'table-source': break; // 9.2.6&#13;
			case 'scenario': break; // 9.2.6&#13;
&#13;
			case 'iteration': break; // 9.4.3 &lt;table:iteration&gt;&#13;
			case 'content-validations': break; // 9.4.4 &lt;table:&#13;
			case 'content-validation': break; // 9.4.5 &lt;table:&#13;
			case 'help-message': break; // 9.4.6 &lt;table:&#13;
			case 'error-message': break; // 9.4.7 &lt;table:&#13;
			case 'database-ranges': break; // 9.4.14 &lt;table:database-ranges&gt;&#13;
			case 'filter': break; // 9.5.2 &lt;table:filter&gt;&#13;
			case 'filter-and': break; // 9.5.3 &lt;table:filter-and&gt;&#13;
			case 'filter-or': break; // 9.5.4 &lt;table:filter-or&gt;&#13;
			case 'filter-condition': break; // 9.5.5 &lt;table:filter-condition&gt;&#13;
&#13;
			case 'list-level-style-bullet': break; // 16.31 &lt;text:&#13;
			case 'list-level-style-number': break; // 16.32 &lt;text:&#13;
			case 'list-level-properties': break; // 17.19 &lt;style:&#13;
&#13;
			/* 7.3 Document Fields */&#13;
			case 'sender-firstname': // 7.3.6.2&#13;
			case 'sender-lastname': // 7.3.6.3&#13;
			case 'sender-initials': // 7.3.6.4&#13;
			case 'sender-title': // 7.3.6.5&#13;
			case 'sender-position': // 7.3.6.6&#13;
			case 'sender-email': // 7.3.6.7&#13;
			case 'sender-phone-private': // 7.3.6.8&#13;
			case 'sender-fax': // 7.3.6.9&#13;
			case 'sender-company': // 7.3.6.10&#13;
			case 'sender-phone-work': // 7.3.6.11&#13;
			case 'sender-street': // 7.3.6.12&#13;
			case 'sender-city': // 7.3.6.13&#13;
			case 'sender-postal-code': // 7.3.6.14&#13;
			case 'sender-country': // 7.3.6.15&#13;
			case 'sender-state-or-province': // 7.3.6.16&#13;
			case 'author-name': // 7.3.7.1&#13;
			case 'author-initials': // 7.3.7.2&#13;
			case 'chapter': // 7.3.8&#13;
			case 'file-name': // 7.3.9&#13;
			case 'template-name': // 7.3.9&#13;
			case 'sheet-name': // 7.3.9&#13;
				break;&#13;
&#13;
			case 'event-listener':&#13;
				break;&#13;
			/* TODO: FODS Properties */&#13;
			case 'initial-creator':&#13;
			case 'creation-date':&#13;
			case 'print-date':&#13;
			case 'generator':&#13;
			case 'document-statistic':&#13;
			case 'user-defined':&#13;
			case 'editing-duration':&#13;
			case 'editing-cycles':&#13;
				break;&#13;
&#13;
			/* TODO: FODS Config */&#13;
			case 'config-item':&#13;
				break;&#13;
&#13;
			/* TODO: style tokens */&#13;
			case 'page-number': break; // TODO &lt;text:page-number&gt;&#13;
			case 'page-count': break; // TODO &lt;text:page-count&gt;&#13;
			case 'time': break; // TODO &lt;text:time&gt;&#13;
&#13;
			/* 9.3 Advanced Table Cells */&#13;
			case 'cell-range-source': break; // 9.3.1 &lt;table:&#13;
			case 'detective': break; // 9.3.2 &lt;table:&#13;
			case 'operation': break; // 9.3.3 &lt;table:&#13;
			case 'highlighted-range': break; // 9.3.4 &lt;table:&#13;
&#13;
			/* 9.6 Data Pilot Tables &lt;table: */&#13;
			case 'data-pilot-table': // 9.6.3&#13;
			case 'source-cell-range': // 9.6.5&#13;
			case 'source-service': // 9.6.6&#13;
			case 'data-pilot-field': // 9.6.7&#13;
			case 'data-pilot-level': // 9.6.8&#13;
			case 'data-pilot-subtotals': // 9.6.9&#13;
			case 'data-pilot-subtotal': // 9.6.10&#13;
			case 'data-pilot-members': // 9.6.11&#13;
			case 'data-pilot-member': // 9.6.12&#13;
			case 'data-pilot-display-info': // 9.6.13&#13;
			case 'data-pilot-sort-info': // 9.6.14&#13;
			case 'data-pilot-layout-info': // 9.6.15&#13;
			case 'data-pilot-field-reference': // 9.6.16&#13;
			case 'data-pilot-groups': // 9.6.17&#13;
			case 'data-pilot-group': // 9.6.18&#13;
			case 'data-pilot-group-member': // 9.6.19&#13;
				break;&#13;
&#13;
			/* 10.3 Drawing Shapes */&#13;
			case 'rect': // 10.3.2&#13;
				break;&#13;
&#13;
			/* 14.6 DDE Connections */&#13;
			case 'dde-connection-decls': // 14.6.2 &lt;text:&#13;
			case 'dde-connection-decl': // 14.6.3 &lt;text:&#13;
			case 'dde-link': // 14.6.4 &lt;table:&#13;
			case 'dde-source': // 14.6.5 &lt;office:&#13;
				break;&#13;
&#13;
			case 'properties': break; // 13.7 &lt;form:properties&gt;&#13;
			case 'property': break; // 13.8 &lt;form:property&gt;&#13;
&#13;
			case 'a': // 6.1.8 hyperlink&#13;
				if(Rn[1]!== '/') {&#13;
					atag = parsexmltag(Rn[0], false);&#13;
					if(!atag.href) break;&#13;
					atag.Target = unescapexml(atag.href); delete atag.href;&#13;
					if(atag.Target.charAt(0) == "#" &amp;&amp; atag.Target.indexOf(".") &gt; -1) {&#13;
						_Ref = ods_to_csf_3D(atag.Target.slice(1));&#13;
						atag.Target = "#" + _Ref[0] + "!" + _Ref[1];&#13;
					} else if(atag.Target.match(/^\.\.[\\\/]/)) atag.Target = atag.Target.slice(3);&#13;
				}&#13;
				break;&#13;
&#13;
			/* non-standard */&#13;
			case 'table-protection': break;&#13;
			case 'data-pilot-grand-total': break; // &lt;table:&#13;
			case 'office-document-common-attrs': break; // bare&#13;
			default: switch(Rn[2]) {&#13;
				case 'dc:':       // TODO: properties&#13;
				case 'calcext:':  // ignore undocumented extensions&#13;
				case 'loext:':    // ignore undocumented extensions&#13;
				case 'ooo:':      // ignore undocumented extensions&#13;
				case 'chartooo:': // ignore undocumented extensions&#13;
				case 'draw:':     // TODO: drawing&#13;
				case 'style:':    // TODO: styles&#13;
				case 'chart:':    // TODO: charts&#13;
				case 'form:':     // TODO: forms&#13;
				case 'uof:':      // TODO: uof&#13;
				case '表:':       // TODO: uof&#13;
				case '字:':       // TODO: uof&#13;
					break;&#13;
				default: if(opts.WTF) throw new Error(Rn);&#13;
			}&#13;
		}&#13;
		var out = ({&#13;
			Sheets: Sheets,&#13;
			SheetNames: SheetNames,&#13;
			Workbook: WB&#13;
		});&#13;
		if(opts.bookSheets) delete out.Sheets;&#13;
		return out;&#13;
}&#13;
&#13;
function parse_ods(zip, opts) {&#13;
	opts = opts || ({});&#13;
	if(safegetzipfile(zip, 'META-INF/manifest.xml')) parse_manifest(getzipdata(zip, 'META-INF/manifest.xml'), opts);&#13;
	var styles = getzipstr(zip, 'styles.xml');&#13;
	var Styles = styles &amp;&amp; parse_ods_styles(utf8read(styles), opts);&#13;
	var content = getzipstr(zip, 'content.xml');&#13;
	if(!content) throw new Error("Missing content.xml in ODS / UOF file");&#13;
	var wb = parse_content_xml(utf8read(content), opts, Styles);&#13;
	if(safegetzipfile(zip, 'meta.xml')) wb.Props = parse_core_props(getzipdata(zip, 'meta.xml'));&#13;
	wb.bookType = "ods";&#13;
	return wb;&#13;
}&#13;
function parse_fods(data, opts) {&#13;
	var wb = parse_content_xml(data, opts);&#13;
	wb.bookType = "fods";&#13;
	return wb;&#13;
}&#13;
&#13;
/* OpenDocument */&#13;
var write_styles_ods = /* @__PURE__ */(function() {&#13;
	var master_styles = [&#13;
		'&lt;office:master-styles&gt;',&#13;
			'&lt;style:master-page style:name="mp1" style:page-layout-name="mp1"&gt;',&#13;
				'&lt;style:header/&gt;',&#13;
				'&lt;style:header-left style:display="false"/&gt;',&#13;
				'&lt;style:footer/&gt;',&#13;
				'&lt;style:footer-left style:display="false"/&gt;',&#13;
			'&lt;/style:master-page&gt;',&#13;
		'&lt;/office:master-styles&gt;'&#13;
	].join("");&#13;
&#13;
	var payload = '&lt;office:document-styles ' + wxt_helper({&#13;
		'xmlns:office':   "urn:oasis:names:tc:opendocument:xmlns:office:1.0",&#13;
		'xmlns:table':    "urn:oasis:names:tc:opendocument:xmlns:table:1.0",&#13;
		'xmlns:style':    "urn:oasis:names:tc:opendocument:xmlns:style:1.0",&#13;
		'xmlns:text':     "urn:oasis:names:tc:opendocument:xmlns:text:1.0",&#13;
		'xmlns:draw':     "urn:oasis:names:tc:opendocument:xmlns:drawing:1.0",&#13;
		'xmlns:fo':       "urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0",&#13;
		'xmlns:xlink':    "http://www.w3.org/1999/xlink",&#13;
		'xmlns:dc':       "http://purl.org/dc/elements/1.1/",&#13;
		'xmlns:number':   "urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0",&#13;
		'xmlns:svg':      "urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0",&#13;
		'xmlns:of':       "urn:oasis:names:tc:opendocument:xmlns:of:1.2",&#13;
		'office:version': "1.2"&#13;
	}) + '&gt;' + master_styles + '&lt;/office:document-styles&gt;';&#13;
&#13;
	return function wso() {&#13;
		return XML_HEADER + payload;&#13;
	};&#13;
})();&#13;
&#13;
// TODO: find out if anyone actually read the spec.  LO has some wild errors&#13;
function write_number_format_ods(nf, nfidx) {&#13;
	var type = "number", payload = "", nopts = { "style:name": nfidx }, c = "", i = 0;&#13;
	nf = nf.replace(/"[$]"/g, "$");&#13;
	/* TODO: replace with an actual parser based on a real grammar */&#13;
	j: {&#13;
		// TODO: support style maps&#13;
		if(nf.indexOf(";") &gt; -1) {&#13;
			console.error("Unsupported ODS Style Map exported.  Using first branch of " + nf);&#13;
			nf = nf.slice(0, nf.indexOf(";"));&#13;
		}&#13;
&#13;
		if(nf == "@") { type = "text"; payload = "&lt;number:text-content/&gt;"; break j; }&#13;
&#13;
		/* currency flag */&#13;
		if(nf.indexOf(/\$/) &gt; -1) { type = "currency"; }&#13;
&#13;
		/* opening string literal */&#13;
		if(nf[i] == '"') {&#13;
			c = "";&#13;
			while(nf[++i] != '"' || nf[++i] == '"') c += nf[i]; --i;&#13;
			if(nf[i+1] == "*") {&#13;
				i++;&#13;
				payload += '&lt;number:fill-character&gt;' + escapexml(c.replace(/""/g, '"')) + '&lt;/number:fill-character&gt;';&#13;
			} else {&#13;
				payload += '&lt;number:text&gt;' + escapexml(c.replace(/""/g, '"')) + '&lt;/number:text&gt;';&#13;
			}&#13;
			nf = nf.slice(i+1); i = 0;&#13;
		}&#13;
&#13;
		/* fractions */&#13;
		var t = nf.match(/# (\?+)\/(\?+)/);&#13;
		if(t) { payload += writextag("number:fraction", null, {"number:min-integer-digits":0, "number:min-numerator-digits": t[1].length, "number:max-denominator-value": Math.max(+(t[1].replace(/./g, "9")), +(t[2].replace(/./g, "9"))) }); break j; }&#13;
		if((t=nf.match(/# (\?+)\/(\d+)/))) { payload += writextag("number:fraction", null, {"number:min-integer-digits":0, "number:min-numerator-digits": t[1].length, "number:denominator-value": +t[2]}); break j; }&#13;
&#13;
		/* percentages */&#13;
		if((t=nf.match(/(\d+)(|\.\d+)%/))) { type = "percentage"; payload += writextag("number:number", null, {"number:decimal-places": t[2] &amp;&amp; t.length - 1 || 0, "number:min-decimal-places": t[2] &amp;&amp; t.length - 1 || 0, "number:min-integer-digits": t[1].length }) + "&lt;number:text&gt;%&lt;/number:text&gt;"; break j; }&#13;
&#13;
		/* datetime */&#13;
		var has_time = false;&#13;
		if(["y","m","d"].indexOf(nf[0]) &gt; -1) {&#13;
			type = "date";&#13;
			k: for(; i &lt; nf.length; ++i) switch((c = nf[i].toLowerCase())) {&#13;
				case "h": case "s": has_time = true; --i; break k;&#13;
				case "m":&#13;
					l: for(var h = i+1; h &lt; nf.length; ++h) switch(nf[h]) {&#13;
						case "y": case "d": break l;&#13;
						case "h": case "s": has_time = true; --i; break k;&#13;
					}&#13;
					/* falls through */&#13;
				case "y": case "d":&#13;
					while((nf[++i]||"").toLowerCase() == c[0]) c += c[0]; --i;&#13;
					switch(c) {&#13;
						case "y": case "yy": payload += "&lt;number:year/&gt;"; break;&#13;
						case "yyy": case "yyyy": payload += '&lt;number:year number:style="long"/&gt;'; break;&#13;
						case "mmmmm": console.error("ODS has no equivalent of format |mmmmm|");&#13;
							/* falls through */&#13;
						case "m": case "mm": case "mmm": case "mmmm":&#13;
							payload += '&lt;number:month number:style="' + (c.length % 2 ? "short" : "long") + '" number:textual="' + (c.length &gt;= 3 ? "true" : "false") + '"/&gt;';&#13;
							break;&#13;
						case "d": case "dd": payload += '&lt;number:day number:style="' + (c.length % 2 ? "short" : "long") + '"/&gt;'; break;&#13;
						case "ddd": case "dddd": payload += '&lt;number:day-of-week number:style="' + (c.length % 2 ? "short" : "long") + '"/&gt;'; break;&#13;
					}&#13;
					break;&#13;
				case '"':&#13;
					while(nf[++i] != '"' || nf[++i] == '"') c += nf[i]; --i;&#13;
					payload += '&lt;number:text&gt;' + escapexml(c.slice(1).replace(/""/g, '"')) + '&lt;/number:text&gt;';&#13;
					break;&#13;
				case '/': payload += '&lt;number:text&gt;' + escapexml(c) + '&lt;/number:text&gt;'; break;&#13;
				default: console.error("unrecognized character " + c + " in ODF format " + nf);&#13;
			}&#13;
			if(!has_time) break j;&#13;
			nf = nf.slice(i+1); i = 0;&#13;
		}&#13;
		if(nf.match(/^\[?[hms]/)) {&#13;
			if(type == "number") type = "time";&#13;
			if(nf.match(/\[/)) {&#13;
				nf = nf.replace(/[\[\]]/g, "");&#13;
				nopts['number:truncate-on-overflow'] = "false";&#13;
			}&#13;
			for(; i &lt; nf.length; ++i) switch((c = nf[i].toLowerCase())) {&#13;
				case "h": case "m": case "s":&#13;
					while((nf[++i]||"").toLowerCase() == c[0]) c += c[0]; --i;&#13;
					switch(c) {&#13;
						case "h": case "hh": payload += '&lt;number:hours number:style="' + (c.length % 2 ? "short" : "long") + '"/&gt;'; break;&#13;
						case "m": case "mm": payload += '&lt;number:minutes number:style="' + (c.length % 2 ? "short" : "long") + '"/&gt;'; break;&#13;
						case "s": case "ss":&#13;
							if(nf[i+1] == ".") do { c += nf[i+1]; ++i; } while(nf[i+1] == "0");&#13;
							payload += '&lt;number:seconds number:style="' + (c.match("ss") ? "long" : "short") + '"' + (c.match(/\./) ? ' number:decimal-places="' + (c.match(/0+/)||[""])[0].length + '"' : "")+ '/&gt;'; break;&#13;
					}&#13;
					break;&#13;
				case '"':&#13;
					while(nf[++i] != '"' || nf[++i] == '"') c += nf[i]; --i;&#13;
					payload += '&lt;number:text&gt;' + escapexml(c.slice(1).replace(/""/g, '"')) + '&lt;/number:text&gt;';&#13;
					break;&#13;
				case '/': payload += '&lt;number:text&gt;' + escapexml(c) + '&lt;/number:text&gt;'; break;&#13;
				case "a":&#13;
					if(nf.slice(i, i+3).toLowerCase() == "a/p") { payload += '&lt;number:am-pm/&gt;'; i += 2; break; } // Note: ODF does not support A/P&#13;
					if(nf.slice(i, i+5).toLowerCase() == "am/pm")  { payload += '&lt;number:am-pm/&gt;'; i += 4; break; }&#13;
					/* falls through */&#13;
				default: console.error("unrecognized character " + c + " in ODF format " + nf);&#13;
			}&#13;
			break j;&#13;
		}&#13;
&#13;
		/* currency flag */&#13;
		if(nf.indexOf(/\$/) &gt; -1) { type = "currency"; }&#13;
&#13;
		/* should be in a char loop */&#13;
		if(nf[0] == "$") { payload += '&lt;number:currency-symbol number:language="en" number:country="US"&gt;$&lt;/number:currency-symbol&gt;'; nf = nf.slice(1); i = 0; }&#13;
		i = 0; if(nf[i] == '"') {&#13;
			while(nf[++i] != '"' || nf[++i] == '"') c += nf[i]; --i;&#13;
			if(nf[i+1] == "*") {&#13;
				i++;&#13;
				payload += '&lt;number:fill-character&gt;' + escapexml(c.replace(/""/g, '"')) + '&lt;/number:fill-character&gt;';&#13;
			} else {&#13;
				payload += '&lt;number:text&gt;' + escapexml(c.replace(/""/g, '"')) + '&lt;/number:text&gt;';&#13;
			}&#13;
			nf = nf.slice(i+1); i = 0;&#13;
		}&#13;
&#13;
		/* number TODO: interstitial text e.g. 000)000-0000 */&#13;
		var np = nf.match(/([#0][0#,]*)(\.[0#]*|)(E[+]?0*|)/i);&#13;
		if(!np || !np[0]) console.error("Could not find numeric part of " + nf);&#13;
		else {&#13;
			var base = np[1].replace(/,/g, "");&#13;
			payload += '&lt;number:' + (np[3] ? "scientific-" : "")+ 'number' +&#13;
				' number:min-integer-digits="' + (base.indexOf("0") == -1 ? "0" : base.length - base.indexOf("0")) + '"' +&#13;
				(np[0].indexOf(",") &gt; -1 ? ' number:grouping="true"' : "") +&#13;
				(np[2] &amp;&amp; ' number:decimal-places="' + (np[2].length - 1) + '"' || ' number:decimal-places="0"') +&#13;
				(np[3] &amp;&amp; np[3].indexOf("+") &gt; -1 ? ' number:forced-exponent-sign="true"' : "" ) +&#13;
				(np[3] ? ' number:min-exponent-digits="' + np[3].match(/0+/)[0].length + '"' : "" ) +&#13;
				'&gt;' +&#13;
				/* TODO: interstitial text placeholders */&#13;
				'&lt;/number:' + (np[3] ? "scientific-" : "") + 'number&gt;';&#13;
			i = np.index + np[0].length;&#13;
		}&#13;
&#13;
		/* residual text */&#13;
		if(nf[i] == '"') {&#13;
			c = "";&#13;
			while(nf[++i] != '"' || nf[++i] == '"') c += nf[i]; --i;&#13;
			payload += '&lt;number:text&gt;' + escapexml(c.replace(/""/g, '"')) + '&lt;/number:text&gt;';&#13;
		}&#13;
	}&#13;
&#13;
	if(!payload) { console.error("Could not generate ODS number format for |" + nf + "|"); return ""; }&#13;
	return writextag("number:" + type + "-style", payload, nopts);&#13;
}&#13;
&#13;
function write_names_ods(Names, SheetNames, idx) {&#13;
	var scoped = Names.filter(function(name) { return name.Sheet == (idx == -1 ? null : idx); });&#13;
	if(!scoped.length) return "";&#13;
	return "      &lt;table:named-expressions&gt;\n" + scoped.map(function(name) {&#13;
		var odsref =  csf_to_ods_3D(name.Ref);&#13;
		return "        " + writextag("table:named-range", null, {&#13;
			"table:name": name.Name,&#13;
			"table:cell-range-address": odsref,&#13;
			"table:base-cell-address": odsref.replace(/[\.]?[^\.]*$/, ".$A$1")&#13;
		});&#13;
	}).join("\n") + "\n      &lt;/table:named-expressions&gt;\n";&#13;
}&#13;
var write_content_ods = /* @__PURE__ */(function() {&#13;
	/* 6.1.2 White Space Characters */&#13;
	var write_text_p = function(text) {&#13;
		return escapexml(text)&#13;
			.replace(/  +/g, function($$){return '&lt;text:s text:c="'+$$.length+'"/&gt;';})&#13;
			.replace(/\t/g, "&lt;text:tab/&gt;")&#13;
			.replace(/\n/g, "&lt;/text:p&gt;&lt;text:p&gt;")&#13;
			.replace(/^ /, "&lt;text:s/&gt;").replace(/ $/, "&lt;text:s/&gt;");&#13;
	};&#13;
&#13;
	var null_cell_xml = '          &lt;table:table-cell /&gt;\n';&#13;
	var covered_cell_xml = '          &lt;table:covered-table-cell/&gt;\n';&#13;
	var write_ws = function(ws, wb, i, opts, nfs) {&#13;
		/* Section 9 Tables */&#13;
		var o = [];&#13;
		o.push('      &lt;table:table table:name="' + escapexml(wb.SheetNames[i]) + '" table:style-name="ta1"&gt;\n');&#13;
		var R=0,C=0, range = decode_range(ws['!ref']||"A1");&#13;
		var marr = ws['!merges'] || [], mi = 0;&#13;
		var dense = Array.isArray(ws);&#13;
		if(ws["!cols"]) {&#13;
			for(C = 0; C &lt;= range.e.c; ++C) o.push('        &lt;table:table-column' + (ws["!cols"][C] ? ' table:style-name="co' + ws["!cols"][C].ods + '"' : '') + '&gt;&lt;/table:table-column&gt;\n');&#13;
		}&#13;
		var H = "", ROWS = ws["!rows"]||[];&#13;
		for(R = 0; R &lt; range.s.r; ++R) {&#13;
			H = ROWS[R] ? ' table:style-name="ro' + ROWS[R].ods + '"' : "";&#13;
			o.push('        &lt;table:table-row' + H + '&gt;&lt;/table:table-row&gt;\n');&#13;
		}&#13;
		for(; R &lt;= range.e.r; ++R) {&#13;
			H = ROWS[R] ? ' table:style-name="ro' + ROWS[R].ods + '"' : "";&#13;
			o.push('        &lt;table:table-row' + H + '&gt;\n');&#13;
			for(C=0; C &lt; range.s.c; ++C) o.push(null_cell_xml);&#13;
			for(; C &lt;= range.e.c; ++C) {&#13;
				var skip = false, ct = {}, textp = "";&#13;
				for(mi = 0; mi != marr.length; ++mi) {&#13;
					if(marr[mi].s.c &gt; C) continue;&#13;
					if(marr[mi].s.r &gt; R) continue;&#13;
					if(marr[mi].e.c &lt; C) continue;&#13;
					if(marr[mi].e.r &lt; R) continue;&#13;
					if(marr[mi].s.c != C || marr[mi].s.r != R) skip = true;&#13;
					ct['table:number-columns-spanned'] = (marr[mi].e.c - marr[mi].s.c + 1);&#13;
					ct['table:number-rows-spanned'] =    (marr[mi].e.r - marr[mi].s.r + 1);&#13;
					break;&#13;
				}&#13;
				if(skip) { o.push(covered_cell_xml); continue; }&#13;
				var ref = encode_cell({r:R, c:C}), cell = dense ? (ws[R]||[])[C]: ws[ref];&#13;
				if(cell &amp;&amp; cell.f) {&#13;
					ct['table:formula'] = escapexml(csf_to_ods_formula(cell.f));&#13;
					if(cell.F) {&#13;
						if(cell.F.slice(0, ref.length) == ref) {&#13;
							var _Fref = decode_range(cell.F);&#13;
							ct['table:number-matrix-columns-spanned'] = (_Fref.e.c - _Fref.s.c + 1);&#13;
							ct['table:number-matrix-rows-spanned'] =    (_Fref.e.r - _Fref.s.r + 1);&#13;
						}&#13;
					}&#13;
				}&#13;
				if(!cell) { o.push(null_cell_xml); continue; }&#13;
				switch(cell.t) {&#13;
					case 'b':&#13;
						textp = (cell.v ? 'TRUE' : 'FALSE');&#13;
						ct['office:value-type'] = "boolean";&#13;
						ct['office:boolean-value'] = (cell.v ? 'true' : 'false');&#13;
						break;&#13;
					case 'n':&#13;
						textp = (cell.w||String(cell.v||0));&#13;
						ct['office:value-type'] = "float";&#13;
						ct['office:value'] = (cell.v||0);&#13;
						break;&#13;
					case 's': case 'str':&#13;
						textp = cell.v == null ? "" : cell.v;&#13;
						ct['office:value-type'] = "string";&#13;
						break;&#13;
					case 'd':&#13;
						textp = (cell.w||(parseDate(cell.v).toISOString()));&#13;
						ct['office:value-type'] = "date";&#13;
						ct['office:date-value'] = (parseDate(cell.v).toISOString());&#13;
						ct['table:style-name'] = "ce1";&#13;
						break;&#13;
					//case 'e':&#13;
					default: o.push(null_cell_xml); continue;&#13;
				}&#13;
				var text_p = write_text_p(textp);&#13;
				if(cell.l &amp;&amp; cell.l.Target) {&#13;
					var _tgt = cell.l.Target;&#13;
					_tgt = _tgt.charAt(0) == "#" ? "#" + csf_to_ods_3D(_tgt.slice(1)) : _tgt;&#13;
					// TODO: choose correct parent path format based on link delimiters&#13;
					if(_tgt.charAt(0) != "#" &amp;&amp; !_tgt.match(/^\w+:/)) _tgt = '../' + _tgt;&#13;
					text_p = writextag('text:a', text_p, {'xlink:href': _tgt.replace(/&amp;/g, "&amp;amp;")});&#13;
				}&#13;
				if(nfs[cell.z]) ct["table:style-name"] = "ce" + nfs[cell.z].slice(1);&#13;
				o.push('          ' + writextag('table:table-cell', writextag('text:p', text_p, {}), ct) + '\n');&#13;
			}&#13;
			o.push('        &lt;/table:table-row&gt;\n');&#13;
		}&#13;
		if((wb.Workbook||{}).Names) o.push(write_names_ods(wb.Workbook.Names, wb.SheetNames, i));&#13;
		o.push('      &lt;/table:table&gt;\n');&#13;
		return o.join("");&#13;
	};&#13;
&#13;
	var write_automatic_styles_ods = function(o, wb) {&#13;
		o.push(' &lt;office:automatic-styles&gt;\n');&#13;
&#13;
		/* column styles */&#13;
		var cidx = 0;&#13;
		wb.SheetNames.map(function(n) { return wb.Sheets[n]; }).forEach(function(ws) {&#13;
			if(!ws) return;&#13;
			if(ws["!cols"]) {&#13;
				for(var C = 0; C &lt; ws["!cols"].length; ++C) if(ws["!cols"][C]) {&#13;
					var colobj = ws["!cols"][C];&#13;
					if(colobj.width == null &amp;&amp; colobj.wpx == null &amp;&amp; colobj.wch == null) continue;&#13;
					process_col(colobj);&#13;
					colobj.ods = cidx;&#13;
					var w = ws["!cols"][C].wpx + "px";&#13;
					o.push('  &lt;style:style style:name="co' + cidx + '" style:family="table-column"&gt;\n');&#13;
					o.push('   &lt;style:table-column-properties fo:break-before="auto" style:column-width="' + w + '"/&gt;\n');&#13;
					o.push('  &lt;/style:style&gt;\n');&#13;
					++cidx;&#13;
				}&#13;
			}&#13;
		});&#13;
&#13;
		/* row styles */&#13;
		var ridx = 0;&#13;
		wb.SheetNames.map(function(n) { return wb.Sheets[n]; }).forEach(function(ws) {&#13;
			if(!ws) return;&#13;
			if(ws["!rows"]) {&#13;
				for(var R = 0; R &lt; ws["!rows"].length; ++R) if(ws["!rows"][R]) {&#13;
					ws["!rows"][R].ods = ridx;&#13;
					var h = ws["!rows"][R].hpx + "px";&#13;
					o.push('  &lt;style:style style:name="ro' + ridx + '" style:family="table-row"&gt;\n');&#13;
					o.push('   &lt;style:table-row-properties fo:break-before="auto" style:row-height="' + h + '"/&gt;\n');&#13;
					o.push('  &lt;/style:style&gt;\n');&#13;
					++ridx;&#13;
				}&#13;
			}&#13;
		});&#13;
&#13;
		/* table */&#13;
		o.push('  &lt;style:style style:name="ta1" style:family="table" style:master-page-name="mp1"&gt;\n');&#13;
		o.push('   &lt;style:table-properties table:display="true" style:writing-mode="lr-tb"/&gt;\n');&#13;
		o.push('  &lt;/style:style&gt;\n');&#13;
&#13;
		o.push('  &lt;number:date-style style:name="N37" number:automatic-order="true"&gt;\n');&#13;
		o.push('   &lt;number:month number:style="long"/&gt;\n');&#13;
		o.push('   &lt;number:text&gt;/&lt;/number:text&gt;\n');&#13;
		o.push('   &lt;number:day number:style="long"/&gt;\n');&#13;
		o.push('   &lt;number:text&gt;/&lt;/number:text&gt;\n');&#13;
		o.push('   &lt;number:year/&gt;\n');&#13;
		o.push('  &lt;/number:date-style&gt;\n');&#13;
&#13;
		/* number formats, table cells, text */&#13;
		var nfs = {};&#13;
		var nfi = 69;&#13;
		wb.SheetNames.map(function(n) { return wb.Sheets[n]; }).forEach(function(ws) {&#13;
			if(!ws) return;&#13;
			var range = decode_range(ws["!ref"]);&#13;
			for(var R = 0; R &lt;= range.e.r; ++R) for(var C = 0; C &lt;= range.e.c; ++C) {&#13;
				var c = Array.isArray(ws) ? (ws[R]||[])[C] : ws[encode_cell({r:R,c:C})];&#13;
				if(!c || !c.z || c.z.toLowerCase() == "general") continue;&#13;
				if(!nfs[c.z]) {&#13;
					var out = write_number_format_ods(c.z, "N" + nfi);&#13;
					if(out) { nfs[c.z] = "N" + nfi; ++nfi; o.push(out + "\n"); }&#13;
				}&#13;
			}&#13;
		});&#13;
		o.push('  &lt;style:style style:name="ce1" style:family="table-cell" style:parent-style-name="Default" style:data-style-name="N37"/&gt;\n');&#13;
		keys(nfs).forEach(function(nf) {&#13;
			o.push('&lt;style:style style:name="ce' + nfs[nf].slice(1) + '" style:family="table-cell" style:parent-style-name="Default" style:data-style-name="' + nfs[nf] + '"/&gt;\n');&#13;
		});&#13;
&#13;
		/* page-layout */&#13;
&#13;
		o.push(' &lt;/office:automatic-styles&gt;\n');&#13;
		return nfs;&#13;
	};&#13;
&#13;
	return function wcx(wb, opts) {&#13;
		var o = [XML_HEADER];&#13;
		/* 3.1.3.2 */&#13;
		var attr = wxt_helper({&#13;
			'xmlns:office':       "urn:oasis:names:tc:opendocument:xmlns:office:1.0",&#13;
			'xmlns:table':        "urn:oasis:names:tc:opendocument:xmlns:table:1.0",&#13;
			'xmlns:style':        "urn:oasis:names:tc:opendocument:xmlns:style:1.0",&#13;
			'xmlns:text':         "urn:oasis:names:tc:opendocument:xmlns:text:1.0",&#13;
			'xmlns:draw':         "urn:oasis:names:tc:opendocument:xmlns:drawing:1.0",&#13;
			'xmlns:fo':           "urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0",&#13;
			'xmlns:xlink':        "http://www.w3.org/1999/xlink",&#13;
			'xmlns:dc':           "http://purl.org/dc/elements/1.1/",&#13;
			'xmlns:meta':         "urn:oasis:names:tc:opendocument:xmlns:meta:1.0",&#13;
			'xmlns:number':       "urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0",&#13;
			'xmlns:presentation': "urn:oasis:names:tc:opendocument:xmlns:presentation:1.0",&#13;
			'xmlns:svg':          "urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0",&#13;
			'xmlns:chart':        "urn:oasis:names:tc:opendocument:xmlns:chart:1.0",&#13;
			'xmlns:dr3d':         "urn:oasis:names:tc:opendocument:xmlns:dr3d:1.0",&#13;
			'xmlns:math':         "http://www.w3.org/1998/Math/MathML",&#13;
			'xmlns:form':         "urn:oasis:names:tc:opendocument:xmlns:form:1.0",&#13;
			'xmlns:script':       "urn:oasis:names:tc:opendocument:xmlns:script:1.0",&#13;
			'xmlns:ooo':          "http://openoffice.org/2004/office",&#13;
			'xmlns:ooow':         "http://openoffice.org/2004/writer",&#13;
			'xmlns:oooc':         "http://openoffice.org/2004/calc",&#13;
			'xmlns:dom':          "http://www.w3.org/2001/xml-events",&#13;
			'xmlns:xforms':       "http://www.w3.org/2002/xforms",&#13;
			'xmlns:xsd':          "http://www.w3.org/2001/XMLSchema",&#13;
			'xmlns:xsi':          "http://www.w3.org/2001/XMLSchema-instance",&#13;
			'xmlns:sheet':        "urn:oasis:names:tc:opendocument:sh33tjs:1.0",&#13;
			'xmlns:rpt':          "http://openoffice.org/2005/report",&#13;
			'xmlns:of':           "urn:oasis:names:tc:opendocument:xmlns:of:1.2",&#13;
			'xmlns:xhtml':        "http://www.w3.org/1999/xhtml",&#13;
			'xmlns:grddl':        "http://www.w3.org/2003/g/data-view#",&#13;
			'xmlns:tableooo':     "http://openoffice.org/2009/table",&#13;
			'xmlns:drawooo':      "http://openoffice.org/2010/draw",&#13;
			'xmlns:calcext':      "urn:org:documentfoundation:names:experimental:calc:xmlns:calcext:1.0",&#13;
			'xmlns:loext':        "urn:org:documentfoundation:names:experimental:office:xmlns:loext:1.0",&#13;
			'xmlns:field':        "urn:openoffice:names:experimental:ooo-ms-interop:xmlns:field:1.0",&#13;
			'xmlns:formx':        "urn:openoffice:names:experimental:ooxml-odf-interop:xmlns:form:1.0",&#13;
			'xmlns:css3t':        "http://www.w3.org/TR/css3-text/",&#13;
			'office:version':     "1.2"&#13;
		});&#13;
&#13;
		var fods = wxt_helper({&#13;
			'xmlns:config':    "urn:oasis:names:tc:opendocument:xmlns:config:1.0",&#13;
			'office:mimetype': "application/vnd.oasis.opendocument.spreadsheet"&#13;
		});&#13;
&#13;
		if(opts.bookType == "fods") {&#13;
			o.push('&lt;office:document' + attr + fods + '&gt;\n');&#13;
			o.push(write_meta_ods().replace(/&lt;office:document-meta.*?&gt;/, "").replace(/&lt;\/office:document-meta&gt;/, "") + "\n");&#13;
			// TODO: settings (equiv of settings.xml for ODS)&#13;
		} else o.push('&lt;office:document-content' + attr  + '&gt;\n');&#13;
		// o.push('  &lt;office:scripts/&gt;\n');&#13;
		var nfs = write_automatic_styles_ods(o, wb);&#13;
		o.push('  &lt;office:body&gt;\n');&#13;
		o.push('    &lt;office:spreadsheet&gt;\n');&#13;
		if(((wb.Workbook||{}).WBProps||{}).date1904) o.push('      &lt;table:calculation-settings table:case-sensitive="false" table:search-criteria-must-apply-to-whole-cell="true" table:use-wildcards="true" table:use-regular-expressions="false" table:automatic-find-labels="false"&gt;\n        &lt;table:null-date table:date-value="1904-01-01"/&gt;\n      &lt;/table:calculation-settings&gt;\n');&#13;
		for(var i = 0; i != wb.SheetNames.length; ++i) o.push(write_ws(wb.Sheets[wb.SheetNames[i]], wb, i, opts, nfs));&#13;
		if((wb.Workbook||{}).Names) o.push(write_names_ods(wb.Workbook.Names, wb.SheetNames, -1));&#13;
		o.push('    &lt;/office:spreadsheet&gt;\n');&#13;
		o.push('  &lt;/office:body&gt;\n');&#13;
		if(opts.bookType == "fods") o.push('&lt;/office:document&gt;');&#13;
		else o.push('&lt;/office:document-content&gt;');&#13;
		return o.join("");&#13;
	};&#13;
})();&#13;
&#13;
function write_ods(wb, opts) {&#13;
	if(opts.bookType == "fods") return write_content_ods(wb, opts);&#13;
&#13;
	var zip = zip_new();&#13;
	var f = "";&#13;
&#13;
	var manifest = [];&#13;
	var rdf = [];&#13;
&#13;
	/* Part 3 Section 3.3 MIME Media Type */&#13;
	f = "mimetype";&#13;
	zip_add_file(zip, f, "application/vnd.oasis.opendocument.spreadsheet");&#13;
&#13;
	/* Part 1 Section 2.2 Documents */&#13;
	f = "content.xml";&#13;
	zip_add_file(zip, f, write_content_ods(wb, opts));&#13;
	manifest.push([f, "text/xml"]);&#13;
	rdf.push([f, "ContentFile"]);&#13;
&#13;
	/* TODO: these are hard-coded styles to satiate excel */&#13;
	f = "styles.xml";&#13;
	zip_add_file(zip, f, write_styles_ods(wb, opts));&#13;
	manifest.push([f, "text/xml"]);&#13;
	rdf.push([f, "StylesFile"]);&#13;
&#13;
	/* TODO: this is hard-coded to satiate excel */&#13;
	f = "meta.xml";&#13;
	zip_add_file(zip, f, XML_HEADER + write_meta_ods());&#13;
	manifest.push([f, "text/xml"]);&#13;
	rdf.push([f, "MetadataFile"]);&#13;
&#13;
	/* Part 3 Section 6 Metadata Manifest File */&#13;
	f = "manifest.rdf";&#13;
	zip_add_file(zip, f, write_rdf(rdf/*, opts*/));&#13;
	manifest.push([f, "application/rdf+xml"]);&#13;
&#13;
	/* Part 3 Section 4 Manifest File */&#13;
	f = "META-INF/manifest.xml";&#13;
	zip_add_file(zip, f, write_manifest(manifest/*, opts*/));&#13;
&#13;
	return zip;&#13;
}&#13;
&#13;
/*! sheetjs (C) 2013-present xlsx -- http://sheetjs.com */&#13;
var subarray = function() {&#13;
  try {&#13;
    if (typeof Uint8Array == "undefined")&#13;
      return "slice";&#13;
    if (typeof Uint8Array.prototype.subarray == "undefined")&#13;
      return "slice";&#13;
    if (typeof Buffer !== "undefined") {&#13;
      if (typeof Buffer.prototype.subarray == "undefined")&#13;
        return "slice";&#13;
      if ((typeof Buffer.from == "function" ? Buffer.from([72, 62]) : new Buffer([72, 62])) instanceof Uint8Array)&#13;
        return "subarray";&#13;
      return "slice";&#13;
    }&#13;
    return "subarray";&#13;
  } catch (e) {&#13;
    return "slice";&#13;
  }&#13;
}();&#13;
function u8_to_dataview(array) {&#13;
  return new DataView(array.buffer, array.byteOffset, array.byteLength);&#13;
}&#13;
function u8str(u8) {&#13;
  return typeof TextDecoder != "undefined" ? new TextDecoder().decode(u8) : utf8read(a2s(u8));&#13;
}&#13;
function stru8(str) {&#13;
  return typeof TextEncoder != "undefined" ? new TextEncoder().encode(str) : s2a(utf8write(str));&#13;
}&#13;
function u8contains(body, search) {&#13;
  var L = body.indexOf(search[0]);&#13;
  if (L == -1)&#13;
    return false;&#13;
  outer:&#13;
    for (; L &lt;= body.length - search.length; ++L) {&#13;
      for (var j = 0; j &lt; search.length; ++j)&#13;
        if (body[L + j] != search[j])&#13;
          continue outer;&#13;
      return true;&#13;
    }&#13;
  return false;&#13;
}&#13;
function u8concat(u8a) {&#13;
  var len = u8a.reduce(function(acc, x) {&#13;
    return acc + x.length;&#13;
  }, 0);&#13;
  var out = new Uint8Array(len);&#13;
  var off = 0;&#13;
  u8a.forEach(function(u8) {&#13;
    out.set(u8, off);&#13;
    off += u8.length;&#13;
  });&#13;
  return out;&#13;
}&#13;
function popcnt(x) {&#13;
  x -= x &gt;&gt; 1 &amp; 1431655765;&#13;
  x = (x &amp; 858993459) + (x &gt;&gt; 2 &amp; 858993459);&#13;
  return (x + (x &gt;&gt; 4) &amp; 252645135) * 16843009 &gt;&gt;&gt; 24;&#13;
}&#13;
function readDecimal128LE(buf, offset) {&#13;
  var exp = (buf[offset + 15] &amp; 127) &lt;&lt; 7 | buf[offset + 14] &gt;&gt; 1;&#13;
  var mantissa = buf[offset + 14] &amp; 1;&#13;
  for (var j = offset + 13; j &gt;= offset; --j)&#13;
    mantissa = mantissa * 256 + buf[j];&#13;
  return (buf[offset + 15] &amp; 128 ? -mantissa : mantissa) * Math.pow(10, exp - 6176);&#13;
}&#13;
function writeDecimal128LE(buf, offset, value) {&#13;
  var exp = Math.floor(value == 0 ? 0 : Math.LOG10E * Math.log(Math.abs(value))) + 6176 - 16;&#13;
  var mantissa = value / Math.pow(10, exp - 6176);&#13;
  buf[offset + 15] |= exp &gt;&gt; 7;&#13;
  buf[offset + 14] |= (exp &amp; 127) &lt;&lt; 1;&#13;
  for (var i = 0; mantissa &gt;= 1; ++i, mantissa /= 256)&#13;
    buf[offset + i] = mantissa &amp; 255;&#13;
  buf[offset + 15] |= value &gt;= 0 ? 0 : 128;&#13;
}&#13;
function parse_varint49(buf, ptr) {&#13;
  var l = ptr ? ptr[0] : 0;&#13;
  var usz = buf[l] &amp; 127;&#13;
  varint:&#13;
    if (buf[l++] &gt;= 128) {&#13;
      usz |= (buf[l] &amp; 127) &lt;&lt; 7;&#13;
      if (buf[l++] &lt; 128)&#13;
        break varint;&#13;
      usz |= (buf[l] &amp; 127) &lt;&lt; 14;&#13;
      if (buf[l++] &lt; 128)&#13;
        break varint;&#13;
      usz |= (buf[l] &amp; 127) &lt;&lt; 21;&#13;
      if (buf[l++] &lt; 128)&#13;
        break varint;&#13;
      usz += (buf[l] &amp; 127) * Math.pow(2, 28);&#13;
      ++l;&#13;
      if (buf[l++] &lt; 128)&#13;
        break varint;&#13;
      usz += (buf[l] &amp; 127) * Math.pow(2, 35);&#13;
      ++l;&#13;
      if (buf[l++] &lt; 128)&#13;
        break varint;&#13;
      usz += (buf[l] &amp; 127) * Math.pow(2, 42);&#13;
      ++l;&#13;
      if (buf[l++] &lt; 128)&#13;
        break varint;&#13;
    }&#13;
  if (ptr)&#13;
    ptr[0] = l;&#13;
  return usz;&#13;
}&#13;
function write_varint49(v) {&#13;
  var usz = new Uint8Array(7);&#13;
  usz[0] = v &amp; 127;&#13;
  var L = 1;&#13;
  sz:&#13;
    if (v &gt; 127) {&#13;
      usz[L - 1] |= 128;&#13;
      usz[L] = v &gt;&gt; 7 &amp; 127;&#13;
      ++L;&#13;
      if (v &lt;= 16383)&#13;
        break sz;&#13;
      usz[L - 1] |= 128;&#13;
      usz[L] = v &gt;&gt; 14 &amp; 127;&#13;
      ++L;&#13;
      if (v &lt;= 2097151)&#13;
        break sz;&#13;
      usz[L - 1] |= 128;&#13;
      usz[L] = v &gt;&gt; 21 &amp; 127;&#13;
      ++L;&#13;
      if (v &lt;= 268435455)&#13;
        break sz;&#13;
      usz[L - 1] |= 128;&#13;
      usz[L] = v / 256 &gt;&gt;&gt; 21 &amp; 127;&#13;
      ++L;&#13;
      if (v &lt;= 34359738367)&#13;
        break sz;&#13;
      usz[L - 1] |= 128;&#13;
      usz[L] = v / 65536 &gt;&gt;&gt; 21 &amp; 127;&#13;
      ++L;&#13;
      if (v &lt;= 4398046511103)&#13;
        break sz;&#13;
      usz[L - 1] |= 128;&#13;
      usz[L] = v / 16777216 &gt;&gt;&gt; 21 &amp; 127;&#13;
      ++L;&#13;
    }&#13;
  return usz[subarray](0, L);&#13;
}&#13;
function parse_packed_varints(buf) {&#13;
  var ptr = [0];&#13;
  var out = [];&#13;
  while (ptr[0] &lt; buf.length)&#13;
    out.push(parse_varint49(buf, ptr));&#13;
  return out;&#13;
}&#13;
function write_packed_varints(nums) {&#13;
  return u8concat(nums.map(function(x) {&#13;
    return write_varint49(x);&#13;
  }));&#13;
}&#13;
function varint_to_i32(buf) {&#13;
  var l = 0, i32 = buf[l] &amp; 127;&#13;
  varint:&#13;
    if (buf[l++] &gt;= 128) {&#13;
      i32 |= (buf[l] &amp; 127) &lt;&lt; 7;&#13;
      if (buf[l++] &lt; 128)&#13;
        break varint;&#13;
      i32 |= (buf[l] &amp; 127) &lt;&lt; 14;&#13;
      if (buf[l++] &lt; 128)&#13;
        break varint;&#13;
      i32 |= (buf[l] &amp; 127) &lt;&lt; 21;&#13;
      if (buf[l++] &lt; 128)&#13;
        break varint;&#13;
      i32 |= (buf[l] &amp; 127) &lt;&lt; 28;&#13;
    }&#13;
  return i32;&#13;
}&#13;
function varint_to_u64(buf) {&#13;
  var l = 0, lo = buf[l] &amp; 127, hi = 0;&#13;
  varint:&#13;
    if (buf[l++] &gt;= 128) {&#13;
      lo |= (buf[l] &amp; 127) &lt;&lt; 7;&#13;
      if (buf[l++] &lt; 128)&#13;
        break varint;&#13;
      lo |= (buf[l] &amp; 127) &lt;&lt; 14;&#13;
      if (buf[l++] &lt; 128)&#13;
        break varint;&#13;
      lo |= (buf[l] &amp; 127) &lt;&lt; 21;&#13;
      if (buf[l++] &lt; 128)&#13;
        break varint;&#13;
      lo |= (buf[l] &amp; 127) &lt;&lt; 28;&#13;
      hi = buf[l] &gt;&gt; 4 &amp; 7;&#13;
      if (buf[l++] &lt; 128)&#13;
        break varint;&#13;
      hi |= (buf[l] &amp; 127) &lt;&lt; 3;&#13;
      if (buf[l++] &lt; 128)&#13;
        break varint;&#13;
      hi |= (buf[l] &amp; 127) &lt;&lt; 10;&#13;
      if (buf[l++] &lt; 128)&#13;
        break varint;&#13;
      hi |= (buf[l] &amp; 127) &lt;&lt; 17;&#13;
      if (buf[l++] &lt; 128)&#13;
        break varint;&#13;
      hi |= (buf[l] &amp; 127) &lt;&lt; 24;&#13;
      if (buf[l++] &lt; 128)&#13;
        break varint;&#13;
      hi |= (buf[l] &amp; 127) &lt;&lt; 31;&#13;
    }&#13;
  return [lo &gt;&gt;&gt; 0, hi &gt;&gt;&gt; 0];&#13;
}&#13;
function parse_shallow(buf) {&#13;
  var out = [], ptr = [0];&#13;
  while (ptr[0] &lt; buf.length) {&#13;
    var off = ptr[0];&#13;
    var num = parse_varint49(buf, ptr);&#13;
    var type = num &amp; 7;&#13;
    num = Math.floor(num / 8);&#13;
    var len = 0;&#13;
    var res;&#13;
    if (num == 0)&#13;
      break;&#13;
    switch (type) {&#13;
      case 0:&#13;
        {&#13;
          var l = ptr[0];&#13;
          while (buf[ptr[0]++] &gt;= 128)&#13;
            ;&#13;
          res = buf[subarray](l, ptr[0]);&#13;
        }&#13;
        break;&#13;
      case 5:&#13;
        len = 4;&#13;
        res = buf[subarray](ptr[0], ptr[0] + len);&#13;
        ptr[0] += len;&#13;
        break;&#13;
      case 1:&#13;
        len = 8;&#13;
        res = buf[subarray](ptr[0], ptr[0] + len);&#13;
        ptr[0] += len;&#13;
        break;&#13;
      case 2:&#13;
        len = parse_varint49(buf, ptr);&#13;
        res = buf[subarray](ptr[0], ptr[0] + len);&#13;
        ptr[0] += len;&#13;
        break;&#13;
      case 3:&#13;
      case 4:&#13;
      default:&#13;
        throw new Error("PB Type ".concat(type, " for Field ").concat(num, " at offset ").concat(off));&#13;
    }&#13;
    var v = { data: res, type: type };&#13;
    if (out[num] == null)&#13;
      out[num] = [v];&#13;
    else&#13;
      out[num].push(v);&#13;
  }&#13;
  return out;&#13;
}&#13;
function write_shallow(proto) {&#13;
  var out = [];&#13;
  proto.forEach(function(field, idx) {&#13;
    if (idx == 0)&#13;
      return;&#13;
    field.forEach(function(item) {&#13;
      if (!item.data)&#13;
        return;&#13;
      out.push(write_varint49(idx * 8 + item.type));&#13;
      if (item.type == 2)&#13;
        out.push(write_varint49(item.data.length));&#13;
      out.push(item.data);&#13;
    });&#13;
  });&#13;
  return u8concat(out);&#13;
}&#13;
function mappa(data, cb) {&#13;
  return (data == null ? void 0 : data.map(function(d) {&#13;
    return cb(d.data);&#13;
  })) || [];&#13;
}&#13;
function parse_iwa_file(buf) {&#13;
  var _a;&#13;
  var out = [], ptr = [0];&#13;
  while (ptr[0] &lt; buf.length) {&#13;
    var len = parse_varint49(buf, ptr);&#13;
    var ai = parse_shallow(buf[subarray](ptr[0], ptr[0] + len));&#13;
    ptr[0] += len;&#13;
    var res = {&#13;
      id: varint_to_i32(ai[1][0].data),&#13;
      messages: []&#13;
    };&#13;
    ai[2].forEach(function(b) {&#13;
      var mi = parse_shallow(b.data);&#13;
      var fl = varint_to_i32(mi[3][0].data);&#13;
      res.messages.push({&#13;
        meta: mi,&#13;
        data: buf[subarray](ptr[0], ptr[0] + fl)&#13;
      });&#13;
      ptr[0] += fl;&#13;
    });&#13;
    if ((_a = ai[3]) == null ? void 0 : _a[0])&#13;
      res.merge = varint_to_i32(ai[3][0].data) &gt;&gt;&gt; 0 &gt; 0;&#13;
    out.push(res);&#13;
  }&#13;
  return out;&#13;
}&#13;
function write_iwa_file(ias) {&#13;
  var bufs = [];&#13;
  ias.forEach(function(ia) {&#13;
    var ai = [&#13;
      [],&#13;
      [{ data: write_varint49(ia.id), type: 0 }],&#13;
      []&#13;
    ];&#13;
    if (ia.merge != null)&#13;
      ai[3] = [{ data: write_varint49(+!!ia.merge), type: 0 }];&#13;
    var midata = [];&#13;
    ia.messages.forEach(function(mi) {&#13;
      midata.push(mi.data);&#13;
      mi.meta[3] = [{ type: 0, data: write_varint49(mi.data.length) }];&#13;
      ai[2].push({ data: write_shallow(mi.meta), type: 2 });&#13;
    });&#13;
    var aipayload = write_shallow(ai);&#13;
    bufs.push(write_varint49(aipayload.length));&#13;
    bufs.push(aipayload);&#13;
    midata.forEach(function(mid) {&#13;
      return bufs.push(mid);&#13;
    });&#13;
  });&#13;
  return u8concat(bufs);&#13;
}&#13;
function parse_snappy_chunk(type, buf) {&#13;
  if (type != 0)&#13;
    throw new Error("Unexpected Snappy chunk type ".concat(type));&#13;
  var ptr = [0];&#13;
  var usz = parse_varint49(buf, ptr);&#13;
  var chunks = [];&#13;
  while (ptr[0] &lt; buf.length) {&#13;
    var tag = buf[ptr[0]] &amp; 3;&#13;
    if (tag == 0) {&#13;
      var len = buf[ptr[0]++] &gt;&gt; 2;&#13;
      if (len &lt; 60)&#13;
        ++len;&#13;
      else {&#13;
        var c = len - 59;&#13;
        len = buf[ptr[0]];&#13;
        if (c &gt; 1)&#13;
          len |= buf[ptr[0] + 1] &lt;&lt; 8;&#13;
        if (c &gt; 2)&#13;
          len |= buf[ptr[0] + 2] &lt;&lt; 16;&#13;
        if (c &gt; 3)&#13;
          len |= buf[ptr[0] + 3] &lt;&lt; 24;&#13;
        len &gt;&gt;&gt;= 0;&#13;
        len++;&#13;
        ptr[0] += c;&#13;
      }&#13;
      chunks.push(buf[subarray](ptr[0], ptr[0] + len));&#13;
      ptr[0] += len;&#13;
      continue;&#13;
    } else {&#13;
      var offset = 0, length = 0;&#13;
      if (tag == 1) {&#13;
        length = (buf[ptr[0]] &gt;&gt; 2 &amp; 7) + 4;&#13;
        offset = (buf[ptr[0]++] &amp; 224) &lt;&lt; 3;&#13;
        offset |= buf[ptr[0]++];&#13;
      } else {&#13;
        length = (buf[ptr[0]++] &gt;&gt; 2) + 1;&#13;
        if (tag == 2) {&#13;
          offset = buf[ptr[0]] | buf[ptr[0] + 1] &lt;&lt; 8;&#13;
          ptr[0] += 2;&#13;
        } else {&#13;
          offset = (buf[ptr[0]] | buf[ptr[0] + 1] &lt;&lt; 8 | buf[ptr[0] + 2] &lt;&lt; 16 | buf[ptr[0] + 3] &lt;&lt; 24) &gt;&gt;&gt; 0;&#13;
          ptr[0] += 4;&#13;
        }&#13;
      }&#13;
      if (offset == 0)&#13;
        throw new Error("Invalid offset 0");&#13;
      var j = chunks.length - 1, off = offset;&#13;
      while (j &gt;= 0 &amp;&amp; off &gt;= chunks[j].length) {&#13;
        off -= chunks[j].length;&#13;
        --j;&#13;
      }&#13;
      if (j &lt; 0) {&#13;
        if (off == 0)&#13;
          off = chunks[j = 0].length;&#13;
        else&#13;
          throw new Error("Invalid offset beyond length");&#13;
      }&#13;
      if (length &lt; off)&#13;
        chunks.push(chunks[j][subarray](chunks[j].length - off, chunks[j].length - off + length));&#13;
      else {&#13;
        if (off &gt; 0) {&#13;
          chunks.push(chunks[j][subarray](chunks[j].length - off));&#13;
          length -= off;&#13;
        }&#13;
        ++j;&#13;
        while (length &gt;= chunks[j].length) {&#13;
          chunks.push(chunks[j]);&#13;
          length -= chunks[j].length;&#13;
          ++j;&#13;
        }&#13;
        if (length)&#13;
          chunks.push(chunks[j][subarray](0, length));&#13;
      }&#13;
      if (chunks.length &gt; 100)&#13;
        chunks = [u8concat(chunks)];&#13;
    }&#13;
  }&#13;
  if (chunks.reduce(function(acc, u8) {&#13;
    return acc + u8.length;&#13;
  }, 0) != usz)&#13;
    throw new Error("Unexpected length: ".concat(chunks.reduce(function(acc, u8) {&#13;
      return acc + u8.length;&#13;
    }, 0), " != ").concat(usz));&#13;
  return chunks;&#13;
}&#13;
function decompress_iwa_file(buf) {&#13;
  if (Array.isArray(buf))&#13;
    buf = new Uint8Array(buf);&#13;
  var out = [];&#13;
  var l = 0;&#13;
  while (l &lt; buf.length) {&#13;
    var t = buf[l++];&#13;
    var len = buf[l] | buf[l + 1] &lt;&lt; 8 | buf[l + 2] &lt;&lt; 16;&#13;
    l += 3;&#13;
    out.push.apply(out, parse_snappy_chunk(t, buf[subarray](l, l + len)));&#13;
    l += len;&#13;
  }&#13;
  if (l !== buf.length)&#13;
    throw new Error("data is not a valid framed stream!");&#13;
  return u8concat(out);&#13;
}&#13;
function compress_iwa_file(buf) {&#13;
  var out = [];&#13;
  var l = 0;&#13;
  while (l &lt; buf.length) {&#13;
    var c = Math.min(buf.length - l, 268435455);&#13;
    var frame = new Uint8Array(4);&#13;
    out.push(frame);&#13;
    var usz = write_varint49(c);&#13;
    var L = usz.length;&#13;
    out.push(usz);&#13;
    if (c &lt;= 60) {&#13;
      L++;&#13;
      out.push(new Uint8Array([c - 1 &lt;&lt; 2]));&#13;
    } else if (c &lt;= 256) {&#13;
      L += 2;&#13;
      out.push(new Uint8Array([240, c - 1 &amp; 255]));&#13;
    } else if (c &lt;= 65536) {&#13;
      L += 3;&#13;
      out.push(new Uint8Array([244, c - 1 &amp; 255, c - 1 &gt;&gt; 8 &amp; 255]));&#13;
    } else if (c &lt;= 16777216) {&#13;
      L += 4;&#13;
      out.push(new Uint8Array([248, c - 1 &amp; 255, c - 1 &gt;&gt; 8 &amp; 255, c - 1 &gt;&gt; 16 &amp; 255]));&#13;
    } else if (c &lt;= 4294967296) {&#13;
      L += 5;&#13;
      out.push(new Uint8Array([252, c - 1 &amp; 255, c - 1 &gt;&gt; 8 &amp; 255, c - 1 &gt;&gt; 16 &amp; 255, c - 1 &gt;&gt;&gt; 24 &amp; 255]));&#13;
    }&#13;
    out.push(buf[subarray](l, l + c));&#13;
    L += c;&#13;
    frame[0] = 0;&#13;
    frame[1] = L &amp; 255;&#13;
    frame[2] = L &gt;&gt; 8 &amp; 255;&#13;
    frame[3] = L &gt;&gt; 16 &amp; 255;&#13;
    l += c;&#13;
  }&#13;
  return u8concat(out);&#13;
}&#13;
var numbers_lut_new = function() {&#13;
  return { sst: [], rsst: [], ofmt: [], nfmt: [] };&#13;
};&#13;
function numbers_format_cell(cell, t, flags, ofmt, nfmt) {&#13;
  var _a, _b, _c, _d;&#13;
  var ctype = t &amp; 255, ver = t &gt;&gt; 8;&#13;
  var fmt = ver &gt;= 5 ? nfmt : ofmt;&#13;
  dur:&#13;
    if (flags &amp; (ver &gt; 4 ? 8 : 4) &amp;&amp; cell.t == "n" &amp;&amp; ctype == 7) {&#13;
      var dstyle = ((_a = fmt[7]) == null ? void 0 : _a[0]) ? parse_varint49(fmt[7][0].data) : -1;&#13;
      if (dstyle == -1)&#13;
        break dur;&#13;
      var dmin = ((_b = fmt[15]) == null ? void 0 : _b[0]) ? parse_varint49(fmt[15][0].data) : -1;&#13;
      var dmax = ((_c = fmt[16]) == null ? void 0 : _c[0]) ? parse_varint49(fmt[16][0].data) : -1;&#13;
      var auto = ((_d = fmt[40]) == null ? void 0 : _d[0]) ? parse_varint49(fmt[40][0].data) : -1;&#13;
      var d = cell.v, dd = d;&#13;
      autodur:&#13;
        if (auto) {&#13;
          if (d == 0) {&#13;
            dmin = dmax = 2;&#13;
            break autodur;&#13;
          }&#13;
          if (d &gt;= 604800)&#13;
            dmin = 1;&#13;
          else if (d &gt;= 86400)&#13;
            dmin = 2;&#13;
          else if (d &gt;= 3600)&#13;
            dmin = 4;&#13;
          else if (d &gt;= 60)&#13;
            dmin = 8;&#13;
          else if (d &gt;= 1)&#13;
            dmin = 16;&#13;
          else&#13;
            dmin = 32;&#13;
          if (Math.floor(d) != d)&#13;
            dmax = 32;&#13;
          else if (d % 60)&#13;
            dmax = 16;&#13;
          else if (d % 3600)&#13;
            dmax = 8;&#13;
          else if (d % 86400)&#13;
            dmax = 4;&#13;
          else if (d % 604800)&#13;
            dmax = 2;&#13;
          if (dmax &lt; dmin)&#13;
            dmax = dmin;&#13;
        }&#13;
      if (dmin == -1 || dmax == -1)&#13;
        break dur;&#13;
      var dstr = [], zstr = [];&#13;
      if (dmin == 1) {&#13;
        dd = d / 604800;&#13;
        if (dmax == 1) {&#13;
          zstr.push('d"d"');&#13;
        } else {&#13;
          dd |= 0;&#13;
          d -= 604800 * dd;&#13;
        }&#13;
        dstr.push(dd + (dstyle == 2 ? " week" + (dd == 1 ? "" : "s") : dstyle == 1 ? "w" : ""));&#13;
      }&#13;
      if (dmin &lt;= 2 &amp;&amp; dmax &gt;= 2) {&#13;
        dd = d / 86400;&#13;
        if (dmax &gt; 2) {&#13;
          dd |= 0;&#13;
          d -= 86400 * dd;&#13;
        }&#13;
        zstr.push('d"d"');&#13;
        dstr.push(dd + (dstyle == 2 ? " day" + (dd == 1 ? "" : "s") : dstyle == 1 ? "d" : ""));&#13;
      }&#13;
      if (dmin &lt;= 4 &amp;&amp; dmax &gt;= 4) {&#13;
        dd = d / 3600;&#13;
        if (dmax &gt; 4) {&#13;
          dd |= 0;&#13;
          d -= 3600 * dd;&#13;
        }&#13;
        zstr.push((dmin &gt;= 4 ? "[h]" : "h") + '"h"');&#13;
        dstr.push(dd + (dstyle == 2 ? " hour" + (dd == 1 ? "" : "s") : dstyle == 1 ? "h" : ""));&#13;
      }&#13;
      if (dmin &lt;= 8 &amp;&amp; dmax &gt;= 8) {&#13;
        dd = d / 60;&#13;
        if (dmax &gt; 8) {&#13;
          dd |= 0;&#13;
          d -= 60 * dd;&#13;
        }&#13;
        zstr.push((dmin &gt;= 8 ? "[m]" : "m") + '"m"');&#13;
        if (dstyle == 0)&#13;
          dstr.push((dmin == 8 &amp;&amp; dmax == 8 || dd &gt;= 10 ? "" : "0") + dd);&#13;
        else&#13;
          dstr.push(dd + (dstyle == 2 ? " minute" + (dd == 1 ? "" : "s") : dstyle == 1 ? "m" : ""));&#13;
      }&#13;
      if (dmin &lt;= 16 &amp;&amp; dmax &gt;= 16) {&#13;
        dd = d;&#13;
        if (dmax &gt; 16) {&#13;
          dd |= 0;&#13;
          d -= dd;&#13;
        }&#13;
        zstr.push((dmin &gt;= 16 ? "[s]" : "s") + '"s"');&#13;
        if (dstyle == 0)&#13;
          dstr.push((dmax == 16 &amp;&amp; dmin == 16 || dd &gt;= 10 ? "" : "0") + dd);&#13;
        else&#13;
          dstr.push(dd + (dstyle == 2 ? " second" + (dd == 1 ? "" : "s") : dstyle == 1 ? "s" : ""));&#13;
      }&#13;
      if (dmax &gt;= 32) {&#13;
        dd = Math.round(1e3 * d);&#13;
        if (dmin &lt; 32)&#13;
          zstr.push('.000"ms"');&#13;
        if (dstyle == 0)&#13;
          dstr.push((dd &gt;= 100 ? "" : dd &gt;= 10 ? "0" : "00") + dd);&#13;
        else&#13;
          dstr.push(dd + (dstyle == 2 ? " millisecond" + (dd == 1 ? "" : "s") : dstyle == 1 ? "ms" : ""));&#13;
      }&#13;
      cell.w = dstr.join(dstyle == 0 ? ":" : " ");&#13;
      cell.z = zstr.join(dstyle == 0 ? '":"' : " ");&#13;
      if (dstyle == 0)&#13;
        cell.w = cell.w.replace(/:(\d\d\d)$/, ".$1");&#13;
    }&#13;
}&#13;
function parse_old_storage(buf, lut, v) {&#13;
  var dv = u8_to_dataview(buf);&#13;
  var flags = dv.getUint32(4, true);&#13;
  var ridx = -1, sidx = -1, zidx = -1, ieee = NaN, dt = new Date(2001, 0, 1);&#13;
  var doff = v &gt; 1 ? 12 : 8;&#13;
  if (flags &amp; 2) {&#13;
    zidx = dv.getUint32(doff, true);&#13;
    doff += 4;&#13;
  }&#13;
  doff += popcnt(flags &amp; (v &gt; 1 ? 3468 : 396)) * 4;&#13;
  if (flags &amp; 512) {&#13;
    ridx = dv.getUint32(doff, true);&#13;
    doff += 4;&#13;
  }&#13;
  doff += popcnt(flags &amp; (v &gt; 1 ? 12288 : 4096)) * 4;&#13;
  if (flags &amp; 16) {&#13;
    sidx = dv.getUint32(doff, true);&#13;
    doff += 4;&#13;
  }&#13;
  if (flags &amp; 32) {&#13;
    ieee = dv.getFloat64(doff, true);&#13;
    doff += 8;&#13;
  }&#13;
  if (flags &amp; 64) {&#13;
    dt.setTime(dt.getTime() + dv.getFloat64(doff, true) * 1e3);&#13;
    doff += 8;&#13;
  }&#13;
  if (v &gt; 1) {&#13;
    flags = dv.getUint32(8, true) &gt;&gt;&gt; 16;&#13;
    if (flags &amp; 255) {&#13;
      if (zidx == -1)&#13;
        zidx = dv.getUint32(doff, true);&#13;
      doff += 4;&#13;
    }&#13;
  }&#13;
  var ret;&#13;
  var t = buf[v &gt;= 4 ? 1 : 2];&#13;
  switch (t) {&#13;
    case 0:&#13;
      return void 0;&#13;
    case 2:&#13;
      ret = { t: "n", v: ieee };&#13;
      break;&#13;
    case 3:&#13;
      ret = { t: "s", v: lut.sst[sidx] };&#13;
      break;&#13;
    case 5:&#13;
      ret = { t: "d", v: dt };&#13;
      break;&#13;
    case 6:&#13;
      ret = { t: "b", v: ieee &gt; 0 };&#13;
      break;&#13;
    case 7:&#13;
      ret = { t: "n", v: ieee };&#13;
      break;&#13;
    case 8:&#13;
      ret = { t: "e", v: 0 };&#13;
      break;&#13;
    case 9:&#13;
      {&#13;
        if (ridx &gt; -1)&#13;
          ret = { t: "s", v: lut.rsst[ridx] };&#13;
        else&#13;
          throw new Error("Unsupported cell type ".concat(buf[subarray](0, 4)));&#13;
      }&#13;
      break;&#13;
    default:&#13;
      throw new Error("Unsupported cell type ".concat(buf[subarray](0, 4)));&#13;
  }&#13;
  if (zidx &gt; -1)&#13;
    numbers_format_cell(ret, t | v &lt;&lt; 8, flags, lut.ofmt[zidx], lut.nfmt[zidx]);&#13;
  if (t == 7)&#13;
    ret.v /= 86400;&#13;
  return ret;&#13;
}&#13;
function parse_new_storage(buf, lut) {&#13;
  var dv = u8_to_dataview(buf);&#13;
  var flags = dv.getUint32(4, true);&#13;
  var fields = dv.getUint32(8, true);&#13;
  var doff = 12;&#13;
  var ridx = -1, sidx = -1, zidx = -1, d128 = NaN, ieee = NaN, dt = new Date(2001, 0, 1);&#13;
  if (fields &amp; 1) {&#13;
    d128 = readDecimal128LE(buf, doff);&#13;
    doff += 16;&#13;
  }&#13;
  if (fields &amp; 2) {&#13;
    ieee = dv.getFloat64(doff, true);&#13;
    doff += 8;&#13;
  }&#13;
  if (fields &amp; 4) {&#13;
    dt.setTime(dt.getTime() + dv.getFloat64(doff, true) * 1e3);&#13;
    doff += 8;&#13;
  }&#13;
  if (fields &amp; 8) {&#13;
    sidx = dv.getUint32(doff, true);&#13;
    doff += 4;&#13;
  }&#13;
  if (fields &amp; 16) {&#13;
    ridx = dv.getUint32(doff, true);&#13;
    doff += 4;&#13;
  }&#13;
  var ret;&#13;
  var t = buf[1];&#13;
  switch (t) {&#13;
    case 0:&#13;
      return void 0;&#13;
    case 2:&#13;
      ret = { t: "n", v: d128 };&#13;
      break;&#13;
    case 3:&#13;
      ret = { t: "s", v: lut.sst[sidx] };&#13;
      break;&#13;
    case 5:&#13;
      ret = { t: "d", v: dt };&#13;
      break;&#13;
    case 6:&#13;
      ret = { t: "b", v: ieee &gt; 0 };&#13;
      break;&#13;
    case 7:&#13;
      ret = { t: "n", v: ieee };&#13;
      break;&#13;
    case 8:&#13;
      ret = { t: "e", v: 0 };&#13;
      break;&#13;
    case 9:&#13;
      ret = { t: "s", v: lut.rsst[ridx] };&#13;
      break;&#13;
    case 10:&#13;
      ret = { t: "n", v: d128 };&#13;
      break;&#13;
    default:&#13;
      throw new Error("Unsupported cell type ".concat(buf[1], " : ").concat(fields &amp; 31, " : ").concat(buf[subarray](0, 4)));&#13;
  }&#13;
  doff += popcnt(fields &amp; 8160) * 4;&#13;
  if (fields &amp; 516096) {&#13;
    if (zidx == -1)&#13;
      zidx = dv.getUint32(doff, true);&#13;
    doff += 4;&#13;
  }&#13;
  if (zidx &gt; -1)&#13;
    numbers_format_cell(ret, t | 5 &lt;&lt; 8, fields &gt;&gt; 13, lut.ofmt[zidx], lut.nfmt[zidx]);&#13;
  if (t == 7)&#13;
    ret.v /= 86400;&#13;
  return ret;&#13;
}&#13;
function write_new_storage(cell, sst) {&#13;
  var out = new Uint8Array(32), dv = u8_to_dataview(out), l = 12, flags = 0;&#13;
  out[0] = 5;&#13;
  switch (cell.t) {&#13;
    case "n":&#13;
      out[1] = 2;&#13;
      writeDecimal128LE(out, l, cell.v);&#13;
      flags |= 1;&#13;
      l += 16;&#13;
      break;&#13;
    case "b":&#13;
      out[1] = 6;&#13;
      dv.setFloat64(l, cell.v ? 1 : 0, true);&#13;
      flags |= 2;&#13;
      l += 8;&#13;
      break;&#13;
    case "s":&#13;
      var s = cell.v == null ? "" : String(cell.v);&#13;
      var isst = sst.indexOf(s);&#13;
      if (isst == -1)&#13;
        sst[isst = sst.length] = s;&#13;
      out[1] = 3;&#13;
      dv.setUint32(l, isst, true);&#13;
      flags |= 8;&#13;
      l += 4;&#13;
      break;&#13;
    default:&#13;
      throw "unsupported cell type " + cell.t;&#13;
  }&#13;
  dv.setUint32(8, flags, true);&#13;
  return out[subarray](0, l);&#13;
}&#13;
function write_old_storage(cell, sst) {&#13;
  var out = new Uint8Array(32), dv = u8_to_dataview(out), l = 12, flags = 0;&#13;
  out[0] = 4;&#13;
  switch (cell.t) {&#13;
    case "n":&#13;
      out[2] = 2;&#13;
      dv.setFloat64(l, cell.v, true);&#13;
      flags |= 32;&#13;
      l += 8;&#13;
      break;&#13;
    case "b":&#13;
      out[2] = 6;&#13;
      dv.setFloat64(l, cell.v ? 1 : 0, true);&#13;
      flags |= 32;&#13;
      l += 8;&#13;
      break;&#13;
    case "s":&#13;
      var s = cell.v == null ? "" : String(cell.v);&#13;
      var isst = sst.indexOf(s);&#13;
      if (isst == -1)&#13;
        sst[isst = sst.length] = s;&#13;
      out[2] = 3;&#13;
      dv.setUint32(l, isst, true);&#13;
      flags |= 16;&#13;
      l += 4;&#13;
      break;&#13;
    default:&#13;
      throw "unsupported cell type " + cell.t;&#13;
  }&#13;
  dv.setUint32(8, flags, true);&#13;
  return out[subarray](0, l);&#13;
}&#13;
function parse_cell_storage(buf, lut) {&#13;
  switch (buf[0]) {&#13;
    case 0:&#13;
    case 1:&#13;
    case 2:&#13;
    case 3:&#13;
    case 4:&#13;
      return parse_old_storage(buf, lut, buf[0]);&#13;
    case 5:&#13;
      return parse_new_storage(buf, lut);&#13;
    default:&#13;
      throw new Error("Unsupported payload version ".concat(buf[0]));&#13;
  }&#13;
}&#13;
function parse_TSP_Reference(buf) {&#13;
  var pb = parse_shallow(buf);&#13;
  return parse_varint49(pb[1][0].data);&#13;
}&#13;
function write_TSP_Reference(idx) {&#13;
  return write_shallow([&#13;
    [],&#13;
    [{ type: 0, data: write_varint49(idx) }]&#13;
  ]);&#13;
}&#13;
function numbers_add_oref(iwa, ref) {&#13;
  var _a;&#13;
  var orefs = ((_a = iwa.messages[0].meta[5]) == null ? void 0 : _a[0]) ? parse_packed_varints(iwa.messages[0].meta[5][0].data) : [];&#13;
  var orefidx = orefs.indexOf(ref);&#13;
  if (orefidx == -1) {&#13;
    orefs.push(ref);&#13;
    iwa.messages[0].meta[5] = [{ type: 2, data: write_packed_varints(orefs) }];&#13;
  }&#13;
}&#13;
function numbers_del_oref(iwa, ref) {&#13;
  var _a;&#13;
  var orefs = ((_a = iwa.messages[0].meta[5]) == null ? void 0 : _a[0]) ? parse_packed_varints(iwa.messages[0].meta[5][0].data) : [];&#13;
  iwa.messages[0].meta[5] = [{ type: 2, data: write_packed_varints(orefs.filter(function(r) {&#13;
    return r != ref;&#13;
  })) }];&#13;
}&#13;
function parse_TST_TableDataList(M, root) {&#13;
  var pb = parse_shallow(root.data);&#13;
  var type = varint_to_i32(pb[1][0].data);&#13;
  var entries = pb[3];&#13;
  var data = [];&#13;
  (entries || []).forEach(function(entry) {&#13;
    var le = parse_shallow(entry.data);&#13;
    if (!le[1])&#13;
      return;&#13;
    var key = varint_to_i32(le[1][0].data) &gt;&gt;&gt; 0;&#13;
    switch (type) {&#13;
      case 1:&#13;
        data[key] = u8str(le[3][0].data);&#13;
        break;&#13;
      case 8:&#13;
        {&#13;
          var rt = M[parse_TSP_Reference(le[9][0].data)][0];&#13;
          var rtp = parse_shallow(rt.data);&#13;
          var rtpref = M[parse_TSP_Reference(rtp[1][0].data)][0];&#13;
          var mtype = varint_to_i32(rtpref.meta[1][0].data);&#13;
          if (mtype != 2001)&#13;
            throw new Error("2000 unexpected reference to ".concat(mtype));&#13;
          var tswpsa = parse_shallow(rtpref.data);&#13;
          data[key] = tswpsa[3].map(function(x) {&#13;
            return u8str(x.data);&#13;
          }).join("");&#13;
        }&#13;
        break;&#13;
      case 2:&#13;
        data[key] = parse_shallow(le[6][0].data);&#13;
        break;&#13;
      default:&#13;
        throw type;&#13;
    }&#13;
  });&#13;
  return data;&#13;
}&#13;
function parse_TST_TileRowInfo(u8, type) {&#13;
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;&#13;
  var pb = parse_shallow(u8);&#13;
  var R = varint_to_i32(pb[1][0].data) &gt;&gt;&gt; 0;&#13;
  var cnt = varint_to_i32(pb[2][0].data) &gt;&gt;&gt; 0;&#13;
  var wide_offsets = ((_b = (_a = pb[8]) == null ? void 0 : _a[0]) == null ? void 0 : _b.data) &amp;&amp; varint_to_i32(pb[8][0].data) &gt; 0 || false;&#13;
  var used_storage_u8, used_storage;&#13;
  if (((_d = (_c = pb[7]) == null ? void 0 : _c[0]) == null ? void 0 : _d.data) &amp;&amp; type != 0) {&#13;
    used_storage_u8 = (_f = (_e = pb[7]) == null ? void 0 : _e[0]) == null ? void 0 : _f.data;&#13;
    used_storage = (_h = (_g = pb[6]) == null ? void 0 : _g[0]) == null ? void 0 : _h.data;&#13;
  } else if (((_j = (_i = pb[4]) == null ? void 0 : _i[0]) == null ? void 0 : _j.data) &amp;&amp; type != 1) {&#13;
    used_storage_u8 = (_l = (_k = pb[4]) == null ? void 0 : _k[0]) == null ? void 0 : _l.data;&#13;
    used_storage = (_n = (_m = pb[3]) == null ? void 0 : _m[0]) == null ? void 0 : _n.data;&#13;
  } else&#13;
    throw "NUMBERS Tile missing ".concat(type, " cell storage");&#13;
  var width = wide_offsets ? 4 : 1;&#13;
  var used_storage_offsets = u8_to_dataview(used_storage_u8);&#13;
  var offsets = [];&#13;
  for (var C = 0; C &lt; used_storage_u8.length / 2; ++C) {&#13;
    var off = used_storage_offsets.getUint16(C * 2, true);&#13;
    if (off &lt; 65535)&#13;
      offsets.push([C, off]);&#13;
  }&#13;
  if (offsets.length != cnt)&#13;
    throw "Expected ".concat(cnt, " cells, found ").concat(offsets.length);&#13;
  var cells = [];&#13;
  for (C = 0; C &lt; offsets.length - 1; ++C)&#13;
    cells[offsets[C][0]] = used_storage[subarray](offsets[C][1] * width, offsets[C + 1][1] * width);&#13;
  if (offsets.length &gt;= 1)&#13;
    cells[offsets[offsets.length - 1][0]] = used_storage[subarray](offsets[offsets.length - 1][1] * width);&#13;
  return { R: R, cells: cells };&#13;
}&#13;
function parse_TST_Tile(M, root) {&#13;
  var _a;&#13;
  var pb = parse_shallow(root.data);&#13;
  var storage = -1;&#13;
  if ((_a = pb == null ? void 0 : pb[7]) == null ? void 0 : _a[0]) {&#13;
    if (varint_to_i32(pb[7][0].data) &gt;&gt;&gt; 0)&#13;
      storage = 1;&#13;
    else&#13;
      storage = 0;&#13;
  }&#13;
  var ri = mappa(pb[5], function(u8) {&#13;
    return parse_TST_TileRowInfo(u8, storage);&#13;
  });&#13;
  return {&#13;
    nrows: varint_to_i32(pb[4][0].data) &gt;&gt;&gt; 0,&#13;
    data: ri.reduce(function(acc, x) {&#13;
      if (!acc[x.R])&#13;
        acc[x.R] = [];&#13;
      x.cells.forEach(function(cell, C) {&#13;
        if (acc[x.R][C])&#13;
          throw new Error("Duplicate cell r=".concat(x.R, " c=").concat(C));&#13;
        acc[x.R][C] = cell;&#13;
      });&#13;
      return acc;&#13;
    }, [])&#13;
  };&#13;
}&#13;
function parse_TST_TableModelArchive(M, root, ws) {&#13;
  var _a, _b, _c, _d, _e, _f;&#13;
  var pb = parse_shallow(root.data);&#13;
  var range = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } };&#13;
  range.e.r = (varint_to_i32(pb[6][0].data) &gt;&gt;&gt; 0) - 1;&#13;
  if (range.e.r &lt; 0)&#13;
    throw new Error("Invalid row varint ".concat(pb[6][0].data));&#13;
  range.e.c = (varint_to_i32(pb[7][0].data) &gt;&gt;&gt; 0) - 1;&#13;
  if (range.e.c &lt; 0)&#13;
    throw new Error("Invalid col varint ".concat(pb[7][0].data));&#13;
  ws["!ref"] = encode_range(range);&#13;
  var dense = Array.isArray(ws);&#13;
  var store = parse_shallow(pb[4][0].data);&#13;
  var lut = numbers_lut_new();&#13;
  if ((_a = store[4]) == null ? void 0 : _a[0])&#13;
    lut.sst = parse_TST_TableDataList(M, M[parse_TSP_Reference(store[4][0].data)][0]);&#13;
  if ((_b = store[11]) == null ? void 0 : _b[0])&#13;
    lut.ofmt = parse_TST_TableDataList(M, M[parse_TSP_Reference(store[11][0].data)][0]);&#13;
  if ((_c = store[17]) == null ? void 0 : _c[0])&#13;
    lut.rsst = parse_TST_TableDataList(M, M[parse_TSP_Reference(store[17][0].data)][0]);&#13;
  if ((_d = store[22]) == null ? void 0 : _d[0])&#13;
    lut.nfmt = parse_TST_TableDataList(M, M[parse_TSP_Reference(store[22][0].data)][0]);&#13;
  var tile = parse_shallow(store[3][0].data);&#13;
  var _R = 0;&#13;
  tile[1].forEach(function(t) {&#13;
    var tl = parse_shallow(t.data);&#13;
    var ref2 = M[parse_TSP_Reference(tl[2][0].data)][0];&#13;
    var mtype2 = varint_to_i32(ref2.meta[1][0].data);&#13;
    if (mtype2 != 6002)&#13;
      throw new Error("6001 unexpected reference to ".concat(mtype2));&#13;
    var _tile = parse_TST_Tile(M, ref2);&#13;
    _tile.data.forEach(function(row, R) {&#13;
      row.forEach(function(buf, C) {&#13;
        var res = parse_cell_storage(buf, lut);&#13;
        if (res) {&#13;
          if (dense) {&#13;
            if (!ws[_R + R])&#13;
              ws[_R + R] = [];&#13;
            ws[_R + R][C] = res;&#13;
          } else {&#13;
            var addr = encode_cell({ r: _R + R, c: C });&#13;
            ws[addr] = res;&#13;
          }&#13;
        }&#13;
      });&#13;
    });&#13;
    _R += _tile.nrows;&#13;
  });&#13;
  if ((_e = store[13]) == null ? void 0 : _e[0]) {&#13;
    var ref = M[parse_TSP_Reference(store[13][0].data)][0];&#13;
    var mtype = varint_to_i32(ref.meta[1][0].data);&#13;
    if (mtype != 6144)&#13;
      throw new Error("Expected merge type 6144, found ".concat(mtype));&#13;
    ws["!merges"] = (_f = parse_shallow(ref.data)) == null ? void 0 : _f[1].map(function(pi) {&#13;
      var merge = parse_shallow(pi.data);&#13;
      var origin = u8_to_dataview(parse_shallow(merge[1][0].data)[1][0].data), size = u8_to_dataview(parse_shallow(merge[2][0].data)[1][0].data);&#13;
      return {&#13;
        s: { r: origin.getUint16(0, true), c: origin.getUint16(2, true) },&#13;
        e: {&#13;
          r: origin.getUint16(0, true) + size.getUint16(0, true) - 1,&#13;
          c: origin.getUint16(2, true) + size.getUint16(2, true) - 1&#13;
        }&#13;
      };&#13;
    });&#13;
  }&#13;
}&#13;
function parse_TST_TableInfoArchive(M, root, opts) {&#13;
  var pb = parse_shallow(root.data);&#13;
  var out;&#13;
  if (!(opts == null ? void 0 : opts.dense))&#13;
    out = { "!ref": "A1" };&#13;
  else&#13;
    out = [];&#13;
  out["!ref"] = "A1";&#13;
  var tableref = M[parse_TSP_Reference(pb[2][0].data)];&#13;
  var mtype = varint_to_i32(tableref[0].meta[1][0].data);&#13;
  if (mtype != 6001)&#13;
    throw new Error("6000 unexpected reference to ".concat(mtype));&#13;
  parse_TST_TableModelArchive(M, tableref[0], out);&#13;
  return out;&#13;
}&#13;
function parse_TN_SheetArchive(M, root, opts) {&#13;
  var _a;&#13;
  var pb = parse_shallow(root.data);&#13;
  var out = {&#13;
    name: ((_a = pb[1]) == null ? void 0 : _a[0]) ? u8str(pb[1][0].data) : "",&#13;
    sheets: []&#13;
  };&#13;
  var shapeoffs = mappa(pb[2], parse_TSP_Reference);&#13;
  shapeoffs.forEach(function(off) {&#13;
    M[off].forEach(function(m) {&#13;
      var mtype = varint_to_i32(m.meta[1][0].data);&#13;
      if (mtype == 6e3)&#13;
        out.sheets.push(parse_TST_TableInfoArchive(M, m, opts));&#13;
    });&#13;
  });&#13;
  return out;&#13;
}&#13;
function parse_TN_DocumentArchive(M, root, opts) {&#13;
  var _a;&#13;
  var out = book_new();&#13;
  var pb = parse_shallow(root.data);&#13;
  if ((_a = pb[2]) == null ? void 0 : _a[0])&#13;
    throw new Error("Keynote presentations are not supported");&#13;
  var sheetoffs = mappa(pb[1], parse_TSP_Reference);&#13;
  sheetoffs.forEach(function(off) {&#13;
    M[off].forEach(function(m) {&#13;
      var mtype = varint_to_i32(m.meta[1][0].data);&#13;
      if (mtype == 2) {&#13;
        var root2 = parse_TN_SheetArchive(M, m, opts);&#13;
        root2.sheets.forEach(function(sheet, idx) {&#13;
          book_append_sheet(out, sheet, idx == 0 ? root2.name : root2.name + "_" + idx, true);&#13;
        });&#13;
      }&#13;
    });&#13;
  });&#13;
  if (out.SheetNames.length == 0)&#13;
    throw new Error("Empty NUMBERS file");&#13;
  out.bookType = "numbers";&#13;
  return out;&#13;
}&#13;
function parse_numbers_iwa(cfb, opts) {&#13;
  var _a, _b, _c, _d, _e, _f, _g;&#13;
  var M = {}, indices = [];&#13;
  cfb.FullPaths.forEach(function(p) {&#13;
    if (p.match(/\.iwpv2/))&#13;
      throw new Error("Unsupported password protection");&#13;
  });&#13;
  cfb.FileIndex.forEach(function(s) {&#13;
    if (!s.name.match(/\.iwa$/))&#13;
      return;&#13;
    if (s.content[0] == 98)&#13;
      return;&#13;
    var o;&#13;
    try {&#13;
      o = decompress_iwa_file(s.content);&#13;
    } catch (e) {&#13;
      return console.log("?? " + s.content.length + " " + (e.message || e));&#13;
    }&#13;
    var packets;&#13;
    try {&#13;
      packets = parse_iwa_file(o);&#13;
    } catch (e) {&#13;
      return console.log("## " + (e.message || e));&#13;
    }&#13;
    packets.forEach(function(packet) {&#13;
      M[packet.id] = packet.messages;&#13;
      indices.push(packet.id);&#13;
    });&#13;
  });&#13;
  if (!indices.length)&#13;
    throw new Error("File has no messages");&#13;
  if (((_c = (_b = (_a = M == null ? void 0 : M[1]) == null ? void 0 : _a[0].meta) == null ? void 0 : _b[1]) == null ? void 0 : _c[0].data) &amp;&amp; varint_to_i32(M[1][0].meta[1][0].data) == 1e4)&#13;
    throw new Error("Pages documents are not supported");&#13;
  var docroot = ((_g = (_f = (_e = (_d = M == null ? void 0 : M[1]) == null ? void 0 : _d[0]) == null ? void 0 : _e.meta) == null ? void 0 : _f[1]) == null ? void 0 : _g[0].data) &amp;&amp; varint_to_i32(M[1][0].meta[1][0].data) == 1 &amp;&amp; M[1][0];&#13;
  if (!docroot)&#13;
    indices.forEach(function(idx) {&#13;
      M[idx].forEach(function(iwam) {&#13;
        var mtype = varint_to_i32(iwam.meta[1][0].data) &gt;&gt;&gt; 0;&#13;
        if (mtype == 1) {&#13;
          if (!docroot)&#13;
            docroot = iwam;&#13;
          else&#13;
            throw new Error("Document has multiple roots");&#13;
        }&#13;
      });&#13;
    });&#13;
  if (!docroot)&#13;
    throw new Error("Cannot find Document root");&#13;
  return parse_TN_DocumentArchive(M, docroot, opts);&#13;
}&#13;
function write_TST_TileRowInfo(data, SST, wide) {&#13;
  var _a, _b;&#13;
  var tri = [&#13;
    [],&#13;
    [{ type: 0, data: write_varint49(0) }],&#13;
    [{ type: 0, data: write_varint49(0) }],&#13;
    [{ type: 2, data: new Uint8Array([]) }],&#13;
    [{ type: 2, data: new Uint8Array(Array.from({ length: 510 }, function() {&#13;
      return 255;&#13;
    })) }],&#13;
    [{ type: 0, data: write_varint49(5) }],&#13;
    [{ type: 2, data: new Uint8Array([]) }],&#13;
    [{ type: 2, data: new Uint8Array(Array.from({ length: 510 }, function() {&#13;
      return 255;&#13;
    })) }],&#13;
    [{ type: 0, data: write_varint49(1) }]&#13;
  ];&#13;
  if (!((_a = tri[6]) == null ? void 0 : _a[0]) || !((_b = tri[7]) == null ? void 0 : _b[0]))&#13;
    throw "Mutation only works on post-BNC storages!";&#13;
  var cnt = 0;&#13;
  if (tri[7][0].data.length &lt; 2 * data.length) {&#13;
    var new_7 = new Uint8Array(2 * data.length);&#13;
    new_7.set(tri[7][0].data);&#13;
    tri[7][0].data = new_7;&#13;
  }&#13;
  if (tri[4][0].data.length &lt; 2 * data.length) {&#13;
    var new_4 = new Uint8Array(2 * data.length);&#13;
    new_4.set(tri[4][0].data);&#13;
    tri[4][0].data = new_4;&#13;
  }&#13;
  var dv = u8_to_dataview(tri[7][0].data), last_offset = 0, cell_storage = [];&#13;
  var _dv = u8_to_dataview(tri[4][0].data), _last_offset = 0, _cell_storage = [];&#13;
  var width = wide ? 4 : 1;&#13;
  for (var C = 0; C &lt; data.length; ++C) {&#13;
    if (data[C] == null) {&#13;
      dv.setUint16(C * 2, 65535, true);&#13;
      _dv.setUint16(C * 2, 65535);&#13;
      continue;&#13;
    }&#13;
    dv.setUint16(C * 2, last_offset / width, true);&#13;
    _dv.setUint16(C * 2, _last_offset / width, true);&#13;
    var celload, _celload;&#13;
    switch (typeof data[C]) {&#13;
      case "string":&#13;
        celload = write_new_storage({ t: "s", v: data[C] }, SST);&#13;
        _celload = write_old_storage({ t: "s", v: data[C] }, SST);&#13;
        break;&#13;
      case "number":&#13;
        celload = write_new_storage({ t: "n", v: data[C] }, SST);&#13;
        _celload = write_old_storage({ t: "n", v: data[C] }, SST);&#13;
        break;&#13;
      case "boolean":&#13;
        celload = write_new_storage({ t: "b", v: data[C] }, SST);&#13;
        _celload = write_old_storage({ t: "b", v: data[C] }, SST);&#13;
        break;&#13;
      default:&#13;
        if (data[C] instanceof Date) {&#13;
          celload = write_new_storage({ t: "s", v: data[C].toISOString() }, SST);&#13;
          _celload = write_old_storage({ t: "s", v: data[C].toISOString() }, SST);&#13;
          break;&#13;
        }&#13;
        throw new Error("Unsupported value " + data[C]);&#13;
    }&#13;
    cell_storage.push(celload);&#13;
    last_offset += celload.length;&#13;
    {&#13;
      _cell_storage.push(_celload);&#13;
      _last_offset += _celload.length;&#13;
    }&#13;
    ++cnt;&#13;
  }&#13;
  tri[2][0].data = write_varint49(cnt);&#13;
  tri[5][0].data = write_varint49(5);&#13;
  for (; C &lt; tri[7][0].data.length / 2; ++C) {&#13;
    dv.setUint16(C * 2, 65535, true);&#13;
    _dv.setUint16(C * 2, 65535, true);&#13;
  }&#13;
  tri[6][0].data = u8concat(cell_storage);&#13;
  tri[3][0].data = u8concat(_cell_storage);&#13;
  tri[8] = [{ type: 0, data: write_varint49(wide ? 1 : 0) }];&#13;
  return tri;&#13;
}&#13;
function write_iwam(type, payload) {&#13;
  return {&#13;
    meta: [&#13;
      [],&#13;
      [{ type: 0, data: write_varint49(type) }]&#13;
    ],&#13;
    data: payload&#13;
  };&#13;
}&#13;
function get_unique_msgid(dep, dependents) {&#13;
  if (!dependents.last)&#13;
    dependents.last = 927262;&#13;
  for (var i = dependents.last; i &lt; 2e6; ++i)&#13;
    if (!dependents[i]) {&#13;
      dependents[dependents.last = i] = dep;&#13;
      return i;&#13;
    }&#13;
  throw new Error("Too many messages");&#13;
}&#13;
function build_numbers_deps(cfb) {&#13;
  var dependents = {};&#13;
  var indices = [];&#13;
  cfb.FileIndex.map(function(fi, idx) {&#13;
    return [fi, cfb.FullPaths[idx]];&#13;
  }).forEach(function(row) {&#13;
    var fi = row[0], fp = row[1];&#13;
    if (fi.type != 2)&#13;
      return;&#13;
    if (!fi.name.match(/\.iwa/))&#13;
      return;&#13;
    if (fi.name.match(/OperationStorage/))&#13;
      return;&#13;
    parse_iwa_file(decompress_iwa_file(fi.content)).forEach(function(packet) {&#13;
      indices.push(packet.id);&#13;
      dependents[packet.id] = { deps: [], location: fp, type: varint_to_i32(packet.messages[0].meta[1][0].data) };&#13;
    });&#13;
  });&#13;
  indices.sort(function(x, y) {&#13;
    return x - y;&#13;
  });&#13;
  var indices_varint = indices.filter(function(x) {&#13;
    return x &gt; 1;&#13;
  }).map(function(x) {&#13;
    return [x, write_varint49(x)];&#13;
  });&#13;
  cfb.FileIndex.forEach(function(fi) {&#13;
    if (!fi.name.match(/\.iwa/))&#13;
      return;&#13;
    if (fi.name.match(/OperationStorage/))&#13;
      return;&#13;
    parse_iwa_file(decompress_iwa_file(fi.content)).forEach(function(ia) {&#13;
      indices_varint.forEach(function(ivi) {&#13;
        if (ia.messages.some(function(mess) {&#13;
          return varint_to_i32(mess.meta[1][0].data) != 11006 &amp;&amp; u8contains(mess.data, ivi[1]);&#13;
        })) {&#13;
          dependents[ivi[0]].deps.push(ia.id);&#13;
        }&#13;
      });&#13;
    });&#13;
  });&#13;
  return dependents;&#13;
}&#13;
function write_numbers_iwa(wb, opts) {&#13;
  if (!opts || !opts.numbers)&#13;
    throw new Error("Must pass a `numbers` option -- check the README");&#13;
  var cfb = CFB.read(opts.numbers, { type: "base64" });&#13;
  var deps = build_numbers_deps(cfb);&#13;
  var docroot = numbers_iwa_find(cfb, deps, 1);&#13;
  if (docroot == null)&#13;
    throw "Could not find message ".concat(1, " in Numbers template");&#13;
  var sheetrefs = mappa(parse_shallow(docroot.messages[0].data)[1], parse_TSP_Reference);&#13;
  if (sheetrefs.length &gt; 1)&#13;
    throw new Error("Template NUMBERS file must have exactly one sheet");&#13;
  wb.SheetNames.forEach(function(name, idx) {&#13;
    if (idx &gt;= 1) {&#13;
      numbers_add_ws(cfb, deps, idx + 1);&#13;
      docroot = numbers_iwa_find(cfb, deps, 1);&#13;
      sheetrefs = mappa(parse_shallow(docroot.messages[0].data)[1], parse_TSP_Reference);&#13;
    }&#13;
    write_numbers_ws(cfb, deps, wb.Sheets[name], name, idx, sheetrefs[idx]);&#13;
  });&#13;
  return cfb;&#13;
}&#13;
function numbers_iwa_doit(cfb, deps, id, cb) {&#13;
  var entry = CFB.find(cfb, deps[id].location);&#13;
  if (!entry)&#13;
    throw "Could not find ".concat(deps[id].location, " in Numbers template");&#13;
  var x = parse_iwa_file(decompress_iwa_file(entry.content));&#13;
  var ainfo = x.find(function(packet) {&#13;
    return packet.id == id;&#13;
  });&#13;
  cb(ainfo, x);&#13;
  entry.content = compress_iwa_file(write_iwa_file(x));&#13;
  entry.size = entry.content.length;&#13;
}&#13;
function numbers_iwa_find(cfb, deps, id) {&#13;
  var entry = CFB.find(cfb, deps[id].location);&#13;
  if (!entry)&#13;
    throw "Could not find ".concat(deps[id].location, " in Numbers template");&#13;
  var x = parse_iwa_file(decompress_iwa_file(entry.content));&#13;
  var ainfo = x.find(function(packet) {&#13;
    return packet.id == id;&#13;
  });&#13;
  return ainfo;&#13;
}&#13;
function numbers_add_ws(cfb, deps, wsidx) {&#13;
  var sheetref = -1, newsheetref = -1;&#13;
  var remap = {};&#13;
  numbers_iwa_doit(cfb, deps, 1, function(docroot, arch) {&#13;
    var doc = parse_shallow(docroot.messages[0].data);&#13;
    sheetref = parse_TSP_Reference(parse_shallow(docroot.messages[0].data)[1][0].data);&#13;
    newsheetref = get_unique_msgid({ deps: [1], location: deps[sheetref].location, type: 2 }, deps);&#13;
    remap[sheetref] = newsheetref;&#13;
    numbers_add_oref(docroot, newsheetref);&#13;
    doc[1].push({ type: 2, data: write_TSP_Reference(newsheetref) });&#13;
    var sheet = numbers_iwa_find(cfb, deps, sheetref);&#13;
    sheet.id = newsheetref;&#13;
    if (deps[1].location == deps[newsheetref].location)&#13;
      arch.push(sheet);&#13;
    else&#13;
      numbers_iwa_doit(cfb, deps, newsheetref, function(_, x) {&#13;
        return x.push(sheet);&#13;
      });&#13;
    docroot.messages[0].data = write_shallow(doc);&#13;
  });&#13;
  var tiaref = -1;&#13;
  numbers_iwa_doit(cfb, deps, newsheetref, function(sheetroot, arch) {&#13;
    var sa = parse_shallow(sheetroot.messages[0].data);&#13;
    for (var i = 3; i &lt;= 69; ++i)&#13;
      delete sa[i];&#13;
    var drawables = mappa(sa[2], parse_TSP_Reference);&#13;
    drawables.forEach(function(n) {&#13;
      return numbers_del_oref(sheetroot, n);&#13;
    });&#13;
    tiaref = get_unique_msgid({ deps: [newsheetref], location: deps[drawables[0]].location, type: deps[drawables[0]].type }, deps);&#13;
    numbers_add_oref(sheetroot, tiaref);&#13;
    remap[drawables[0]] = tiaref;&#13;
    sa[2] = [{ type: 2, data: write_TSP_Reference(tiaref) }];&#13;
    var tia = numbers_iwa_find(cfb, deps, drawables[0]);&#13;
    tia.id = tiaref;&#13;
    if (deps[drawables[0]].location == deps[newsheetref].location)&#13;
      arch.push(tia);&#13;
    else {&#13;
      var loc2 = deps[newsheetref].location;&#13;
      loc2 = loc2.replace(/^Root Entry\//, "");&#13;
      loc2 = loc2.replace(/^Index\//, "").replace(/\.iwa$/, "");&#13;
      numbers_iwa_doit(cfb, deps, 2, function(ai) {&#13;
        var mlist = parse_shallow(ai.messages[0].data);&#13;
        var parentidx = mlist[3].findIndex(function(m) {&#13;
          var _a, _b;&#13;
          var mm = parse_shallow(m.data);&#13;
          if ((_a = mm[3]) == null ? void 0 : _a[0])&#13;
            return u8str(mm[3][0].data) == loc2;&#13;
          if (((_b = mm[2]) == null ? void 0 : _b[0]) &amp;&amp; u8str(mm[2][0].data) == loc2)&#13;
            return true;&#13;
          return false;&#13;
        });&#13;
        var parent = parse_shallow(mlist[3][parentidx].data);&#13;
        if (!parent[6])&#13;
          parent[6] = [];&#13;
        parent[6].push({&#13;
          type: 2,&#13;
          data: write_shallow([&#13;
            [],&#13;
            [{ type: 0, data: write_varint49(tiaref) }]&#13;
          ])&#13;
        });&#13;
        mlist[3][parentidx].data = write_shallow(parent);&#13;
        ai.messages[0].data = write_shallow(mlist);&#13;
      });&#13;
      numbers_iwa_doit(cfb, deps, tiaref, function(_, x) {&#13;
        return x.push(tia);&#13;
      });&#13;
    }&#13;
    sheetroot.messages[0].data = write_shallow(sa);&#13;
  });&#13;
  var tmaref = -1;&#13;
  numbers_iwa_doit(cfb, deps, tiaref, function(tiaroot, arch) {&#13;
    var tia = parse_shallow(tiaroot.messages[0].data);&#13;
    var da = parse_shallow(tia[1][0].data);&#13;
    for (var i = 3; i &lt;= 69; ++i)&#13;
      delete da[i];&#13;
    var dap = parse_TSP_Reference(da[2][0].data);&#13;
    da[2][0].data = write_TSP_Reference(remap[dap]);&#13;
    tia[1][0].data = write_shallow(da);&#13;
    var oldtmaref = parse_TSP_Reference(tia[2][0].data);&#13;
    numbers_del_oref(tiaroot, oldtmaref);&#13;
    tmaref = get_unique_msgid({ deps: [tiaref], location: deps[oldtmaref].location, type: deps[oldtmaref].type }, deps);&#13;
    numbers_add_oref(tiaroot, tmaref);&#13;
    remap[oldtmaref] = tmaref;&#13;
    tia[2][0].data = write_TSP_Reference(tmaref);&#13;
    var tma = numbers_iwa_find(cfb, deps, oldtmaref);&#13;
    tma.id = tmaref;&#13;
    if (deps[tiaref].location == deps[tmaref].location)&#13;
      arch.push(tma);&#13;
    else&#13;
      numbers_iwa_doit(cfb, deps, tmaref, function(_, x) {&#13;
        return x.push(tma);&#13;
      });&#13;
    tiaroot.messages[0].data = write_shallow(tia);&#13;
  });&#13;
  var loc = deps[tmaref].location;&#13;
  loc = loc.replace(/^Root Entry\//, "");&#13;
  loc = loc.replace(/^Index\//, "").replace(/\.iwa$/, "");&#13;
  numbers_iwa_doit(cfb, deps, tmaref, function(tmaroot, arch) {&#13;
    var _a, _b;&#13;
    var tma = parse_shallow(tmaroot.messages[0].data);&#13;
    var uuid = u8str(tma[1][0].data), new_uuid = uuid.replace(/-[A-Z0-9]*/, "-".concat(wsidx.toString(16).padStart(4, "0")));&#13;
    tma[1][0].data = stru8(new_uuid);&#13;
    [12, 13, 29, 31, 32, 33, 39, 44, 47, 81, 82, 84].forEach(function(n) {&#13;
      return delete tma[n];&#13;
    });&#13;
    if (tma[45]) {&#13;
      var srrta = parse_shallow(tma[45][0].data);&#13;
      var ref = parse_TSP_Reference(srrta[1][0].data);&#13;
      numbers_del_oref(tmaroot, ref);&#13;
      delete tma[45];&#13;
    }&#13;
    if (tma[70]) {&#13;
      var hsoa = parse_shallow(tma[70][0].data);&#13;
      (_a = hsoa[2]) == null ? void 0 : _a.forEach(function(item) {&#13;
        var hsa = parse_shallow(item.data);&#13;
        [2, 3].map(function(n) {&#13;
          return hsa[n][0];&#13;
        }).forEach(function(hseadata) {&#13;
          var hsea = parse_shallow(hseadata.data);&#13;
          if (!hsea[8])&#13;
            return;&#13;
          var ref2 = parse_TSP_Reference(hsea[8][0].data);&#13;
          numbers_del_oref(tmaroot, ref2);&#13;
        });&#13;
      });&#13;
      delete tma[70];&#13;
    }&#13;
    [&#13;
      46,&#13;
      30,&#13;
      34,&#13;
      35,&#13;
      36,&#13;
      38,&#13;
      48,&#13;
      49,&#13;
      60,&#13;
      61,&#13;
      62,&#13;
      63,&#13;
      64,&#13;
      71,&#13;
      72,&#13;
      73,&#13;
      74,&#13;
      75,&#13;
      85,&#13;
      86,&#13;
      87,&#13;
      88,&#13;
      89&#13;
    ].forEach(function(n) {&#13;
      if (!tma[n])&#13;
        return;&#13;
      var ref2 = parse_TSP_Reference(tma[n][0].data);&#13;
      delete tma[n];&#13;
      numbers_del_oref(tmaroot, ref2);&#13;
    });&#13;
    var store = parse_shallow(tma[4][0].data);&#13;
    {&#13;
      [2, 4, 5, 6, 11, 12, 13, 15, 16, 17, 18, 19, 20, 21, 22].forEach(function(n) {&#13;
        var _a2;&#13;
        if (!((_a2 = store[n]) == null ? void 0 : _a2[0]))&#13;
          return;&#13;
        var oldref = parse_TSP_Reference(store[n][0].data);&#13;
        var newref = get_unique_msgid({ deps: [tmaref], location: deps[oldref].location, type: deps[oldref].type }, deps);&#13;
        numbers_del_oref(tmaroot, oldref);&#13;
        numbers_add_oref(tmaroot, newref);&#13;
        remap[oldref] = newref;&#13;
        var msg = numbers_iwa_find(cfb, deps, oldref);&#13;
        msg.id = newref;&#13;
        if (deps[oldref].location == deps[tmaref].location)&#13;
          arch.push(msg);&#13;
        else {&#13;
          deps[newref].location = deps[oldref].location.replace(oldref.toString(), newref.toString());&#13;
          if (deps[newref].location == deps[oldref].location)&#13;
            deps[newref].location = deps[newref].location.replace(/\.iwa/, "-".concat(newref, ".iwa"));&#13;
          CFB.utils.cfb_add(cfb, deps[newref].location, compress_iwa_file(write_iwa_file([msg])));&#13;
          var newloc = deps[newref].location;&#13;
          newloc = newloc.replace(/^Root Entry\//, "");&#13;
          newloc = newloc.replace(/^Index\//, "").replace(/\.iwa$/, "");&#13;
          numbers_iwa_doit(cfb, deps, 2, function(ai) {&#13;
            var mlist = parse_shallow(ai.messages[0].data);&#13;
            mlist[3].push({ type: 2, data: write_shallow([&#13;
              [],&#13;
              [{ type: 0, data: write_varint49(newref) }],&#13;
              [{ type: 2, data: stru8(newloc.replace(/-.*$/, "")) }],&#13;
              [{ type: 2, data: stru8(newloc) }],&#13;
              [{ type: 2, data: new Uint8Array([2, 0, 0]) }],&#13;
              [{ type: 2, data: new Uint8Array([2, 0, 0]) }],&#13;
              [],&#13;
              [],&#13;
              [],&#13;
              [],&#13;
              [{ type: 0, data: write_varint49(0) }],&#13;
              [],&#13;
              [{ type: 0, data: write_varint49(0) }]&#13;
            ]) });&#13;
            mlist[1] = [{ type: 0, data: write_varint49(Math.max(newref + 1, parse_varint49(mlist[1][0].data))) }];&#13;
            var parentidx = mlist[3].findIndex(function(m) {&#13;
              var _a3, _b2;&#13;
              var mm = parse_shallow(m.data);&#13;
              if ((_a3 = mm[3]) == null ? void 0 : _a3[0])&#13;
                return u8str(mm[3][0].data) == loc;&#13;
              if (((_b2 = mm[2]) == null ? void 0 : _b2[0]) &amp;&amp; u8str(mm[2][0].data) == loc)&#13;
                return true;&#13;
              return false;&#13;
            });&#13;
            var parent = parse_shallow(mlist[3][parentidx].data);&#13;
            if (!parent[6])&#13;
              parent[6] = [];&#13;
            parent[6].push({&#13;
              type: 2,&#13;
              data: write_shallow([&#13;
                [],&#13;
                [{ type: 0, data: write_varint49(newref) }]&#13;
              ])&#13;
            });&#13;
            mlist[3][parentidx].data = write_shallow(parent);&#13;
            ai.messages[0].data = write_shallow(mlist);&#13;
          });&#13;
        }&#13;
        store[n][0].data = write_TSP_Reference(newref);&#13;
      });&#13;
      var row_headers = parse_shallow(store[1][0].data);&#13;
      {&#13;
        (_b = row_headers[2]) == null ? void 0 : _b.forEach(function(tspref) {&#13;
          var oldref = parse_TSP_Reference(tspref.data);&#13;
          var newref = get_unique_msgid({ deps: [tmaref], location: deps[oldref].location, type: deps[oldref].type }, deps);&#13;
          numbers_del_oref(tmaroot, oldref);&#13;
          numbers_add_oref(tmaroot, newref);&#13;
          remap[oldref] = newref;&#13;
          var msg = numbers_iwa_find(cfb, deps, oldref);&#13;
          msg.id = newref;&#13;
          if (deps[oldref].location == deps[tmaref].location) {&#13;
            arch.push(msg);&#13;
          } else {&#13;
            deps[newref].location = deps[oldref].location.replace(oldref.toString(), newref.toString());&#13;
            if (deps[newref].location == deps[oldref].location)&#13;
              deps[newref].location = deps[newref].location.replace(/\.iwa/, "-".concat(newref, ".iwa"));&#13;
            CFB.utils.cfb_add(cfb, deps[newref].location, compress_iwa_file(write_iwa_file([msg])));&#13;
            var newloc = deps[newref].location;&#13;
            newloc = newloc.replace(/^Root Entry\//, "");&#13;
            newloc = newloc.replace(/^Index\//, "").replace(/\.iwa$/, "");&#13;
            numbers_iwa_doit(cfb, deps, 2, function(ai) {&#13;
              var mlist = parse_shallow(ai.messages[0].data);&#13;
              mlist[3].push({ type: 2, data: write_shallow([&#13;
                [],&#13;
                [{ type: 0, data: write_varint49(newref) }],&#13;
                [{ type: 2, data: stru8(newloc.replace(/-.*$/, "")) }],&#13;
                [{ type: 2, data: stru8(newloc) }],&#13;
                [{ type: 2, data: new Uint8Array([2, 0, 0]) }],&#13;
                [{ type: 2, data: new Uint8Array([2, 0, 0]) }],&#13;
                [],&#13;
                [],&#13;
                [],&#13;
                [],&#13;
                [{ type: 0, data: write_varint49(0) }],&#13;
                [],&#13;
                [{ type: 0, data: write_varint49(0) }]&#13;
              ]) });&#13;
              mlist[1] = [{ type: 0, data: write_varint49(Math.max(newref + 1, parse_varint49(mlist[1][0].data))) }];&#13;
              var parentidx = mlist[3].findIndex(function(m) {&#13;
                var _a2, _b2;&#13;
                var mm = parse_shallow(m.data);&#13;
                if ((_a2 = mm[3]) == null ? void 0 : _a2[0])&#13;
                  return u8str(mm[3][0].data) == loc;&#13;
                if (((_b2 = mm[2]) == null ? void 0 : _b2[0]) &amp;&amp; u8str(mm[2][0].data) == loc)&#13;
                  return true;&#13;
                return false;&#13;
              });&#13;
              var parent = parse_shallow(mlist[3][parentidx].data);&#13;
              if (!parent[6])&#13;
                parent[6] = [];&#13;
              parent[6].push({&#13;
                type: 2,&#13;
                data: write_shallow([&#13;
                  [],&#13;
                  [{ type: 0, data: write_varint49(newref) }]&#13;
                ])&#13;
              });&#13;
              mlist[3][parentidx].data = write_shallow(parent);&#13;
              ai.messages[0].data = write_shallow(mlist);&#13;
            });&#13;
          }&#13;
          tspref.data = write_TSP_Reference(newref);&#13;
        });&#13;
      }&#13;
      store[1][0].data = write_shallow(row_headers);&#13;
      var tiles = parse_shallow(store[3][0].data);&#13;
      {&#13;
        tiles[1].forEach(function(t) {&#13;
          var tst = parse_shallow(t.data);&#13;
          var oldtileref = parse_TSP_Reference(tst[2][0].data);&#13;
          var newtileref = remap[oldtileref];&#13;
          if (!remap[oldtileref]) {&#13;
            newtileref = get_unique_msgid({ deps: [tmaref], location: "", type: deps[oldtileref].type }, deps);&#13;
            deps[newtileref].location = "Root Entry/Index/Tables/Tile-".concat(newtileref, ".iwa");&#13;
            remap[oldtileref] = newtileref;&#13;
            var oldtile = numbers_iwa_find(cfb, deps, oldtileref);&#13;
            oldtile.id = newtileref;&#13;
            numbers_del_oref(tmaroot, oldtileref);&#13;
            numbers_add_oref(tmaroot, newtileref);&#13;
            CFB.utils.cfb_add(cfb, "/Index/Tables/Tile-".concat(newtileref, ".iwa"), compress_iwa_file(write_iwa_file([oldtile])));&#13;
            numbers_iwa_doit(cfb, deps, 2, function(ai) {&#13;
              var mlist = parse_shallow(ai.messages[0].data);&#13;
              mlist[3].push({ type: 2, data: write_shallow([&#13;
                [],&#13;
                [{ type: 0, data: write_varint49(newtileref) }],&#13;
                [{ type: 2, data: stru8("Tables/Tile") }],&#13;
                [{ type: 2, data: stru8("Tables/Tile-".concat(newtileref)) }],&#13;
                [{ type: 2, data: new Uint8Array([2, 0, 0]) }],&#13;
                [{ type: 2, data: new Uint8Array([2, 0, 0]) }],&#13;
                [],&#13;
                [],&#13;
                [],&#13;
                [],&#13;
                [{ type: 0, data: write_varint49(0) }],&#13;
                [],&#13;
                [{ type: 0, data: write_varint49(0) }]&#13;
              ]) });&#13;
              mlist[1] = [{ type: 0, data: write_varint49(Math.max(newtileref + 1, parse_varint49(mlist[1][0].data))) }];&#13;
              var parentidx = mlist[3].findIndex(function(m) {&#13;
                var _a2, _b2;&#13;
                var mm = parse_shallow(m.data);&#13;
                if ((_a2 = mm[3]) == null ? void 0 : _a2[0])&#13;
                  return u8str(mm[3][0].data) == loc;&#13;
                if (((_b2 = mm[2]) == null ? void 0 : _b2[0]) &amp;&amp; u8str(mm[2][0].data) == loc)&#13;
                  return true;&#13;
                return false;&#13;
              });&#13;
              var parent = parse_shallow(mlist[3][parentidx].data);&#13;
              if (!parent[6])&#13;
                parent[6] = [];&#13;
              parent[6].push({&#13;
                type: 2,&#13;
                data: write_shallow([&#13;
                  [],&#13;
                  [{ type: 0, data: write_varint49(newtileref) }]&#13;
                ])&#13;
              });&#13;
              mlist[3][parentidx].data = write_shallow(parent);&#13;
              ai.messages[0].data = write_shallow(mlist);&#13;
            });&#13;
          }&#13;
          tst[2][0].data = write_TSP_Reference(newtileref);&#13;
          t.data = write_shallow(tst);&#13;
        });&#13;
      }&#13;
      store[3][0].data = write_shallow(tiles);&#13;
    }&#13;
    tma[4][0].data = write_shallow(store);&#13;
    tmaroot.messages[0].data = write_shallow(tma);&#13;
  });&#13;
}&#13;
function write_numbers_ws(cfb, deps, ws, wsname, sheetidx, rootref) {&#13;
  var drawables = [];&#13;
  numbers_iwa_doit(cfb, deps, rootref, function(docroot) {&#13;
    var sheetref = parse_shallow(docroot.messages[0].data);&#13;
    {&#13;
      sheetref[1] = [{ type: 2, data: stru8(wsname) }];&#13;
      drawables = mappa(sheetref[2], parse_TSP_Reference);&#13;
    }&#13;
    docroot.messages[0].data = write_shallow(sheetref);&#13;
  });&#13;
  var tia = numbers_iwa_find(cfb, deps, drawables[0]);&#13;
  var tmaref = parse_TSP_Reference(parse_shallow(tia.messages[0].data)[2][0].data);&#13;
  numbers_iwa_doit(cfb, deps, tmaref, function(docroot, x) {&#13;
    return write_numbers_tma(cfb, deps, ws, docroot, x, tmaref);&#13;
  });&#13;
}&#13;
var USE_WIDE_ROWS = true;&#13;
function write_numbers_tma(cfb, deps, ws, tmaroot, tmafile, tmaref) {&#13;
  var range = decode_range(ws["!ref"]);&#13;
  range.s.r = range.s.c = 0;&#13;
  var trunc = false;&#13;
  if (range.e.c &gt; 999) {&#13;
    trunc = true;&#13;
    range.e.c = 999;&#13;
  }&#13;
  if (range.e.r &gt; 999999) {&#13;
    trunc = true;&#13;
    range.e.r = 999999;&#13;
  }&#13;
  if (trunc)&#13;
    console.error("Truncating to ".concat(encode_range(range)));&#13;
  var data = sheet_to_json(ws, { range: range, header: 1 });&#13;
  var SST = ["~Sh33tJ5~"];&#13;
  var loc = deps[tmaref].location;&#13;
  loc = loc.replace(/^Root Entry\//, "");&#13;
  loc = loc.replace(/^Index\//, "").replace(/\.iwa$/, "");&#13;
  var pb = parse_shallow(tmaroot.messages[0].data);&#13;
  {&#13;
    pb[6][0].data = write_varint49(range.e.r + 1);&#13;
    pb[7][0].data = write_varint49(range.e.c + 1);&#13;
    delete pb[46];&#13;
    var store = parse_shallow(pb[4][0].data);&#13;
    {&#13;
      var row_header_ref = parse_TSP_Reference(parse_shallow(store[1][0].data)[2][0].data);&#13;
      numbers_iwa_doit(cfb, deps, row_header_ref, function(rowhead, _x) {&#13;
        var _a;&#13;
        var base_bucket = parse_shallow(rowhead.messages[0].data);&#13;
        if ((_a = base_bucket == null ? void 0 : base_bucket[2]) == null ? void 0 : _a[0])&#13;
          for (var R2 = 0; R2 &lt; data.length; ++R2) {&#13;
            var _bucket = parse_shallow(base_bucket[2][0].data);&#13;
            _bucket[1][0].data = write_varint49(R2);&#13;
            _bucket[4][0].data = write_varint49(data[R2].length);&#13;
            base_bucket[2][R2] = { type: base_bucket[2][0].type, data: write_shallow(_bucket) };&#13;
          }&#13;
        rowhead.messages[0].data = write_shallow(base_bucket);&#13;
      });&#13;
      var col_header_ref = parse_TSP_Reference(store[2][0].data);&#13;
      numbers_iwa_doit(cfb, deps, col_header_ref, function(colhead, _x) {&#13;
        var base_bucket = parse_shallow(colhead.messages[0].data);&#13;
        for (var C = 0; C &lt;= range.e.c; ++C) {&#13;
          var _bucket = parse_shallow(base_bucket[2][0].data);&#13;
          _bucket[1][0].data = write_varint49(C);&#13;
          _bucket[4][0].data = write_varint49(range.e.r + 1);&#13;
          base_bucket[2][C] = { type: base_bucket[2][0].type, data: write_shallow(_bucket) };&#13;
        }&#13;
        colhead.messages[0].data = write_shallow(base_bucket);&#13;
      });&#13;
      var rbtree = parse_shallow(store[9][0].data);&#13;
      rbtree[1] = [];&#13;
      var tilestore = parse_shallow(store[3][0].data);&#13;
      {&#13;
        var tstride = 256;&#13;
        tilestore[2] = [{ type: 0, data: write_varint49(tstride) }];&#13;
        var tileref = parse_TSP_Reference(parse_shallow(tilestore[1][0].data)[2][0].data);&#13;
        var save_token = function() {&#13;
          var metadata = numbers_iwa_find(cfb, deps, 2);&#13;
          var mlist = parse_shallow(metadata.messages[0].data);&#13;
          var mlst = mlist[3].filter(function(m) {&#13;
            return parse_varint49(parse_shallow(m.data)[1][0].data) == tileref;&#13;
          });&#13;
          return (mlst == null ? void 0 : mlst.length) ? parse_varint49(parse_shallow(mlst[0].data)[12][0].data) : 0;&#13;
        }();&#13;
        {&#13;
          CFB.utils.cfb_del(cfb, deps[tileref].location);&#13;
          numbers_iwa_doit(cfb, deps, 2, function(ai) {&#13;
            var mlist = parse_shallow(ai.messages[0].data);&#13;
            mlist[3] = mlist[3].filter(function(m) {&#13;
              return parse_varint49(parse_shallow(m.data)[1][0].data) != tileref;&#13;
            });&#13;
            var parentidx = mlist[3].findIndex(function(m) {&#13;
              var _a, _b;&#13;
              var mm = parse_shallow(m.data);&#13;
              if ((_a = mm[3]) == null ? void 0 : _a[0])&#13;
                return u8str(mm[3][0].data) == loc;&#13;
              if (((_b = mm[2]) == null ? void 0 : _b[0]) &amp;&amp; u8str(mm[2][0].data) == loc)&#13;
                return true;&#13;
              return false;&#13;
            });&#13;
            var parent = parse_shallow(mlist[3][parentidx].data);&#13;
            if (!parent[6])&#13;
              parent[6] = [];&#13;
            parent[6] = parent[6].filter(function(m) {&#13;
              return parse_varint49(parse_shallow(m.data)[1][0].data) != tileref;&#13;
            });&#13;
            mlist[3][parentidx].data = write_shallow(parent);&#13;
            ai.messages[0].data = write_shallow(mlist);&#13;
          });&#13;
          numbers_del_oref(tmaroot, tileref);&#13;
        }&#13;
        tilestore[1] = [];&#13;
        var ntiles = Math.ceil((range.e.r + 1) / tstride);&#13;
        for (var tidx = 0; tidx &lt; ntiles; ++tidx) {&#13;
          var newtileid = get_unique_msgid({&#13;
            deps: [],&#13;
            location: "",&#13;
            type: 6002&#13;
          }, deps);&#13;
          deps[newtileid].location = "Root Entry/Index/Tables/Tile-".concat(newtileid, ".iwa");&#13;
          var tiledata = [&#13;
            [],&#13;
            [{ type: 0, data: write_varint49(0) }],&#13;
            [{ type: 0, data: write_varint49(Math.min(range.e.r + 1, (tidx + 1) * tstride)) }],&#13;
            [{ type: 0, data: write_varint49(0) }],&#13;
            [{ type: 0, data: write_varint49(Math.min((tidx + 1) * tstride, range.e.r + 1) - tidx * tstride) }],&#13;
            [],&#13;
            [{ type: 0, data: write_varint49(5) }],&#13;
            [{ type: 0, data: write_varint49(1) }],&#13;
            [{ type: 0, data: write_varint49(USE_WIDE_ROWS ? 1 : 0) }]&#13;
          ];&#13;
          for (var R = tidx * tstride; R &lt;= Math.min(range.e.r, (tidx + 1) * tstride - 1); ++R) {&#13;
            var tilerow = write_TST_TileRowInfo(data[R], SST, USE_WIDE_ROWS);&#13;
            tilerow[1][0].data = write_varint49(R - tidx * tstride);&#13;
            tiledata[5].push({ data: write_shallow(tilerow), type: 2 });&#13;
          }&#13;
          tilestore[1].push({ type: 2, data: write_shallow([&#13;
            [],&#13;
            [{ type: 0, data: write_varint49(tidx) }],&#13;
            [{ type: 2, data: write_TSP_Reference(newtileid) }]&#13;
          ]) });&#13;
          var newtile = {&#13;
            id: newtileid,&#13;
            messages: [write_iwam(6002, write_shallow(tiledata))]&#13;
          };&#13;
          var tilecontent = compress_iwa_file(write_iwa_file([newtile]));&#13;
          CFB.utils.cfb_add(cfb, "/Index/Tables/Tile-".concat(newtileid, ".iwa"), tilecontent);&#13;
          numbers_iwa_doit(cfb, deps, 2, function(ai) {&#13;
            var mlist = parse_shallow(ai.messages[0].data);&#13;
            mlist[3].push({ type: 2, data: write_shallow([&#13;
              [],&#13;
              [{ type: 0, data: write_varint49(newtileid) }],&#13;
              [{ type: 2, data: stru8("Tables/Tile") }],&#13;
              [{ type: 2, data: stru8("Tables/Tile-".concat(newtileid)) }],&#13;
              [{ type: 2, data: new Uint8Array([2, 0, 0]) }],&#13;
              [{ type: 2, data: new Uint8Array([2, 0, 0]) }],&#13;
              [],&#13;
              [],&#13;
              [],&#13;
              [],&#13;
              [{ type: 0, data: write_varint49(0) }],&#13;
              [],&#13;
              [{ type: 0, data: write_varint49(save_token) }]&#13;
            ]) });&#13;
            mlist[1] = [{ type: 0, data: write_varint49(Math.max(newtileid + 1, parse_varint49(mlist[1][0].data))) }];&#13;
            var parentidx = mlist[3].findIndex(function(m) {&#13;
              var _a, _b;&#13;
              var mm = parse_shallow(m.data);&#13;
              if ((_a = mm[3]) == null ? void 0 : _a[0])&#13;
                return u8str(mm[3][0].data) == loc;&#13;
              if (((_b = mm[2]) == null ? void 0 : _b[0]) &amp;&amp; u8str(mm[2][0].data) == loc)&#13;
                return true;&#13;
              return false;&#13;
            });&#13;
            var parent = parse_shallow(mlist[3][parentidx].data);&#13;
            if (!parent[6])&#13;
              parent[6] = [];&#13;
            parent[6].push({&#13;
              type: 2,&#13;
              data: write_shallow([&#13;
                [],&#13;
                [{ type: 0, data: write_varint49(newtileid) }]&#13;
              ])&#13;
            });&#13;
            mlist[3][parentidx].data = write_shallow(parent);&#13;
            ai.messages[0].data = write_shallow(mlist);&#13;
          });&#13;
          numbers_add_oref(tmaroot, newtileid);&#13;
          rbtree[1].push({ type: 2, data: write_shallow([&#13;
            [],&#13;
            [{ type: 0, data: write_varint49(tidx * tstride) }],&#13;
            [{ type: 0, data: write_varint49(tidx) }]&#13;
          ]) });&#13;
        }&#13;
      }&#13;
      store[3][0].data = write_shallow(tilestore);&#13;
      store[9][0].data = write_shallow(rbtree);&#13;
      store[10] = [{ type: 2, data: new Uint8Array([]) }];&#13;
      if (ws["!merges"]) {&#13;
        var mergeid = get_unique_msgid({&#13;
          type: 6144,&#13;
          deps: [tmaref],&#13;
          location: deps[tmaref].location&#13;
        }, deps);&#13;
        tmafile.push({&#13;
          id: mergeid,&#13;
          messages: [write_iwam(6144, write_shallow([&#13;
            [],&#13;
            ws["!merges"].map(function(m) {&#13;
              return { type: 2, data: write_shallow([&#13;
                [],&#13;
                [{ type: 2, data: write_shallow([&#13;
                  [],&#13;
                  [{ type: 5, data: new Uint8Array(new Uint16Array([m.s.r, m.s.c]).buffer) }]&#13;
                ]) }],&#13;
                [{ type: 2, data: write_shallow([&#13;
                  [],&#13;
                  [{ type: 5, data: new Uint8Array(new Uint16Array([m.e.r - m.s.r + 1, m.e.c - m.s.c + 1]).buffer) }]&#13;
                ]) }]&#13;
              ]) };&#13;
            })&#13;
          ]))]&#13;
        });&#13;
        store[13] = [{ type: 2, data: write_TSP_Reference(mergeid) }];&#13;
        numbers_iwa_doit(cfb, deps, 2, function(ai) {&#13;
          var mlist = parse_shallow(ai.messages[0].data);&#13;
          var parentidx = mlist[3].findIndex(function(m) {&#13;
            var _a, _b;&#13;
            var mm = parse_shallow(m.data);&#13;
            if ((_a = mm[3]) == null ? void 0 : _a[0])&#13;
              return u8str(mm[3][0].data) == loc;&#13;
            if (((_b = mm[2]) == null ? void 0 : _b[0]) &amp;&amp; u8str(mm[2][0].data) == loc)&#13;
              return true;&#13;
            return false;&#13;
          });&#13;
          var parent = parse_shallow(mlist[3][parentidx].data);&#13;
          if (!parent[6])&#13;
            parent[6] = [];&#13;
          parent[6].push({&#13;
            type: 2,&#13;
            data: write_shallow([&#13;
              [],&#13;
              [{ type: 0, data: write_varint49(mergeid) }]&#13;
            ])&#13;
          });&#13;
          mlist[3][parentidx].data = write_shallow(parent);&#13;
          ai.messages[0].data = write_shallow(mlist);&#13;
        });&#13;
        numbers_add_oref(tmaroot, mergeid);&#13;
      } else&#13;
        delete store[13];&#13;
      var sstref = parse_TSP_Reference(store[4][0].data);&#13;
      numbers_iwa_doit(cfb, deps, sstref, function(sstroot) {&#13;
        var sstdata = parse_shallow(sstroot.messages[0].data);&#13;
        {&#13;
          sstdata[3] = [];&#13;
          SST.forEach(function(str, i) {&#13;
            if (i == 0)&#13;
              return;&#13;
            sstdata[3].push({ type: 2, data: write_shallow([&#13;
              [],&#13;
              [{ type: 0, data: write_varint49(i) }],&#13;
              [{ type: 0, data: write_varint49(1) }],&#13;
              [{ type: 2, data: stru8(str) }]&#13;
            ]) });&#13;
          });&#13;
        }&#13;
        sstroot.messages[0].data = write_shallow(sstdata);&#13;
      });&#13;
    }&#13;
    pb[4][0].data = write_shallow(store);&#13;
  }&#13;
  tmaroot.messages[0].data = write_shallow(pb);&#13;
}&#13;
function fix_opts_func(defaults) {&#13;
	return function fix_opts(opts) {&#13;
		for(var i = 0; i != defaults.length; ++i) {&#13;
			var d = defaults[i];&#13;
			if(opts[d[0]] === undefined) opts[d[0]] = d[1];&#13;
			if(d[2] === 'n') opts[d[0]] = Number(opts[d[0]]);&#13;
		}&#13;
	};&#13;
}&#13;
&#13;
function fix_read_opts(opts) {&#13;
fix_opts_func([&#13;
	['cellNF', false], /* emit cell number format string as .z */&#13;
	['cellHTML', true], /* emit html string as .h */&#13;
	['cellFormula', true], /* emit formulae as .f */&#13;
	['cellStyles', false], /* emits style/theme as .s */&#13;
	['cellText', true], /* emit formatted text as .w */&#13;
	['cellDates', false], /* emit date cells with type `d` */&#13;
&#13;
	['sheetStubs', false], /* emit empty cells */&#13;
	['sheetRows', 0, 'n'], /* read n rows (0 = read all rows) */&#13;
&#13;
	['bookDeps', false], /* parse calculation chains */&#13;
	['bookSheets', false], /* only try to get sheet names (no Sheets) */&#13;
	['bookProps', false], /* only try to get properties (no Sheets) */&#13;
	['bookFiles', false], /* include raw file structure (keys, files, cfb) */&#13;
	['bookVBA', false], /* include vba raw data (vbaraw) */&#13;
&#13;
	['password',''], /* password */&#13;
	['WTF', false] /* WTF mode (throws errors) */&#13;
])(opts);&#13;
}&#13;
&#13;
function fix_write_opts(opts) {&#13;
fix_opts_func([&#13;
	['cellDates', false], /* write date cells with type `d` */&#13;
&#13;
	['bookSST', false], /* Generate Shared String Table */&#13;
&#13;
	['bookType', 'xlsx'], /* Type of workbook (xlsx/m/b) */&#13;
&#13;
	['compression', false], /* Use file compression */&#13;
&#13;
	['WTF', false] /* WTF mode (throws errors) */&#13;
])(opts);&#13;
}&#13;
function get_sheet_type(n) {&#13;
	if(RELS.WS.indexOf(n) &gt; -1) return "sheet";&#13;
	if(RELS.CS &amp;&amp; n == RELS.CS) return "chart";&#13;
	if(RELS.DS &amp;&amp; n == RELS.DS) return "dialog";&#13;
	if(RELS.MS &amp;&amp; n == RELS.MS) return "macro";&#13;
	return (n &amp;&amp; n.length) ? n : "sheet";&#13;
}&#13;
function safe_parse_wbrels(wbrels, sheets) {&#13;
	if(!wbrels) return 0;&#13;
	try {&#13;
		wbrels = sheets.map(function pwbr(w) { if(!w.id) w.id = w.strRelID; return [w.name, wbrels['!id'][w.id].Target, get_sheet_type(wbrels['!id'][w.id].Type)]; });&#13;
	} catch(e) { return null; }&#13;
	return !wbrels || wbrels.length === 0 ? null : wbrels;&#13;
}&#13;
&#13;
function safe_parse_sheet(zip, path, relsPath, sheet, idx, sheetRels, sheets, stype, opts, wb, themes, styles) {&#13;
	try {&#13;
		sheetRels[sheet]=parse_rels(getzipstr(zip, relsPath, true), path);&#13;
		var data = getzipdata(zip, path);&#13;
		var _ws;&#13;
		switch(stype) {&#13;
			case 'sheet':  _ws = parse_ws(data, path, idx, opts, sheetRels[sheet], wb, themes, styles); break;&#13;
			case 'chart':  _ws = parse_cs(data, path, idx, opts, sheetRels[sheet], wb, themes, styles);&#13;
				if(!_ws || !_ws['!drawel']) break;&#13;
				var dfile = resolve_path(_ws['!drawel'].Target, path);&#13;
				var drelsp = get_rels_path(dfile);&#13;
				var draw = parse_drawing(getzipstr(zip, dfile, true), parse_rels(getzipstr(zip, drelsp, true), dfile));&#13;
				var chartp = resolve_path(draw, dfile);&#13;
				var crelsp = get_rels_path(chartp);&#13;
				_ws = parse_chart(getzipstr(zip, chartp, true), chartp, opts, parse_rels(getzipstr(zip, crelsp, true), chartp), wb, _ws);&#13;
				break;&#13;
			case 'macro':  _ws = parse_ms(data, path, idx, opts, sheetRels[sheet], wb, themes, styles); break;&#13;
			case 'dialog': _ws = parse_ds(data, path, idx, opts, sheetRels[sheet], wb, themes, styles); break;&#13;
			default: throw new Error("Unrecognized sheet type " + stype);&#13;
		}&#13;
		sheets[sheet] = _ws;&#13;
&#13;
		/* scan rels for comments and threaded comments */&#13;
		var comments = [], tcomments = [];&#13;
		if(sheetRels &amp;&amp; sheetRels[sheet]) keys(sheetRels[sheet]).forEach(function(n) {&#13;
			var dfile = "";&#13;
			if(sheetRels[sheet][n].Type == RELS.CMNT) {&#13;
				dfile = resolve_path(sheetRels[sheet][n].Target, path);&#13;
				comments = parse_cmnt(getzipdata(zip, dfile, true), dfile, opts);&#13;
				if(!comments || !comments.length) return;&#13;
				sheet_insert_comments(_ws, comments, false);&#13;
			}&#13;
			if(sheetRels[sheet][n].Type == RELS.TCMNT) {&#13;
				dfile = resolve_path(sheetRels[sheet][n].Target, path);&#13;
				tcomments = tcomments.concat(parse_tcmnt_xml(getzipdata(zip, dfile, true), opts));&#13;
			}&#13;
		});&#13;
		if(tcomments &amp;&amp; tcomments.length) sheet_insert_comments(_ws, tcomments, true, opts.people || []);&#13;
	} catch(e) { if(opts.WTF) throw e; }&#13;
}&#13;
&#13;
function strip_front_slash(x) { return x.charAt(0) == '/' ? x.slice(1) : x; }&#13;
&#13;
function parse_zip(zip, opts) {&#13;
	make_ssf();&#13;
	opts = opts || {};&#13;
	fix_read_opts(opts);&#13;
&#13;
	/* OpenDocument Part 3 Section 2.2.1 OpenDocument Package */&#13;
	if(safegetzipfile(zip, 'META-INF/manifest.xml')) return parse_ods(zip, opts);&#13;
	/* UOC */&#13;
	if(safegetzipfile(zip, 'objectdata.xml')) return parse_ods(zip, opts);&#13;
	/* Numbers */&#13;
	if(safegetzipfile(zip, 'Index/Document.iwa')) {&#13;
		if(typeof Uint8Array == "undefined") throw new Error('NUMBERS file parsing requires Uint8Array support');&#13;
		if(typeof parse_numbers_iwa != "undefined") {&#13;
			if(zip.FileIndex) return parse_numbers_iwa(zip, opts);&#13;
			var _zip = CFB.utils.cfb_new();&#13;
			zipentries(zip).forEach(function(e) { zip_add_file(_zip, e, getzipbin(zip, e)); });&#13;
			return parse_numbers_iwa(_zip, opts);&#13;
		}&#13;
		throw new Error('Unsupported NUMBERS file');&#13;
	}&#13;
	if(!safegetzipfile(zip, '[Content_Types].xml')) {&#13;
		if(safegetzipfile(zip, 'index.xml.gz')) throw new Error('Unsupported NUMBERS 08 file');&#13;
		if(safegetzipfile(zip, 'index.xml')) throw new Error('Unsupported NUMBERS 09 file');&#13;
		var index_zip = CFB.find(zip, 'Index.zip');&#13;
		if(index_zip) {&#13;
			opts = dup(opts);&#13;
			delete opts.type;&#13;
			if(typeof index_zip.content == "string") opts.type = "binary";&#13;
			// TODO: Bun buffer bug&#13;
			if(typeof Bun !== "undefined" &amp;&amp; Buffer.isBuffer(index_zip.content)) return readSync(new Uint8Array(index_zip.content), opts);&#13;
			return readSync(index_zip.content, opts);&#13;
		}&#13;
		throw new Error('Unsupported ZIP file');&#13;
	}&#13;
&#13;
	var entries = zipentries(zip);&#13;
	var dir = parse_ct((getzipstr(zip, '[Content_Types].xml')));&#13;
	var xlsb = false;&#13;
	var sheets, binname;&#13;
	if(dir.workbooks.length === 0) {&#13;
		binname = "xl/workbook.xml";&#13;
		if(getzipdata(zip,binname, true)) dir.workbooks.push(binname);&#13;
	}&#13;
	if(dir.workbooks.length === 0) {&#13;
		binname = "xl/workbook.bin";&#13;
		if(!getzipdata(zip,binname,true)) throw new Error("Could not find workbook");&#13;
		dir.workbooks.push(binname);&#13;
		xlsb = true;&#13;
	}&#13;
	if(dir.workbooks[0].slice(-3) == "bin") xlsb = true;&#13;
&#13;
	var themes = ({});&#13;
	var styles = ({});&#13;
	if(!opts.bookSheets &amp;&amp; !opts.bookProps) {&#13;
		strs = [];&#13;
		if(dir.sst) try { strs=parse_sst(getzipdata(zip, strip_front_slash(dir.sst)), dir.sst, opts); } catch(e) { if(opts.WTF) throw e; }&#13;
&#13;
		if(opts.cellStyles &amp;&amp; dir.themes.length) themes = parse_theme_xml(getzipstr(zip, dir.themes[0].replace(/^\//,''), true)||"", opts);&#13;
&#13;
		if(dir.style) styles = parse_sty(getzipdata(zip, strip_front_slash(dir.style)), dir.style, themes, opts);&#13;
	}&#13;
&#13;
	/*var externbooks = */dir.links.map(function(link) {&#13;
		try {&#13;
			var rels = parse_rels(getzipstr(zip, get_rels_path(strip_front_slash(link))), link);&#13;
			return parse_xlink(getzipdata(zip, strip_front_slash(link)), rels, link, opts);&#13;
		} catch(e) {}&#13;
	});&#13;
&#13;
	var wb = parse_wb(getzipdata(zip, strip_front_slash(dir.workbooks[0])), dir.workbooks[0], opts);&#13;
&#13;
	var props = {}, propdata = "";&#13;
&#13;
	if(dir.coreprops.length) {&#13;
		propdata = getzipdata(zip, strip_front_slash(dir.coreprops[0]), true);&#13;
		if(propdata) props = parse_core_props(propdata);&#13;
		if(dir.extprops.length !== 0) {&#13;
			propdata = getzipdata(zip, strip_front_slash(dir.extprops[0]), true);&#13;
			if(propdata) parse_ext_props(propdata, props, opts);&#13;
		}&#13;
	}&#13;
&#13;
	var custprops = {};&#13;
	if(!opts.bookSheets || opts.bookProps) {&#13;
		if (dir.custprops.length !== 0) {&#13;
			propdata = getzipstr(zip, strip_front_slash(dir.custprops[0]), true);&#13;
			if(propdata) custprops = parse_cust_props(propdata, opts);&#13;
		}&#13;
	}&#13;
&#13;
	var out = ({});&#13;
	if(opts.bookSheets || opts.bookProps) {&#13;
		if(wb.Sheets) sheets = wb.Sheets.map(function pluck(x){ return x.name; });&#13;
		else if(props.Worksheets &amp;&amp; props.SheetNames.length &gt; 0) sheets=props.SheetNames;&#13;
		if(opts.bookProps) { out.Props = props; out.Custprops = custprops; }&#13;
		if(opts.bookSheets &amp;&amp; typeof sheets !== 'undefined') out.SheetNames = sheets;&#13;
		if(opts.bookSheets ? out.SheetNames : opts.bookProps) return out;&#13;
	}&#13;
	sheets = {};&#13;
&#13;
	var deps = {};&#13;
	if(opts.bookDeps &amp;&amp; dir.calcchain) deps=parse_cc(getzipdata(zip, strip_front_slash(dir.calcchain)),dir.calcchain,opts);&#13;
&#13;
	var i=0;&#13;
	var sheetRels = ({});&#13;
	var path, relsPath;&#13;
&#13;
	{&#13;
		var wbsheets = wb.Sheets;&#13;
		props.Worksheets = wbsheets.length;&#13;
		props.SheetNames = [];&#13;
		for(var j = 0; j != wbsheets.length; ++j) {&#13;
			props.SheetNames[j] = wbsheets[j].name;&#13;
		}&#13;
	}&#13;
&#13;
	var wbext = xlsb ? "bin" : "xml";&#13;
	var wbrelsi = dir.workbooks[0].lastIndexOf("/");&#13;
	var wbrelsfile = (dir.workbooks[0].slice(0, wbrelsi+1) + "_rels/" + dir.workbooks[0].slice(wbrelsi+1) + ".rels").replace(/^\//,"");&#13;
	if(!safegetzipfile(zip, wbrelsfile)) wbrelsfile = 'xl/_rels/workbook.' + wbext + '.rels';&#13;
	var wbrels = parse_rels(getzipstr(zip, wbrelsfile, true), wbrelsfile.replace(/_rels.*/, "s5s"));&#13;
&#13;
	if((dir.metadata || []).length &gt;= 1) {&#13;
		/* TODO: MDX and other types of metadata */&#13;
		opts.xlmeta = parse_xlmeta(getzipdata(zip, strip_front_slash(dir.metadata[0])),dir.metadata[0],opts);&#13;
	}&#13;
&#13;
	if((dir.people || []).length &gt;= 1) {&#13;
		opts.people = parse_people_xml(getzipdata(zip, strip_front_slash(dir.people[0])),opts);&#13;
	}&#13;
&#13;
	if(wbrels) wbrels = safe_parse_wbrels(wbrels, wb.Sheets);&#13;
&#13;
	/* Numbers iOS hack */&#13;
	var nmode = (getzipdata(zip,"xl/worksheets/sheet.xml",true))?1:0;&#13;
	wsloop: for(i = 0; i != props.Worksheets; ++i) {&#13;
		var stype = "sheet";&#13;
		if(wbrels &amp;&amp; wbrels[i]) {&#13;
			path = 'xl/' + (wbrels[i][1]).replace(/[\/]?xl\//, "");&#13;
			if(!safegetzipfile(zip, path)) path = wbrels[i][1];&#13;
			if(!safegetzipfile(zip, path)) path = wbrelsfile.replace(/_rels\/.*$/,"") + wbrels[i][1];&#13;
			stype = wbrels[i][2];&#13;
		} else {&#13;
			path = 'xl/worksheets/sheet'+(i+1-nmode)+"." + wbext;&#13;
			path = path.replace(/sheet0\./,"sheet.");&#13;
		}&#13;
		relsPath = path.replace(/^(.*)(\/)([^\/]*)$/, "$1/_rels/$3.rels");&#13;
		if(opts &amp;&amp; opts.sheets != null) switch(typeof opts.sheets) {&#13;
			case "number": if(i != opts.sheets) continue wsloop; break;&#13;
			case "string": if(props.SheetNames[i].toLowerCase() != opts.sheets.toLowerCase()) continue wsloop; break;&#13;
			default: if(Array.isArray &amp;&amp; Array.isArray(opts.sheets)) {&#13;
				var snjseen = false;&#13;
				for(var snj = 0; snj != opts.sheets.length; ++snj) {&#13;
					if(typeof opts.sheets[snj] == "number" &amp;&amp; opts.sheets[snj] == i) snjseen=1;&#13;
					if(typeof opts.sheets[snj] == "string" &amp;&amp; opts.sheets[snj].toLowerCase() == props.SheetNames[i].toLowerCase()) snjseen = 1;&#13;
				}&#13;
				if(!snjseen) continue wsloop;&#13;
			}&#13;
		}&#13;
		safe_parse_sheet(zip, path, relsPath, props.SheetNames[i], i, sheetRels, sheets, stype, opts, wb, themes, styles);&#13;
	}&#13;
&#13;
	out = ({&#13;
		Directory: dir,&#13;
		Workbook: wb,&#13;
		Props: props,&#13;
		Custprops: custprops,&#13;
		Deps: deps,&#13;
		Sheets: sheets,&#13;
		SheetNames: props.SheetNames,&#13;
		Strings: strs,&#13;
		Styles: styles,&#13;
		Themes: themes,&#13;
		SSF: dup(table_fmt)&#13;
	});&#13;
	if(opts &amp;&amp; opts.bookFiles) {&#13;
		if(zip.files) {&#13;
			out.keys = entries;&#13;
			out.files = zip.files;&#13;
		} else {&#13;
			out.keys = [];&#13;
			out.files = {};&#13;
			zip.FullPaths.forEach(function(p, idx) {&#13;
				p = p.replace(/^Root Entry[\/]/, "");&#13;
				out.keys.push(p);&#13;
				out.files[p] = zip.FileIndex[idx];&#13;
			});&#13;
		}&#13;
	}&#13;
	if(opts &amp;&amp; opts.bookVBA) {&#13;
		if(dir.vba.length &gt; 0) out.vbaraw = getzipdata(zip,strip_front_slash(dir.vba[0]),true);&#13;
		else if(dir.defaults &amp;&amp; dir.defaults.bin === CT_VBA) out.vbaraw = getzipdata(zip, 'xl/vbaProject.bin',true);&#13;
	}&#13;
	// TODO: pass back content types metdata for xlsm/xlsx resolution&#13;
	out.bookType = xlsb ? "xlsb" : "xlsx";&#13;
	return out;&#13;
}&#13;
&#13;
/* [MS-OFFCRYPTO] 2.1.1 */&#13;
function parse_xlsxcfb(cfb, _opts) {&#13;
	var opts = _opts || {};&#13;
	var f = 'Workbook', data = CFB.find(cfb, f);&#13;
	try {&#13;
	f = '/!DataSpaces/Version';&#13;
	data = CFB.find(cfb, f); if(!data || !data.content) throw new Error("ECMA-376 Encrypted file missing " + f);&#13;
	/*var version = */parse_DataSpaceVersionInfo(data.content);&#13;
&#13;
	/* 2.3.4.1 */&#13;
	f = '/!DataSpaces/DataSpaceMap';&#13;
	data = CFB.find(cfb, f); if(!data || !data.content) throw new Error("ECMA-376 Encrypted file missing " + f);&#13;
	var dsm = parse_DataSpaceMap(data.content);&#13;
	if(dsm.length !== 1 || dsm[0].comps.length !== 1 || dsm[0].comps[0].t !== 0 || dsm[0].name !== "StrongEncryptionDataSpace" || dsm[0].comps[0].v !== "EncryptedPackage")&#13;
		throw new Error("ECMA-376 Encrypted file bad " + f);&#13;
&#13;
	/* 2.3.4.2 */&#13;
	f = '/!DataSpaces/DataSpaceInfo/StrongEncryptionDataSpace';&#13;
	data = CFB.find(cfb, f); if(!data || !data.content) throw new Error("ECMA-376 Encrypted file missing " + f);&#13;
	var seds = parse_DataSpaceDefinition(data.content);&#13;
	if(seds.length != 1 || seds[0] != "StrongEncryptionTransform")&#13;
		throw new Error("ECMA-376 Encrypted file bad " + f);&#13;
&#13;
	/* 2.3.4.3 */&#13;
	f = '/!DataSpaces/TransformInfo/StrongEncryptionTransform/!Primary';&#13;
	data = CFB.find(cfb, f); if(!data || !data.content) throw new Error("ECMA-376 Encrypted file missing " + f);&#13;
	/*var hdr = */parse_Primary(data.content);&#13;
	} catch(e) {}&#13;
&#13;
	f = '/EncryptionInfo';&#13;
	data = CFB.find(cfb, f); if(!data || !data.content) throw new Error("ECMA-376 Encrypted file missing " + f);&#13;
	var einfo = parse_EncryptionInfo(data.content);&#13;
&#13;
	/* 2.3.4.4 */&#13;
	f = '/EncryptedPackage';&#13;
	data = CFB.find(cfb, f); if(!data || !data.content) throw new Error("ECMA-376 Encrypted file missing " + f);&#13;
&#13;
/*global decrypt_agile */&#13;
if(einfo[0] == 0x04 &amp;&amp; typeof decrypt_agile !== 'undefined') return decrypt_agile(einfo[1], data.content, opts.password || "", opts);&#13;
/*global decrypt_std76 */&#13;
if(einfo[0] == 0x02 &amp;&amp; typeof decrypt_std76 !== 'undefined') return decrypt_std76(einfo[1], data.content, opts.password || "", opts);&#13;
	throw new Error("File is password-protected");&#13;
}&#13;
&#13;
function write_zip_xlsb(wb, opts) {&#13;
	if(wb &amp;&amp; !wb.SSF) {&#13;
		wb.SSF = dup(table_fmt);&#13;
	}&#13;
	if(wb &amp;&amp; wb.SSF) {&#13;
		make_ssf(); SSF_load_table(wb.SSF);&#13;
		// $FlowIgnore&#13;
		opts.revssf = evert_num(wb.SSF); opts.revssf[wb.SSF[65535]] = 0;&#13;
		opts.ssf = wb.SSF;&#13;
	}&#13;
	opts.rels = {}; opts.wbrels = {};&#13;
	opts.Strings = []; opts.Strings.Count = 0; opts.Strings.Unique = 0;&#13;
	if(browser_has_Map) opts.revStrings = new Map();&#13;
	else { opts.revStrings = {}; opts.revStrings.foo = []; delete opts.revStrings.foo; }&#13;
	var wbext = "bin";&#13;
	var vbafmt = true;&#13;
	var ct = new_ct();&#13;
	fix_write_opts(opts = opts || {});&#13;
	var zip = zip_new();&#13;
	var f = "", rId = 0;&#13;
&#13;
	opts.cellXfs = [];&#13;
	get_cell_style(opts.cellXfs, {}, {revssf:{"General":0}});&#13;
&#13;
	if(!wb.Props) wb.Props = {};&#13;
&#13;
	f = "docProps/core.xml";&#13;
	zip_add_file(zip, f, write_core_props(wb.Props, opts));&#13;
	ct.coreprops.push(f);&#13;
	add_rels(opts.rels, 2, f, RELS.CORE_PROPS);&#13;
&#13;
f = "docProps/app.xml";&#13;
	if(wb.Props &amp;&amp; wb.Props.SheetNames){/* empty */}&#13;
	else if(!wb.Workbook || !wb.Workbook.Sheets) wb.Props.SheetNames = wb.SheetNames;&#13;
	else {&#13;
		var _sn = [];&#13;
		for(var _i = 0; _i &lt; wb.SheetNames.length; ++_i)&#13;
			if((wb.Workbook.Sheets[_i]||{}).Hidden != 2) _sn.push(wb.SheetNames[_i]);&#13;
		wb.Props.SheetNames = _sn;&#13;
	}&#13;
	wb.Props.Worksheets = wb.Props.SheetNames.length;&#13;
	zip_add_file(zip, f, write_ext_props(wb.Props, opts));&#13;
	ct.extprops.push(f);&#13;
	add_rels(opts.rels, 3, f, RELS.EXT_PROPS);&#13;
&#13;
	if(wb.Custprops !== wb.Props &amp;&amp; keys(wb.Custprops||{}).length &gt; 0) {&#13;
		f = "docProps/custom.xml";&#13;
		zip_add_file(zip, f, write_cust_props(wb.Custprops, opts));&#13;
		ct.custprops.push(f);&#13;
		add_rels(opts.rels, 4, f, RELS.CUST_PROPS);&#13;
	}&#13;
&#13;
	for(rId=1;rId &lt;= wb.SheetNames.length; ++rId) {&#13;
		var wsrels = {'!id':{}};&#13;
		var ws = wb.Sheets[wb.SheetNames[rId-1]];&#13;
		var _type = (ws || {})["!type"] || "sheet";&#13;
		switch(_type) {&#13;
		case "chart":&#13;
			/* falls through */&#13;
		default:&#13;
			f = "xl/worksheets/sheet" + rId + "." + wbext;&#13;
			zip_add_file(zip, f, write_ws_bin(rId-1, opts, wb, wsrels));&#13;
			ct.sheets.push(f);&#13;
			add_rels(opts.wbrels, -1, "worksheets/sheet" + rId + "." + wbext, RELS.WS[0]);&#13;
		}&#13;
&#13;
		if(ws) {&#13;
			var comments = ws['!comments'];&#13;
			var need_vml = false;&#13;
			var cf = "";&#13;
			if(comments &amp;&amp; comments.length &gt; 0) {&#13;
				cf = "xl/comments" + rId + "." + wbext;&#13;
				zip_add_file(zip, cf, write_comments_bin(comments, opts));&#13;
				ct.comments.push(cf);&#13;
				add_rels(wsrels, -1, "../comments" + rId + "." + wbext, RELS.CMNT);&#13;
				need_vml = true;&#13;
			}&#13;
			if(ws['!legacy']) {&#13;
				if(need_vml) zip_add_file(zip, "xl/drawings/vmlDrawing" + (rId) + ".vml", write_vml(rId, ws['!comments']));&#13;
			}&#13;
			delete ws['!comments'];&#13;
			delete ws['!legacy'];&#13;
		}&#13;
&#13;
		if(wsrels['!id'].rId1) zip_add_file(zip, get_rels_path(f), write_rels(wsrels));&#13;
	}&#13;
&#13;
	if(opts.Strings != null &amp;&amp; opts.Strings.length &gt; 0) {&#13;
		f = "xl/sharedStrings." + wbext;&#13;
		zip_add_file(zip, f, write_sst_bin(opts.Strings, opts));&#13;
		ct.strs.push(f);&#13;
		add_rels(opts.wbrels, -1, "sharedStrings." + wbext, RELS.SST);&#13;
	}&#13;
&#13;
	f = "xl/workbook." + wbext;&#13;
	zip_add_file(zip, f, write_wb_bin(wb, opts));&#13;
	ct.workbooks.push(f);&#13;
	add_rels(opts.rels, 1, f, RELS.WB);&#13;
&#13;
	/* TODO: something more intelligent with themes */&#13;
&#13;
	f = "xl/theme/theme1.xml";&#13;
	var ww = write_theme(wb.Themes, opts);&#13;
	zip_add_file(zip, f, ww);&#13;
	ct.themes.push(f);&#13;
	add_rels(opts.wbrels, -1, "theme/theme1.xml", RELS.THEME);&#13;
&#13;
	/* TODO: something more intelligent with styles */&#13;
&#13;
	f = "xl/styles." + wbext;&#13;
	zip_add_file(zip, f, write_sty_bin(wb, opts));&#13;
	ct.styles.push(f);&#13;
	add_rels(opts.wbrels, -1, "styles." + wbext, RELS.STY);&#13;
&#13;
	if(wb.vbaraw &amp;&amp; vbafmt) {&#13;
		f = "xl/vbaProject.bin";&#13;
		zip_add_file(zip, f, wb.vbaraw);&#13;
		ct.vba.push(f);&#13;
		add_rels(opts.wbrels, -1, "vbaProject.bin", RELS.VBA);&#13;
	}&#13;
&#13;
	f = "xl/metadata." + wbext;&#13;
	zip_add_file(zip, f, write_xlmeta_bin());&#13;
	ct.metadata.push(f);&#13;
	add_rels(opts.wbrels, -1, "metadata." + wbext, RELS.XLMETA);&#13;
&#13;
	zip_add_file(zip, "[Content_Types].xml", write_ct(ct, opts));&#13;
	zip_add_file(zip, '_rels/.rels', write_rels(opts.rels));&#13;
	zip_add_file(zip, 'xl/_rels/workbook.' + wbext + '.rels', write_rels(opts.wbrels));&#13;
&#13;
	delete opts.revssf; delete opts.ssf;&#13;
	return zip;&#13;
}&#13;
&#13;
function write_zip_xlsx(wb, opts) {&#13;
	if(wb &amp;&amp; !wb.SSF) {&#13;
		wb.SSF = dup(table_fmt);&#13;
	}&#13;
	if(wb &amp;&amp; wb.SSF) {&#13;
		make_ssf(); SSF_load_table(wb.SSF);&#13;
		// $FlowIgnore&#13;
		opts.revssf = evert_num(wb.SSF); opts.revssf[wb.SSF[65535]] = 0;&#13;
		opts.ssf = wb.SSF;&#13;
	}&#13;
	opts.rels = {}; opts.wbrels = {};&#13;
	opts.Strings = []; opts.Strings.Count = 0; opts.Strings.Unique = 0;&#13;
	if(browser_has_Map) opts.revStrings = new Map();&#13;
	else { opts.revStrings = {}; opts.revStrings.foo = []; delete opts.revStrings.foo; }&#13;
	var wbext = "xml";&#13;
	var vbafmt = VBAFMTS.indexOf(opts.bookType) &gt; -1;&#13;
	var ct = new_ct();&#13;
	fix_write_opts(opts = opts || {});&#13;
	var zip = zip_new();&#13;
	var f = "", rId = 0;&#13;
&#13;
	opts.cellXfs = [];&#13;
	get_cell_style(opts.cellXfs, {}, {revssf:{"General":0}});&#13;
&#13;
	if(!wb.Props) wb.Props = {};&#13;
&#13;
	f = "docProps/core.xml";&#13;
	zip_add_file(zip, f, write_core_props(wb.Props, opts));&#13;
	ct.coreprops.push(f);&#13;
	add_rels(opts.rels, 2, f, RELS.CORE_PROPS);&#13;
&#13;
f = "docProps/app.xml";&#13;
	if(wb.Props &amp;&amp; wb.Props.SheetNames){/* empty */}&#13;
	else if(!wb.Workbook || !wb.Workbook.Sheets) wb.Props.SheetNames = wb.SheetNames;&#13;
	else {&#13;
		var _sn = [];&#13;
		for(var _i = 0; _i &lt; wb.SheetNames.length; ++_i)&#13;
			if((wb.Workbook.Sheets[_i]||{}).Hidden != 2) _sn.push(wb.SheetNames[_i]);&#13;
		wb.Props.SheetNames = _sn;&#13;
	}&#13;
	wb.Props.Worksheets = wb.Props.SheetNames.length;&#13;
	zip_add_file(zip, f, write_ext_props(wb.Props, opts));&#13;
	ct.extprops.push(f);&#13;
	add_rels(opts.rels, 3, f, RELS.EXT_PROPS);&#13;
&#13;
	if(wb.Custprops !== wb.Props &amp;&amp; keys(wb.Custprops||{}).length &gt; 0) {&#13;
		f = "docProps/custom.xml";&#13;
		zip_add_file(zip, f, write_cust_props(wb.Custprops, opts));&#13;
		ct.custprops.push(f);&#13;
		add_rels(opts.rels, 4, f, RELS.CUST_PROPS);&#13;
	}&#13;
&#13;
	var people = ["SheetJ5"];&#13;
	opts.tcid = 0;&#13;
&#13;
	for(rId=1;rId &lt;= wb.SheetNames.length; ++rId) {&#13;
		var wsrels = {'!id':{}};&#13;
		var ws = wb.Sheets[wb.SheetNames[rId-1]];&#13;
		var _type = (ws || {})["!type"] || "sheet";&#13;
		switch(_type) {&#13;
		case "chart":&#13;
			/* falls through */&#13;
		default:&#13;
			f = "xl/worksheets/sheet" + rId + "." + wbext;&#13;
			zip_add_file(zip, f, write_ws_xml(rId-1, opts, wb, wsrels));&#13;
			ct.sheets.push(f);&#13;
			add_rels(opts.wbrels, -1, "worksheets/sheet" + rId + "." + wbext, RELS.WS[0]);&#13;
		}&#13;
&#13;
		if(ws) {&#13;
			var comments = ws['!comments'];&#13;
			var need_vml = false;&#13;
			var cf = "";&#13;
			if(comments &amp;&amp; comments.length &gt; 0) {&#13;
				var needtc = false;&#13;
				comments.forEach(function(carr) {&#13;
					carr[1].forEach(function(c) { if(c.T == true) needtc = true; });&#13;
				});&#13;
				if(needtc) {&#13;
					cf = "xl/threadedComments/threadedComment" + rId + ".xml";&#13;
					zip_add_file(zip, cf, write_tcmnt_xml(comments, people, opts));&#13;
					ct.threadedcomments.push(cf);&#13;
					add_rels(wsrels, -1, "../threadedComments/threadedComment" + rId + ".xml", RELS.TCMNT);&#13;
				}&#13;
&#13;
				cf = "xl/comments" + rId + "." + wbext;&#13;
				zip_add_file(zip, cf, write_comments_xml(comments, opts));&#13;
				ct.comments.push(cf);&#13;
				add_rels(wsrels, -1, "../comments" + rId + "." + wbext, RELS.CMNT);&#13;
				need_vml = true;&#13;
			}&#13;
			if(ws['!legacy']) {&#13;
				if(need_vml) zip_add_file(zip, "xl/drawings/vmlDrawing" + (rId) + ".vml", write_vml(rId, ws['!comments']));&#13;
			}&#13;
			delete ws['!comments'];&#13;
			delete ws['!legacy'];&#13;
		}&#13;
&#13;
		if(wsrels['!id'].rId1) zip_add_file(zip, get_rels_path(f), write_rels(wsrels));&#13;
	}&#13;
&#13;
	if(opts.Strings != null &amp;&amp; opts.Strings.length &gt; 0) {&#13;
		f = "xl/sharedStrings." + wbext;&#13;
		zip_add_file(zip, f, write_sst_xml(opts.Strings, opts));&#13;
		ct.strs.push(f);&#13;
		add_rels(opts.wbrels, -1, "sharedStrings." + wbext, RELS.SST);&#13;
	}&#13;
&#13;
	f = "xl/workbook." + wbext;&#13;
	zip_add_file(zip, f, write_wb_xml(wb, opts));&#13;
	ct.workbooks.push(f);&#13;
	add_rels(opts.rels, 1, f, RELS.WB);&#13;
&#13;
	/* TODO: something more intelligent with themes */&#13;
&#13;
	f = "xl/theme/theme1.xml";&#13;
	zip_add_file(zip, f, write_theme(wb.Themes, opts));&#13;
	ct.themes.push(f);&#13;
	add_rels(opts.wbrels, -1, "theme/theme1.xml", RELS.THEME);&#13;
&#13;
	/* TODO: something more intelligent with styles */&#13;
&#13;
	f = "xl/styles." + wbext;&#13;
	zip_add_file(zip, f, write_sty_xml(wb, opts));&#13;
	ct.styles.push(f);&#13;
	add_rels(opts.wbrels, -1, "styles." + wbext, RELS.STY);&#13;
&#13;
	if(wb.vbaraw &amp;&amp; vbafmt) {&#13;
		f = "xl/vbaProject.bin";&#13;
		zip_add_file(zip, f, wb.vbaraw);&#13;
		ct.vba.push(f);&#13;
		add_rels(opts.wbrels, -1, "vbaProject.bin", RELS.VBA);&#13;
	}&#13;
&#13;
	f = "xl/metadata." + wbext;&#13;
	zip_add_file(zip, f, write_xlmeta_xml());&#13;
	ct.metadata.push(f);&#13;
	add_rels(opts.wbrels, -1, "metadata." + wbext, RELS.XLMETA);&#13;
&#13;
	if(people.length &gt; 1) {&#13;
		f = "xl/persons/person.xml";&#13;
		zip_add_file(zip, f, write_people_xml(people, opts));&#13;
		ct.people.push(f);&#13;
		add_rels(opts.wbrels, -1, "persons/person.xml", RELS.PEOPLE);&#13;
	}&#13;
&#13;
	zip_add_file(zip, "[Content_Types].xml", write_ct(ct, opts));&#13;
	zip_add_file(zip, '_rels/.rels', write_rels(opts.rels));&#13;
	zip_add_file(zip, 'xl/_rels/workbook.' + wbext + '.rels', write_rels(opts.wbrels));&#13;
&#13;
	delete opts.revssf; delete opts.ssf;&#13;
	return zip;&#13;
}&#13;
&#13;
function firstbyte(f,o) {&#13;
	var x = "";&#13;
	switch((o||{}).type || "base64") {&#13;
		case 'buffer': return [f[0], f[1], f[2], f[3], f[4], f[5], f[6], f[7]];&#13;
		case 'base64': x = Base64_decode(f.slice(0,12)); break;&#13;
		case 'binary': x = f; break;&#13;
		case 'array':  return [f[0], f[1], f[2], f[3], f[4], f[5], f[6], f[7]];&#13;
		default: throw new Error("Unrecognized type " + (o &amp;&amp; o.type || "undefined"));&#13;
	}&#13;
	return [x.charCodeAt(0), x.charCodeAt(1), x.charCodeAt(2), x.charCodeAt(3), x.charCodeAt(4), x.charCodeAt(5), x.charCodeAt(6), x.charCodeAt(7)];&#13;
}&#13;
&#13;
function read_cfb(cfb, opts) {&#13;
	if(CFB.find(cfb, "EncryptedPackage")) return parse_xlsxcfb(cfb, opts);&#13;
	return parse_xlscfb(cfb, opts);&#13;
}&#13;
&#13;
function read_zip(data, opts) {&#13;
	var zip, d = data;&#13;
	var o = opts||{};&#13;
	if(!o.type) o.type = (has_buf &amp;&amp; Buffer.isBuffer(data)) ? "buffer" : "base64";&#13;
	zip = zip_read(d, o);&#13;
	return parse_zip(zip, o);&#13;
}&#13;
&#13;
function read_plaintext(data, o) {&#13;
	var i = 0;&#13;
	main: while(i &lt; data.length) switch(data.charCodeAt(i)) {&#13;
		case 0x0A: case 0x0D: case 0x20: ++i; break;&#13;
		case 0x3C: return parse_xlml(data.slice(i),o);&#13;
		default: break main;&#13;
	}&#13;
	return PRN.to_workbook(data, o);&#13;
}&#13;
&#13;
function read_plaintext_raw(data, o) {&#13;
	var str = "", bytes = firstbyte(data, o);&#13;
	switch(o.type) {&#13;
		case 'base64': str = Base64_decode(data); break;&#13;
		case 'binary': str = data; break;&#13;
		case 'buffer': str = data.toString('binary'); break;&#13;
		case 'array': str = cc2str(data); break;&#13;
		default: throw new Error("Unrecognized type " + o.type);&#13;
	}&#13;
	if(bytes[0] == 0xEF &amp;&amp; bytes[1] == 0xBB &amp;&amp; bytes[2] == 0xBF) str = utf8read(str);&#13;
	o.type = "binary";&#13;
	return read_plaintext(str, o);&#13;
}&#13;
&#13;
function read_utf16(data, o) {&#13;
	var d = data;&#13;
	if(o.type == 'base64') d = Base64_decode(d);&#13;
	d = typeof $cptable !== "undefined" ? $cptable.utils.decode(1200, d.slice(2), 'str') : utf16leread(d.slice(2));&#13;
	o.type = "binary";&#13;
	return read_plaintext(d, o);&#13;
}&#13;
&#13;
function bstrify(data) {&#13;
	return !data.match(/[^\x00-\x7F]/) ? data : utf8write(data);&#13;
}&#13;
&#13;
function read_prn(data, d, o, str) {&#13;
	if(str) { o.type = "string"; return PRN.to_workbook(data, o); }&#13;
	return PRN.to_workbook(d, o);&#13;
}&#13;
&#13;
function readSync(data, opts) {&#13;
	reset_cp();&#13;
	var o = opts||{};&#13;
	if(o.codepage &amp;&amp; typeof $cptable === "undefined") console.error("Codepage tables are not loaded.  Non-ASCII characters may not give expected results");&#13;
	if(typeof ArrayBuffer !== 'undefined' &amp;&amp; data instanceof ArrayBuffer) return readSync(new Uint8Array(data), (o = dup(o), o.type = "array", o));&#13;
	if(typeof Uint8Array !== 'undefined' &amp;&amp; data instanceof Uint8Array &amp;&amp; !o.type) o.type = typeof Deno !== "undefined" ? "buffer" : "array";&#13;
	var d = data, n = [0,0,0,0], str = false;&#13;
	if(o.cellStyles) { o.cellNF = true; o.sheetStubs = true; }&#13;
	_ssfopts = {};&#13;
	if(o.dateNF) _ssfopts.dateNF = o.dateNF;&#13;
	if(!o.type) o.type = (has_buf &amp;&amp; Buffer.isBuffer(data)) ? "buffer" : "base64";&#13;
	if(o.type == "file") { o.type = has_buf ? "buffer" : "binary"; d = read_binary(data); if(typeof Uint8Array !== 'undefined' &amp;&amp; !has_buf) o.type = "array"; }&#13;
	if(o.type == "string") { str = true; o.type = "binary"; o.codepage = 65001; d = bstrify(data); }&#13;
	if(o.type == 'array' &amp;&amp; typeof Uint8Array !== 'undefined' &amp;&amp; data instanceof Uint8Array &amp;&amp; typeof ArrayBuffer !== 'undefined') {&#13;
		// $FlowIgnore&#13;
		var ab=new ArrayBuffer(3), vu=new Uint8Array(ab); vu.foo="bar";&#13;
		// $FlowIgnore&#13;
		if(!vu.foo) {o=dup(o); o.type='array'; return readSync(ab2a(d), o);}&#13;
	}&#13;
	switch((n = firstbyte(d, o))[0]) {&#13;
		case 0xD0: if(n[1] === 0xCF &amp;&amp; n[2] === 0x11 &amp;&amp; n[3] === 0xE0 &amp;&amp; n[4] === 0xA1 &amp;&amp; n[5] === 0xB1 &amp;&amp; n[6] === 0x1A &amp;&amp; n[7] === 0xE1) return read_cfb(CFB.read(d, o), o); break;&#13;
		case 0x09: if(n[1] &lt;= 0x08) return parse_xlscfb(d, o); break;&#13;
		case 0x3C: return parse_xlml(d, o);&#13;
		case 0x49:&#13;
			if(n[1] === 0x49 &amp;&amp; n[2] === 0x2a &amp;&amp; n[3] === 0x00) throw new Error("TIFF Image File is not a spreadsheet");&#13;
			if(n[1] === 0x44) return read_wb_ID(d, o);&#13;
			break;&#13;
		case 0x54: if(n[1] === 0x41 &amp;&amp; n[2] === 0x42 &amp;&amp; n[3] === 0x4C) return DIF.to_workbook(d, o); break;&#13;
		case 0x50: return (n[1] === 0x4B &amp;&amp; n[2] &lt; 0x09 &amp;&amp; n[3] &lt; 0x09) ? read_zip(d, o) : read_prn(data, d, o, str);&#13;
		case 0xEF: return n[3] === 0x3C ? parse_xlml(d, o) : read_prn(data, d, o, str);&#13;
		case 0xFF:&#13;
			if(n[1] === 0xFE) { return read_utf16(d, o); }&#13;
			else if(n[1] === 0x00 &amp;&amp; n[2] === 0x02 &amp;&amp; n[3] === 0x00) return WK_.to_workbook(d, o);&#13;
			break;&#13;
		case 0x00:&#13;
			if(n[1] === 0x00) {&#13;
				if(n[2] &gt;= 0x02 &amp;&amp; n[3] === 0x00) return WK_.to_workbook(d, o);&#13;
				if(n[2] === 0x00 &amp;&amp; (n[3] === 0x08 || n[3] === 0x09)) return WK_.to_workbook(d, o);&#13;
			}&#13;
			break;&#13;
		case 0x03: case 0x83: case 0x8B: case 0x8C: return DBF.to_workbook(d, o);&#13;
		case 0x7B: if(n[1] === 0x5C &amp;&amp; n[2] === 0x72 &amp;&amp; n[3] === 0x74) return rtf_to_workbook(d, o); break;&#13;
		case 0x0A: case 0x0D: case 0x20: return read_plaintext_raw(d, o);&#13;
		case 0x89: if(n[1] === 0x50 &amp;&amp; n[2] === 0x4E &amp;&amp; n[3] === 0x47) throw new Error("PNG Image File is not a spreadsheet"); break;&#13;
		case 0x08: if(n[1] === 0xE7) throw new Error("Unsupported Multiplan 1.x file!"); break;&#13;
		case 0x0C:&#13;
			if(n[1] === 0xEC) throw new Error("Unsupported Multiplan 2.x file!");&#13;
			if(n[1] === 0xED) throw new Error("Unsupported Multiplan 3.x file!");&#13;
			break;&#13;
	}&#13;
	if(DBF_SUPPORTED_VERSIONS.indexOf(n[0]) &gt; -1 &amp;&amp; n[2] &lt;= 12 &amp;&amp; n[3] &lt;= 31) return DBF.to_workbook(d, o);&#13;
	return read_prn(data, d, o, str);&#13;
}&#13;
&#13;
function readFileSync(filename, opts) {&#13;
	var o = opts||{}; o.type = 'file';&#13;
	return readSync(filename, o);&#13;
}&#13;
function write_cfb_ctr(cfb, o) {&#13;
	switch(o.type) {&#13;
		case "base64": case "binary": break;&#13;
		case "buffer": case "array": o.type = ""; break;&#13;
		case "file": return write_dl(o.file, CFB.write(cfb, {type:has_buf ? 'buffer' : ""}));&#13;
		case "string": throw new Error("'string' output type invalid for '" + o.bookType + "' files");&#13;
		default: throw new Error("Unrecognized type " + o.type);&#13;
	}&#13;
	return CFB.write(cfb, o);&#13;
}&#13;
&#13;
function write_zip(wb, opts) {&#13;
	switch(opts.bookType) {&#13;
		case "ods": return write_ods(wb, opts);&#13;
		case "numbers": return write_numbers_iwa(wb, opts);&#13;
		case "xlsb": return write_zip_xlsb(wb, opts);&#13;
		default: return write_zip_xlsx(wb, opts);&#13;
	}&#13;
}&#13;
&#13;
function write_zip_type(wb, opts) {&#13;
	var o = dup(opts||{});&#13;
	var z = write_zip(wb, o);&#13;
	return write_zip_denouement(z, o);&#13;
}&#13;
function write_zip_typeXLSX(wb, opts) {&#13;
	var o = dup(opts||{});&#13;
	var z = write_zip_xlsx(wb, o);&#13;
	return write_zip_denouement(z, o);&#13;
}&#13;
function write_zip_denouement(z, o) {&#13;
	var oopts = {};&#13;
	var ftype = has_buf ? "nodebuffer" : (typeof Uint8Array !== "undefined" ? "array" : "string");&#13;
	if(o.compression) oopts.compression = 'DEFLATE';&#13;
	if(o.password) oopts.type = ftype;&#13;
	else switch(o.type) {&#13;
		case "base64": oopts.type = "base64"; break;&#13;
		case "binary": oopts.type = "string"; break;&#13;
		case "string": throw new Error("'string' output type invalid for '" + o.bookType + "' files");&#13;
		case "buffer":&#13;
		case "file": oopts.type = ftype; break;&#13;
		default: throw new Error("Unrecognized type " + o.type);&#13;
	}&#13;
	var out = z.FullPaths ? CFB.write(z, {fileType:"zip", type: {"nodebuffer": "buffer", "string": "binary"}[oopts.type] || oopts.type, compression: !!o.compression}) : z.generate(oopts);&#13;
	if(typeof Deno !== "undefined") {&#13;
		if(typeof out == "string") {&#13;
			if(o.type == "binary" || o.type == "base64") return out;&#13;
			out = new Uint8Array(s2ab(out));&#13;
		}&#13;
	}&#13;
/*jshint -W083 */&#13;
	if(o.password &amp;&amp; typeof encrypt_agile !== 'undefined') return write_cfb_ctr(encrypt_agile(out, o.password), o); // eslint-disable-line no-undef&#13;
/*jshint +W083 */&#13;
	if(o.type === "file") return write_dl(o.file, out);&#13;
	return o.type == "string" ? utf8read(out) : out;&#13;
}&#13;
&#13;
function write_cfb_type(wb, opts) {&#13;
	var o = opts||{};&#13;
	var cfb = write_xlscfb(wb, o);&#13;
	return write_cfb_ctr(cfb, o);&#13;
}&#13;
&#13;
function write_string_type(out, opts, bom) {&#13;
	if(!bom) bom = "";&#13;
	var o = bom + out;&#13;
	switch(opts.type) {&#13;
		case "base64": return Base64_encode(utf8write(o));&#13;
		case "binary": return utf8write(o);&#13;
		case "string": return out;&#13;
		case "file": return write_dl(opts.file, o, 'utf8');&#13;
		case "buffer": {&#13;
			if(has_buf) return Buffer_from(o, 'utf8');&#13;
			else if(typeof TextEncoder !== "undefined") return new TextEncoder().encode(o);&#13;
			else return write_string_type(o, {type:'binary'}).split("").map(function(c) { return c.charCodeAt(0); });&#13;
		}&#13;
	}&#13;
	throw new Error("Unrecognized type " + opts.type);&#13;
}&#13;
&#13;
function write_stxt_type(out, opts) {&#13;
	switch(opts.type) {&#13;
		case "base64": return Base64_encode_pass(out);&#13;
		case "binary": return out;&#13;
		case "string": return out; /* override in sheet_to_txt */&#13;
		case "file": return write_dl(opts.file, out, 'binary');&#13;
		case "buffer": {&#13;
			if(has_buf) return Buffer_from(out, 'binary');&#13;
			else return out.split("").map(function(c) { return c.charCodeAt(0); });&#13;
		}&#13;
	}&#13;
	throw new Error("Unrecognized type " + opts.type);&#13;
}&#13;
&#13;
/* TODO: test consistency */&#13;
function write_binary_type(out, opts) {&#13;
	switch(opts.type) {&#13;
		case "string":&#13;
		case "base64":&#13;
		case "binary":&#13;
			var bstr = "";&#13;
			// $FlowIgnore&#13;
			for(var i = 0; i &lt; out.length; ++i) bstr += String.fromCharCode(out[i]);&#13;
			return opts.type == 'base64' ? Base64_encode(bstr) : opts.type == 'string' ? utf8read(bstr) : bstr;&#13;
		case "file": return write_dl(opts.file, out);&#13;
		case "buffer": return out;&#13;
		default: throw new Error("Unrecognized type " + opts.type);&#13;
	}&#13;
}&#13;
&#13;
function writeSyncXLSX(wb, opts) {&#13;
	reset_cp();&#13;
	check_wb(wb);&#13;
	var o = dup(opts||{});&#13;
	if(o.cellStyles) { o.cellNF = true; o.sheetStubs = true; }&#13;
	if(o.type == "array") { o.type = "binary"; var out = (writeSyncXLSX(wb, o)); o.type = "array"; return s2ab(out); }&#13;
	return write_zip_typeXLSX(wb, o);&#13;
}&#13;
&#13;
function writeSync(wb, opts) {&#13;
	reset_cp();&#13;
	check_wb(wb);&#13;
	var o = dup(opts||{});&#13;
	if(o.cellStyles) { o.cellNF = true; o.sheetStubs = true; }&#13;
	if(o.type == "array") { o.type = "binary"; var out = (writeSync(wb, o)); o.type = "array"; return s2ab(out); }&#13;
	var idx = 0;&#13;
	if(o.sheet) {&#13;
		if(typeof o.sheet == "number") idx = o.sheet;&#13;
		else idx = wb.SheetNames.indexOf(o.sheet);&#13;
		if(!wb.SheetNames[idx]) throw new Error("Sheet not found: " + o.sheet + " : " + (typeof o.sheet));&#13;
	}&#13;
	switch(o.bookType || 'xlsb') {&#13;
		case 'xml':&#13;
		case 'xlml': return write_string_type(write_xlml(wb, o), o);&#13;
		case 'slk':&#13;
		case 'sylk': return write_string_type(SYLK.from_sheet(wb.Sheets[wb.SheetNames[idx]], o, wb), o);&#13;
		case 'htm':&#13;
		case 'html': return write_string_type(sheet_to_html(wb.Sheets[wb.SheetNames[idx]], o), o);&#13;
		case 'txt': return write_stxt_type(sheet_to_txt(wb.Sheets[wb.SheetNames[idx]], o), o);&#13;
		case 'csv': return write_string_type(sheet_to_csv(wb.Sheets[wb.SheetNames[idx]], o), o, "\ufeff");&#13;
		case 'dif': return write_string_type(DIF.from_sheet(wb.Sheets[wb.SheetNames[idx]], o), o);&#13;
		case 'dbf': return write_binary_type(DBF.from_sheet(wb.Sheets[wb.SheetNames[idx]], o), o);&#13;
		case 'prn': return write_string_type(PRN.from_sheet(wb.Sheets[wb.SheetNames[idx]], o), o);&#13;
		case 'rtf': return write_string_type(sheet_to_rtf(wb.Sheets[wb.SheetNames[idx]], o), o);&#13;
		case 'eth': return write_string_type(ETH.from_sheet(wb.Sheets[wb.SheetNames[idx]], o), o);&#13;
		case 'fods': return write_string_type(write_ods(wb, o), o);&#13;
		case 'wk1': return write_binary_type(WK_.sheet_to_wk1(wb.Sheets[wb.SheetNames[idx]], o), o);&#13;
		case 'wk3': return write_binary_type(WK_.book_to_wk3(wb, o), o);&#13;
		case 'biff2': if(!o.biff) o.biff = 2; /* falls through */&#13;
		case 'biff3': if(!o.biff) o.biff = 3; /* falls through */&#13;
		case 'biff4': if(!o.biff) o.biff = 4; return write_binary_type(write_biff_buf(wb, o), o);&#13;
		case 'biff5': if(!o.biff) o.biff = 5; /* falls through */&#13;
		case 'biff8':&#13;
		case 'xla':&#13;
		case 'xls': if(!o.biff) o.biff = 8; return write_cfb_type(wb, o);&#13;
		case 'xlsx':&#13;
		case 'xlsm':&#13;
		case 'xlam':&#13;
		case 'xlsb':&#13;
		case 'numbers':&#13;
		case 'ods': return write_zip_type(wb, o);&#13;
		default: throw new Error ("Unrecognized bookType |" + o.bookType + "|");&#13;
	}&#13;
}&#13;
&#13;
function resolve_book_type(o) {&#13;
	if(o.bookType) return;&#13;
	var _BT = {&#13;
		"xls": "biff8",&#13;
		"htm": "html",&#13;
		"slk": "sylk",&#13;
		"socialcalc": "eth",&#13;
		"Sh33tJS": "WTF"&#13;
	};&#13;
	var ext = o.file.slice(o.file.lastIndexOf(".")).toLowerCase();&#13;
	if(ext.match(/^\.[a-z]+$/)) o.bookType = ext.slice(1);&#13;
	o.bookType = _BT[o.bookType] || o.bookType;&#13;
}&#13;
&#13;
function writeFileSync(wb, filename, opts) {&#13;
	var o = opts||{}; o.type = 'file';&#13;
	o.file = filename;&#13;
	resolve_book_type(o);&#13;
	return writeSync(wb, o);&#13;
}&#13;
&#13;
function writeFileSyncXLSX(wb, filename, opts) {&#13;
	var o = opts||{}; o.type = 'file';&#13;
	o.file = filename;&#13;
	resolve_book_type(o);&#13;
	return writeSyncXLSX(wb, o);&#13;
}&#13;
&#13;
&#13;
function writeFileAsync(filename, wb, opts, cb) {&#13;
	var o = opts||{}; o.type = 'file';&#13;
	o.file = filename;&#13;
	resolve_book_type(o);&#13;
	o.type = 'buffer';&#13;
	var _cb = cb; if(!(_cb instanceof Function)) _cb = (opts);&#13;
	return _fs.writeFile(filename, writeSync(wb, o), _cb);&#13;
}&#13;
function make_json_row(sheet, r, R, cols, header, hdr, dense, o) {&#13;
	var rr = encode_row(R);&#13;
	var defval = o.defval, raw = o.raw || !Object.prototype.hasOwnProperty.call(o, "raw");&#13;
	var isempty = true;&#13;
	var row = (header === 1) ? [] : {};&#13;
	if(header !== 1) {&#13;
		if(Object.defineProperty) try { Object.defineProperty(row, '__rowNum__', {value:R, enumerable:false}); } catch(e) { row.__rowNum__ = R; }&#13;
		else row.__rowNum__ = R;&#13;
	}&#13;
	if(!dense || sheet[R]) for (var C = r.s.c; C &lt;= r.e.c; ++C) {&#13;
		var val = dense ? sheet[R][C] : sheet[cols[C] + rr];&#13;
		if(val === undefined || val.t === undefined) {&#13;
			if(defval === undefined) continue;&#13;
			if(hdr[C] != null) { row[hdr[C]] = defval; }&#13;
			continue;&#13;
		}&#13;
		var v = val.v;&#13;
		switch(val.t){&#13;
			case 'z': if(v == null) break; continue;&#13;
			case 'e': v = (v == 0 ? null : void 0); break;&#13;
			case 's': case 'd': case 'b': case 'n': break;&#13;
			default: throw new Error('unrecognized type ' + val.t);&#13;
		}&#13;
		if(hdr[C] != null) {&#13;
			if(v == null) {&#13;
				if(val.t == "e" &amp;&amp; v === null) row[hdr[C]] = null;&#13;
				else if(defval !== undefined) row[hdr[C]] = defval;&#13;
				else if(raw &amp;&amp; v === null) row[hdr[C]] = null;&#13;
				else continue;&#13;
			} else {&#13;
				row[hdr[C]] = raw &amp;&amp; (val.t !== "n" || (val.t === "n" &amp;&amp; o.rawNumbers !== false)) ? v : format_cell(val,v,o);&#13;
			}&#13;
			if(v != null) isempty = false;&#13;
		}&#13;
	}&#13;
	return { row: row, isempty: isempty };&#13;
}&#13;
&#13;
&#13;
function sheet_to_json(sheet, opts) {&#13;
	if(sheet == null || sheet["!ref"] == null) return [];&#13;
	var val = {t:'n',v:0}, header = 0, offset = 1, hdr = [], v=0, vv="";&#13;
	var r = {s:{r:0,c:0},e:{r:0,c:0}};&#13;
	var o = opts || {};&#13;
	var range = o.range != null ? o.range : sheet["!ref"];&#13;
	if(o.header === 1) header = 1;&#13;
	else if(o.header === "A") header = 2;&#13;
	else if(Array.isArray(o.header)) header = 3;&#13;
	else if(o.header == null) header = 0;&#13;
	switch(typeof range) {&#13;
		case 'string': r = safe_decode_range(range); break;&#13;
		case 'number': r = safe_decode_range(sheet["!ref"]); r.s.r = range; break;&#13;
		default: r = range;&#13;
	}&#13;
	if(header &gt; 0) offset = 0;&#13;
	var rr = encode_row(r.s.r);&#13;
	var cols = [];&#13;
	var out = [];&#13;
	var outi = 0, counter = 0;&#13;
	var dense = Array.isArray(sheet);&#13;
	var R = r.s.r, C = 0;&#13;
	var header_cnt = {};&#13;
	if(dense &amp;&amp; !sheet[R]) sheet[R] = [];&#13;
	var colinfo = o.skipHidden &amp;&amp; sheet["!cols"] || [];&#13;
	var rowinfo = o.skipHidden &amp;&amp; sheet["!rows"] || [];&#13;
	for(C = r.s.c; C &lt;= r.e.c; ++C) {&#13;
		if(((colinfo[C]||{}).hidden)) continue;&#13;
		cols[C] = encode_col(C);&#13;
		val = dense ? sheet[R][C] : sheet[cols[C] + rr];&#13;
		switch(header) {&#13;
			case 1: hdr[C] = C - r.s.c; break;&#13;
			case 2: hdr[C] = cols[C]; break;&#13;
			case 3: hdr[C] = o.header[C - r.s.c]; break;&#13;
			default:&#13;
				if(val == null) val = {w: "__EMPTY", t: "s"};&#13;
				vv = v = format_cell(val, null, o);&#13;
				counter = header_cnt[v] || 0;&#13;
				if(!counter) header_cnt[v] = 1;&#13;
				else {&#13;
					do { vv = v + "_" + (counter++); } while(header_cnt[vv]); header_cnt[v] = counter;&#13;
					header_cnt[vv] = 1;&#13;
				}&#13;
				hdr[C] = vv;&#13;
		}&#13;
	}&#13;
	for (R = r.s.r + offset; R &lt;= r.e.r; ++R) {&#13;
		if ((rowinfo[R]||{}).hidden) continue;&#13;
		var row = make_json_row(sheet, r, R, cols, header, hdr, dense, o);&#13;
		if((row.isempty === false) || (header === 1 ? o.blankrows !== false : !!o.blankrows)) out[outi++] = row.row;&#13;
	}&#13;
	out.length = outi;&#13;
	return out;&#13;
}&#13;
&#13;
var qreg = /"/g;&#13;
function make_csv_row(sheet, r, R, cols, fs, rs, FS, o) {&#13;
	var isempty = true;&#13;
	var row = [], txt = "", rr = encode_row(R);&#13;
	for(var C = r.s.c; C &lt;= r.e.c; ++C) {&#13;
		if (!cols[C]) continue;&#13;
		var val = o.dense ? (sheet[R]||[])[C]: sheet[cols[C] + rr];&#13;
		if(val == null) txt = "";&#13;
		else if(val.v != null) {&#13;
			isempty = false;&#13;
			txt = ''+(o.rawNumbers &amp;&amp; val.t == "n" ? val.v : format_cell(val, null, o));&#13;
			for(var i = 0, cc = 0; i !== txt.length; ++i) if((cc = txt.charCodeAt(i)) === fs || cc === rs || cc === 34 || o.forceQuotes) {txt = "\"" + txt.replace(qreg, '""') + "\""; break; }&#13;
			if(txt == "ID") txt = '"ID"';&#13;
		} else if(val.f != null &amp;&amp; !val.F) {&#13;
			isempty = false;&#13;
			txt = '=' + val.f; if(txt.indexOf(",") &gt;= 0) txt = '"' + txt.replace(qreg, '""') + '"';&#13;
		} else txt = "";&#13;
		/* NOTE: Excel CSV does not support array formulae */&#13;
		row.push(txt);&#13;
	}&#13;
	if(o.blankrows === false &amp;&amp; isempty) return null;&#13;
	return row.join(FS);&#13;
}&#13;
&#13;
function sheet_to_csv(sheet, opts) {&#13;
	var out = [];&#13;
	var o = opts == null ? {} : opts;&#13;
	if(sheet == null || sheet["!ref"] == null) return "";&#13;
	var r = safe_decode_range(sheet["!ref"]);&#13;
	var FS = o.FS !== undefined ? o.FS : ",", fs = FS.charCodeAt(0);&#13;
	var RS = o.RS !== undefined ? o.RS : "\n", rs = RS.charCodeAt(0);&#13;
	var endregex = new RegExp((FS=="|" ? "\\|" : FS)+"+$");&#13;
	var row = "", cols = [];&#13;
	o.dense = Array.isArray(sheet);&#13;
	var colinfo = o.skipHidden &amp;&amp; sheet["!cols"] || [];&#13;
	var rowinfo = o.skipHidden &amp;&amp; sheet["!rows"] || [];&#13;
	for(var C = r.s.c; C &lt;= r.e.c; ++C) if (!((colinfo[C]||{}).hidden)) cols[C] = encode_col(C);&#13;
	var w = 0;&#13;
	for(var R = r.s.r; R &lt;= r.e.r; ++R) {&#13;
		if ((rowinfo[R]||{}).hidden) continue;&#13;
		row = make_csv_row(sheet, r, R, cols, fs, rs, FS, o);&#13;
		if(row == null) { continue; }&#13;
		if(o.strip) row = row.replace(endregex,"");&#13;
		if(row || (o.blankrows !== false)) out.push((w++ ? RS : "") + row);&#13;
	}&#13;
	delete o.dense;&#13;
	return out.join("");&#13;
}&#13;
&#13;
function sheet_to_txt(sheet, opts) {&#13;
	if(!opts) opts = {}; opts.FS = "\t"; opts.RS = "\n";&#13;
	var s = sheet_to_csv(sheet, opts);&#13;
	if(typeof $cptable == 'undefined' || opts.type == 'string') return s;&#13;
	var o = $cptable.utils.encode(1200, s, 'str');&#13;
	return String.fromCharCode(255) + String.fromCharCode(254) + o;&#13;
}&#13;
&#13;
function sheet_to_formulae(sheet) {&#13;
	var y = "", x, val="";&#13;
	if(sheet == null || sheet["!ref"] == null) return [];&#13;
	var r = safe_decode_range(sheet['!ref']), rr = "", cols = [], C;&#13;
	var cmds = [];&#13;
	var dense = Array.isArray(sheet);&#13;
	for(C = r.s.c; C &lt;= r.e.c; ++C) cols[C] = encode_col(C);&#13;
	for(var R = r.s.r; R &lt;= r.e.r; ++R) {&#13;
		rr = encode_row(R);&#13;
		for(C = r.s.c; C &lt;= r.e.c; ++C) {&#13;
			y = cols[C] + rr;&#13;
			x = dense ? (sheet[R]||[])[C] : sheet[y];&#13;
			val = "";&#13;
			if(x === undefined) continue;&#13;
			else if(x.F != null) {&#13;
				y = x.F;&#13;
				if(!x.f) continue;&#13;
				val = x.f;&#13;
				if(y.indexOf(":") == -1) y = y + ":" + y;&#13;
			}&#13;
			if(x.f != null) val = x.f;&#13;
			else if(x.t == 'z') continue;&#13;
			else if(x.t == 'n' &amp;&amp; x.v != null) val = "" + x.v;&#13;
			else if(x.t == 'b') val = x.v ? "TRUE" : "FALSE";&#13;
			else if(x.w !== undefined) val = "'" + x.w;&#13;
			else if(x.v === undefined) continue;&#13;
			else if(x.t == 's') val = "'" + x.v;&#13;
			else val = ""+x.v;&#13;
			cmds[cmds.length] = y + "=" + val;&#13;
		}&#13;
	}&#13;
	return cmds;&#13;
}&#13;
&#13;
function sheet_add_json(_ws, js, opts) {&#13;
	var o = opts || {};&#13;
	var dense = _ws ? Array.isArray(_ws) : o.dense;&#13;
	if(DENSE != null &amp;&amp; dense == null) dense = DENSE;&#13;
	var offset = +!o.skipHeader;&#13;
	var ws = _ws || (dense ? ([]) : ({}));&#13;
	var _R = 0, _C = 0;&#13;
	if(ws &amp;&amp; o.origin != null) {&#13;
		if(typeof o.origin == 'number') _R = o.origin;&#13;
		else {&#13;
			var _origin = typeof o.origin == "string" ? decode_cell(o.origin) : o.origin;&#13;
			_R = _origin.r; _C = _origin.c;&#13;
		}&#13;
	}&#13;
	var range = ({s: {c:0, r:0}, e: {c:_C, r:_R + js.length - 1 + offset}});&#13;
	if(ws['!ref']) {&#13;
		var _range = safe_decode_range(ws['!ref']);&#13;
		range.e.c = Math.max(range.e.c, _range.e.c);&#13;
		range.e.r = Math.max(range.e.r, _range.e.r);&#13;
		if(_R == -1) { _R = _range.e.r + 1; range.e.r = _R + js.length - 1 + offset; }&#13;
	} else {&#13;
		if(_R == -1) { _R = 0; range.e.r = js.length - 1 + offset; }&#13;
	}&#13;
	var hdr = o.header || [], C = 0;&#13;
	var ROW = [];&#13;
	js.forEach(function (JS, R) {&#13;
		if(dense &amp;&amp; !ws[_R + R + offset]) ws[_R + R + offset] = [];&#13;
		if(dense) ROW = ws[_R + R + offset];&#13;
		keys(JS).forEach(function(k) {&#13;
			if((C=hdr.indexOf(k)) == -1) hdr[C=hdr.length] = k;&#13;
			var v = JS[k];&#13;
			var t = 'z';&#13;
			var z = "";&#13;
			var ref = dense ? "" : encode_cell({c:_C + C,r:_R + R + offset});&#13;
			var cell = dense ? ROW[_C + C] : ws[ref];&#13;
			if(v &amp;&amp; typeof v === 'object' &amp;&amp; !(v instanceof Date)){&#13;
				ws[ref] = v;&#13;
			} else {&#13;
				if(typeof v == 'number') t = 'n';&#13;
				else if(typeof v == 'boolean') t = 'b';&#13;
				else if(typeof v == 'string') t = 's';&#13;
				else if(v instanceof Date) {&#13;
					t = 'd';&#13;
					if(!o.cellDates) { t = 'n'; v = datenum(v); }&#13;
					z = (cell != null &amp;&amp; cell.z &amp;&amp; fmt_is_date(cell.z)) ? cell.z : (o.dateNF || table_fmt[14]);&#13;
				}&#13;
				else if(v === null &amp;&amp; o.nullError) { t = 'e'; v = 0; }&#13;
				if(!cell) {&#13;
					if(!dense) ws[ref] = cell = ({t:t, v:v});&#13;
					else ROW[_C + C] = cell = ({t:t, v:v});&#13;
				} else {&#13;
					cell.t = t; cell.v = v;&#13;
					delete cell.w; delete cell.R;&#13;
					if(z) cell.z = z;&#13;
				}&#13;
				if(z) cell.z = z;&#13;
			}&#13;
		});&#13;
	});&#13;
	range.e.c = Math.max(range.e.c, _C + hdr.length - 1);&#13;
	var __R = encode_row(_R);&#13;
	if(dense &amp;&amp; !ws[_R]) ws[_R] = [];&#13;
	if(offset) for(C = 0; C &lt; hdr.length; ++C) {&#13;
		if(dense) ws[_R][C + _C] = {t:'s', v:hdr[C]};&#13;
		else ws[encode_col(C + _C) + __R] = {t:'s', v:hdr[C]};&#13;
	}&#13;
	ws['!ref'] = encode_range(range);&#13;
	return ws;&#13;
}&#13;
function json_to_sheet(js, opts) { return sheet_add_json(null, js, opts); }&#13;
&#13;
/* get cell, creating a stub if necessary */&#13;
function ws_get_cell_stub(ws, R, C) {&#13;
	/* A1 cell address */&#13;
	if(typeof R == "string") {&#13;
		/* dense */&#13;
		if(Array.isArray(ws)) {&#13;
			var RC = decode_cell(R);&#13;
			if(!ws[RC.r]) ws[RC.r] = [];&#13;
			return ws[RC.r][RC.c] || (ws[RC.r][RC.c] = {t:'z'});&#13;
		}&#13;
		return ws[R] || (ws[R] = {t:'z'});&#13;
	}&#13;
	/* cell address object */&#13;
	if(typeof R != "number") return ws_get_cell_stub(ws, encode_cell(R));&#13;
	/* R and C are 0-based indices */&#13;
	return ws_get_cell_stub(ws, encode_cell({r:R,c:C||0}));&#13;
}&#13;
&#13;
/* find sheet index for given name / validate index */&#13;
function wb_sheet_idx(wb, sh) {&#13;
	if(typeof sh == "number") {&#13;
		if(sh &gt;= 0 &amp;&amp; wb.SheetNames.length &gt; sh) return sh;&#13;
		throw new Error("Cannot find sheet # " + sh);&#13;
	} else if(typeof sh == "string") {&#13;
		var idx = wb.SheetNames.indexOf(sh);&#13;
		if(idx &gt; -1) return idx;&#13;
		throw new Error("Cannot find sheet name |" + sh + "|");&#13;
	} else throw new Error("Cannot find sheet |" + sh + "|");&#13;
}&#13;
&#13;
/* simple blank workbook object */&#13;
function book_new() {&#13;
	return { SheetNames: [], Sheets: {} };&#13;
}&#13;
&#13;
/* add a worksheet to the end of a given workbook */&#13;
function book_append_sheet(wb, ws, name, roll) {&#13;
	var i = 1;&#13;
	if(!name) for(; i &lt;= 0xFFFF; ++i, name = undefined) if(wb.SheetNames.indexOf(name = "Sheet" + i) == -1) break;&#13;
	if(!name || wb.SheetNames.length &gt;= 0xFFFF) throw new Error("Too many worksheets");&#13;
	if(roll &amp;&amp; wb.SheetNames.indexOf(name) &gt;= 0) {&#13;
		var m = name.match(/(^.*?)(\d+)$/);&#13;
		i = m &amp;&amp; +m[2] || 0;&#13;
		var root = m &amp;&amp; m[1] || name;&#13;
		for(++i; i &lt;= 0xFFFF; ++i) if(wb.SheetNames.indexOf(name = root + i) == -1) break;&#13;
	}&#13;
	check_ws_name(name);&#13;
	if(wb.SheetNames.indexOf(name) &gt;= 0) throw new Error("Worksheet with name |" + name + "| already exists!");&#13;
&#13;
	wb.SheetNames.push(name);&#13;
	wb.Sheets[name] = ws;&#13;
	return name;&#13;
}&#13;
&#13;
/* set sheet visibility (visible/hidden/very hidden) */&#13;
function book_set_sheet_visibility(wb, sh, vis) {&#13;
	if(!wb.Workbook) wb.Workbook = {};&#13;
	if(!wb.Workbook.Sheets) wb.Workbook.Sheets = [];&#13;
&#13;
	var idx = wb_sheet_idx(wb, sh);&#13;
	// $FlowIgnore&#13;
	if(!wb.Workbook.Sheets[idx]) wb.Workbook.Sheets[idx] = {};&#13;
&#13;
	switch(vis) {&#13;
		case 0: case 1: case 2: break;&#13;
		default: throw new Error("Bad sheet visibility setting " + vis);&#13;
	}&#13;
	// $FlowIgnore&#13;
	wb.Workbook.Sheets[idx].Hidden = vis;&#13;
}&#13;
&#13;
/* set number format */&#13;
function cell_set_number_format(cell, fmt) {&#13;
	cell.z = fmt;&#13;
	return cell;&#13;
}&#13;
&#13;
/* set cell hyperlink */&#13;
function cell_set_hyperlink(cell, target, tooltip) {&#13;
	if(!target) {&#13;
		delete cell.l;&#13;
	} else {&#13;
		cell.l = ({ Target: target });&#13;
		if(tooltip) cell.l.Tooltip = tooltip;&#13;
	}&#13;
	return cell;&#13;
}&#13;
function cell_set_internal_link(cell, range, tooltip) { return cell_set_hyperlink(cell, "#" + range, tooltip); }&#13;
&#13;
/* add to cell comments */&#13;
function cell_add_comment(cell, text, author) {&#13;
	if(!cell.c) cell.c = [];&#13;
	cell.c.push({t:text, a:author||"xlsx"});&#13;
}&#13;
&#13;
/* set array formula and flush related cells */&#13;
function sheet_set_array_formula(ws, range, formula, dynamic) {&#13;
	var rng = typeof range != "string" ? range : safe_decode_range(range);&#13;
	var rngstr = typeof range == "string" ? range : encode_range(range);&#13;
	for(var R = rng.s.r; R &lt;= rng.e.r; ++R) for(var C = rng.s.c; C &lt;= rng.e.c; ++C) {&#13;
		var cell = ws_get_cell_stub(ws, R, C);&#13;
		cell.t = 'n';&#13;
		cell.F = rngstr;&#13;
		delete cell.v;&#13;
		if(R == rng.s.r &amp;&amp; C == rng.s.c) {&#13;
			cell.f = formula;&#13;
			if(dynamic) cell.D = true;&#13;
		}&#13;
	}&#13;
	var wsr = decode_range(ws["!ref"]);&#13;
	if(wsr.s.r &gt; rng.s.r) wsr.s.r = rng.s.r;&#13;
	if(wsr.s.c &gt; rng.s.c) wsr.s.c = rng.s.c;&#13;
	if(wsr.e.r &lt; rng.e.r) wsr.e.r = rng.e.r;&#13;
	if(wsr.e.c &lt; rng.e.c) wsr.e.c = rng.e.c;&#13;
	ws["!ref"] = encode_range(wsr);&#13;
	return ws;&#13;
}&#13;
&#13;
var utils = {&#13;
	encode_col: encode_col,&#13;
	encode_row: encode_row,&#13;
	encode_cell: encode_cell,&#13;
	encode_range: encode_range,&#13;
	decode_col: decode_col,&#13;
	decode_row: decode_row,&#13;
	split_cell: split_cell,&#13;
	decode_cell: decode_cell,&#13;
	decode_range: decode_range,&#13;
	format_cell: format_cell,&#13;
	sheet_add_aoa: sheet_add_aoa,&#13;
	sheet_add_json: sheet_add_json,&#13;
	sheet_add_dom: sheet_add_dom,&#13;
	aoa_to_sheet: aoa_to_sheet,&#13;
	json_to_sheet: json_to_sheet,&#13;
	table_to_sheet: parse_dom_table,&#13;
	table_to_book: table_to_book,&#13;
	sheet_to_csv: sheet_to_csv,&#13;
	sheet_to_txt: sheet_to_txt,&#13;
	sheet_to_json: sheet_to_json,&#13;
	sheet_to_html: sheet_to_html,&#13;
	sheet_to_formulae: sheet_to_formulae,&#13;
	sheet_to_row_object_array: sheet_to_json,&#13;
	sheet_get_cell: ws_get_cell_stub,&#13;
	book_new: book_new,&#13;
	book_append_sheet: book_append_sheet,&#13;
	book_set_sheet_visibility: book_set_sheet_visibility,&#13;
	cell_set_number_format: cell_set_number_format,&#13;
	cell_set_hyperlink: cell_set_hyperlink,&#13;
	cell_set_internal_link: cell_set_internal_link,&#13;
	cell_add_comment: cell_add_comment,&#13;
	sheet_set_array_formula: sheet_set_array_formula,&#13;
	consts: {&#13;
		SHEET_VISIBLE: 0,&#13;
		SHEET_HIDDEN: 1,&#13;
		SHEET_VERY_HIDDEN: 2&#13;
	}&#13;
};&#13;
&#13;
var _Readable;&#13;
function set_readable(R) { _Readable = R; }&#13;
&#13;
function write_csv_stream(sheet, opts) {&#13;
	var stream = _Readable();&#13;
	var o = opts == null ? {} : opts;&#13;
	if(sheet == null || sheet["!ref"] == null) { stream.push(null); return stream; }&#13;
	var r = safe_decode_range(sheet["!ref"]);&#13;
	var FS = o.FS !== undefined ? o.FS : ",", fs = FS.charCodeAt(0);&#13;
	var RS = o.RS !== undefined ? o.RS : "\n", rs = RS.charCodeAt(0);&#13;
	var endregex = new RegExp((FS=="|" ? "\\|" : FS)+"+$");&#13;
	var row = "", cols = [];&#13;
	o.dense = Array.isArray(sheet);&#13;
	var colinfo = o.skipHidden &amp;&amp; sheet["!cols"] || [];&#13;
	var rowinfo = o.skipHidden &amp;&amp; sheet["!rows"] || [];&#13;
	for(var C = r.s.c; C &lt;= r.e.c; ++C) if (!((colinfo[C]||{}).hidden)) cols[C] = encode_col(C);&#13;
	var R = r.s.r;&#13;
	var BOM = false, w = 0;&#13;
	stream._read = function() {&#13;
		if(!BOM) { BOM = true; return stream.push("\uFEFF"); }&#13;
		while(R &lt;= r.e.r) {&#13;
			++R;&#13;
			if ((rowinfo[R-1]||{}).hidden) continue;&#13;
			row = make_csv_row(sheet, r, R-1, cols, fs, rs, FS, o);&#13;
			if(row != null) {&#13;
				if(o.strip) row = row.replace(endregex,"");&#13;
				if(row || (o.blankrows !== false)) return stream.push((w++ ? RS : "") + row);&#13;
			}&#13;
		}&#13;
		return stream.push(null);&#13;
	};&#13;
	return stream;&#13;
}&#13;
&#13;
function write_html_stream(ws, opts) {&#13;
	var stream = _Readable();&#13;
&#13;
	var o = opts || {};&#13;
	var header = o.header != null ? o.header : HTML_BEGIN;&#13;
	var footer = o.footer != null ? o.footer : HTML_END;&#13;
	stream.push(header);&#13;
	var r = decode_range(ws['!ref']);&#13;
	o.dense = Array.isArray(ws);&#13;
	stream.push(make_html_preamble(ws, r, o));&#13;
	var R = r.s.r;&#13;
	var end = false;&#13;
	stream._read = function() {&#13;
		if(R &gt; r.e.r) {&#13;
			if(!end) { end = true; stream.push("&lt;/table&gt;" + footer); }&#13;
			return stream.push(null);&#13;
		}&#13;
		while(R &lt;= r.e.r) {&#13;
			stream.push(make_html_row(ws, r, R, o));&#13;
			++R;&#13;
			break;&#13;
		}&#13;
	};&#13;
	return stream;&#13;
}&#13;
&#13;
function write_json_stream(sheet, opts) {&#13;
	var stream = _Readable({objectMode:true});&#13;
&#13;
	if(sheet == null || sheet["!ref"] == null) { stream.push(null); return stream; }&#13;
	var val = {t:'n',v:0}, header = 0, offset = 1, hdr = [], v=0, vv="";&#13;
	var r = {s:{r:0,c:0},e:{r:0,c:0}};&#13;
	var o = opts || {};&#13;
	var range = o.range != null ? o.range : sheet["!ref"];&#13;
	if(o.header === 1) header = 1;&#13;
	else if(o.header === "A") header = 2;&#13;
	else if(Array.isArray(o.header)) header = 3;&#13;
	switch(typeof range) {&#13;
		case 'string': r = safe_decode_range(range); break;&#13;
		case 'number': r = safe_decode_range(sheet["!ref"]); r.s.r = range; break;&#13;
		default: r = range;&#13;
	}&#13;
	if(header &gt; 0) offset = 0;&#13;
	var rr = encode_row(r.s.r);&#13;
	var cols = [];&#13;
	var counter = 0;&#13;
	var dense = Array.isArray(sheet);&#13;
	var R = r.s.r, C = 0;&#13;
	var header_cnt = {};&#13;
	if(dense &amp;&amp; !sheet[R]) sheet[R] = [];&#13;
	var colinfo = o.skipHidden &amp;&amp; sheet["!cols"] || [];&#13;
	var rowinfo = o.skipHidden &amp;&amp; sheet["!rows"] || [];&#13;
	for(C = r.s.c; C &lt;= r.e.c; ++C) {&#13;
		if(((colinfo[C]||{}).hidden)) continue;&#13;
		cols[C] = encode_col(C);&#13;
		val = dense ? sheet[R][C] : sheet[cols[C] + rr];&#13;
		switch(header) {&#13;
			case 1: hdr[C] = C - r.s.c; break;&#13;
			case 2: hdr[C] = cols[C]; break;&#13;
			case 3: hdr[C] = o.header[C - r.s.c]; break;&#13;
			default:&#13;
				if(val == null) val = {w: "__EMPTY", t: "s"};&#13;
				vv = v = format_cell(val, null, o);&#13;
				counter = header_cnt[v] || 0;&#13;
				if(!counter) header_cnt[v] = 1;&#13;
				else {&#13;
					do { vv = v + "_" + (counter++); } while(header_cnt[vv]); header_cnt[v] = counter;&#13;
					header_cnt[vv] = 1;&#13;
				}&#13;
				hdr[C] = vv;&#13;
		}&#13;
	}&#13;
	R = r.s.r + offset;&#13;
	stream._read = function() {&#13;
		while(R &lt;= r.e.r) {&#13;
			if ((rowinfo[R-1]||{}).hidden) continue;&#13;
			var row = make_json_row(sheet, r, R, cols, header, hdr, dense, o);&#13;
			++R;&#13;
			if((row.isempty === false) || (header === 1 ? o.blankrows !== false : !!o.blankrows)) {&#13;
				stream.push(row.row);&#13;
				return;&#13;
			}&#13;
		}&#13;
		return stream.push(null);&#13;
	};&#13;
	return stream;&#13;
}&#13;
&#13;
var __stream = {&#13;
	to_json: write_json_stream,&#13;
	to_html: write_html_stream,&#13;
	to_csv: write_csv_stream,&#13;
	set_readable: set_readable&#13;
};&#13;
if(typeof parse_xlscfb !== "undefined") XLSX.parse_xlscfb = parse_xlscfb;&#13;
XLSX.parse_zip = parse_zip;&#13;
XLSX.read = readSync; //xlsread&#13;
XLSX.readFile = readFileSync; //readFile&#13;
XLSX.readFileSync = readFileSync;&#13;
XLSX.write = writeSync;&#13;
XLSX.writeFile = writeFileSync;&#13;
XLSX.writeFileSync = writeFileSync;&#13;
XLSX.writeFileAsync = writeFileAsync;&#13;
XLSX.utils = utils;&#13;
XLSX.writeXLSX = writeSyncXLSX;&#13;
XLSX.writeFileXLSX = writeFileSyncXLSX;&#13;
XLSX.SSF = SSF;&#13;
if(typeof __stream !== "undefined") XLSX.stream = __stream;&#13;
if(typeof CFB !== "undefined") XLSX.CFB = CFB;&#13;
if(typeof require !== "undefined") {&#13;
  var strmod = require('stream');&#13;
  if((strmod||{}).Readable) set_readable(strmod.Readable);&#13;
	try { _fs = require('fs'); } catch(e) {}&#13;
}&#13;
}&#13;
/*global define */&#13;
if(typeof exports !== 'undefined') make_xlsx_lib(exports);&#13;
else if(typeof module !== 'undefined' &amp;&amp; module.exports) make_xlsx_lib(module.exports);&#13;
else if(typeof define === 'function' &amp;&amp; define.amd) define('xlsx', function() { if(!XLSX.version) make_xlsx_lib(XLSX); return XLSX; });&#13;
else make_xlsx_lib(XLSX);&#13;
/* NOTE: the following extra line is needed for "Lightning Locker Service" */&#13;
//if(typeof window !== 'undefined' &amp;&amp; !window.XLSX) try { window.XLSX = XLSX; } catch(e) {});</script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>toma.istvan</sys_created_by>
        <sys_created_on>2022-11-14 09:08:25</sys_created_on>
        <sys_id>11b0e2931b0f5910c7c9fc078b4bcbe0</sys_id>
        <sys_mod_count>1</sys_mod_count>
        <sys_name>xlsx</sys_name>
        <sys_package display_value="CMB" source="x_tsigh_cmb">365c71ab1be95110c7c9fc078b4bcb2c</sys_package>
        <sys_policy>read</sys_policy>
        <sys_scope display_value="CMB">365c71ab1be95110c7c9fc078b4bcb2c</sys_scope>
        <sys_update_name>sys_script_include_11b0e2931b0f5910c7c9fc078b4bcbe0</sys_update_name>
        <sys_updated_by>toma.istvan</sys_updated_by>
        <sys_updated_on>2022-11-14 11:46:13</sys_updated_on>
    </sys_script_include>
    <sys_update_version action="INSERT_OR_UPDATE">
        <action>DELETE</action>
        <application display_value="CMB">365c71ab1be95110c7c9fc078b4bcb2c</application>
        <file_path/>
        <instance_id>ccd9b113db25195449eac59705961957</instance_id>
        <instance_name>combridgedev</instance_name>
        <name>sys_script_include_11b0e2931b0f5910c7c9fc078b4bcbe0</name>
        <payload><![CDATA[<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_include"><sys_script_include action="INSERT_OR_UPDATE"><access>public</access><active>true</active><api_name>x_tsigh_cmb.xlsx</api_name><caller_access/><client_callable>true</client_callable><description>xlsx.js (C) 2013-present SheetJS -- http://sheetjs.com</description><name>xlsx</name><script>/*! xlsx.js (C) 2013-present xlsx -- http://sheetjs.com */&#13;
/* vim: set ts=2: */&#13;
/*exported XLSX */&#13;
/*global global, exports, module, require:false, process:false, Buffer:false, ArrayBuffer:false, DataView:false, Deno:false, Set:false */&#13;
var XLSX = {};&#13;
function make_xlsx_lib(XLSX){&#13;
XLSX.version = '0.18.12';&#13;
var current_codepage = 1200, current_ansi = 1252;&#13;
/*global cptable:true, window */&#13;
var $cptable;&#13;
&#13;
var VALID_ANSI = [ 874, 932, 936, 949, 950, 1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258, 10000 ];&#13;
/* ECMA-376 Part I 18.4.1 charset to codepage mapping */&#13;
var CS2CP = ({&#13;
0:    1252, /* ANSI */&#13;
1:   65001, /* DEFAULT */&#13;
2:   65001, /* SYMBOL */&#13;
77:  10000, /* MAC */&#13;
128:   932, /* SHIFTJIS */&#13;
129:   949, /* HANGUL */&#13;
130:  1361, /* JOHAB */&#13;
134:   936, /* GB2312 */&#13;
136:   950, /* CHINESEBIG5 */&#13;
161:  1253, /* GREEK */&#13;
162:  1254, /* TURKISH */&#13;
163:  1258, /* VIETNAMESE */&#13;
177:  1255, /* HEBREW */&#13;
178:  1256, /* ARABIC */&#13;
186:  1257, /* BALTIC */&#13;
204:  1251, /* RUSSIAN */&#13;
222:   874, /* THAI */&#13;
238:  1250, /* EASTEUROPE */&#13;
255:  1252, /* OEM */&#13;
69:   6969  /* MISC */&#13;
});&#13;
&#13;
var set_ansi = function(cp) { if(VALID_ANSI.indexOf(cp) == -1) return; current_ansi = CS2CP[0] = cp; };&#13;
function reset_ansi() { set_ansi(1252); }&#13;
&#13;
var set_cp = function(cp) { current_codepage = cp; set_ansi(cp); };&#13;
function reset_cp() { set_cp(1200); reset_ansi(); }&#13;
&#13;
function char_codes(data) { var o = []; for(var i = 0, len = data.length; i &lt; len; ++i) o[i] = data.charCodeAt(i); return o; }&#13;
&#13;
function utf16leread(data) {&#13;
	var o = [];&#13;
	for(var i = 0; i &lt; (data.length&gt;&gt;1); ++i) o[i] = String.fromCharCode(data.charCodeAt(2*i) + (data.charCodeAt(2*i+1)&lt;&lt;8));&#13;
	return o.join("");&#13;
}&#13;
function utf16beread(data) {&#13;
	var o = [];&#13;
	for(var i = 0; i &lt; (data.length&gt;&gt;1); ++i) o[i] = String.fromCharCode(data.charCodeAt(2*i+1) + (data.charCodeAt(2*i)&lt;&lt;8));&#13;
	return o.join("");&#13;
}&#13;
&#13;
var debom = function(data) {&#13;
	var c1 = data.charCodeAt(0), c2 = data.charCodeAt(1);&#13;
	if(c1 == 0xFF &amp;&amp; c2 == 0xFE) return utf16leread(data.slice(2));&#13;
	if(c1 == 0xFE &amp;&amp; c2 == 0xFF) return utf16beread(data.slice(2));&#13;
	if(c1 == 0xFEFF) return data.slice(1);&#13;
	return data;&#13;
};&#13;
&#13;
var _getchar = function _gc1(x) { return String.fromCharCode(x); };&#13;
var _getansi = function _ga1(x) { return String.fromCharCode(x); };&#13;
&#13;
function set_cptable(cptable) {&#13;
	$cptable = cptable;&#13;
	set_cp = function(cp) { current_codepage = cp; set_ansi(cp); };&#13;
	debom = function(data) {&#13;
		if(data.charCodeAt(0) === 0xFF &amp;&amp; data.charCodeAt(1) === 0xFE) { return $cptable.utils.decode(1200, char_codes(data.slice(2))); }&#13;
		return data;&#13;
	};&#13;
	_getchar = function _gc2(x) {&#13;
		if(current_codepage === 1200) return String.fromCharCode(x);&#13;
		return $cptable.utils.decode(current_codepage, [x&amp;255,x&gt;&gt;8])[0];&#13;
	};&#13;
	_getansi = function _ga2(x) {&#13;
		return $cptable.utils.decode(current_ansi, [x])[0];&#13;
	};&#13;
	cpdoit();&#13;
}&#13;
var DENSE = null;&#13;
var DIF_XL = true;&#13;
var Base64_map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";&#13;
function Base64_encode(input) {&#13;
  var o = "";&#13;
  var c1 = 0, c2 = 0, c3 = 0, e1 = 0, e2 = 0, e3 = 0, e4 = 0;&#13;
  for (var i = 0; i &lt; input.length; ) {&#13;
    c1 = input.charCodeAt(i++);&#13;
    e1 = c1 &gt;&gt; 2;&#13;
    c2 = input.charCodeAt(i++);&#13;
    e2 = (c1 &amp; 3) &lt;&lt; 4 | c2 &gt;&gt; 4;&#13;
    c3 = input.charCodeAt(i++);&#13;
    e3 = (c2 &amp; 15) &lt;&lt; 2 | c3 &gt;&gt; 6;&#13;
    e4 = c3 &amp; 63;&#13;
    if (isNaN(c2)) {&#13;
      e3 = e4 = 64;&#13;
    } else if (isNaN(c3)) {&#13;
      e4 = 64;&#13;
    }&#13;
    o += Base64_map.charAt(e1) + Base64_map.charAt(e2) + Base64_map.charAt(e3) + Base64_map.charAt(e4);&#13;
  }&#13;
  return o;&#13;
}&#13;
function Base64_encode_pass(input) {&#13;
  var o = "";&#13;
  var c1 = 0, c2 = 0, c3 = 0, e1 = 0, e2 = 0, e3 = 0, e4 = 0;&#13;
  for (var i = 0; i &lt; input.length; ) {&#13;
    c1 = input.charCodeAt(i++);&#13;
    if (c1 &gt; 255)&#13;
      c1 = 95;&#13;
    e1 = c1 &gt;&gt; 2;&#13;
    c2 = input.charCodeAt(i++);&#13;
    if (c2 &gt; 255)&#13;
      c2 = 95;&#13;
    e2 = (c1 &amp; 3) &lt;&lt; 4 | c2 &gt;&gt; 4;&#13;
    c3 = input.charCodeAt(i++);&#13;
    if (c3 &gt; 255)&#13;
      c3 = 95;&#13;
    e3 = (c2 &amp; 15) &lt;&lt; 2 | c3 &gt;&gt; 6;&#13;
    e4 = c3 &amp; 63;&#13;
    if (isNaN(c2)) {&#13;
      e3 = e4 = 64;&#13;
    } else if (isNaN(c3)) {&#13;
      e4 = 64;&#13;
    }&#13;
    o += Base64_map.charAt(e1) + Base64_map.charAt(e2) + Base64_map.charAt(e3) + Base64_map.charAt(e4);&#13;
  }&#13;
  return o;&#13;
}&#13;
function Base64_decode(input) {&#13;
  var o = "";&#13;
  var c1 = 0, c2 = 0, c3 = 0, e1 = 0, e2 = 0, e3 = 0, e4 = 0;&#13;
  input = input.replace(/^data:([^\/]+\/[^\/]+)?;base64\,/, "").replace(/[^\w\+\/\=]/g, "");&#13;
  for (var i = 0; i &lt; input.length; ) {&#13;
    e1 = Base64_map.indexOf(input.charAt(i++));&#13;
    e2 = Base64_map.indexOf(input.charAt(i++));&#13;
    c1 = e1 &lt;&lt; 2 | e2 &gt;&gt; 4;&#13;
    o += String.fromCharCode(c1);&#13;
    e3 = Base64_map.indexOf(input.charAt(i++));&#13;
    c2 = (e2 &amp; 15) &lt;&lt; 4 | e3 &gt;&gt; 2;&#13;
    if (e3 !== 64) {&#13;
      o += String.fromCharCode(c2);&#13;
    }&#13;
    e4 = Base64_map.indexOf(input.charAt(i++));&#13;
    c3 = (e3 &amp; 3) &lt;&lt; 6 | e4;&#13;
    if (e4 !== 64) {&#13;
      o += String.fromCharCode(c3);&#13;
    }&#13;
  }&#13;
  return o;&#13;
}&#13;
var has_buf = (function() { return typeof Buffer !== 'undefined' &amp;&amp; typeof process !== 'undefined' &amp;&amp; typeof process.versions !== 'undefined' &amp;&amp; !!process.versions.node; })();&#13;
&#13;
var Buffer_from = (function() {&#13;
	if(typeof Buffer !== 'undefined') {&#13;
		var nbfs = !Buffer.from;&#13;
		if(!nbfs) try { Buffer.from("foo", "utf8"); } catch(e) { nbfs = true; }&#13;
		return nbfs ? function(buf, enc) { return (enc) ? new Buffer(buf, enc) : new Buffer(buf); } : Buffer.from.bind(Buffer);&#13;
	}&#13;
	return function() {};&#13;
})();&#13;
var buf_utf16le = (function() {&#13;
	if(typeof Buffer === 'undefined') return false;&#13;
	var x = Buffer_from([65,0]);&#13;
	if(!x) return false;&#13;
	var o = x.toString("utf16le");&#13;
	return o.length == 1;&#13;
})();&#13;
&#13;
&#13;
function new_raw_buf(len) {&#13;
	/* jshint -W056 */&#13;
	if(has_buf) return Buffer.alloc ? Buffer.alloc(len) : new Buffer(len);&#13;
	return typeof Uint8Array != "undefined" ? new Uint8Array(len) : new Array(len);&#13;
	/* jshint +W056 */&#13;
}&#13;
&#13;
function new_unsafe_buf(len) {&#13;
	/* jshint -W056 */&#13;
	if(has_buf) return Buffer.allocUnsafe ? Buffer.allocUnsafe(len) : new Buffer(len);&#13;
	return typeof Uint8Array != "undefined" ? new Uint8Array(len) : new Array(len);&#13;
	/* jshint +W056 */&#13;
}&#13;
&#13;
var s2a = function s2a(s) {&#13;
	if(has_buf) return Buffer_from(s, "binary");&#13;
	return s.split("").map(function(x){ return x.charCodeAt(0) &amp; 0xff; });&#13;
};&#13;
&#13;
function s2ab(s) {&#13;
	if(typeof ArrayBuffer === 'undefined') return s2a(s);&#13;
	var buf = new ArrayBuffer(s.length), view = new Uint8Array(buf);&#13;
	for (var i=0; i!=s.length; ++i) view[i] = s.charCodeAt(i) &amp; 0xFF;&#13;
	return buf;&#13;
}&#13;
&#13;
function a2s(data) {&#13;
	if(Array.isArray(data)) return data.map(function(c) { return String.fromCharCode(c); }).join("");&#13;
	var o = []; for(var i = 0; i &lt; data.length; ++i) o[i] = String.fromCharCode(data[i]); return o.join("");&#13;
}&#13;
&#13;
function a2u(data) {&#13;
	if(typeof Uint8Array === 'undefined') throw new Error("Unsupported");&#13;
	return new Uint8Array(data);&#13;
}&#13;
&#13;
function ab2a(data) {&#13;
	if(typeof ArrayBuffer == 'undefined') throw new Error("Unsupported");&#13;
	if(data instanceof ArrayBuffer) return ab2a(new Uint8Array(data));&#13;
var o = new Array(data.length);&#13;
	for(var i = 0; i &lt; data.length; ++i) o[i] = data[i];&#13;
	return o;&#13;
}&#13;
&#13;
var bconcat = has_buf ? function(bufs) { return Buffer.concat(bufs.map(function(buf) { return Buffer.isBuffer(buf) ? buf : Buffer_from(buf); })); } : function(bufs) {&#13;
	if(typeof Uint8Array !== "undefined") {&#13;
		var i = 0, maxlen = 0;&#13;
		for(i = 0; i &lt; bufs.length; ++i) maxlen += bufs[i].length;&#13;
		var o = new Uint8Array(maxlen);&#13;
		var len = 0;&#13;
		for(i = 0, maxlen = 0; i &lt; bufs.length; maxlen += len, ++i) {&#13;
			len = bufs[i].length;&#13;
			if(bufs[i] instanceof Uint8Array) o.set(bufs[i], maxlen);&#13;
			else if(typeof bufs[i] == "string") o.set(new Uint8Array(s2a(bufs[i])), maxlen);&#13;
			else o.set(new Uint8Array(bufs[i]), maxlen);&#13;
		}&#13;
		return o;&#13;
	}&#13;
	return [].concat.apply([], bufs.map(function(buf) { return Array.isArray(buf) ? buf : [].slice.call(buf); }));&#13;
};&#13;
&#13;
function utf8decode(content) {&#13;
	var out = [], widx = 0, L = content.length + 250;&#13;
	var o = new_raw_buf(content.length + 255);&#13;
	for(var ridx = 0; ridx &lt; content.length; ++ridx) {&#13;
		var c = content.charCodeAt(ridx);&#13;
		if(c &lt; 0x80) o[widx++] = c;&#13;
		else if(c &lt; 0x800) {&#13;
			o[widx++] = (192|((c&gt;&gt;6)&amp;31));&#13;
			o[widx++] = (128|(c&amp;63));&#13;
		} else if(c &gt;= 0xD800 &amp;&amp; c &lt; 0xE000) {&#13;
			c = (c&amp;1023)+64;&#13;
			var d = content.charCodeAt(++ridx)&amp;1023;&#13;
			o[widx++] = (240|((c&gt;&gt;8)&amp;7));&#13;
			o[widx++] = (128|((c&gt;&gt;2)&amp;63));&#13;
			o[widx++] = (128|((d&gt;&gt;6)&amp;15)|((c&amp;3)&lt;&lt;4));&#13;
			o[widx++] = (128|(d&amp;63));&#13;
		} else {&#13;
			o[widx++] = (224|((c&gt;&gt;12)&amp;15));&#13;
			o[widx++] = (128|((c&gt;&gt;6)&amp;63));&#13;
			o[widx++] = (128|(c&amp;63));&#13;
		}&#13;
		if(widx &gt; L) {&#13;
			out.push(o.slice(0, widx));&#13;
			widx = 0;&#13;
			o = new_raw_buf(65535);&#13;
			L = 65530;&#13;
		}&#13;
	}&#13;
	out.push(o.slice(0, widx));&#13;
	return bconcat(out);&#13;
}&#13;
&#13;
var chr0 = /\u0000/g, chr1 = /[\u0001-\u0006]/g;&#13;
/* ssf.js (C) 2013-present xlsx -- http://sheetjs.com */&#13;
/*jshint -W041 */&#13;
function _strrev(x) { var o = "", i = x.length-1; while(i&gt;=0) o += x.charAt(i--); return o; }&#13;
function pad0(v,d){var t=""+v; return t.length&gt;=d?t:fill('0',d-t.length)+t;}&#13;
function pad_(v,d){var t=""+v;return t.length&gt;=d?t:fill(' ',d-t.length)+t;}&#13;
function rpad_(v,d){var t=""+v; return t.length&gt;=d?t:t+fill(' ',d-t.length);}&#13;
function pad0r1(v,d){var t=""+Math.round(v); return t.length&gt;=d?t:fill('0',d-t.length)+t;}&#13;
function pad0r2(v,d){var t=""+v; return t.length&gt;=d?t:fill('0',d-t.length)+t;}&#13;
var p2_32 = Math.pow(2,32);&#13;
function pad0r(v,d){if(v&gt;p2_32||v&lt;-p2_32) return pad0r1(v,d); var i = Math.round(v); return pad0r2(i,d); }&#13;
/* yes, in 2022 this is still faster than string compare */&#13;
function SSF_isgeneral(s, i) { i = i || 0; return s.length &gt;= 7 + i &amp;&amp; (s.charCodeAt(i)|32) === 103 &amp;&amp; (s.charCodeAt(i+1)|32) === 101 &amp;&amp; (s.charCodeAt(i+2)|32) === 110 &amp;&amp; (s.charCodeAt(i+3)|32) === 101 &amp;&amp; (s.charCodeAt(i+4)|32) === 114 &amp;&amp; (s.charCodeAt(i+5)|32) === 97 &amp;&amp; (s.charCodeAt(i+6)|32) === 108; }&#13;
var days = [&#13;
	['Sun', 'Sunday'],&#13;
	['Mon', 'Monday'],&#13;
	['Tue', 'Tuesday'],&#13;
	['Wed', 'Wednesday'],&#13;
	['Thu', 'Thursday'],&#13;
	['Fri', 'Friday'],&#13;
	['Sat', 'Saturday']&#13;
];&#13;
var months = [&#13;
	['J', 'Jan', 'January'],&#13;
	['F', 'Feb', 'February'],&#13;
	['M', 'Mar', 'March'],&#13;
	['A', 'Apr', 'April'],&#13;
	['M', 'May', 'May'],&#13;
	['J', 'Jun', 'June'],&#13;
	['J', 'Jul', 'July'],&#13;
	['A', 'Aug', 'August'],&#13;
	['S', 'Sep', 'September'],&#13;
	['O', 'Oct', 'October'],&#13;
	['N', 'Nov', 'November'],&#13;
	['D', 'Dec', 'December']&#13;
];&#13;
function SSF_init_table(t) {&#13;
	if(!t) t = {};&#13;
	t[0]=  'General';&#13;
	t[1]=  '0';&#13;
	t[2]=  '0.00';&#13;
	t[3]=  '#,##0';&#13;
	t[4]=  '#,##0.00';&#13;
	t[9]=  '0%';&#13;
	t[10]= '0.00%';&#13;
	t[11]= '0.00E+00';&#13;
	t[12]= '# ?/?';&#13;
	t[13]= '# ??/??';&#13;
	t[14]= 'm/d/yy';&#13;
	t[15]= 'd-mmm-yy';&#13;
	t[16]= 'd-mmm';&#13;
	t[17]= 'mmm-yy';&#13;
	t[18]= 'h:mm AM/PM';&#13;
	t[19]= 'h:mm:ss AM/PM';&#13;
	t[20]= 'h:mm';&#13;
	t[21]= 'h:mm:ss';&#13;
	t[22]= 'm/d/yy h:mm';&#13;
	t[37]= '#,##0 ;(#,##0)';&#13;
	t[38]= '#,##0 ;[Red](#,##0)';&#13;
	t[39]= '#,##0.00;(#,##0.00)';&#13;
	t[40]= '#,##0.00;[Red](#,##0.00)';&#13;
	t[45]= 'mm:ss';&#13;
	t[46]= '[h]:mm:ss';&#13;
	t[47]= 'mmss.0';&#13;
	t[48]= '##0.0E+0';&#13;
	t[49]= '@';&#13;
	t[56]= '"上午/下午 "hh"時"mm"分"ss"秒 "';&#13;
	return t;&#13;
}&#13;
/* repeated to satiate webpack */&#13;
var table_fmt = {&#13;
	0:  'General',&#13;
	1:  '0',&#13;
	2:  '0.00',&#13;
	3:  '#,##0',&#13;
	4:  '#,##0.00',&#13;
	9:  '0%',&#13;
	10: '0.00%',&#13;
	11: '0.00E+00',&#13;
	12: '# ?/?',&#13;
	13: '# ??/??',&#13;
	14: 'm/d/yy',&#13;
	15: 'd-mmm-yy',&#13;
	16: 'd-mmm',&#13;
	17: 'mmm-yy',&#13;
	18: 'h:mm AM/PM',&#13;
	19: 'h:mm:ss AM/PM',&#13;
	20: 'h:mm',&#13;
	21: 'h:mm:ss',&#13;
	22: 'm/d/yy h:mm',&#13;
	37: '#,##0 ;(#,##0)',&#13;
	38: '#,##0 ;[Red](#,##0)',&#13;
	39: '#,##0.00;(#,##0.00)',&#13;
	40: '#,##0.00;[Red](#,##0.00)',&#13;
	45: 'mm:ss',&#13;
	46: '[h]:mm:ss',&#13;
	47: 'mmss.0',&#13;
	48: '##0.0E+0',&#13;
	49: '@',&#13;
	56: '"上午/下午 "hh"時"mm"分"ss"秒 "'&#13;
};&#13;
&#13;
/* Defaults determined by systematically testing in Excel 2019 */&#13;
&#13;
/* These formats appear to default to other formats in the table */&#13;
var SSF_default_map = {&#13;
	5:  37, 6:  38, 7:  39, 8:  40,         //  5 -&gt; 37 ...  8 -&gt; 40&#13;
&#13;
	23:  0, 24:  0, 25:  0, 26:  0,         // 23 -&gt;  0 ... 26 -&gt;  0&#13;
&#13;
	27: 14, 28: 14, 29: 14, 30: 14, 31: 14, // 27 -&gt; 14 ... 31 -&gt; 14&#13;
&#13;
	50: 14, 51: 14, 52: 14, 53: 14, 54: 14, // 50 -&gt; 14 ... 58 -&gt; 14&#13;
	55: 14, 56: 14, 57: 14, 58: 14,&#13;
	59:  1, 60:  2, 61:  3, 62:  4,         // 59 -&gt;  1 ... 62 -&gt;  4&#13;
&#13;
	67:  9, 68: 10,                         // 67 -&gt;  9 ... 68 -&gt; 10&#13;
	69: 12, 70: 13, 71: 14,                 // 69 -&gt; 12 ... 71 -&gt; 14&#13;
	72: 14, 73: 15, 74: 16, 75: 17,         // 72 -&gt; 14 ... 75 -&gt; 17&#13;
	76: 20, 77: 21, 78: 22,                 // 76 -&gt; 20 ... 78 -&gt; 22&#13;
	79: 45, 80: 46, 81: 47,                 // 79 -&gt; 45 ... 81 -&gt; 47&#13;
	82: 0                                   // 82 -&gt;  0 ... 65536 -&gt; 0 (omitted)&#13;
};&#13;
&#13;
&#13;
/* These formats technically refer to Accounting formats with no equivalent */&#13;
var SSF_default_str = {&#13;
	//  5 -- Currency,   0 decimal, black negative&#13;
	5:  '"$"#,##0_);\\("$"#,##0\\)',&#13;
	63: '"$"#,##0_);\\("$"#,##0\\)',&#13;
&#13;
	//  6 -- Currency,   0 decimal, red   negative&#13;
	6:  '"$"#,##0_);[Red]\\("$"#,##0\\)',&#13;
	64: '"$"#,##0_);[Red]\\("$"#,##0\\)',&#13;
&#13;
	//  7 -- Currency,   2 decimal, black negative&#13;
	7:  '"$"#,##0.00_);\\("$"#,##0.00\\)',&#13;
	65: '"$"#,##0.00_);\\("$"#,##0.00\\)',&#13;
&#13;
	//  8 -- Currency,   2 decimal, red   negative&#13;
	8:  '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',&#13;
	66: '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',&#13;
&#13;
	// 41 -- Accounting, 0 decimal, No Symbol&#13;
	41: '_(* #,##0_);_(* \\(#,##0\\);_(* "-"_);_(@_)',&#13;
&#13;
	// 42 -- Accounting, 0 decimal, $  Symbol&#13;
	42: '_("$"* #,##0_);_("$"* \\(#,##0\\);_("$"* "-"_);_(@_)',&#13;
&#13;
	// 43 -- Accounting, 2 decimal, No Symbol&#13;
	43: '_(* #,##0.00_);_(* \\(#,##0.00\\);_(* "-"??_);_(@_)',&#13;
&#13;
	// 44 -- Accounting, 2 decimal, $  Symbol&#13;
	44: '_("$"* #,##0.00_);_("$"* \\(#,##0.00\\);_("$"* "-"??_);_(@_)'&#13;
};&#13;
&#13;
function SSF_frac(x, D, mixed) {&#13;
	var sgn = x &lt; 0 ? -1 : 1;&#13;
	var B = x * sgn;&#13;
	var P_2 = 0, P_1 = 1, P = 0;&#13;
	var Q_2 = 1, Q_1 = 0, Q = 0;&#13;
	var A = Math.floor(B);&#13;
	while(Q_1 &lt; D) {&#13;
		A = Math.floor(B);&#13;
		P = A * P_1 + P_2;&#13;
		Q = A * Q_1 + Q_2;&#13;
		if((B - A) &lt; 0.00000005) break;&#13;
		B = 1 / (B - A);&#13;
		P_2 = P_1; P_1 = P;&#13;
		Q_2 = Q_1; Q_1 = Q;&#13;
	}&#13;
	if(Q &gt; D) { if(Q_1 &gt; D) { Q = Q_2; P = P_2; } else { Q = Q_1; P = P_1; } }&#13;
	if(!mixed) return [0, sgn * P, Q];&#13;
	var q = Math.floor(sgn * P/Q);&#13;
	return [q, sgn*P - q*Q, Q];&#13;
}&#13;
function SSF_parse_date_code(v,opts,b2) {&#13;
	if(v &gt; 2958465 || v &lt; 0) return null;&#13;
	var date = (v|0), time = Math.floor(86400 * (v - date)), dow=0;&#13;
	var dout=[];&#13;
	var out={D:date, T:time, u:86400*(v-date)-time,y:0,m:0,d:0,H:0,M:0,S:0,q:0};&#13;
	if(Math.abs(out.u) &lt; 1e-6) out.u = 0;&#13;
	if(opts &amp;&amp; opts.date1904) date += 1462;&#13;
	if(out.u &gt; 0.9999) {&#13;
		out.u = 0;&#13;
		if(++time == 86400) { out.T = time = 0; ++date; ++out.D; }&#13;
	}&#13;
	if(date === 60) {dout = b2 ? [1317,10,29] : [1900,2,29]; dow=3;}&#13;
	else if(date === 0) {dout = b2 ? [1317,8,29] : [1900,1,0]; dow=6;}&#13;
	else {&#13;
		if(date &gt; 60) --date;&#13;
		/* 1 = Jan 1 1900 in Gregorian */&#13;
		var d = new Date(1900, 0, 1);&#13;
		d.setDate(d.getDate() + date - 1);&#13;
		dout = [d.getFullYear(), d.getMonth()+1,d.getDate()];&#13;
		dow = d.getDay();&#13;
		if(date &lt; 60) dow = (dow + 6) % 7;&#13;
		if(b2) dow = SSF_fix_hijri(d, dout);&#13;
	}&#13;
	out.y = dout[0]; out.m = dout[1]; out.d = dout[2];&#13;
	out.S = time % 60; time = Math.floor(time / 60);&#13;
	out.M = time % 60; time = Math.floor(time / 60);&#13;
	out.H = time;&#13;
	out.q = dow;&#13;
	return out;&#13;
}&#13;
var SSFbasedate = new Date(1899, 11, 31, 0, 0, 0);&#13;
var SSFdnthresh = SSFbasedate.getTime();&#13;
var SSFbase1904 = new Date(1900, 2, 1, 0, 0, 0);&#13;
function datenum_local(v, date1904) {&#13;
	var epoch = v.getTime();&#13;
	if(date1904) epoch -= 1461*24*60*60*1000;&#13;
	else if(v &gt;= SSFbase1904) epoch += 24*60*60*1000;&#13;
	return (epoch - (SSFdnthresh + (v.getTimezoneOffset() - SSFbasedate.getTimezoneOffset()) * 60000)) / (24 * 60 * 60 * 1000);&#13;
}&#13;
/* ECMA-376 18.8.30 numFmt*/&#13;
/* Note: `toPrecision` uses standard form when prec &gt; E and E &gt;= -6 */&#13;
/* exponent &gt;= -9 and &lt;= 9 */&#13;
function SSF_strip_decimal(o) {&#13;
	return (o.indexOf(".") == -1) ? o : o.replace(/(?:\.0*|(\.\d*[1-9])0+)$/, "$1");&#13;
}&#13;
&#13;
/* General Exponential always shows 2 digits exp and trims the mantissa */&#13;
function SSF_normalize_exp(o) {&#13;
	if(o.indexOf("E") == -1) return o;&#13;
	return o.replace(/(?:\.0*|(\.\d*[1-9])0+)[Ee]/,"$1E").replace(/(E[+-])(\d)$/,"$10$2");&#13;
}&#13;
&#13;
/* exponent &gt;= -9 and &lt;= 9 */&#13;
function SSF_small_exp(v) {&#13;
	var w = (v&lt;0?12:11);&#13;
	var o = SSF_strip_decimal(v.toFixed(12)); if(o.length &lt;= w) return o;&#13;
	o = v.toPrecision(10); if(o.length &lt;= w) return o;&#13;
	return v.toExponential(5);&#13;
}&#13;
&#13;
/* exponent &gt;= 11 or &lt;= -10 likely exponential */&#13;
function SSF_large_exp(v) {&#13;
	var o = SSF_strip_decimal(v.toFixed(11));&#13;
	return (o.length &gt; (v&lt;0?12:11) || o === "0" || o === "-0") ? v.toPrecision(6) : o;&#13;
}&#13;
&#13;
function SSF_general_num(v) {&#13;
	var V = Math.floor(Math.log(Math.abs(v))*Math.LOG10E), o;&#13;
&#13;
	if(V &gt;= -4 &amp;&amp; V &lt;= -1) o = v.toPrecision(10+V);&#13;
	else if(Math.abs(V) &lt;= 9) o = SSF_small_exp(v);&#13;
	else if(V === 10) o = v.toFixed(10).substr(0,12);&#13;
	else o = SSF_large_exp(v);&#13;
&#13;
	return SSF_strip_decimal(SSF_normalize_exp(o.toUpperCase()));&#13;
}&#13;
&#13;
&#13;
/*&#13;
	"General" rules:&#13;
	- text is passed through ("@")&#13;
	- booleans are rendered as TRUE/FALSE&#13;
	- "up to 11 characters" displayed for numbers&#13;
	- Default date format (code 14) used for Dates&#13;
&#13;
	The longest 32-bit integer text is "-2147483648", exactly 11 chars&#13;
	TODO: technically the display depends on the width of the cell&#13;
*/&#13;
function SSF_general(v, opts) {&#13;
	switch(typeof v) {&#13;
		case 'string': return v;&#13;
		case 'boolean': return v ? "TRUE" : "FALSE";&#13;
		case 'number': return (v|0) === v ? v.toString(10) : SSF_general_num(v);&#13;
		case 'undefined': return "";&#13;
		case 'object':&#13;
			if(v == null) return "";&#13;
			if(v instanceof Date) return SSF_format(14, datenum_local(v, opts &amp;&amp; opts.date1904), opts);&#13;
	}&#13;
	throw new Error("unsupported value in General format: " + v);&#13;
}&#13;
&#13;
function SSF_fix_hijri(date, o) {&#13;
  /* TODO: properly adjust y/m/d and  */&#13;
  o[0] -= 581;&#13;
  var dow = date.getDay();&#13;
  if(date &lt; 60) dow = (dow + 6) % 7;&#13;
  return dow;&#13;
}&#13;
//var THAI_DIGITS = "\u0E50\u0E51\u0E52\u0E53\u0E54\u0E55\u0E56\u0E57\u0E58\u0E59".split("");&#13;
function SSF_write_date(type, fmt, val, ss0) {&#13;
	var o="", ss=0, tt=0, y = val.y, out, outl = 0;&#13;
	switch(type) {&#13;
		case 98: /* 'b' buddhist year */&#13;
			y = val.y + 543;&#13;
			/* falls through */&#13;
		case 121: /* 'y' year */&#13;
		switch(fmt.length) {&#13;
			case 1: case 2: out = y % 100; outl = 2; break;&#13;
			default: out = y % 10000; outl = 4; break;&#13;
		} break;&#13;
		case 109: /* 'm' month */&#13;
		switch(fmt.length) {&#13;
			case 1: case 2: out = val.m; outl = fmt.length; break;&#13;
			case 3: return months[val.m-1][1];&#13;
			case 5: return months[val.m-1][0];&#13;
			default: return months[val.m-1][2];&#13;
		} break;&#13;
		case 100: /* 'd' day */&#13;
		switch(fmt.length) {&#13;
			case 1: case 2: out = val.d; outl = fmt.length; break;&#13;
			case 3: return days[val.q][0];&#13;
			default: return days[val.q][1];&#13;
		} break;&#13;
		case 104: /* 'h' 12-hour */&#13;
		switch(fmt.length) {&#13;
			case 1: case 2: out = 1+(val.H+11)%12; outl = fmt.length; break;&#13;
			default: throw 'bad hour format: ' + fmt;&#13;
		} break;&#13;
		case 72: /* 'H' 24-hour */&#13;
		switch(fmt.length) {&#13;
			case 1: case 2: out = val.H; outl = fmt.length; break;&#13;
			default: throw 'bad hour format: ' + fmt;&#13;
		} break;&#13;
		case 77: /* 'M' minutes */&#13;
		switch(fmt.length) {&#13;
			case 1: case 2: out = val.M; outl = fmt.length; break;&#13;
			default: throw 'bad minute format: ' + fmt;&#13;
		} break;&#13;
		case 115: /* 's' seconds */&#13;
			if(fmt != 's' &amp;&amp; fmt != 'ss' &amp;&amp; fmt != '.0' &amp;&amp; fmt != '.00' &amp;&amp; fmt != '.000') throw 'bad second format: ' + fmt;&#13;
			if(val.u === 0 &amp;&amp; (fmt == "s" || fmt == "ss")) return pad0(val.S, fmt.length);&#13;
if(ss0 &gt;= 2) tt = ss0 === 3 ? 1000 : 100;&#13;
			else tt = ss0 === 1 ? 10 : 1;&#13;
			ss = Math.round((tt)*(val.S + val.u));&#13;
			if(ss &gt;= 60*tt) ss = 0;&#13;
			if(fmt === 's') return ss === 0 ? "0" : ""+ss/tt;&#13;
			o = pad0(ss,2 + ss0);&#13;
			if(fmt === 'ss') return o.substr(0,2);&#13;
			return "." + o.substr(2,fmt.length-1);&#13;
		case 90: /* 'Z' absolute time */&#13;
		switch(fmt) {&#13;
			case '[h]': case '[hh]': out = val.D*24+val.H; break;&#13;
			case '[m]': case '[mm]': out = (val.D*24+val.H)*60+val.M; break;&#13;
			case '[s]': case '[ss]': out = ((val.D*24+val.H)*60+val.M)*60+Math.round(val.S+val.u); break;&#13;
			default: throw 'bad abstime format: ' + fmt;&#13;
		} outl = fmt.length === 3 ? 1 : 2; break;&#13;
		case 101: /* 'e' era */&#13;
			out = y; outl = 1; break;&#13;
	}&#13;
	var outstr = outl &gt; 0 ? pad0(out, outl) : "";&#13;
	return outstr;&#13;
}&#13;
&#13;
&#13;
/*jshint -W086 */&#13;
/*jshint +W086 */&#13;
function commaify(s) {&#13;
	var w = 3;&#13;
	if(s.length &lt;= w) return s;&#13;
	var j = (s.length % w), o = s.substr(0,j);&#13;
	for(; j!=s.length; j+=w) o+=(o.length &gt; 0 ? "," : "") + s.substr(j,w);&#13;
	return o;&#13;
}&#13;
var pct1 = /%/g;&#13;
function write_num_pct(type, fmt, val){&#13;
	var sfmt = fmt.replace(pct1,""), mul = fmt.length - sfmt.length;&#13;
	return write_num(type, sfmt, val * Math.pow(10,2*mul)) + fill("%",mul);&#13;
}&#13;
&#13;
function write_num_cm(type, fmt, val){&#13;
	var idx = fmt.length - 1;&#13;
	while(fmt.charCodeAt(idx-1) === 44) --idx;&#13;
	return write_num(type, fmt.substr(0,idx), val / Math.pow(10,3*(fmt.length-idx)));&#13;
}&#13;
&#13;
function write_num_exp(fmt, val){&#13;
	var o;&#13;
	var idx = fmt.indexOf("E") - fmt.indexOf(".") - 1;&#13;
	if(fmt.match(/^#+0.0E\+0$/)) {&#13;
		if(val == 0) return "0.0E+0";&#13;
		else if(val &lt; 0) return "-" + write_num_exp(fmt, -val);&#13;
		var period = fmt.indexOf("."); if(period === -1) period=fmt.indexOf('E');&#13;
		var ee = Math.floor(Math.log(val)*Math.LOG10E)%period;&#13;
		if(ee &lt; 0) ee += period;&#13;
		o = (val/Math.pow(10,ee)).toPrecision(idx+1+(period+ee)%period);&#13;
		if(o.indexOf("e") === -1) {&#13;
			var fakee = Math.floor(Math.log(val)*Math.LOG10E);&#13;
			if(o.indexOf(".") === -1) o = o.charAt(0) + "." + o.substr(1) + "E+" + (fakee - o.length+ee);&#13;
			else o += "E+" + (fakee - ee);&#13;
			while(o.substr(0,2) === "0.") {&#13;
				o = o.charAt(0) + o.substr(2,period) + "." + o.substr(2+period);&#13;
				o = o.replace(/^0+([1-9])/,"$1").replace(/^0+\./,"0.");&#13;
			}&#13;
			o = o.replace(/\+-/,"-");&#13;
		}&#13;
		o = o.replace(/^([+-]?)(\d*)\.(\d*)[Ee]/,function($$,$1,$2,$3) { return $1 + $2 + $3.substr(0,(period+ee)%period) + "." + $3.substr(ee) + "E"; });&#13;
	} else o = val.toExponential(idx);&#13;
	if(fmt.match(/E\+00$/) &amp;&amp; o.match(/e[+-]\d$/)) o = o.substr(0,o.length-1) + "0" + o.charAt(o.length-1);&#13;
	if(fmt.match(/E\-/) &amp;&amp; o.match(/e\+/)) o = o.replace(/e\+/,"e");&#13;
	return o.replace("e","E");&#13;
}&#13;
var frac1 = /# (\?+)( ?)\/( ?)(\d+)/;&#13;
function write_num_f1(r, aval, sign) {&#13;
	var den = parseInt(r[4],10), rr = Math.round(aval * den), base = Math.floor(rr/den);&#13;
	var myn = (rr - base*den), myd = den;&#13;
	return sign + (base === 0 ? "" : ""+base) + " " + (myn === 0 ? fill(" ", r[1].length + 1 + r[4].length) : pad_(myn,r[1].length) + r[2] + "/" + r[3] + pad0(myd,r[4].length));&#13;
}&#13;
function write_num_f2(r, aval, sign) {&#13;
	return sign + (aval === 0 ? "" : ""+aval) + fill(" ", r[1].length + 2 + r[4].length);&#13;
}&#13;
var dec1 = /^#*0*\.([0#]+)/;&#13;
var closeparen = /\).*[0#]/;&#13;
var phone = /\(###\) ###\\?-####/;&#13;
function hashq(str) {&#13;
	var o = "", cc;&#13;
	for(var i = 0; i != str.length; ++i) switch((cc=str.charCodeAt(i))) {&#13;
		case 35: break;&#13;
		case 63: o+= " "; break;&#13;
		case 48: o+= "0"; break;&#13;
		default: o+= String.fromCharCode(cc);&#13;
	}&#13;
	return o;&#13;
}&#13;
function rnd(val, d) { var dd = Math.pow(10,d); return ""+(Math.round(val * dd)/dd); }&#13;
function dec(val, d) {&#13;
	var _frac = val - Math.floor(val), dd = Math.pow(10,d);&#13;
	if (d &lt; ('' + Math.round(_frac * dd)).length) return 0;&#13;
	return Math.round(_frac * dd);&#13;
}&#13;
function carry(val, d) {&#13;
	if (d &lt; ('' + Math.round((val-Math.floor(val))*Math.pow(10,d))).length) {&#13;
		return 1;&#13;
	}&#13;
	return 0;&#13;
}&#13;
function flr(val) {&#13;
	if(val &lt; 2147483647 &amp;&amp; val &gt; -2147483648) return ""+(val &gt;= 0 ? (val|0) : (val-1|0));&#13;
	return ""+Math.floor(val);&#13;
}&#13;
function write_num_flt(type, fmt, val) {&#13;
	if(type.charCodeAt(0) === 40 &amp;&amp; !fmt.match(closeparen)) {&#13;
		var ffmt = fmt.replace(/\( */,"").replace(/ \)/,"").replace(/\)/,"");&#13;
		if(val &gt;= 0) return write_num_flt('n', ffmt, val);&#13;
		return '(' + write_num_flt('n', ffmt, -val) + ')';&#13;
	}&#13;
	if(fmt.charCodeAt(fmt.length - 1) === 44) return write_num_cm(type, fmt, val);&#13;
	if(fmt.indexOf('%') !== -1) return write_num_pct(type, fmt, val);&#13;
	if(fmt.indexOf('E') !== -1) return write_num_exp(fmt, val);&#13;
	if(fmt.charCodeAt(0) === 36) return "$"+write_num_flt(type,fmt.substr(fmt.charAt(1)==' '?2:1),val);&#13;
	var o;&#13;
	var r, ri, ff, aval = Math.abs(val), sign = val &lt; 0 ? "-" : "";&#13;
	if(fmt.match(/^00+$/)) return sign + pad0r(aval,fmt.length);&#13;
	if(fmt.match(/^[#?]+$/)) {&#13;
		o = pad0r(val,0); if(o === "0") o = "";&#13;
		return o.length &gt; fmt.length ? o : hashq(fmt.substr(0,fmt.length-o.length)) + o;&#13;
	}&#13;
	if((r = fmt.match(frac1))) return write_num_f1(r, aval, sign);&#13;
	if(fmt.match(/^#+0+$/)) return sign + pad0r(aval,fmt.length - fmt.indexOf("0"));&#13;
	if((r = fmt.match(dec1))) {&#13;
		o = rnd(val, r[1].length).replace(/^([^\.]+)$/,"$1."+hashq(r[1])).replace(/\.$/,"."+hashq(r[1])).replace(/\.(\d*)$/,function($$, $1) { return "." + $1 + fill("0", hashq(r[1]).length-$1.length); });&#13;
		return fmt.indexOf("0.") !== -1 ? o : o.replace(/^0\./,".");&#13;
	}&#13;
	fmt = fmt.replace(/^#+([0.])/, "$1");&#13;
	if((r = fmt.match(/^(0*)\.(#*)$/))) {&#13;
		return sign + rnd(aval, r[2].length).replace(/\.(\d*[1-9])0*$/,".$1").replace(/^(-?\d*)$/,"$1.").replace(/^0\./,r[1].length?"0.":".");&#13;
	}&#13;
	if((r = fmt.match(/^#{1,3},##0(\.?)$/))) return sign + commaify(pad0r(aval,0));&#13;
	if((r = fmt.match(/^#,##0\.([#0]*0)$/))) {&#13;
		return val &lt; 0 ? "-" + write_num_flt(type, fmt, -val) : commaify(""+(Math.floor(val) + carry(val, r[1].length))) + "." + pad0(dec(val, r[1].length),r[1].length);&#13;
	}&#13;
	if((r = fmt.match(/^#,#*,#0/))) return write_num_flt(type,fmt.replace(/^#,#*,/,""),val);&#13;
	if((r = fmt.match(/^([0#]+)(\\?-([0#]+))+$/))) {&#13;
		o = _strrev(write_num_flt(type, fmt.replace(/[\\-]/g,""), val));&#13;
		ri = 0;&#13;
		return _strrev(_strrev(fmt.replace(/\\/g,"")).replace(/[0#]/g,function(x){return ri&lt;o.length?o.charAt(ri++):x==='0'?'0':"";}));&#13;
	}&#13;
	if(fmt.match(phone)) {&#13;
		o = write_num_flt(type, "##########", val);&#13;
		return "(" + o.substr(0,3) + ") " + o.substr(3, 3) + "-" + o.substr(6);&#13;
	}&#13;
	var oa = "";&#13;
	if((r = fmt.match(/^([#0?]+)( ?)\/( ?)([#0?]+)/))) {&#13;
		ri = Math.min(r[4].length,7);&#13;
		ff = SSF_frac(aval, Math.pow(10,ri)-1, false);&#13;
		o = "" + sign;&#13;
		oa = write_num("n", r[1], ff[1]);&#13;
		if(oa.charAt(oa.length-1) == " ") oa = oa.substr(0,oa.length-1) + "0";&#13;
		o += oa + r[2] + "/" + r[3];&#13;
		oa = rpad_(ff[2],ri);&#13;
		if(oa.length &lt; r[4].length) oa = hashq(r[4].substr(r[4].length-oa.length)) + oa;&#13;
		o += oa;&#13;
		return o;&#13;
	}&#13;
	if((r = fmt.match(/^# ([#0?]+)( ?)\/( ?)([#0?]+)/))) {&#13;
		ri = Math.min(Math.max(r[1].length, r[4].length),7);&#13;
		ff = SSF_frac(aval, Math.pow(10,ri)-1, true);&#13;
		return sign + (ff[0]||(ff[1] ? "" : "0")) + " " + (ff[1] ? pad_(ff[1],ri) + r[2] + "/" + r[3] + rpad_(ff[2],ri): fill(" ", 2*ri+1 + r[2].length + r[3].length));&#13;
	}&#13;
	if((r = fmt.match(/^[#0?]+$/))) {&#13;
		o = pad0r(val, 0);&#13;
		if(fmt.length &lt;= o.length) return o;&#13;
		return hashq(fmt.substr(0,fmt.length-o.length)) + o;&#13;
	}&#13;
	if((r = fmt.match(/^([#0?]+)\.([#0]+)$/))) {&#13;
		o = "" + val.toFixed(Math.min(r[2].length,10)).replace(/([^0])0+$/,"$1");&#13;
		ri = o.indexOf(".");&#13;
		var lres = fmt.indexOf(".") - ri, rres = fmt.length - o.length - lres;&#13;
		return hashq(fmt.substr(0,lres) + o + fmt.substr(fmt.length-rres));&#13;
	}&#13;
	if((r = fmt.match(/^00,000\.([#0]*0)$/))) {&#13;
		ri = dec(val, r[1].length);&#13;
		return val &lt; 0 ? "-" + write_num_flt(type, fmt, -val) : commaify(flr(val)).replace(/^\d,\d{3}$/,"0$&amp;").replace(/^\d*$/,function($$) { return "00," + ($$.length &lt; 3 ? pad0(0,3-$$.length) : "") + $$; }) + "." + pad0(ri,r[1].length);&#13;
	}&#13;
	switch(fmt) {&#13;
		case "###,##0.00": return write_num_flt(type, "#,##0.00", val);&#13;
		case "###,###":&#13;
		case "##,###":&#13;
		case "#,###": var x = commaify(pad0r(aval,0)); return x !== "0" ? sign + x : "";&#13;
		case "###,###.00": return write_num_flt(type, "###,##0.00",val).replace(/^0\./,".");&#13;
		case "#,###.00": return write_num_flt(type, "#,##0.00",val).replace(/^0\./,".");&#13;
		default:&#13;
	}&#13;
	throw new Error("unsupported format |" + fmt + "|");&#13;
}&#13;
function write_num_cm2(type, fmt, val){&#13;
	var idx = fmt.length - 1;&#13;
	while(fmt.charCodeAt(idx-1) === 44) --idx;&#13;
	return write_num(type, fmt.substr(0,idx), val / Math.pow(10,3*(fmt.length-idx)));&#13;
}&#13;
function write_num_pct2(type, fmt, val){&#13;
	var sfmt = fmt.replace(pct1,""), mul = fmt.length - sfmt.length;&#13;
	return write_num(type, sfmt, val * Math.pow(10,2*mul)) + fill("%",mul);&#13;
}&#13;
function write_num_exp2(fmt, val){&#13;
	var o;&#13;
	var idx = fmt.indexOf("E") - fmt.indexOf(".") - 1;&#13;
	if(fmt.match(/^#+0.0E\+0$/)) {&#13;
		if(val == 0) return "0.0E+0";&#13;
		else if(val &lt; 0) return "-" + write_num_exp2(fmt, -val);&#13;
		var period = fmt.indexOf("."); if(period === -1) period=fmt.indexOf('E');&#13;
		var ee = Math.floor(Math.log(val)*Math.LOG10E)%period;&#13;
		if(ee &lt; 0) ee += period;&#13;
		o = (val/Math.pow(10,ee)).toPrecision(idx+1+(period+ee)%period);&#13;
		if(!o.match(/[Ee]/)) {&#13;
			var fakee = Math.floor(Math.log(val)*Math.LOG10E);&#13;
			if(o.indexOf(".") === -1) o = o.charAt(0) + "." + o.substr(1) + "E+" + (fakee - o.length+ee);&#13;
			else o += "E+" + (fakee - ee);&#13;
			o = o.replace(/\+-/,"-");&#13;
		}&#13;
		o = o.replace(/^([+-]?)(\d*)\.(\d*)[Ee]/,function($$,$1,$2,$3) { return $1 + $2 + $3.substr(0,(period+ee)%period) + "." + $3.substr(ee) + "E"; });&#13;
	} else o = val.toExponential(idx);&#13;
	if(fmt.match(/E\+00$/) &amp;&amp; o.match(/e[+-]\d$/)) o = o.substr(0,o.length-1) + "0" + o.charAt(o.length-1);&#13;
	if(fmt.match(/E\-/) &amp;&amp; o.match(/e\+/)) o = o.replace(/e\+/,"e");&#13;
	return o.replace("e","E");&#13;
}&#13;
function write_num_int(type, fmt, val) {&#13;
	if(type.charCodeAt(0) === 40 &amp;&amp; !fmt.match(closeparen)) {&#13;
		var ffmt = fmt.replace(/\( */,"").replace(/ \)/,"").replace(/\)/,"");&#13;
		if(val &gt;= 0) return write_num_int('n', ffmt, val);&#13;
		return '(' + write_num_int('n', ffmt, -val) + ')';&#13;
	}&#13;
	if(fmt.charCodeAt(fmt.length - 1) === 44) return write_num_cm2(type, fmt, val);&#13;
	if(fmt.indexOf('%') !== -1) return write_num_pct2(type, fmt, val);&#13;
	if(fmt.indexOf('E') !== -1) return write_num_exp2(fmt, val);&#13;
	if(fmt.charCodeAt(0) === 36) return "$"+write_num_int(type,fmt.substr(fmt.charAt(1)==' '?2:1),val);&#13;
	var o;&#13;
	var r, ri, ff, aval = Math.abs(val), sign = val &lt; 0 ? "-" : "";&#13;
	if(fmt.match(/^00+$/)) return sign + pad0(aval,fmt.length);&#13;
	if(fmt.match(/^[#?]+$/)) {&#13;
		o = (""+val); if(val === 0) o = "";&#13;
		return o.length &gt; fmt.length ? o : hashq(fmt.substr(0,fmt.length-o.length)) + o;&#13;
	}&#13;
	if((r = fmt.match(frac1))) return write_num_f2(r, aval, sign);&#13;
	if(fmt.match(/^#+0+$/)) return sign + pad0(aval,fmt.length - fmt.indexOf("0"));&#13;
	if((r = fmt.match(dec1))) {&#13;
o = (""+val).replace(/^([^\.]+)$/,"$1."+hashq(r[1])).replace(/\.$/,"."+hashq(r[1]));&#13;
		o = o.replace(/\.(\d*)$/,function($$, $1) {&#13;
return "." + $1 + fill("0", hashq(r[1]).length-$1.length); });&#13;
		return fmt.indexOf("0.") !== -1 ? o : o.replace(/^0\./,".");&#13;
	}&#13;
	fmt = fmt.replace(/^#+([0.])/, "$1");&#13;
	if((r = fmt.match(/^(0*)\.(#*)$/))) {&#13;
		return sign + (""+aval).replace(/\.(\d*[1-9])0*$/,".$1").replace(/^(-?\d*)$/,"$1.").replace(/^0\./,r[1].length?"0.":".");&#13;
	}&#13;
	if((r = fmt.match(/^#{1,3},##0(\.?)$/))) return sign + commaify((""+aval));&#13;
	if((r = fmt.match(/^#,##0\.([#0]*0)$/))) {&#13;
		return val &lt; 0 ? "-" + write_num_int(type, fmt, -val) : commaify((""+val)) + "." + fill('0',r[1].length);&#13;
	}&#13;
	if((r = fmt.match(/^#,#*,#0/))) return write_num_int(type,fmt.replace(/^#,#*,/,""),val);&#13;
	if((r = fmt.match(/^([0#]+)(\\?-([0#]+))+$/))) {&#13;
		o = _strrev(write_num_int(type, fmt.replace(/[\\-]/g,""), val));&#13;
		ri = 0;&#13;
		return _strrev(_strrev(fmt.replace(/\\/g,"")).replace(/[0#]/g,function(x){return ri&lt;o.length?o.charAt(ri++):x==='0'?'0':"";}));&#13;
	}&#13;
	if(fmt.match(phone)) {&#13;
		o = write_num_int(type, "##########", val);&#13;
		return "(" + o.substr(0,3) + ") " + o.substr(3, 3) + "-" + o.substr(6);&#13;
	}&#13;
	var oa = "";&#13;
	if((r = fmt.match(/^([#0?]+)( ?)\/( ?)([#0?]+)/))) {&#13;
		ri = Math.min(r[4].length,7);&#13;
		ff = SSF_frac(aval, Math.pow(10,ri)-1, false);&#13;
		o = "" + sign;&#13;
		oa = write_num("n", r[1], ff[1]);&#13;
		if(oa.charAt(oa.length-1) == " ") oa = oa.substr(0,oa.length-1) + "0";&#13;
		o += oa + r[2] + "/" + r[3];&#13;
		oa = rpad_(ff[2],ri);&#13;
		if(oa.length &lt; r[4].length) oa = hashq(r[4].substr(r[4].length-oa.length)) + oa;&#13;
		o += oa;&#13;
		return o;&#13;
	}&#13;
	if((r = fmt.match(/^# ([#0?]+)( ?)\/( ?)([#0?]+)/))) {&#13;
		ri = Math.min(Math.max(r[1].length, r[4].length),7);&#13;
		ff = SSF_frac(aval, Math.pow(10,ri)-1, true);&#13;
		return sign + (ff[0]||(ff[1] ? "" : "0")) + " " + (ff[1] ? pad_(ff[1],ri) + r[2] + "/" + r[3] + rpad_(ff[2],ri): fill(" ", 2*ri+1 + r[2].length + r[3].length));&#13;
	}&#13;
	if((r = fmt.match(/^[#0?]+$/))) {&#13;
		o = "" + val;&#13;
		if(fmt.length &lt;= o.length) return o;&#13;
		return hashq(fmt.substr(0,fmt.length-o.length)) + o;&#13;
	}&#13;
	if((r = fmt.match(/^([#0]+)\.([#0]+)$/))) {&#13;
		o = "" + val.toFixed(Math.min(r[2].length,10)).replace(/([^0])0+$/,"$1");&#13;
		ri = o.indexOf(".");&#13;
		var lres = fmt.indexOf(".") - ri, rres = fmt.length - o.length - lres;&#13;
		return hashq(fmt.substr(0,lres) + o + fmt.substr(fmt.length-rres));&#13;
	}&#13;
	if((r = fmt.match(/^00,000\.([#0]*0)$/))) {&#13;
		return val &lt; 0 ? "-" + write_num_int(type, fmt, -val) : commaify(""+val).replace(/^\d,\d{3}$/,"0$&amp;").replace(/^\d*$/,function($$) { return "00," + ($$.length &lt; 3 ? pad0(0,3-$$.length) : "") + $$; }) + "." + pad0(0,r[1].length);&#13;
	}&#13;
	switch(fmt) {&#13;
		case "###,###":&#13;
		case "##,###":&#13;
		case "#,###": var x = commaify(""+aval); return x !== "0" ? sign + x : "";&#13;
		default:&#13;
			if(fmt.match(/\.[0#?]*$/)) return write_num_int(type, fmt.slice(0,fmt.lastIndexOf(".")), val) + hashq(fmt.slice(fmt.lastIndexOf(".")));&#13;
	}&#13;
	throw new Error("unsupported format |" + fmt + "|");&#13;
}&#13;
function write_num(type, fmt, val) {&#13;
	return (val|0) === val ? write_num_int(type, fmt, val) : write_num_flt(type, fmt, val);&#13;
}&#13;
function SSF_split_fmt(fmt) {&#13;
	var out = [];&#13;
	var in_str = false/*, cc*/;&#13;
	for(var i = 0, j = 0; i &lt; fmt.length; ++i) switch((/*cc=*/fmt.charCodeAt(i))) {&#13;
		case 34: /* '"' */&#13;
			in_str = !in_str; break;&#13;
		case 95: case 42: case 92: /* '_' '*' '\\' */&#13;
			++i; break;&#13;
		case 59: /* ';' */&#13;
			out[out.length] = fmt.substr(j,i-j);&#13;
			j = i+1;&#13;
	}&#13;
	out[out.length] = fmt.substr(j);&#13;
	if(in_str === true) throw new Error("Format |" + fmt + "| unterminated string ");&#13;
	return out;&#13;
}&#13;
&#13;
var SSF_abstime = /\[[HhMmSs\u0E0A\u0E19\u0E17]*\]/;&#13;
function fmt_is_date(fmt) {&#13;
	var i = 0, /*cc = 0,*/ c = "", o = "";&#13;
	while(i &lt; fmt.length) {&#13;
		switch((c = fmt.charAt(i))) {&#13;
			case 'G': if(SSF_isgeneral(fmt, i)) i+= 6; i++; break;&#13;
			case '"': for(;(/*cc=*/fmt.charCodeAt(++i)) !== 34 &amp;&amp; i &lt; fmt.length;){/*empty*/} ++i; break;&#13;
			case '\\': i+=2; break;&#13;
			case '_': i+=2; break;&#13;
			case '@': ++i; break;&#13;
			case 'B': case 'b':&#13;
				if(fmt.charAt(i+1) === "1" || fmt.charAt(i+1) === "2") return true;&#13;
				/* falls through */&#13;
			case 'M': case 'D': case 'Y': case 'H': case 'S': case 'E':&#13;
				/* falls through */&#13;
			case 'm': case 'd': case 'y': case 'h': case 's': case 'e': case 'g': return true;&#13;
			case 'A': case 'a': case '上':&#13;
				if(fmt.substr(i, 3).toUpperCase() === "A/P") return true;&#13;
				if(fmt.substr(i, 5).toUpperCase() === "AM/PM") return true;&#13;
				if(fmt.substr(i, 5).toUpperCase() === "上午/下午") return true;&#13;
				++i; break;&#13;
			case '[':&#13;
				o = c;&#13;
				while(fmt.charAt(i++) !== ']' &amp;&amp; i &lt; fmt.length) o += fmt.charAt(i);&#13;
				if(o.match(SSF_abstime)) return true;&#13;
				break;&#13;
			case '.':&#13;
				/* falls through */&#13;
			case '0': case '#':&#13;
				while(i &lt; fmt.length &amp;&amp; ("0#?.,E+-%".indexOf(c=fmt.charAt(++i)) &gt; -1 || (c=='\\' &amp;&amp; fmt.charAt(i+1) == "-" &amp;&amp; "0#".indexOf(fmt.charAt(i+2))&gt;-1))){/* empty */}&#13;
				break;&#13;
			case '?': while(fmt.charAt(++i) === c){/* empty */} break;&#13;
			case '*': ++i; if(fmt.charAt(i) == ' ' || fmt.charAt(i) == '*') ++i; break;&#13;
			case '(': case ')': ++i; break;&#13;
			case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9':&#13;
				while(i &lt; fmt.length &amp;&amp; "0123456789".indexOf(fmt.charAt(++i)) &gt; -1){/* empty */} break;&#13;
			case ' ': ++i; break;&#13;
			default: ++i; break;&#13;
		}&#13;
	}&#13;
	return false;&#13;
}&#13;
&#13;
function eval_fmt(fmt, v, opts, flen) {&#13;
	var out = [], o = "", i = 0, c = "", lst='t', dt, j, cc;&#13;
	var hr='H';&#13;
	/* Tokenize */&#13;
	while(i &lt; fmt.length) {&#13;
		switch((c = fmt.charAt(i))) {&#13;
			case 'G': /* General */&#13;
				if(!SSF_isgeneral(fmt, i)) throw new Error('unrecognized character ' + c + ' in ' +fmt);&#13;
				out[out.length] = {t:'G', v:'General'}; i+=7; break;&#13;
			case '"': /* Literal text */&#13;
				for(o="";(cc=fmt.charCodeAt(++i)) !== 34 &amp;&amp; i &lt; fmt.length;) o += String.fromCharCode(cc);&#13;
				out[out.length] = {t:'t', v:o}; ++i; break;&#13;
			case '\\': var w = fmt.charAt(++i), t = (w === "(" || w === ")") ? w : 't';&#13;
				out[out.length] = {t:t, v:w}; ++i; break;&#13;
			case '_': out[out.length] = {t:'t', v:" "}; i+=2; break;&#13;
			case '@': /* Text Placeholder */&#13;
				out[out.length] = {t:'T', v:v}; ++i; break;&#13;
			case 'B': case 'b':&#13;
				if(fmt.charAt(i+1) === "1" || fmt.charAt(i+1) === "2") {&#13;
					if(dt==null) { dt=SSF_parse_date_code(v, opts, fmt.charAt(i+1) === "2"); if(dt==null) return ""; }&#13;
					out[out.length] = {t:'X', v:fmt.substr(i,2)}; lst = c; i+=2; break;&#13;
				}&#13;
				/* falls through */&#13;
			case 'M': case 'D': case 'Y': case 'H': case 'S': case 'E':&#13;
				c = c.toLowerCase();&#13;
				/* falls through */&#13;
			case 'm': case 'd': case 'y': case 'h': case 's': case 'e': case 'g':&#13;
				if(v &lt; 0) return "";&#13;
				if(dt==null) { dt=SSF_parse_date_code(v, opts); if(dt==null) return ""; }&#13;
				o = c; while(++i &lt; fmt.length &amp;&amp; fmt.charAt(i).toLowerCase() === c) o+=c;&#13;
				if(c === 'm' &amp;&amp; lst.toLowerCase() === 'h') c = 'M';&#13;
				if(c === 'h') c = hr;&#13;
				out[out.length] = {t:c, v:o}; lst = c; break;&#13;
			case 'A': case 'a': case '上':&#13;
				var q={t:c, v:c};&#13;
				if(dt==null) dt=SSF_parse_date_code(v, opts);&#13;
				if(fmt.substr(i, 3).toUpperCase() === "A/P") { if(dt!=null) q.v = dt.H &gt;= 12 ? fmt.charAt(i+2) : c; q.t = 'T'; hr='h';i+=3;}&#13;
				else if(fmt.substr(i,5).toUpperCase() === "AM/PM") { if(dt!=null) q.v = dt.H &gt;= 12 ? "PM" : "AM"; q.t = 'T'; i+=5; hr='h'; }&#13;
				else if(fmt.substr(i,5).toUpperCase() === "上午/下午") { if(dt!=null) q.v = dt.H &gt;= 12 ? "下午" : "上午"; q.t = 'T'; i+=5; hr='h'; }&#13;
				else { q.t = "t"; ++i; }&#13;
				if(dt==null &amp;&amp; q.t === 'T') return "";&#13;
				out[out.length] = q; lst = c; break;&#13;
			case '[':&#13;
				o = c;&#13;
				while(fmt.charAt(i++) !== ']' &amp;&amp; i &lt; fmt.length) o += fmt.charAt(i);&#13;
				if(o.slice(-1) !== ']') throw 'unterminated "[" block: |' + o + '|';&#13;
				if(o.match(SSF_abstime)) {&#13;
					if(dt==null) { dt=SSF_parse_date_code(v, opts); if(dt==null) return ""; }&#13;
					out[out.length] = {t:'Z', v:o.toLowerCase()};&#13;
					lst = o.charAt(1);&#13;
				} else if(o.indexOf("$") &gt; -1) {&#13;
					o = (o.match(/\$([^-\[\]]*)/)||[])[1]||"$";&#13;
					if(!fmt_is_date(fmt)) out[out.length] = {t:'t',v:o};&#13;
				}&#13;
				break;&#13;
			/* Numbers */&#13;
			case '.':&#13;
				if(dt != null) {&#13;
					o = c; while(++i &lt; fmt.length &amp;&amp; (c=fmt.charAt(i)) === "0") o += c;&#13;
					out[out.length] = {t:'s', v:o}; break;&#13;
				}&#13;
				/* falls through */&#13;
			case '0': case '#':&#13;
				o = c; while(++i &lt; fmt.length &amp;&amp; "0#?.,E+-%".indexOf(c=fmt.charAt(i)) &gt; -1) o += c;&#13;
				out[out.length] = {t:'n', v:o}; break;&#13;
			case '?':&#13;
				o = c; while(fmt.charAt(++i) === c) o+=c;&#13;
				out[out.length] = {t:c, v:o}; lst = c; break;&#13;
			case '*': ++i; if(fmt.charAt(i) == ' ' || fmt.charAt(i) == '*') ++i; break; // **&#13;
			case '(': case ')': out[out.length] = {t:(flen===1?'t':c), v:c}; ++i; break;&#13;
			case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9':&#13;
				o = c; while(i &lt; fmt.length &amp;&amp; "0123456789".indexOf(fmt.charAt(++i)) &gt; -1) o+=fmt.charAt(i);&#13;
				out[out.length] = {t:'D', v:o}; break;&#13;
			case ' ': out[out.length] = {t:c, v:c}; ++i; break;&#13;
			case '$': out[out.length] = {t:'t', v:'$'}; ++i; break;&#13;
			default:&#13;
				if(",$-+/():!^&amp;'~{}&lt;&gt;=€acfijklopqrtuvwxzP".indexOf(c) === -1) throw new Error('unrecognized character ' + c + ' in ' + fmt);&#13;
				out[out.length] = {t:'t', v:c}; ++i; break;&#13;
		}&#13;
	}&#13;
&#13;
	/* Scan for date/time parts */&#13;
	var bt = 0, ss0 = 0, ssm;&#13;
	for(i=out.length-1, lst='t'; i &gt;= 0; --i) {&#13;
		switch(out[i].t) {&#13;
			case 'h': case 'H': out[i].t = hr; lst='h'; if(bt &lt; 1) bt = 1; break;&#13;
			case 's':&#13;
				if((ssm=out[i].v.match(/\.0+$/))) ss0=Math.max(ss0,ssm[0].length-1);&#13;
				if(bt &lt; 3) bt = 3;&#13;
			/* falls through */&#13;
			case 'd': case 'y': case 'M': case 'e': lst=out[i].t; break;&#13;
			case 'm': if(lst === 's') { out[i].t = 'M'; if(bt &lt; 2) bt = 2; } break;&#13;
			case 'X': /*if(out[i].v === "B2");*/&#13;
				break;&#13;
			case 'Z':&#13;
				if(bt &lt; 1 &amp;&amp; out[i].v.match(/[Hh]/)) bt = 1;&#13;
				if(bt &lt; 2 &amp;&amp; out[i].v.match(/[Mm]/)) bt = 2;&#13;
				if(bt &lt; 3 &amp;&amp; out[i].v.match(/[Ss]/)) bt = 3;&#13;
		}&#13;
	}&#13;
	/* time rounding depends on presence of minute / second / usec fields */&#13;
	switch(bt) {&#13;
		case 0: break;&#13;
		case 1:&#13;
if(dt.u &gt;= 0.5) { dt.u = 0; ++dt.S; }&#13;
			if(dt.S &gt;=  60) { dt.S = 0; ++dt.M; }&#13;
			if(dt.M &gt;=  60) { dt.M = 0; ++dt.H; }&#13;
			break;&#13;
		case 2:&#13;
if(dt.u &gt;= 0.5) { dt.u = 0; ++dt.S; }&#13;
			if(dt.S &gt;=  60) { dt.S = 0; ++dt.M; }&#13;
			break;&#13;
	}&#13;
&#13;
	/* replace fields */&#13;
	var nstr = "", jj;&#13;
	for(i=0; i &lt; out.length; ++i) {&#13;
		switch(out[i].t) {&#13;
			case 't': case 'T': case ' ': case 'D': break;&#13;
			case 'X': out[i].v = ""; out[i].t = ";"; break;&#13;
			case 'd': case 'm': case 'y': case 'h': case 'H': case 'M': case 's': case 'e': case 'b': case 'Z':&#13;
out[i].v = SSF_write_date(out[i].t.charCodeAt(0), out[i].v, dt, ss0);&#13;
				out[i].t = 't'; break;&#13;
			case 'n': case '?':&#13;
				jj = i+1;&#13;
				while(out[jj] != null &amp;&amp; (&#13;
					(c=out[jj].t) === "?" || c === "D" ||&#13;
					((c === " " || c === "t") &amp;&amp; out[jj+1] != null &amp;&amp; (out[jj+1].t === '?' || out[jj+1].t === "t" &amp;&amp; out[jj+1].v === '/')) ||&#13;
					(out[i].t === '(' &amp;&amp; (c === ' ' || c === 'n' || c === ')')) ||&#13;
					(c === 't' &amp;&amp; (out[jj].v === '/' || out[jj].v === ' ' &amp;&amp; out[jj+1] != null &amp;&amp; out[jj+1].t == '?'))&#13;
				)) {&#13;
					out[i].v += out[jj].v;&#13;
					out[jj] = {v:"", t:";"}; ++jj;&#13;
				}&#13;
				nstr += out[i].v;&#13;
				i = jj-1; break;&#13;
			case 'G': out[i].t = 't'; out[i].v = SSF_general(v,opts); break;&#13;
		}&#13;
	}&#13;
	var vv = "", myv, ostr;&#13;
	if(nstr.length &gt; 0) {&#13;
		if(nstr.charCodeAt(0) == 40) /* '(' */ {&#13;
			myv = (v&lt;0&amp;&amp;nstr.charCodeAt(0) === 45 ? -v : v);&#13;
			ostr = write_num('n', nstr, myv);&#13;
		} else {&#13;
			myv = (v&lt;0 &amp;&amp; flen &gt; 1 ? -v : v);&#13;
			ostr = write_num('n', nstr, myv);&#13;
			if(myv &lt; 0 &amp;&amp; out[0] &amp;&amp; out[0].t == 't') {&#13;
				ostr = ostr.substr(1);&#13;
				out[0].v = "-" + out[0].v;&#13;
			}&#13;
		}&#13;
		jj=ostr.length-1;&#13;
		var decpt = out.length;&#13;
		for(i=0; i &lt; out.length; ++i) if(out[i] != null &amp;&amp; out[i].t != 't' &amp;&amp; out[i].v.indexOf(".") &gt; -1) { decpt = i; break; }&#13;
		var lasti=out.length;&#13;
		if(decpt === out.length &amp;&amp; ostr.indexOf("E") === -1) {&#13;
			for(i=out.length-1; i&gt;= 0;--i) {&#13;
				if(out[i] == null || 'n?'.indexOf(out[i].t) === -1) continue;&#13;
				if(jj&gt;=out[i].v.length-1) { jj -= out[i].v.length; out[i].v = ostr.substr(jj+1, out[i].v.length); }&#13;
				else if(jj &lt; 0) out[i].v = "";&#13;
				else { out[i].v = ostr.substr(0, jj+1); jj = -1; }&#13;
				out[i].t = 't';&#13;
				lasti = i;&#13;
			}&#13;
			if(jj&gt;=0 &amp;&amp; lasti&lt;out.length) out[lasti].v = ostr.substr(0,jj+1) + out[lasti].v;&#13;
		}&#13;
		else if(decpt !== out.length &amp;&amp; ostr.indexOf("E") === -1) {&#13;
			jj = ostr.indexOf(".")-1;&#13;
			for(i=decpt; i&gt;= 0; --i) {&#13;
				if(out[i] == null || 'n?'.indexOf(out[i].t) === -1) continue;&#13;
				j=out[i].v.indexOf(".")&gt;-1&amp;&amp;i===decpt?out[i].v.indexOf(".")-1:out[i].v.length-1;&#13;
				vv = out[i].v.substr(j+1);&#13;
				for(; j&gt;=0; --j) {&#13;
					if(jj&gt;=0 &amp;&amp; (out[i].v.charAt(j) === "0" || out[i].v.charAt(j) === "#")) vv = ostr.charAt(jj--) + vv;&#13;
				}&#13;
				out[i].v = vv;&#13;
				out[i].t = 't';&#13;
				lasti = i;&#13;
			}&#13;
			if(jj&gt;=0 &amp;&amp; lasti&lt;out.length) out[lasti].v = ostr.substr(0,jj+1) + out[lasti].v;&#13;
			jj = ostr.indexOf(".")+1;&#13;
			for(i=decpt; i&lt;out.length; ++i) {&#13;
				if(out[i] == null || ('n?('.indexOf(out[i].t) === -1 &amp;&amp; i !== decpt)) continue;&#13;
				j=out[i].v.indexOf(".")&gt;-1&amp;&amp;i===decpt?out[i].v.indexOf(".")+1:0;&#13;
				vv = out[i].v.substr(0,j);&#13;
				for(; j&lt;out[i].v.length; ++j) {&#13;
					if(jj&lt;ostr.length) vv += ostr.charAt(jj++);&#13;
				}&#13;
				out[i].v = vv;&#13;
				out[i].t = 't';&#13;
				lasti = i;&#13;
			}&#13;
		}&#13;
	}&#13;
	for(i=0; i&lt;out.length; ++i) if(out[i] != null &amp;&amp; 'n?'.indexOf(out[i].t)&gt;-1) {&#13;
		myv = (flen &gt;1 &amp;&amp; v &lt; 0 &amp;&amp; i&gt;0 &amp;&amp; out[i-1].v === "-" ? -v:v);&#13;
		out[i].v = write_num(out[i].t, out[i].v, myv);&#13;
		out[i].t = 't';&#13;
	}&#13;
	var retval = "";&#13;
	for(i=0; i !== out.length; ++i) if(out[i] != null) retval += out[i].v;&#13;
	return retval;&#13;
}&#13;
&#13;
var cfregex2 = /\[(=|&gt;[=]?|&lt;[&gt;=]?)(-?\d+(?:\.\d*)?)\]/;&#13;
function chkcond(v, rr) {&#13;
	if(rr == null) return false;&#13;
	var thresh = parseFloat(rr[2]);&#13;
	switch(rr[1]) {&#13;
		case "=":  if(v == thresh) return true; break;&#13;
		case "&gt;":  if(v &gt;  thresh) return true; break;&#13;
		case "&lt;":  if(v &lt;  thresh) return true; break;&#13;
		case "&lt;&gt;": if(v != thresh) return true; break;&#13;
		case "&gt;=": if(v &gt;= thresh) return true; break;&#13;
		case "&lt;=": if(v &lt;= thresh) return true; break;&#13;
	}&#13;
	return false;&#13;
}&#13;
function choose_fmt(f, v) {&#13;
	var fmt = SSF_split_fmt(f);&#13;
	var l = fmt.length, lat = fmt[l-1].indexOf("@");&#13;
	if(l&lt;4 &amp;&amp; lat&gt;-1) --l;&#13;
	if(fmt.length &gt; 4) throw new Error("cannot find right format for |" + fmt.join("|") + "|");&#13;
	if(typeof v !== "number") return [4, fmt.length === 4 || lat&gt;-1?fmt[fmt.length-1]:"@"];&#13;
	switch(fmt.length) {&#13;
		case 1: fmt = lat&gt;-1 ? ["General", "General", "General", fmt[0]] : [fmt[0], fmt[0], fmt[0], "@"]; break;&#13;
		case 2: fmt = lat&gt;-1 ? [fmt[0], fmt[0], fmt[0], fmt[1]] : [fmt[0], fmt[1], fmt[0], "@"]; break;&#13;
		case 3: fmt = lat&gt;-1 ? [fmt[0], fmt[1], fmt[0], fmt[2]] : [fmt[0], fmt[1], fmt[2], "@"]; break;&#13;
		case 4: break;&#13;
	}&#13;
	var ff = v &gt; 0 ? fmt[0] : v &lt; 0 ? fmt[1] : fmt[2];&#13;
	if(fmt[0].indexOf("[") === -1 &amp;&amp; fmt[1].indexOf("[") === -1) return [l, ff];&#13;
	if(fmt[0].match(/\[[=&lt;&gt;]/) != null || fmt[1].match(/\[[=&lt;&gt;]/) != null) {&#13;
		var m1 = fmt[0].match(cfregex2);&#13;
		var m2 = fmt[1].match(cfregex2);&#13;
		return chkcond(v, m1) ? [l, fmt[0]] : chkcond(v, m2) ? [l, fmt[1]] : [l, fmt[m1 != null &amp;&amp; m2 != null ? 2 : 1]];&#13;
	}&#13;
	return [l, ff];&#13;
}&#13;
function SSF_format(fmt,v,o) {&#13;
	if(o == null) o = {};&#13;
	var sfmt = "";&#13;
	switch(typeof fmt) {&#13;
		case "string":&#13;
			if(fmt == "m/d/yy" &amp;&amp; o.dateNF) sfmt = o.dateNF;&#13;
			else sfmt = fmt;&#13;
			break;&#13;
		case "number":&#13;
			if(fmt == 14 &amp;&amp; o.dateNF) sfmt = o.dateNF;&#13;
			else sfmt = (o.table != null ? (o.table) : table_fmt)[fmt];&#13;
			if(sfmt == null) sfmt = (o.table &amp;&amp; o.table[SSF_default_map[fmt]]) || table_fmt[SSF_default_map[fmt]];&#13;
			if(sfmt == null) sfmt = SSF_default_str[fmt] || "General";&#13;
			break;&#13;
	}&#13;
	if(SSF_isgeneral(sfmt,0)) return SSF_general(v, o);&#13;
	if(v instanceof Date) v = datenum_local(v, o.date1904);&#13;
	var f = choose_fmt(sfmt, v);&#13;
	if(SSF_isgeneral(f[1])) return SSF_general(v, o);&#13;
	if(v === true) v = "TRUE"; else if(v === false) v = "FALSE";&#13;
	else if(v === "" || v == null) return "";&#13;
	return eval_fmt(f[1], v, o, f[0]);&#13;
}&#13;
function SSF_load(fmt, idx) {&#13;
	if(typeof idx != 'number') {&#13;
		idx = +idx || -1;&#13;
for(var i = 0; i &lt; 0x0188; ++i) {&#13;
if(table_fmt[i] == undefined) { if(idx &lt; 0) idx = i; continue; }&#13;
			if(table_fmt[i] == fmt) { idx = i; break; }&#13;
		}&#13;
if(idx &lt; 0) idx = 0x187;&#13;
	}&#13;
table_fmt[idx] = fmt;&#13;
	return idx;&#13;
}&#13;
function SSF_load_table(tbl) {&#13;
	for(var i=0; i!=0x0188; ++i)&#13;
		if(tbl[i] !== undefined) SSF_load(tbl[i], i);&#13;
}&#13;
&#13;
function make_ssf() {&#13;
	table_fmt = SSF_init_table();&#13;
}&#13;
&#13;
var SSF = {&#13;
	format: SSF_format,&#13;
	load: SSF_load,&#13;
	_table: table_fmt,&#13;
	load_table: SSF_load_table,&#13;
	parse_date_code: SSF_parse_date_code,&#13;
	is_date: fmt_is_date,&#13;
	get_table: function get_table() { return SSF._table = table_fmt; }&#13;
};&#13;
&#13;
var SSFImplicit/*{[number]:string}*/ = ({&#13;
	"5": '"$"#,##0_);\\("$"#,##0\\)',&#13;
	"6": '"$"#,##0_);[Red]\\("$"#,##0\\)',&#13;
	"7": '"$"#,##0.00_);\\("$"#,##0.00\\)',&#13;
	"8": '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',&#13;
	"23": 'General', "24": 'General', "25": 'General', "26": 'General',&#13;
	"27": 'm/d/yy', "28": 'm/d/yy', "29": 'm/d/yy', "30": 'm/d/yy', "31": 'm/d/yy',&#13;
	"32": 'h:mm:ss', "33": 'h:mm:ss', "34": 'h:mm:ss', "35": 'h:mm:ss',&#13;
	"36": 'm/d/yy',&#13;
	"41": '_(* #,##0_);_(* \(#,##0\);_(* "-"_);_(@_)',&#13;
	"42": '_("$"* #,##0_);_("$"* \(#,##0\);_("$"* "-"_);_(@_)',&#13;
	"43": '_(* #,##0.00_);_(* \(#,##0.00\);_(* "-"??_);_(@_)',&#13;
	"44": '_("$"* #,##0.00_);_("$"* \(#,##0.00\);_("$"* "-"??_);_(@_)',&#13;
	"50": 'm/d/yy', "51": 'm/d/yy', "52": 'm/d/yy', "53": 'm/d/yy', "54": 'm/d/yy',&#13;
	"55": 'm/d/yy', "56": 'm/d/yy', "57": 'm/d/yy', "58": 'm/d/yy',&#13;
	"59": '0',&#13;
	"60": '0.00',&#13;
	"61": '#,##0',&#13;
	"62": '#,##0.00',&#13;
	"63": '"$"#,##0_);\\("$"#,##0\\)',&#13;
	"64": '"$"#,##0_);[Red]\\("$"#,##0\\)',&#13;
	"65": '"$"#,##0.00_);\\("$"#,##0.00\\)',&#13;
	"66": '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',&#13;
	"67": '0%',&#13;
	"68": '0.00%',&#13;
	"69": '# ?/?',&#13;
	"70": '# ??/??',&#13;
	"71": 'm/d/yy',&#13;
	"72": 'm/d/yy',&#13;
	"73": 'd-mmm-yy',&#13;
	"74": 'd-mmm',&#13;
	"75": 'mmm-yy',&#13;
	"76": 'h:mm',&#13;
	"77": 'h:mm:ss',&#13;
	"78": 'm/d/yy h:mm',&#13;
	"79": 'mm:ss',&#13;
	"80": '[h]:mm:ss',&#13;
	"81": 'mmss.0'&#13;
});&#13;
&#13;
/* dateNF parse TODO: move to SSF */&#13;
var dateNFregex = /[dD]+|[mM]+|[yYeE]+|[Hh]+|[Ss]+/g;&#13;
function dateNF_regex(dateNF) {&#13;
	var fmt = typeof dateNF == "number" ? table_fmt[dateNF] : dateNF;&#13;
	fmt = fmt.replace(dateNFregex, "(\\d+)");&#13;
	return new RegExp("^" + fmt + "$");&#13;
}&#13;
function dateNF_fix(str, dateNF, match) {&#13;
	var Y = -1, m = -1, d = -1, H = -1, M = -1, S = -1;&#13;
	(dateNF.match(dateNFregex)||[]).forEach(function(n, i) {&#13;
		var v = parseInt(match[i+1], 10);&#13;
		switch(n.toLowerCase().charAt(0)) {&#13;
			case 'y': Y = v; break; case 'd': d = v; break;&#13;
			case 'h': H = v; break; case 's': S = v; break;&#13;
			case 'm': if(H &gt;= 0) M = v; else m = v; break;&#13;
		}&#13;
	});&#13;
	if(S &gt;= 0 &amp;&amp; M == -1 &amp;&amp; m &gt;= 0) { M = m; m = -1; }&#13;
	var datestr = (("" + (Y&gt;=0?Y: new Date().getFullYear())).slice(-4) + "-" + ("00" + (m&gt;=1?m:1)).slice(-2) + "-" + ("00" + (d&gt;=1?d:1)).slice(-2));&#13;
	if(datestr.length == 7) datestr = "0" + datestr;&#13;
	if(datestr.length == 8) datestr = "20" + datestr;&#13;
	var timestr = (("00" + (H&gt;=0?H:0)).slice(-2) + ":" + ("00" + (M&gt;=0?M:0)).slice(-2) + ":" + ("00" + (S&gt;=0?S:0)).slice(-2));&#13;
	if(H == -1 &amp;&amp; M == -1 &amp;&amp; S == -1) return datestr;&#13;
	if(Y == -1 &amp;&amp; m == -1 &amp;&amp; d == -1) return timestr;&#13;
	return datestr + "T" + timestr;&#13;
}&#13;
&#13;
/* table of bad formats written by third-party tools */&#13;
var bad_formats = {&#13;
	"d.m": "d\\.m" // Issue #2571 Google Sheets writes invalid format 'd.m', correct format is 'd"."m' or 'd\\.m'&#13;
};&#13;
&#13;
function SSF__load(fmt, idx) {&#13;
	return SSF_load(bad_formats[fmt] || fmt, idx);&#13;
}&#13;
&#13;
/* cfb.js (C) 2013-present xlsx -- http://sheetjs.com */&#13;
/* vim: set ts=2: */&#13;
/*jshint eqnull:true */&#13;
/*exported CFB */&#13;
/*global Uint8Array:false, Uint16Array:false */&#13;
&#13;
/* crc32.js (C) 2014-present xlsx -- http://sheetjs.com */&#13;
/* vim: set ts=2: */&#13;
/*exported CRC32 */&#13;
var CRC32 = (function() {&#13;
var CRC32 = {};&#13;
CRC32.version = '1.2.0';&#13;
/* see perf/crc32table.js */&#13;
/*global Int32Array */&#13;
function signed_crc_table() {&#13;
	var c = 0, table = new Array(256);&#13;
&#13;
	for(var n =0; n != 256; ++n){&#13;
		c = n;&#13;
		c = ((c&amp;1) ? (-306674912 ^ (c &gt;&gt;&gt; 1)) : (c &gt;&gt;&gt; 1));&#13;
		c = ((c&amp;1) ? (-306674912 ^ (c &gt;&gt;&gt; 1)) : (c &gt;&gt;&gt; 1));&#13;
		c = ((c&amp;1) ? (-306674912 ^ (c &gt;&gt;&gt; 1)) : (c &gt;&gt;&gt; 1));&#13;
		c = ((c&amp;1) ? (-306674912 ^ (c &gt;&gt;&gt; 1)) : (c &gt;&gt;&gt; 1));&#13;
		c = ((c&amp;1) ? (-306674912 ^ (c &gt;&gt;&gt; 1)) : (c &gt;&gt;&gt; 1));&#13;
		c = ((c&amp;1) ? (-306674912 ^ (c &gt;&gt;&gt; 1)) : (c &gt;&gt;&gt; 1));&#13;
		c = ((c&amp;1) ? (-306674912 ^ (c &gt;&gt;&gt; 1)) : (c &gt;&gt;&gt; 1));&#13;
		c = ((c&amp;1) ? (-306674912 ^ (c &gt;&gt;&gt; 1)) : (c &gt;&gt;&gt; 1));&#13;
		table[n] = c;&#13;
	}&#13;
&#13;
	return typeof Int32Array !== 'undefined' ? new Int32Array(table) : table;&#13;
}&#13;
&#13;
var T0 = signed_crc_table();&#13;
function slice_by_16_tables(T) {&#13;
	var c = 0, v = 0, n = 0, table = typeof Int32Array !== 'undefined' ? new Int32Array(4096) : new Array(4096) ;&#13;
&#13;
	for(n = 0; n != 256; ++n) table[n] = T[n];&#13;
	for(n = 0; n != 256; ++n) {&#13;
		v = T[n];&#13;
		for(c = 256 + n; c &lt; 4096; c += 256) v = table[c] = (v &gt;&gt;&gt; 8) ^ T[v &amp; 0xFF];&#13;
	}&#13;
	var out = [];&#13;
	for(n = 1; n != 16; ++n) out[n - 1] = typeof Int32Array !== 'undefined' ? table.subarray(n * 256, n * 256 + 256) : table.slice(n * 256, n * 256 + 256);&#13;
	return out;&#13;
}&#13;
var TT = slice_by_16_tables(T0);&#13;
var T1 = TT[0],  T2 = TT[1],  T3 = TT[2],  T4 = TT[3],  T5 = TT[4];&#13;
var T6 = TT[5],  T7 = TT[6],  T8 = TT[7],  T9 = TT[8],  Ta = TT[9];&#13;
var Tb = TT[10], Tc = TT[11], Td = TT[12], Te = TT[13], Tf = TT[14];&#13;
function crc32_bstr(bstr, seed) {&#13;
	var C = seed ^ -1;&#13;
	for(var i = 0, L = bstr.length; i &lt; L;) C = (C&gt;&gt;&gt;8) ^ T0[(C^bstr.charCodeAt(i++))&amp;0xFF];&#13;
	return ~C;&#13;
}&#13;
&#13;
function crc32_buf(B, seed) {&#13;
	var C = seed ^ -1, L = B.length - 15, i = 0;&#13;
	for(; i &lt; L;) C =&#13;
		Tf[B[i++] ^ (C &amp; 255)] ^&#13;
		Te[B[i++] ^ ((C &gt;&gt; 8) &amp; 255)] ^&#13;
		Td[B[i++] ^ ((C &gt;&gt; 16) &amp; 255)] ^&#13;
		Tc[B[i++] ^ (C &gt;&gt;&gt; 24)] ^&#13;
		Tb[B[i++]] ^ Ta[B[i++]] ^ T9[B[i++]] ^ T8[B[i++]] ^&#13;
		T7[B[i++]] ^ T6[B[i++]] ^ T5[B[i++]] ^ T4[B[i++]] ^&#13;
		T3[B[i++]] ^ T2[B[i++]] ^ T1[B[i++]] ^ T0[B[i++]];&#13;
	L += 15;&#13;
	while(i &lt; L) C = (C&gt;&gt;&gt;8) ^ T0[(C^B[i++])&amp;0xFF];&#13;
	return ~C;&#13;
}&#13;
&#13;
function crc32_str(str, seed) {&#13;
	var C = seed ^ -1;&#13;
	for(var i = 0, L = str.length, c = 0, d = 0; i &lt; L;) {&#13;
		c = str.charCodeAt(i++);&#13;
		if(c &lt; 0x80) {&#13;
			C = (C&gt;&gt;&gt;8) ^ T0[(C^c)&amp;0xFF];&#13;
		} else if(c &lt; 0x800) {&#13;
			C = (C&gt;&gt;&gt;8) ^ T0[(C ^ (192|((c&gt;&gt;6)&amp;31)))&amp;0xFF];&#13;
			C = (C&gt;&gt;&gt;8) ^ T0[(C ^ (128|(c&amp;63)))&amp;0xFF];&#13;
		} else if(c &gt;= 0xD800 &amp;&amp; c &lt; 0xE000) {&#13;
			c = (c&amp;1023)+64; d = str.charCodeAt(i++)&amp;1023;&#13;
			C = (C&gt;&gt;&gt;8) ^ T0[(C ^ (240|((c&gt;&gt;8)&amp;7)))&amp;0xFF];&#13;
			C = (C&gt;&gt;&gt;8) ^ T0[(C ^ (128|((c&gt;&gt;2)&amp;63)))&amp;0xFF];&#13;
			C = (C&gt;&gt;&gt;8) ^ T0[(C ^ (128|((d&gt;&gt;6)&amp;15)|((c&amp;3)&lt;&lt;4)))&amp;0xFF];&#13;
			C = (C&gt;&gt;&gt;8) ^ T0[(C ^ (128|(d&amp;63)))&amp;0xFF];&#13;
		} else {&#13;
			C = (C&gt;&gt;&gt;8) ^ T0[(C ^ (224|((c&gt;&gt;12)&amp;15)))&amp;0xFF];&#13;
			C = (C&gt;&gt;&gt;8) ^ T0[(C ^ (128|((c&gt;&gt;6)&amp;63)))&amp;0xFF];&#13;
			C = (C&gt;&gt;&gt;8) ^ T0[(C ^ (128|(c&amp;63)))&amp;0xFF];&#13;
		}&#13;
	}&#13;
	return ~C;&#13;
}&#13;
CRC32.table = T0;&#13;
CRC32.bstr = crc32_bstr;&#13;
CRC32.buf = crc32_buf;&#13;
CRC32.str = crc32_str;&#13;
return CRC32;&#13;
})();&#13;
/* [MS-CFB] v20171201 */&#13;
var CFB = (function _CFB(){&#13;
var exports = {};&#13;
exports.version = '1.2.2';&#13;
/* [MS-CFB] 2.6.4 */&#13;
function namecmp(l, r) {&#13;
	var L = l.split("/"), R = r.split("/");&#13;
	for(var i = 0, c = 0, Z = Math.min(L.length, R.length); i &lt; Z; ++i) {&#13;
		if((c = L[i].length - R[i].length)) return c;&#13;
		if(L[i] != R[i]) return L[i] &lt; R[i] ? -1 : 1;&#13;
	}&#13;
	return L.length - R.length;&#13;
}&#13;
function dirname(p) {&#13;
	if(p.charAt(p.length - 1) == "/") return (p.slice(0,-1).indexOf("/") === -1) ? p : dirname(p.slice(0, -1));&#13;
	var c = p.lastIndexOf("/");&#13;
	return (c === -1) ? p : p.slice(0, c+1);&#13;
}&#13;
&#13;
function filename(p) {&#13;
	if(p.charAt(p.length - 1) == "/") return filename(p.slice(0, -1));&#13;
	var c = p.lastIndexOf("/");&#13;
	return (c === -1) ? p : p.slice(c+1);&#13;
}&#13;
/* -------------------------------------------------------------------------- */&#13;
/* DOS Date format:&#13;
   high|YYYYYYYm.mmmddddd.HHHHHMMM.MMMSSSSS|low&#13;
   add 1980 to stored year&#13;
   stored second should be doubled&#13;
*/&#13;
&#13;
/* write JS date to buf as a DOS date */&#13;
function write_dos_date(buf, date) {&#13;
	if(typeof date === "string") date = new Date(date);&#13;
	var hms = date.getHours();&#13;
	hms = hms &lt;&lt; 6 | date.getMinutes();&#13;
	hms = hms &lt;&lt; 5 | (date.getSeconds()&gt;&gt;&gt;1);&#13;
	buf.write_shift(2, hms);&#13;
	var ymd = (date.getFullYear() - 1980);&#13;
	ymd = ymd &lt;&lt; 4 | (date.getMonth()+1);&#13;
	ymd = ymd &lt;&lt; 5 | date.getDate();&#13;
	buf.write_shift(2, ymd);&#13;
}&#13;
&#13;
/* read four bytes from buf and interpret as a DOS date */&#13;
function parse_dos_date(buf) {&#13;
	var hms = buf.read_shift(2) &amp; 0xFFFF;&#13;
	var ymd = buf.read_shift(2) &amp; 0xFFFF;&#13;
	var val = new Date();&#13;
	var d = ymd &amp; 0x1F; ymd &gt;&gt;&gt;= 5;&#13;
	var m = ymd &amp; 0x0F; ymd &gt;&gt;&gt;= 4;&#13;
	val.setMilliseconds(0);&#13;
	val.setFullYear(ymd + 1980);&#13;
	val.setMonth(m-1);&#13;
	val.setDate(d);&#13;
	var S = hms &amp; 0x1F; hms &gt;&gt;&gt;= 5;&#13;
	var M = hms &amp; 0x3F; hms &gt;&gt;&gt;= 6;&#13;
	val.setHours(hms);&#13;
	val.setMinutes(M);&#13;
	val.setSeconds(S&lt;&lt;1);&#13;
	return val;&#13;
}&#13;
function parse_extra_field(blob) {&#13;
	prep_blob(blob, 0);&#13;
	var o = {};&#13;
	var flags = 0;&#13;
	while(blob.l &lt;= blob.length - 4) {&#13;
		var type = blob.read_shift(2);&#13;
		var sz = blob.read_shift(2), tgt = blob.l + sz;&#13;
		var p = {};&#13;
		switch(type) {&#13;
			/* UNIX-style Timestamps */&#13;
			case 0x5455: {&#13;
				flags = blob.read_shift(1);&#13;
				if(flags &amp; 1) p.mtime = blob.read_shift(4);&#13;
				/* for some reason, CD flag corresponds to LFH */&#13;
				if(sz &gt; 5) {&#13;
					if(flags &amp; 2) p.atime = blob.read_shift(4);&#13;
					if(flags &amp; 4) p.ctime = blob.read_shift(4);&#13;
				}&#13;
				if(p.mtime) p.mt = new Date(p.mtime*1000);&#13;
			} break;&#13;
			/* ZIP64 Extended Information Field */&#13;
			case 0x0001: {&#13;
				var sz1 = blob.read_shift(4), sz2 = blob.read_shift(4);&#13;
				p.usz = (sz2 * Math.pow(2,32) + sz1);&#13;
				sz1 = blob.read_shift(4); sz2 = blob.read_shift(4);&#13;
				p.csz = (sz2 * Math.pow(2,32) + sz1);&#13;
				// NOTE: volume fields are skipped&#13;
			} break;&#13;
		}&#13;
		blob.l = tgt;&#13;
		o[type] = p;&#13;
	}&#13;
	return o;&#13;
}&#13;
var fs;&#13;
function get_fs() { return fs || (fs = _fs); }&#13;
function parse(file, options) {&#13;
if(file[0] == 0x50 &amp;&amp; file[1] == 0x4b) return parse_zip(file, options);&#13;
if((file[0] | 0x20) == 0x6d &amp;&amp; (file[1]|0x20) == 0x69) return parse_mad(file, options);&#13;
if(file.length &lt; 512) throw new Error("CFB file size " + file.length + " &lt; 512");&#13;
var mver = 3;&#13;
var ssz = 512;&#13;
var nmfs = 0; // number of mini FAT sectors&#13;
var difat_sec_cnt = 0;&#13;
var dir_start = 0;&#13;
var minifat_start = 0;&#13;
var difat_start = 0;&#13;
&#13;
var fat_addrs = []; // locations of FAT sectors&#13;
&#13;
/* [MS-CFB] 2.2 Compound File Header */&#13;
var blob = file.slice(0,512);&#13;
prep_blob(blob, 0);&#13;
&#13;
/* major version */&#13;
var mv = check_get_mver(blob);&#13;
mver = mv[0];&#13;
switch(mver) {&#13;
	case 3: ssz = 512; break; case 4: ssz = 4096; break;&#13;
	case 0: if(mv[1] == 0) return parse_zip(file, options);&#13;
	/* falls through */&#13;
	default: throw new Error("Major Version: Expected 3 or 4 saw " + mver);&#13;
}&#13;
&#13;
/* reprocess header */&#13;
if(ssz !== 512) { blob = file.slice(0,ssz); prep_blob(blob, 28 /* blob.l */); }&#13;
/* Save header for final object */&#13;
var header = file.slice(0,ssz);&#13;
&#13;
check_shifts(blob, mver);&#13;
&#13;
// Number of Directory Sectors&#13;
var dir_cnt = blob.read_shift(4, 'i');&#13;
if(mver === 3 &amp;&amp; dir_cnt !== 0) throw new Error('# Directory Sectors: Expected 0 saw ' + dir_cnt);&#13;
&#13;
// Number of FAT Sectors&#13;
blob.l += 4;&#13;
&#13;
// First Directory Sector Location&#13;
dir_start = blob.read_shift(4, 'i');&#13;
&#13;
// Transaction Signature&#13;
blob.l += 4;&#13;
&#13;
// Mini Stream Cutoff Size&#13;
blob.chk('00100000', 'Mini Stream Cutoff Size: ');&#13;
&#13;
// First Mini FAT Sector Location&#13;
minifat_start = blob.read_shift(4, 'i');&#13;
&#13;
// Number of Mini FAT Sectors&#13;
nmfs = blob.read_shift(4, 'i');&#13;
&#13;
// First DIFAT sector location&#13;
difat_start = blob.read_shift(4, 'i');&#13;
&#13;
// Number of DIFAT Sectors&#13;
difat_sec_cnt = blob.read_shift(4, 'i');&#13;
&#13;
// Grab FAT Sector Locations&#13;
for(var q = -1, j = 0; j &lt; 109; ++j) { /* 109 = (512 - blob.l)&gt;&gt;&gt;2; */&#13;
	q = blob.read_shift(4, 'i');&#13;
	if(q&lt;0) break;&#13;
	fat_addrs[j] = q;&#13;
}&#13;
&#13;
/** Break the file up into sectors */&#13;
var sectors = sectorify(file, ssz);&#13;
&#13;
sleuth_fat(difat_start, difat_sec_cnt, sectors, ssz, fat_addrs);&#13;
&#13;
/** Chains */&#13;
var sector_list = make_sector_list(sectors, dir_start, fat_addrs, ssz);&#13;
&#13;
sector_list[dir_start].name = "!Directory";&#13;
if(nmfs &gt; 0 &amp;&amp; minifat_start !== ENDOFCHAIN) sector_list[minifat_start].name = "!MiniFAT";&#13;
sector_list[fat_addrs[0]].name = "!FAT";&#13;
sector_list.fat_addrs = fat_addrs;&#13;
sector_list.ssz = ssz;&#13;
&#13;
/* [MS-CFB] 2.6.1 Compound File Directory Entry */&#13;
var files = {}, Paths = [], FileIndex = [], FullPaths = [];&#13;
read_directory(dir_start, sector_list, sectors, Paths, nmfs, files, FileIndex, minifat_start);&#13;
&#13;
build_full_paths(FileIndex, FullPaths, Paths);&#13;
Paths.shift();&#13;
&#13;
var o = {&#13;
	FileIndex: FileIndex,&#13;
	FullPaths: FullPaths&#13;
};&#13;
&#13;
// $FlowIgnore&#13;
if(options &amp;&amp; options.raw) o.raw = {header: header, sectors: sectors};&#13;
return o;&#13;
} // parse&#13;
&#13;
/* [MS-CFB] 2.2 Compound File Header -- read up to major version */&#13;
function check_get_mver(blob) {&#13;
	if(blob[blob.l] == 0x50 &amp;&amp; blob[blob.l + 1] == 0x4b) return [0, 0];&#13;
	// header signature 8&#13;
	blob.chk(HEADER_SIGNATURE, 'Header Signature: ');&#13;
&#13;
	// clsid 16&#13;
	//blob.chk(HEADER_CLSID, 'CLSID: ');&#13;
	blob.l += 16;&#13;
&#13;
	// minor version 2&#13;
	var mver = blob.read_shift(2, 'u');&#13;
&#13;
	return [blob.read_shift(2,'u'), mver];&#13;
}&#13;
function check_shifts(blob, mver) {&#13;
	var shift = 0x09;&#13;
&#13;
	// Byte Order&#13;
	//blob.chk('feff', 'Byte Order: '); // note: some writers put 0xffff&#13;
	blob.l += 2;&#13;
&#13;
	// Sector Shift&#13;
	switch((shift = blob.read_shift(2))) {&#13;
		case 0x09: if(mver != 3) throw new Error('Sector Shift: Expected 9 saw ' + shift); break;&#13;
		case 0x0c: if(mver != 4) throw new Error('Sector Shift: Expected 12 saw ' + shift); break;&#13;
		default: throw new Error('Sector Shift: Expected 9 or 12 saw ' + shift);&#13;
	}&#13;
&#13;
	// Mini Sector Shift&#13;
	blob.chk('0600', 'Mini Sector Shift: ');&#13;
&#13;
	// Reserved&#13;
	blob.chk('000000000000', 'Reserved: ');&#13;
}&#13;
&#13;
/** Break the file up into sectors */&#13;
function sectorify(file, ssz) {&#13;
	var nsectors = Math.ceil(file.length/ssz)-1;&#13;
	var sectors = [];&#13;
	for(var i=1; i &lt; nsectors; ++i) sectors[i-1] = file.slice(i*ssz,(i+1)*ssz);&#13;
	sectors[nsectors-1] = file.slice(nsectors*ssz);&#13;
	return sectors;&#13;
}&#13;
&#13;
/* [MS-CFB] 2.6.4 Red-Black Tree */&#13;
function build_full_paths(FI, FP, Paths) {&#13;
	var i = 0, L = 0, R = 0, C = 0, j = 0, pl = Paths.length;&#13;
	var dad = [], q = [];&#13;
&#13;
	for(; i &lt; pl; ++i) { dad[i]=q[i]=i; FP[i]=Paths[i]; }&#13;
&#13;
	for(; j &lt; q.length; ++j) {&#13;
		i = q[j];&#13;
		L = FI[i].L; R = FI[i].R; C = FI[i].C;&#13;
		if(dad[i] === i) {&#13;
			if(L !== -1 /*NOSTREAM*/ &amp;&amp; dad[L] !== L) dad[i] = dad[L];&#13;
			if(R !== -1 &amp;&amp; dad[R] !== R) dad[i] = dad[R];&#13;
		}&#13;
		if(C !== -1 /*NOSTREAM*/) dad[C] = i;&#13;
		if(L !== -1 &amp;&amp; i != dad[i]) { dad[L] = dad[i]; if(q.lastIndexOf(L) &lt; j) q.push(L); }&#13;
		if(R !== -1 &amp;&amp; i != dad[i]) { dad[R] = dad[i]; if(q.lastIndexOf(R) &lt; j) q.push(R); }&#13;
	}&#13;
	for(i=1; i &lt; pl; ++i) if(dad[i] === i) {&#13;
		if(R !== -1 /*NOSTREAM*/ &amp;&amp; dad[R] !== R) dad[i] = dad[R];&#13;
		else if(L !== -1 &amp;&amp; dad[L] !== L) dad[i] = dad[L];&#13;
	}&#13;
&#13;
	for(i=1; i &lt; pl; ++i) {&#13;
		if(FI[i].type === 0 /* unknown */) continue;&#13;
		j = i;&#13;
		if(j != dad[j]) do {&#13;
			j = dad[j];&#13;
			FP[i] = FP[j] + "/" + FP[i];&#13;
		} while (j !== 0 &amp;&amp; -1 !== dad[j] &amp;&amp; j != dad[j]);&#13;
		dad[i] = -1;&#13;
	}&#13;
&#13;
	FP[0] += "/";&#13;
	for(i=1; i &lt; pl; ++i) {&#13;
		if(FI[i].type !== 2 /* stream */) FP[i] += "/";&#13;
	}&#13;
}&#13;
&#13;
function get_mfat_entry(entry, payload, mini) {&#13;
	var start = entry.start, size = entry.size;&#13;
	//return (payload.slice(start*MSSZ, start*MSSZ + size));&#13;
	var o = [];&#13;
	var idx = start;&#13;
	while(mini &amp;&amp; size &gt; 0 &amp;&amp; idx &gt;= 0) {&#13;
		o.push(payload.slice(idx * MSSZ, idx * MSSZ + MSSZ));&#13;
		size -= MSSZ;&#13;
		idx = __readInt32LE(mini, idx * 4);&#13;
	}&#13;
	if(o.length === 0) return (new_buf(0));&#13;
	return (bconcat(o).slice(0, entry.size));&#13;
}&#13;
&#13;
/** Chase down the rest of the DIFAT chain to build a comprehensive list&#13;
    DIFAT chains by storing the next sector number as the last 32 bits */&#13;
function sleuth_fat(idx, cnt, sectors, ssz, fat_addrs) {&#13;
	var q = ENDOFCHAIN;&#13;
	if(idx === ENDOFCHAIN) {&#13;
		if(cnt !== 0) throw new Error("DIFAT chain shorter than expected");&#13;
	} else if(idx !== -1 /*FREESECT*/) {&#13;
		var sector = sectors[idx], m = (ssz&gt;&gt;&gt;2)-1;&#13;
		if(!sector) return;&#13;
		for(var i = 0; i &lt; m; ++i) {&#13;
			if((q = __readInt32LE(sector,i*4)) === ENDOFCHAIN) break;&#13;
			fat_addrs.push(q);&#13;
		}&#13;
		if(cnt &gt;= 1) sleuth_fat(__readInt32LE(sector,ssz-4),cnt - 1, sectors, ssz, fat_addrs);&#13;
	}&#13;
}&#13;
&#13;
/** Follow the linked list of sectors for a given starting point */&#13;
function get_sector_list(sectors, start, fat_addrs, ssz, chkd) {&#13;
	var buf = [], buf_chain = [];&#13;
	if(!chkd) chkd = [];&#13;
	var modulus = ssz - 1, j = 0, jj = 0;&#13;
	for(j=start; j&gt;=0;) {&#13;
		chkd[j] = true;&#13;
		buf[buf.length] = j;&#13;
		buf_chain.push(sectors[j]);&#13;
		var addr = fat_addrs[Math.floor(j*4/ssz)];&#13;
		jj = ((j*4) &amp; modulus);&#13;
		if(ssz &lt; 4 + jj) throw new Error("FAT boundary crossed: " + j + " 4 "+ssz);&#13;
		if(!sectors[addr]) break;&#13;
		j = __readInt32LE(sectors[addr], jj);&#13;
	}&#13;
	return {nodes: buf, data:__toBuffer([buf_chain])};&#13;
}&#13;
&#13;
/** Chase down the sector linked lists */&#13;
function make_sector_list(sectors, dir_start, fat_addrs, ssz) {&#13;
	var sl = sectors.length, sector_list = ([]);&#13;
	var chkd = [], buf = [], buf_chain = [];&#13;
	var modulus = ssz - 1, i=0, j=0, k=0, jj=0;&#13;
	for(i=0; i &lt; sl; ++i) {&#13;
		buf = ([]);&#13;
		k = (i + dir_start); if(k &gt;= sl) k-=sl;&#13;
		if(chkd[k]) continue;&#13;
		buf_chain = [];&#13;
		var seen = [];&#13;
		for(j=k; j&gt;=0;) {&#13;
			seen[j] = true;&#13;
			chkd[j] = true;&#13;
			buf[buf.length] = j;&#13;
			buf_chain.push(sectors[j]);&#13;
			var addr = fat_addrs[Math.floor(j*4/ssz)];&#13;
			jj = ((j*4) &amp; modulus);&#13;
			if(ssz &lt; 4 + jj) throw new Error("FAT boundary crossed: " + j + " 4 "+ssz);&#13;
			if(!sectors[addr]) break;&#13;
			j = __readInt32LE(sectors[addr], jj);&#13;
			if(seen[j]) break;&#13;
		}&#13;
		sector_list[k] = ({nodes: buf, data:__toBuffer([buf_chain])});&#13;
	}&#13;
	return sector_list;&#13;
}&#13;
&#13;
/* [MS-CFB] 2.6.1 Compound File Directory Entry */&#13;
function read_directory(dir_start, sector_list, sectors, Paths, nmfs, files, FileIndex, mini) {&#13;
	var minifat_store = 0, pl = (Paths.length?2:0);&#13;
	var sector = sector_list[dir_start].data;&#13;
	var i = 0, namelen = 0, name;&#13;
	for(; i &lt; sector.length; i+= 128) {&#13;
		var blob = sector.slice(i, i+128);&#13;
		prep_blob(blob, 64);&#13;
		namelen = blob.read_shift(2);&#13;
		name = __utf16le(blob,0,namelen-pl);&#13;
		Paths.push(name);&#13;
		var o = ({&#13;
			name:  name,&#13;
			type:  blob.read_shift(1),&#13;
			color: blob.read_shift(1),&#13;
			L:     blob.read_shift(4, 'i'),&#13;
			R:     blob.read_shift(4, 'i'),&#13;
			C:     blob.read_shift(4, 'i'),&#13;
			clsid: blob.read_shift(16),&#13;
			state: blob.read_shift(4, 'i'),&#13;
			start: 0,&#13;
			size: 0&#13;
		});&#13;
		var ctime = blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2);&#13;
		if(ctime !== 0) o.ct = read_date(blob, blob.l-8);&#13;
		var mtime = blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2);&#13;
		if(mtime !== 0) o.mt = read_date(blob, blob.l-8);&#13;
		o.start = blob.read_shift(4, 'i');&#13;
		o.size = blob.read_shift(4, 'i');&#13;
		if(o.size &lt; 0 &amp;&amp; o.start &lt; 0) { o.size = o.type = 0; o.start = ENDOFCHAIN; o.name = ""; }&#13;
		if(o.type === 5) { /* root */&#13;
			minifat_store = o.start;&#13;
			if(nmfs &gt; 0 &amp;&amp; minifat_store !== ENDOFCHAIN) sector_list[minifat_store].name = "!StreamData";&#13;
			/*minifat_size = o.size;*/&#13;
		} else if(o.size &gt;= 4096 /* MSCSZ */) {&#13;
			o.storage = 'fat';&#13;
			if(sector_list[o.start] === undefined) sector_list[o.start] = get_sector_list(sectors, o.start, sector_list.fat_addrs, sector_list.ssz);&#13;
			sector_list[o.start].name = o.name;&#13;
			o.content = (sector_list[o.start].data.slice(0,o.size));&#13;
		} else {&#13;
			o.storage = 'minifat';&#13;
			if(o.size &lt; 0) o.size = 0;&#13;
			else if(minifat_store !== ENDOFCHAIN &amp;&amp; o.start !== ENDOFCHAIN &amp;&amp; sector_list[minifat_store]) {&#13;
				o.content = get_mfat_entry(o, sector_list[minifat_store].data, (sector_list[mini]||{}).data);&#13;
			}&#13;
		}&#13;
		if(o.content) prep_blob(o.content, 0);&#13;
		files[name] = o;&#13;
		FileIndex.push(o);&#13;
	}&#13;
}&#13;
&#13;
function read_date(blob, offset) {&#13;
	return new Date(( ( (__readUInt32LE(blob,offset+4)/1e7)*Math.pow(2,32)+__readUInt32LE(blob,offset)/1e7 ) - 11644473600)*1000);&#13;
}&#13;
&#13;
function read_file(filename, options) {&#13;
	get_fs();&#13;
	return parse(fs.readFileSync(filename), options);&#13;
}&#13;
&#13;
function read(blob, options) {&#13;
	var type = options &amp;&amp; options.type;&#13;
	if(!type) {&#13;
		if(has_buf &amp;&amp; Buffer.isBuffer(blob)) type = "buffer";&#13;
	}&#13;
	switch(type || "base64") {&#13;
		case "file": return read_file(blob, options);&#13;
		case "base64": return parse(s2a(Base64_decode(blob)), options);&#13;
		case "binary": return parse(s2a(blob), options);&#13;
	}&#13;
	return parse(blob, options);&#13;
}&#13;
&#13;
function init_cfb(cfb, opts) {&#13;
	var o = opts || {}, root = o.root || "Root Entry";&#13;
	if(!cfb.FullPaths) cfb.FullPaths = [];&#13;
	if(!cfb.FileIndex) cfb.FileIndex = [];&#13;
	if(cfb.FullPaths.length !== cfb.FileIndex.length) throw new Error("inconsistent CFB structure");&#13;
	if(cfb.FullPaths.length === 0) {&#13;
		cfb.FullPaths[0] = root + "/";&#13;
		cfb.FileIndex[0] = ({ name: root, type: 5 });&#13;
	}&#13;
	if(o.CLSID) cfb.FileIndex[0].clsid = o.CLSID;&#13;
	seed_cfb(cfb);&#13;
}&#13;
function seed_cfb(cfb) {&#13;
	var nm = "\u0001Sh33tJ5";&#13;
	if(CFB.find(cfb, "/" + nm)) return;&#13;
	var p = new_buf(4); p[0] = 55; p[1] = p[3] = 50; p[2] = 54;&#13;
	cfb.FileIndex.push(({ name: nm, type: 2, content:p, size:4, L:69, R:69, C:69 }));&#13;
	cfb.FullPaths.push(cfb.FullPaths[0] + nm);&#13;
	rebuild_cfb(cfb);&#13;
}&#13;
function rebuild_cfb(cfb, f) {&#13;
	init_cfb(cfb);&#13;
	var gc = false, s = false;&#13;
	for(var i = cfb.FullPaths.length - 1; i &gt;= 0; --i) {&#13;
		var _file = cfb.FileIndex[i];&#13;
		switch(_file.type) {&#13;
			case 0:&#13;
				if(s) gc = true;&#13;
				else { cfb.FileIndex.pop(); cfb.FullPaths.pop(); }&#13;
				break;&#13;
			case 1: case 2: case 5:&#13;
				s = true;&#13;
				if(isNaN(_file.R * _file.L * _file.C)) gc = true;&#13;
				if(_file.R &gt; -1 &amp;&amp; _file.L &gt; -1 &amp;&amp; _file.R == _file.L) gc = true;&#13;
				break;&#13;
			default: gc = true; break;&#13;
		}&#13;
	}&#13;
	if(!gc &amp;&amp; !f) return;&#13;
&#13;
	var now = new Date(1987, 1, 19), j = 0;&#13;
	// Track which names exist&#13;
	var fullPaths = Object.create ? Object.create(null) : {};&#13;
	var data = [];&#13;
	for(i = 0; i &lt; cfb.FullPaths.length; ++i) {&#13;
		fullPaths[cfb.FullPaths[i]] = true;&#13;
		if(cfb.FileIndex[i].type === 0) continue;&#13;
		data.push([cfb.FullPaths[i], cfb.FileIndex[i]]);&#13;
	}&#13;
	for(i = 0; i &lt; data.length; ++i) {&#13;
		var dad = dirname(data[i][0]);&#13;
		s = fullPaths[dad];&#13;
		while(!s) {&#13;
			while(dirname(dad) &amp;&amp; !fullPaths[dirname(dad)]) dad = dirname(dad);&#13;
&#13;
			data.push([dad, ({&#13;
				name: filename(dad).replace("/",""),&#13;
				type: 1,&#13;
				clsid: HEADER_CLSID,&#13;
				ct: now, mt: now,&#13;
				content: null&#13;
			})]);&#13;
&#13;
			// Add name to set&#13;
			fullPaths[dad] = true;&#13;
&#13;
			dad = dirname(data[i][0]);&#13;
			s = fullPaths[dad];&#13;
		}&#13;
	}&#13;
&#13;
	data.sort(function(x,y) { return namecmp(x[0], y[0]); });&#13;
	cfb.FullPaths = []; cfb.FileIndex = [];&#13;
	for(i = 0; i &lt; data.length; ++i) { cfb.FullPaths[i] = data[i][0]; cfb.FileIndex[i] = data[i][1]; }&#13;
	for(i = 0; i &lt; data.length; ++i) {&#13;
		var elt = cfb.FileIndex[i];&#13;
		var nm = cfb.FullPaths[i];&#13;
&#13;
		elt.name =  filename(nm).replace("/","");&#13;
		elt.L = elt.R = elt.C = -(elt.color = 1);&#13;
		elt.size = elt.content ? elt.content.length : 0;&#13;
		elt.start = 0;&#13;
		elt.clsid = (elt.clsid || HEADER_CLSID);&#13;
		if(i === 0) {&#13;
			elt.C = data.length &gt; 1 ? 1 : -1;&#13;
			elt.size = 0;&#13;
			elt.type = 5;&#13;
		} else if(nm.slice(-1) == "/") {&#13;
			for(j=i+1;j &lt; data.length; ++j) if(dirname(cfb.FullPaths[j])==nm) break;&#13;
			elt.C = j &gt;= data.length ? -1 : j;&#13;
			for(j=i+1;j &lt; data.length; ++j) if(dirname(cfb.FullPaths[j])==dirname(nm)) break;&#13;
			elt.R = j &gt;= data.length ? -1 : j;&#13;
			elt.type = 1;&#13;
		} else {&#13;
			if(dirname(cfb.FullPaths[i+1]||"") == dirname(nm)) elt.R = i + 1;&#13;
			elt.type = 2;&#13;
		}&#13;
	}&#13;
&#13;
}&#13;
&#13;
function _write(cfb, options) {&#13;
	var _opts = options || {};&#13;
	/* MAD is order-sensitive, skip rebuild and sort */&#13;
	if(_opts.fileType == 'mad') return write_mad(cfb, _opts);&#13;
	rebuild_cfb(cfb);&#13;
	switch(_opts.fileType) {&#13;
		case 'zip': return write_zip(cfb, _opts);&#13;
		//case 'mad': return write_mad(cfb, _opts);&#13;
	}&#13;
	var L = (function(cfb){&#13;
		var mini_size = 0, fat_size = 0;&#13;
		for(var i = 0; i &lt; cfb.FileIndex.length; ++i) {&#13;
			var file = cfb.FileIndex[i];&#13;
			if(!file.content) continue;&#13;
			var flen = file.content.length;&#13;
			if(flen &gt; 0){&#13;
				if(flen &lt; 0x1000) mini_size += (flen + 0x3F) &gt;&gt; 6;&#13;
				else fat_size += (flen + 0x01FF) &gt;&gt; 9;&#13;
			}&#13;
		}&#13;
		var dir_cnt = (cfb.FullPaths.length +3) &gt;&gt; 2;&#13;
		var mini_cnt = (mini_size + 7) &gt;&gt; 3;&#13;
		var mfat_cnt = (mini_size + 0x7F) &gt;&gt; 7;&#13;
		var fat_base = mini_cnt + fat_size + dir_cnt + mfat_cnt;&#13;
		var fat_cnt = (fat_base + 0x7F) &gt;&gt; 7;&#13;
		var difat_cnt = fat_cnt &lt;= 109 ? 0 : Math.ceil((fat_cnt-109)/0x7F);&#13;
		while(((fat_base + fat_cnt + difat_cnt + 0x7F) &gt;&gt; 7) &gt; fat_cnt) difat_cnt = ++fat_cnt &lt;= 109 ? 0 : Math.ceil((fat_cnt-109)/0x7F);&#13;
		var L =  [1, difat_cnt, fat_cnt, mfat_cnt, dir_cnt, fat_size, mini_size, 0];&#13;
		cfb.FileIndex[0].size = mini_size &lt;&lt; 6;&#13;
		L[7] = (cfb.FileIndex[0].start=L[0]+L[1]+L[2]+L[3]+L[4]+L[5])+((L[6]+7) &gt;&gt; 3);&#13;
		return L;&#13;
	})(cfb);&#13;
	var o = new_buf(L[7] &lt;&lt; 9);&#13;
	var i = 0, T = 0;&#13;
	{&#13;
		for(i = 0; i &lt; 8; ++i) o.write_shift(1, HEADER_SIG[i]);&#13;
		for(i = 0; i &lt; 8; ++i) o.write_shift(2, 0);&#13;
		o.write_shift(2, 0x003E);&#13;
		o.write_shift(2, 0x0003);&#13;
		o.write_shift(2, 0xFFFE);&#13;
		o.write_shift(2, 0x0009);&#13;
		o.write_shift(2, 0x0006);&#13;
		for(i = 0; i &lt; 3; ++i) o.write_shift(2, 0);&#13;
		o.write_shift(4, 0);&#13;
		o.write_shift(4, L[2]);&#13;
		o.write_shift(4, L[0] + L[1] + L[2] + L[3] - 1);&#13;
		o.write_shift(4, 0);&#13;
		o.write_shift(4, 1&lt;&lt;12);&#13;
		o.write_shift(4, L[3] ? L[0] + L[1] + L[2] - 1: ENDOFCHAIN);&#13;
		o.write_shift(4, L[3]);&#13;
		o.write_shift(-4, L[1] ? L[0] - 1: ENDOFCHAIN);&#13;
		o.write_shift(4, L[1]);&#13;
		for(i = 0; i &lt; 109; ++i) o.write_shift(-4, i &lt; L[2] ? L[1] + i : -1);&#13;
	}&#13;
	if(L[1]) {&#13;
		for(T = 0; T &lt; L[1]; ++T) {&#13;
			for(; i &lt; 236 + T * 127; ++i) o.write_shift(-4, i &lt; L[2] ? L[1] + i : -1);&#13;
			o.write_shift(-4, T === L[1] - 1 ? ENDOFCHAIN : T + 1);&#13;
		}&#13;
	}&#13;
	var chainit = function(w) {&#13;
		for(T += w; i&lt;T-1; ++i) o.write_shift(-4, i+1);&#13;
		if(w) { ++i; o.write_shift(-4, ENDOFCHAIN); }&#13;
	};&#13;
	T = i = 0;&#13;
	for(T+=L[1]; i&lt;T; ++i) o.write_shift(-4, consts.DIFSECT);&#13;
	for(T+=L[2]; i&lt;T; ++i) o.write_shift(-4, consts.FATSECT);&#13;
	chainit(L[3]);&#13;
	chainit(L[4]);&#13;
	var j = 0, flen = 0;&#13;
	var file = cfb.FileIndex[0];&#13;
	for(; j &lt; cfb.FileIndex.length; ++j) {&#13;
		file = cfb.FileIndex[j];&#13;
		if(!file.content) continue;&#13;
flen = file.content.length;&#13;
		if(flen &lt; 0x1000) continue;&#13;
		file.start = T;&#13;
		chainit((flen + 0x01FF) &gt;&gt; 9);&#13;
	}&#13;
	chainit((L[6] + 7) &gt;&gt; 3);&#13;
	while(o.l &amp; 0x1FF) o.write_shift(-4, consts.ENDOFCHAIN);&#13;
	T = i = 0;&#13;
	for(j = 0; j &lt; cfb.FileIndex.length; ++j) {&#13;
		file = cfb.FileIndex[j];&#13;
		if(!file.content) continue;&#13;
flen = file.content.length;&#13;
		if(!flen || flen &gt;= 0x1000) continue;&#13;
		file.start = T;&#13;
		chainit((flen + 0x3F) &gt;&gt; 6);&#13;
	}&#13;
	while(o.l &amp; 0x1FF) o.write_shift(-4, consts.ENDOFCHAIN);&#13;
	for(i = 0; i &lt; L[4]&lt;&lt;2; ++i) {&#13;
		var nm = cfb.FullPaths[i];&#13;
		if(!nm || nm.length === 0) {&#13;
			for(j = 0; j &lt; 17; ++j) o.write_shift(4, 0);&#13;
			for(j = 0; j &lt; 3; ++j) o.write_shift(4, -1);&#13;
			for(j = 0; j &lt; 12; ++j) o.write_shift(4, 0);&#13;
			continue;&#13;
		}&#13;
		file = cfb.FileIndex[i];&#13;
		if(i === 0) file.start = file.size ? file.start - 1 : ENDOFCHAIN;&#13;
		var _nm = (i === 0 &amp;&amp; _opts.root) || file.name;&#13;
		if(_nm.length &gt; 32) {&#13;
			console.error("Name " + _nm + " will be truncated to " + _nm.slice(0,32));&#13;
			_nm = _nm.slice(0, 32);&#13;
		}&#13;
		flen = 2*(_nm.length+1);&#13;
		o.write_shift(64, _nm, "utf16le");&#13;
		o.write_shift(2, flen);&#13;
		o.write_shift(1, file.type);&#13;
		o.write_shift(1, file.color);&#13;
		o.write_shift(-4, file.L);&#13;
		o.write_shift(-4, file.R);&#13;
		o.write_shift(-4, file.C);&#13;
		if(!file.clsid) for(j = 0; j &lt; 4; ++j) o.write_shift(4, 0);&#13;
		else o.write_shift(16, file.clsid, "hex");&#13;
		o.write_shift(4, file.state || 0);&#13;
		o.write_shift(4, 0); o.write_shift(4, 0);&#13;
		o.write_shift(4, 0); o.write_shift(4, 0);&#13;
		o.write_shift(4, file.start);&#13;
		o.write_shift(4, file.size); o.write_shift(4, 0);&#13;
	}&#13;
	for(i = 1; i &lt; cfb.FileIndex.length; ++i) {&#13;
		file = cfb.FileIndex[i];&#13;
if(file.size &gt;= 0x1000) {&#13;
			o.l = (file.start+1) &lt;&lt; 9;&#13;
			if (has_buf &amp;&amp; Buffer.isBuffer(file.content)) {&#13;
				file.content.copy(o, o.l, 0, file.size);&#13;
				// o is a 0-filled Buffer so just set next offset&#13;
				o.l += (file.size + 511) &amp; -512;&#13;
			} else {&#13;
				for(j = 0; j &lt; file.size; ++j) o.write_shift(1, file.content[j]);&#13;
				for(; j &amp; 0x1FF; ++j) o.write_shift(1, 0);&#13;
			}&#13;
		}&#13;
	}&#13;
	for(i = 1; i &lt; cfb.FileIndex.length; ++i) {&#13;
		file = cfb.FileIndex[i];&#13;
if(file.size &gt; 0 &amp;&amp; file.size &lt; 0x1000) {&#13;
			if (has_buf &amp;&amp; Buffer.isBuffer(file.content)) {&#13;
				file.content.copy(o, o.l, 0, file.size);&#13;
				// o is a 0-filled Buffer so just set next offset&#13;
				o.l += (file.size + 63) &amp; -64;&#13;
			} else {&#13;
				for(j = 0; j &lt; file.size; ++j) o.write_shift(1, file.content[j]);&#13;
				for(; j &amp; 0x3F; ++j) o.write_shift(1, 0);&#13;
			}&#13;
		}&#13;
	}&#13;
	if (has_buf) {&#13;
		o.l = o.length;&#13;
	} else {&#13;
		// When using Buffer, already 0-filled&#13;
		while(o.l &lt; o.length) o.write_shift(1, 0);&#13;
	}&#13;
	return o;&#13;
}&#13;
/* [MS-CFB] 2.6.4 (Unicode 3.0.1 case conversion) */&#13;
function find(cfb, path) {&#13;
	var UCFullPaths = cfb.FullPaths.map(function(x) { return x.toUpperCase(); });&#13;
	var UCPaths = UCFullPaths.map(function(x) { var y = x.split("/"); return y[y.length - (x.slice(-1) == "/" ? 2 : 1)]; });&#13;
	var k = false;&#13;
	if(path.charCodeAt(0) === 47 /* "/" */) { k = true; path = UCFullPaths[0].slice(0, -1) + path; }&#13;
	else k = path.indexOf("/") !== -1;&#13;
	var UCPath = path.toUpperCase();&#13;
	var w = k === true ? UCFullPaths.indexOf(UCPath) : UCPaths.indexOf(UCPath);&#13;
	if(w !== -1) return cfb.FileIndex[w];&#13;
&#13;
	var m = !UCPath.match(chr1);&#13;
	UCPath = UCPath.replace(chr0,'');&#13;
	if(m) UCPath = UCPath.replace(chr1,'!');&#13;
	for(w = 0; w &lt; UCFullPaths.length; ++w) {&#13;
		if((m ? UCFullPaths[w].replace(chr1,'!') : UCFullPaths[w]).replace(chr0,'') == UCPath) return cfb.FileIndex[w];&#13;
		if((m ? UCPaths[w].replace(chr1,'!') : UCPaths[w]).replace(chr0,'') == UCPath) return cfb.FileIndex[w];&#13;
	}&#13;
	return null;&#13;
}&#13;
/** CFB Constants */&#13;
var MSSZ = 64; /* Mini Sector Size = 1&lt;&lt;6 */&#13;
//var MSCSZ = 4096; /* Mini Stream Cutoff Size */&#13;
/* 2.1 Compound File Sector Numbers and Types */&#13;
var ENDOFCHAIN = -2;&#13;
/* 2.2 Compound File Header */&#13;
var HEADER_SIGNATURE = 'd0cf11e0a1b11ae1';&#13;
var HEADER_SIG = [0xD0, 0xCF, 0x11, 0xE0, 0xA1, 0xB1, 0x1A, 0xE1];&#13;
var HEADER_CLSID = '00000000000000000000000000000000';&#13;
var consts = {&#13;
	/* 2.1 Compund File Sector Numbers and Types */&#13;
	MAXREGSECT: -6,&#13;
	DIFSECT: -4,&#13;
	FATSECT: -3,&#13;
	ENDOFCHAIN: ENDOFCHAIN,&#13;
	FREESECT: -1,&#13;
	/* 2.2 Compound File Header */&#13;
	HEADER_SIGNATURE: HEADER_SIGNATURE,&#13;
	HEADER_MINOR_VERSION: '3e00',&#13;
	MAXREGSID: -6,&#13;
	NOSTREAM: -1,&#13;
	HEADER_CLSID: HEADER_CLSID,&#13;
	/* 2.6.1 Compound File Directory Entry */&#13;
	EntryTypes: ['unknown','storage','stream','lockbytes','property','root']&#13;
};&#13;
&#13;
function write_file(cfb, filename, options) {&#13;
	get_fs();&#13;
	var o = _write(cfb, options);&#13;
fs.writeFileSync(filename, o);&#13;
}&#13;
&#13;
function a2s(o) {&#13;
	var out = new Array(o.length);&#13;
	for(var i = 0; i &lt; o.length; ++i) out[i] = String.fromCharCode(o[i]);&#13;
	return out.join("");&#13;
}&#13;
&#13;
function write(cfb, options) {&#13;
	var o = _write(cfb, options);&#13;
	switch(options &amp;&amp; options.type || "buffer") {&#13;
		case "file": get_fs(); fs.writeFileSync(options.filename, (o)); return o;&#13;
		case "binary": return typeof o == "string" ? o : a2s(o);&#13;
		case "base64": return Base64_encode(typeof o == "string" ? o : a2s(o));&#13;
		case "buffer": if(has_buf) return Buffer.isBuffer(o) ? o : Buffer_from(o);&#13;
			/* falls through */&#13;
		case "array": return typeof o == "string" ? s2a(o) : o;&#13;
	}&#13;
	return o;&#13;
}&#13;
/* node &lt; 8.1 zlib does not expose bytesRead, so default to pure JS */&#13;
var _zlib;&#13;
function use_zlib(zlib) { try {&#13;
	var InflateRaw = zlib.InflateRaw;&#13;
	var InflRaw = new InflateRaw();&#13;
	InflRaw._processChunk(new Uint8Array([3, 0]), InflRaw._finishFlushFlag);&#13;
	if(InflRaw.bytesRead) _zlib = zlib;&#13;
	else throw new Error("zlib does not expose bytesRead");&#13;
} catch(e) {console.error("cannot use native zlib: " + (e.message || e)); } }&#13;
&#13;
function _inflateRawSync(payload, usz) {&#13;
	if(!_zlib) return _inflate(payload, usz);&#13;
	var InflateRaw = _zlib.InflateRaw;&#13;
	var InflRaw = new InflateRaw();&#13;
	var out = InflRaw._processChunk(payload.slice(payload.l), InflRaw._finishFlushFlag);&#13;
	payload.l += InflRaw.bytesRead;&#13;
	return out;&#13;
}&#13;
&#13;
function _deflateRawSync(payload) {&#13;
	return _zlib ? _zlib.deflateRawSync(payload) : _deflate(payload);&#13;
}&#13;
var CLEN_ORDER = [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];&#13;
&#13;
/*  LEN_ID = [ 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285 ]; */&#13;
var LEN_LN = [   3,   4,   5,   6,   7,   8,   9,  10,  11,  13 , 15,  17,  19,  23,  27,  31,  35,  43,  51,  59,  67,  83,  99, 115, 131, 163, 195, 227, 258 ];&#13;
&#13;
/*  DST_ID = [  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13,  14,  15,  16,  17,  18,  19,   20,   21,   22,   23,   24,   25,   26,    27,    28,    29 ]; */&#13;
var DST_LN = [  1,  2,  3,  4,  5,  7,  9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577 ];&#13;
&#13;
function bit_swap_8(n) { var t = (((((n&lt;&lt;1)|(n&lt;&lt;11)) &amp; 0x22110) | (((n&lt;&lt;5)|(n&lt;&lt;15)) &amp; 0x88440))); return ((t&gt;&gt;16) | (t&gt;&gt;8) |t)&amp;0xFF; }&#13;
&#13;
var use_typed_arrays = typeof Uint8Array !== 'undefined';&#13;
&#13;
var bitswap8 = use_typed_arrays ? new Uint8Array(1&lt;&lt;8) : [];&#13;
for(var q = 0; q &lt; (1&lt;&lt;8); ++q) bitswap8[q] = bit_swap_8(q);&#13;
&#13;
function bit_swap_n(n, b) {&#13;
	var rev = bitswap8[n &amp; 0xFF];&#13;
	if(b &lt;= 8) return rev &gt;&gt;&gt; (8-b);&#13;
	rev = (rev &lt;&lt; 8) | bitswap8[(n&gt;&gt;8)&amp;0xFF];&#13;
	if(b &lt;= 16) return rev &gt;&gt;&gt; (16-b);&#13;
	rev = (rev &lt;&lt; 8) | bitswap8[(n&gt;&gt;16)&amp;0xFF];&#13;
	return rev &gt;&gt;&gt; (24-b);&#13;
}&#13;
&#13;
/* helpers for unaligned bit reads */&#13;
function read_bits_2(buf, bl) { var w = (bl&amp;7), h = (bl&gt;&gt;&gt;3); return ((buf[h]|(w &lt;= 6 ? 0 : buf[h+1]&lt;&lt;8))&gt;&gt;&gt;w)&amp; 0x03; }&#13;
function read_bits_3(buf, bl) { var w = (bl&amp;7), h = (bl&gt;&gt;&gt;3); return ((buf[h]|(w &lt;= 5 ? 0 : buf[h+1]&lt;&lt;8))&gt;&gt;&gt;w)&amp; 0x07; }&#13;
function read_bits_4(buf, bl) { var w = (bl&amp;7), h = (bl&gt;&gt;&gt;3); return ((buf[h]|(w &lt;= 4 ? 0 : buf[h+1]&lt;&lt;8))&gt;&gt;&gt;w)&amp; 0x0F; }&#13;
function read_bits_5(buf, bl) { var w = (bl&amp;7), h = (bl&gt;&gt;&gt;3); return ((buf[h]|(w &lt;= 3 ? 0 : buf[h+1]&lt;&lt;8))&gt;&gt;&gt;w)&amp; 0x1F; }&#13;
function read_bits_7(buf, bl) { var w = (bl&amp;7), h = (bl&gt;&gt;&gt;3); return ((buf[h]|(w &lt;= 1 ? 0 : buf[h+1]&lt;&lt;8))&gt;&gt;&gt;w)&amp; 0x7F; }&#13;
&#13;
/* works up to n = 3 * 8 + 1 = 25 */&#13;
function read_bits_n(buf, bl, n) {&#13;
	var w = (bl&amp;7), h = (bl&gt;&gt;&gt;3), f = ((1&lt;&lt;n)-1);&#13;
	var v = buf[h] &gt;&gt;&gt; w;&#13;
	if(n &lt; 8 - w) return v &amp; f;&#13;
	v |= buf[h+1]&lt;&lt;(8-w);&#13;
	if(n &lt; 16 - w) return v &amp; f;&#13;
	v |= buf[h+2]&lt;&lt;(16-w);&#13;
	if(n &lt; 24 - w) return v &amp; f;&#13;
	v |= buf[h+3]&lt;&lt;(24-w);&#13;
	return v &amp; f;&#13;
}&#13;
&#13;
/* helpers for unaligned bit writes */&#13;
function write_bits_3(buf, bl, v) { var w = bl &amp; 7, h = bl &gt;&gt;&gt; 3;&#13;
	if(w &lt;= 5) buf[h] |= (v &amp; 7) &lt;&lt; w;&#13;
	else {&#13;
		buf[h] |= (v &lt;&lt; w) &amp; 0xFF;&#13;
		buf[h+1] = (v&amp;7) &gt;&gt; (8-w);&#13;
	}&#13;
	return bl + 3;&#13;
}&#13;
&#13;
function write_bits_1(buf, bl, v) {&#13;
	var w = bl &amp; 7, h = bl &gt;&gt;&gt; 3;&#13;
	v = (v&amp;1) &lt;&lt; w;&#13;
	buf[h] |= v;&#13;
	return bl + 1;&#13;
}&#13;
function write_bits_8(buf, bl, v) {&#13;
	var w = bl &amp; 7, h = bl &gt;&gt;&gt; 3;&#13;
	v &lt;&lt;= w;&#13;
	buf[h] |=  v &amp; 0xFF; v &gt;&gt;&gt;= 8;&#13;
	buf[h+1] = v;&#13;
	return bl + 8;&#13;
}&#13;
function write_bits_16(buf, bl, v) {&#13;
	var w = bl &amp; 7, h = bl &gt;&gt;&gt; 3;&#13;
	v &lt;&lt;= w;&#13;
	buf[h] |=  v &amp; 0xFF; v &gt;&gt;&gt;= 8;&#13;
	buf[h+1] = v &amp; 0xFF;&#13;
	buf[h+2] = v &gt;&gt;&gt; 8;&#13;
	return bl + 16;&#13;
}&#13;
&#13;
/* until ArrayBuffer#realloc is a thing, fake a realloc */&#13;
function realloc(b, sz) {&#13;
	var L = b.length, M = 2*L &gt; sz ? 2*L : sz + 5, i = 0;&#13;
	if(L &gt;= sz) return b;&#13;
	if(has_buf) {&#13;
		var o = new_unsafe_buf(M);&#13;
		// $FlowIgnore&#13;
		if(b.copy) b.copy(o);&#13;
		else for(; i &lt; b.length; ++i) o[i] = b[i];&#13;
		return o;&#13;
	} else if(use_typed_arrays) {&#13;
		var a = new Uint8Array(M);&#13;
		if(a.set) a.set(b);&#13;
		else for(; i &lt; L; ++i) a[i] = b[i];&#13;
		return a;&#13;
	}&#13;
	b.length = M;&#13;
	return b;&#13;
}&#13;
&#13;
/* zero-filled arrays for older browsers */&#13;
function zero_fill_array(n) {&#13;
	var o = new Array(n);&#13;
	for(var i = 0; i &lt; n; ++i) o[i] = 0;&#13;
	return o;&#13;
}&#13;
&#13;
/* build tree (used for literals and lengths) */&#13;
function build_tree(clens, cmap, MAX) {&#13;
	var maxlen = 1, w = 0, i = 0, j = 0, ccode = 0, L = clens.length;&#13;
&#13;
	var bl_count  = use_typed_arrays ? new Uint16Array(32) : zero_fill_array(32);&#13;
	for(i = 0; i &lt; 32; ++i) bl_count[i] = 0;&#13;
&#13;
	for(i = L; i &lt; MAX; ++i) clens[i] = 0;&#13;
	L = clens.length;&#13;
&#13;
	var ctree = use_typed_arrays ? new Uint16Array(L) : zero_fill_array(L); // []&#13;
&#13;
	/* build code tree */&#13;
	for(i = 0; i &lt; L; ++i) {&#13;
		bl_count[(w = clens[i])]++;&#13;
		if(maxlen &lt; w) maxlen = w;&#13;
		ctree[i] = 0;&#13;
	}&#13;
	bl_count[0] = 0;&#13;
	for(i = 1; i &lt;= maxlen; ++i) bl_count[i+16] = (ccode = (ccode + bl_count[i-1])&lt;&lt;1);&#13;
	for(i = 0; i &lt; L; ++i) {&#13;
		ccode = clens[i];&#13;
		if(ccode != 0) ctree[i] = bl_count[ccode+16]++;&#13;
	}&#13;
&#13;
	/* cmap[maxlen + 4 bits] = (off&amp;15) + (lit&lt;&lt;4) reverse mapping */&#13;
	var cleni = 0;&#13;
	for(i = 0; i &lt; L; ++i) {&#13;
		cleni = clens[i];&#13;
		if(cleni != 0) {&#13;
			ccode = bit_swap_n(ctree[i], maxlen)&gt;&gt;(maxlen-cleni);&#13;
			for(j = (1&lt;&lt;(maxlen + 4 - cleni)) - 1; j&gt;=0; --j)&#13;
				cmap[ccode|(j&lt;&lt;cleni)] = (cleni&amp;15) | (i&lt;&lt;4);&#13;
		}&#13;
	}&#13;
	return maxlen;&#13;
}&#13;
&#13;
/* Fixed Huffman */&#13;
var fix_lmap = use_typed_arrays ? new Uint16Array(512) : zero_fill_array(512);&#13;
var fix_dmap = use_typed_arrays ? new Uint16Array(32)  : zero_fill_array(32);&#13;
if(!use_typed_arrays) {&#13;
	for(var i = 0; i &lt; 512; ++i) fix_lmap[i] = 0;&#13;
	for(i = 0; i &lt; 32; ++i) fix_dmap[i] = 0;&#13;
}&#13;
(function() {&#13;
	var dlens = [];&#13;
	var i = 0;&#13;
	for(;i&lt;32; i++) dlens.push(5);&#13;
	build_tree(dlens, fix_dmap, 32);&#13;
&#13;
	var clens = [];&#13;
	i = 0;&#13;
	for(; i&lt;=143; i++) clens.push(8);&#13;
	for(; i&lt;=255; i++) clens.push(9);&#13;
	for(; i&lt;=279; i++) clens.push(7);&#13;
	for(; i&lt;=287; i++) clens.push(8);&#13;
	build_tree(clens, fix_lmap, 288);&#13;
})();var _deflateRaw = (function _deflateRawIIFE() {&#13;
	var DST_LN_RE = use_typed_arrays ? new Uint8Array(0x8000) : [];&#13;
	var j = 0, k = 0;&#13;
	for(; j &lt; DST_LN.length - 1; ++j) {&#13;
		for(; k &lt; DST_LN[j+1]; ++k) DST_LN_RE[k] = j;&#13;
	}&#13;
	for(;k &lt; 32768; ++k) DST_LN_RE[k] = 29;&#13;
&#13;
	var LEN_LN_RE = use_typed_arrays ? new Uint8Array(0x103) : [];&#13;
	for(j = 0, k = 0; j &lt; LEN_LN.length - 1; ++j) {&#13;
		for(; k &lt; LEN_LN[j+1]; ++k) LEN_LN_RE[k] = j;&#13;
	}&#13;
&#13;
	function write_stored(data, out) {&#13;
		var boff = 0;&#13;
		while(boff &lt; data.length) {&#13;
			var L = Math.min(0xFFFF, data.length - boff);&#13;
			var h = boff + L == data.length;&#13;
			out.write_shift(1, +h);&#13;
			out.write_shift(2, L);&#13;
			out.write_shift(2, (~L) &amp; 0xFFFF);&#13;
			while(L-- &gt; 0) out[out.l++] = data[boff++];&#13;
		}&#13;
		return out.l;&#13;
	}&#13;
&#13;
	/* Fixed Huffman */&#13;
	function write_huff_fixed(data, out) {&#13;
		var bl = 0;&#13;
		var boff = 0;&#13;
		var addrs = use_typed_arrays ? new Uint16Array(0x8000) : [];&#13;
		while(boff &lt; data.length) {&#13;
			var L = /* data.length - boff; */ Math.min(0xFFFF, data.length - boff);&#13;
&#13;
			/* write a stored block for short data */&#13;
			if(L &lt; 10) {&#13;
				bl = write_bits_3(out, bl, +!!(boff + L == data.length)); // jshint ignore:line&#13;
				if(bl &amp; 7) bl += 8 - (bl &amp; 7);&#13;
				out.l = (bl / 8) | 0;&#13;
				out.write_shift(2, L);&#13;
				out.write_shift(2, (~L) &amp; 0xFFFF);&#13;
				while(L-- &gt; 0) out[out.l++] = data[boff++];&#13;
				bl = out.l * 8;&#13;
				continue;&#13;
			}&#13;
&#13;
			bl = write_bits_3(out, bl, +!!(boff + L == data.length) + 2); // jshint ignore:line&#13;
			var hash = 0;&#13;
			while(L-- &gt; 0) {&#13;
				var d = data[boff];&#13;
				hash = ((hash &lt;&lt; 5) ^ d) &amp; 0x7FFF;&#13;
&#13;
				var match = -1, mlen = 0;&#13;
&#13;
				if((match = addrs[hash])) {&#13;
					match |= boff &amp; ~0x7FFF;&#13;
					if(match &gt; boff) match -= 0x8000;&#13;
					if(match &lt; boff) while(data[match + mlen] == data[boff + mlen] &amp;&amp; mlen &lt; 250) ++mlen;&#13;
				}&#13;
&#13;
				if(mlen &gt; 2) {&#13;
					/* Copy Token  */&#13;
					d = LEN_LN_RE[mlen];&#13;
					if(d &lt;= 22) bl = write_bits_8(out, bl, bitswap8[d+1]&gt;&gt;1) - 1;&#13;
					else {&#13;
						write_bits_8(out, bl, 3);&#13;
						bl += 5;&#13;
						write_bits_8(out, bl, bitswap8[d-23]&gt;&gt;5);&#13;
						bl += 3;&#13;
					}&#13;
					var len_eb = (d &lt; 8) ? 0 : ((d - 4)&gt;&gt;2);&#13;
					if(len_eb &gt; 0) {&#13;
						write_bits_16(out, bl, mlen - LEN_LN[d]);&#13;
						bl += len_eb;&#13;
					}&#13;
&#13;
					d = DST_LN_RE[boff - match];&#13;
					bl = write_bits_8(out, bl, bitswap8[d]&gt;&gt;3);&#13;
					bl -= 3;&#13;
&#13;
					var dst_eb = d &lt; 4 ? 0 : (d-2)&gt;&gt;1;&#13;
					if(dst_eb &gt; 0) {&#13;
						write_bits_16(out, bl, boff - match - DST_LN[d]);&#13;
						bl += dst_eb;&#13;
					}&#13;
					for(var q = 0; q &lt; mlen; ++q) {&#13;
						addrs[hash] = boff &amp; 0x7FFF;&#13;
						hash = ((hash &lt;&lt; 5) ^ data[boff]) &amp; 0x7FFF;&#13;
						++boff;&#13;
					}&#13;
					L-= mlen - 1;&#13;
				} else {&#13;
					/* Literal Token */&#13;
					if(d &lt;= 143) d = d + 48;&#13;
					else bl = write_bits_1(out, bl, 1);&#13;
					bl = write_bits_8(out, bl, bitswap8[d]);&#13;
					addrs[hash] = boff &amp; 0x7FFF;&#13;
					++boff;&#13;
				}&#13;
			}&#13;
&#13;
			bl = write_bits_8(out, bl, 0) - 1;&#13;
		}&#13;
		out.l = ((bl + 7)/8)|0;&#13;
		return out.l;&#13;
	}&#13;
	return function _deflateRaw(data, out) {&#13;
		if(data.length &lt; 8) return write_stored(data, out);&#13;
		return write_huff_fixed(data, out);&#13;
	};&#13;
})();&#13;
&#13;
function _deflate(data) {&#13;
	var buf = new_buf(50+Math.floor(data.length*1.1));&#13;
	var off = _deflateRaw(data, buf);&#13;
	return buf.slice(0, off);&#13;
}&#13;
/* modified inflate function also moves original read head */&#13;
&#13;
var dyn_lmap = use_typed_arrays ? new Uint16Array(32768) : zero_fill_array(32768);&#13;
var dyn_dmap = use_typed_arrays ? new Uint16Array(32768) : zero_fill_array(32768);&#13;
var dyn_cmap = use_typed_arrays ? new Uint16Array(128)   : zero_fill_array(128);&#13;
var dyn_len_1 = 1, dyn_len_2 = 1;&#13;
&#13;
/* 5.5.3 Expanding Huffman Codes */&#13;
function dyn(data, boff) {&#13;
	/* nomenclature from RFC1951 refers to bit values; these are offset by the implicit constant */&#13;
	var _HLIT = read_bits_5(data, boff) + 257; boff += 5;&#13;
	var _HDIST = read_bits_5(data, boff) + 1; boff += 5;&#13;
	var _HCLEN = read_bits_4(data, boff) + 4; boff += 4;&#13;
	var w = 0;&#13;
&#13;
	/* grab and store code lengths */&#13;
	var clens = use_typed_arrays ? new Uint8Array(19) : zero_fill_array(19);&#13;
	var ctree = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ];&#13;
	var maxlen = 1;&#13;
	var bl_count =  use_typed_arrays ? new Uint8Array(8) : zero_fill_array(8);&#13;
	var next_code = use_typed_arrays ? new Uint8Array(8) : zero_fill_array(8);&#13;
	var L = clens.length; /* 19 */&#13;
	for(var i = 0; i &lt; _HCLEN; ++i) {&#13;
		clens[CLEN_ORDER[i]] = w = read_bits_3(data, boff);&#13;
		if(maxlen &lt; w) maxlen = w;&#13;
		bl_count[w]++;&#13;
		boff += 3;&#13;
	}&#13;
&#13;
	/* build code tree */&#13;
	var ccode = 0;&#13;
	bl_count[0] = 0;&#13;
	for(i = 1; i &lt;= maxlen; ++i) next_code[i] = ccode = (ccode + bl_count[i-1])&lt;&lt;1;&#13;
	for(i = 0; i &lt; L; ++i) if((ccode = clens[i]) != 0) ctree[i] = next_code[ccode]++;&#13;
	/* cmap[7 bits from stream] = (off&amp;7) + (lit&lt;&lt;3) */&#13;
	var cleni = 0;&#13;
	for(i = 0; i &lt; L; ++i) {&#13;
		cleni = clens[i];&#13;
		if(cleni != 0) {&#13;
			ccode = bitswap8[ctree[i]]&gt;&gt;(8-cleni);&#13;
			for(var j = (1&lt;&lt;(7-cleni))-1; j&gt;=0; --j) dyn_cmap[ccode|(j&lt;&lt;cleni)] = (cleni&amp;7) | (i&lt;&lt;3);&#13;
		}&#13;
	}&#13;
&#13;
	/* read literal and dist codes at once */&#13;
	var hcodes = [];&#13;
	maxlen = 1;&#13;
	for(; hcodes.length &lt; _HLIT + _HDIST;) {&#13;
		ccode = dyn_cmap[read_bits_7(data, boff)];&#13;
		boff += ccode &amp; 7;&#13;
		switch((ccode &gt;&gt;&gt;= 3)) {&#13;
			case 16:&#13;
				w = 3 + read_bits_2(data, boff); boff += 2;&#13;
				ccode = hcodes[hcodes.length - 1];&#13;
				while(w-- &gt; 0) hcodes.push(ccode);&#13;
				break;&#13;
			case 17:&#13;
				w = 3 + read_bits_3(data, boff); boff += 3;&#13;
				while(w-- &gt; 0) hcodes.push(0);&#13;
				break;&#13;
			case 18:&#13;
				w = 11 + read_bits_7(data, boff); boff += 7;&#13;
				while(w -- &gt; 0) hcodes.push(0);&#13;
				break;&#13;
			default:&#13;
				hcodes.push(ccode);&#13;
				if(maxlen &lt; ccode) maxlen = ccode;&#13;
				break;&#13;
		}&#13;
	}&#13;
&#13;
	/* build literal / length trees */&#13;
	var h1 = hcodes.slice(0, _HLIT), h2 = hcodes.slice(_HLIT);&#13;
	for(i = _HLIT; i &lt; 286; ++i) h1[i] = 0;&#13;
	for(i = _HDIST; i &lt; 30; ++i) h2[i] = 0;&#13;
	dyn_len_1 = build_tree(h1, dyn_lmap, 286);&#13;
	dyn_len_2 = build_tree(h2, dyn_dmap, 30);&#13;
	return boff;&#13;
}&#13;
&#13;
/* return [ data, bytesRead ] */&#13;
function inflate(data, usz) {&#13;
	/* shortcircuit for empty buffer [0x03, 0x00] */&#13;
	if(data[0] == 3 &amp;&amp; !(data[1] &amp; 0x3)) { return [new_raw_buf(usz), 2]; }&#13;
&#13;
	/* bit offset */&#13;
	var boff = 0;&#13;
&#13;
	/* header includes final bit and type bits */&#13;
	var header = 0;&#13;
&#13;
	var outbuf = new_unsafe_buf(usz ? usz : (1&lt;&lt;18));&#13;
	var woff = 0;&#13;
	var OL = outbuf.length&gt;&gt;&gt;0;&#13;
	var max_len_1 = 0, max_len_2 = 0;&#13;
&#13;
	while((header&amp;1) == 0) {&#13;
		header = read_bits_3(data, boff); boff += 3;&#13;
		if((header &gt;&gt;&gt; 1) == 0) {&#13;
			/* Stored block */&#13;
			if(boff &amp; 7) boff += 8 - (boff&amp;7);&#13;
			/* 2 bytes sz, 2 bytes bit inverse */&#13;
			var sz = data[boff&gt;&gt;&gt;3] | data[(boff&gt;&gt;&gt;3)+1]&lt;&lt;8;&#13;
			boff += 32;&#13;
			/* push sz bytes */&#13;
			if(sz &gt; 0) {&#13;
				if(!usz &amp;&amp; OL &lt; woff + sz) { outbuf = realloc(outbuf, woff + sz); OL = outbuf.length; }&#13;
				while(sz-- &gt; 0) { outbuf[woff++] = data[boff&gt;&gt;&gt;3]; boff += 8; }&#13;
			}&#13;
			continue;&#13;
		} else if((header &gt;&gt; 1) == 1) {&#13;
			/* Fixed Huffman */&#13;
			max_len_1 = 9; max_len_2 = 5;&#13;
		} else {&#13;
			/* Dynamic Huffman */&#13;
			boff = dyn(data, boff);&#13;
			max_len_1 = dyn_len_1; max_len_2 = dyn_len_2;&#13;
		}&#13;
		for(;;) { // while(true) is apparently out of vogue in modern JS circles&#13;
			if(!usz &amp;&amp; (OL &lt; woff + 32767)) { outbuf = realloc(outbuf, woff + 32767); OL = outbuf.length; }&#13;
			/* ingest code and move read head */&#13;
			var bits = read_bits_n(data, boff, max_len_1);&#13;
			var code = (header&gt;&gt;&gt;1) == 1 ? fix_lmap[bits] : dyn_lmap[bits];&#13;
			boff += code &amp; 15; code &gt;&gt;&gt;= 4;&#13;
			/* 0-255 are literals, 256 is end of block token, 257+ are copy tokens */&#13;
			if(((code&gt;&gt;&gt;8)&amp;0xFF) === 0) outbuf[woff++] = code;&#13;
			else if(code == 256) break;&#13;
			else {&#13;
				code -= 257;&#13;
				var len_eb = (code &lt; 8) ? 0 : ((code-4)&gt;&gt;2); if(len_eb &gt; 5) len_eb = 0;&#13;
				var tgt = woff + LEN_LN[code];&#13;
				/* length extra bits */&#13;
				if(len_eb &gt; 0) {&#13;
					tgt += read_bits_n(data, boff, len_eb);&#13;
					boff += len_eb;&#13;
				}&#13;
&#13;
				/* dist code */&#13;
				bits = read_bits_n(data, boff, max_len_2);&#13;
				code = (header&gt;&gt;&gt;1) == 1 ? fix_dmap[bits] : dyn_dmap[bits];&#13;
				boff += code &amp; 15; code &gt;&gt;&gt;= 4;&#13;
				var dst_eb = (code &lt; 4 ? 0 : (code-2)&gt;&gt;1);&#13;
				var dst = DST_LN[code];&#13;
				/* dist extra bits */&#13;
				if(dst_eb &gt; 0) {&#13;
					dst += read_bits_n(data, boff, dst_eb);&#13;
					boff += dst_eb;&#13;
				}&#13;
&#13;
				/* in the common case, manual byte copy is faster than TA set / Buffer copy */&#13;
				if(!usz &amp;&amp; OL &lt; tgt) { outbuf = realloc(outbuf, tgt + 100); OL = outbuf.length; }&#13;
				while(woff &lt; tgt) { outbuf[woff] = outbuf[woff - dst]; ++woff; }&#13;
			}&#13;
		}&#13;
	}&#13;
	if(usz) return [outbuf, (boff+7)&gt;&gt;&gt;3];&#13;
	return [outbuf.slice(0, woff), (boff+7)&gt;&gt;&gt;3];&#13;
}&#13;
&#13;
function _inflate(payload, usz) {&#13;
	var data = payload.slice(payload.l||0);&#13;
	var out = inflate(data, usz);&#13;
	payload.l += out[1];&#13;
	return out[0];&#13;
}&#13;
&#13;
function warn_or_throw(wrn, msg) {&#13;
	if(wrn) { if(typeof console !== 'undefined') console.error(msg); }&#13;
	else throw new Error(msg);&#13;
}&#13;
&#13;
function parse_zip(file, options) {&#13;
	var blob = file;&#13;
	prep_blob(blob, 0);&#13;
&#13;
	var FileIndex = [], FullPaths = [];&#13;
	var o = {&#13;
		FileIndex: FileIndex,&#13;
		FullPaths: FullPaths&#13;
	};&#13;
	init_cfb(o, { root: options.root });&#13;
&#13;
	/* find end of central directory, start just after signature */&#13;
	var i = blob.length - 4;&#13;
	while((blob[i] != 0x50 || blob[i+1] != 0x4b || blob[i+2] != 0x05 || blob[i+3] != 0x06) &amp;&amp; i &gt;= 0) --i;&#13;
	blob.l = i + 4;&#13;
&#13;
	/* parse end of central directory */&#13;
	blob.l += 4;&#13;
	var fcnt = blob.read_shift(2);&#13;
	blob.l += 6;&#13;
	var start_cd = blob.read_shift(4);&#13;
&#13;
	/* parse central directory */&#13;
	blob.l = start_cd;&#13;
&#13;
	for(i = 0; i &lt; fcnt; ++i) {&#13;
		/* trust local file header instead of CD entry */&#13;
		blob.l += 20;&#13;
		var csz = blob.read_shift(4);&#13;
		var usz = blob.read_shift(4);&#13;
		var namelen = blob.read_shift(2);&#13;
		var efsz = blob.read_shift(2);&#13;
		var fcsz = blob.read_shift(2);&#13;
		blob.l += 8;&#13;
		var offset = blob.read_shift(4);&#13;
		var EF = parse_extra_field(blob.slice(blob.l+namelen, blob.l+namelen+efsz));&#13;
		blob.l += namelen + efsz + fcsz;&#13;
&#13;
		var L = blob.l;&#13;
		blob.l = offset + 4;&#13;
		/* ZIP64 lengths */&#13;
		if(EF &amp;&amp; EF[0x0001]) {&#13;
			if((EF[0x0001]||{}).usz) usz = EF[0x0001].usz;&#13;
			if((EF[0x0001]||{}).csz) csz = EF[0x0001].csz;&#13;
		}&#13;
		parse_local_file(blob, csz, usz, o, EF);&#13;
		blob.l = L;&#13;
	}&#13;
&#13;
	return o;&#13;
}&#13;
&#13;
&#13;
/* head starts just after local file header signature */&#13;
function parse_local_file(blob, csz, usz, o, EF) {&#13;
	/* [local file header] */&#13;
	blob.l += 2;&#13;
	var flags = blob.read_shift(2);&#13;
	var meth = blob.read_shift(2);&#13;
	var date = parse_dos_date(blob);&#13;
&#13;
	if(flags &amp; 0x2041) throw new Error("Unsupported ZIP encryption");&#13;
	var crc32 = blob.read_shift(4);&#13;
	var _csz = blob.read_shift(4);&#13;
	var _usz = blob.read_shift(4);&#13;
&#13;
	var namelen = blob.read_shift(2);&#13;
	var efsz = blob.read_shift(2);&#13;
&#13;
	// TODO: flags &amp; (1&lt;&lt;11) // UTF8&#13;
	var name = ""; for(var i = 0; i &lt; namelen; ++i) name += String.fromCharCode(blob[blob.l++]);&#13;
	if(efsz) {&#13;
		var ef = parse_extra_field(blob.slice(blob.l, blob.l + efsz));&#13;
		if((ef[0x5455]||{}).mt) date = ef[0x5455].mt;&#13;
		if((ef[0x0001]||{}).usz) _usz = ef[0x0001].usz;&#13;
		if((ef[0x0001]||{}).csz) _csz = ef[0x0001].csz;&#13;
		if(EF) {&#13;
			if((EF[0x5455]||{}).mt) date = EF[0x5455].mt;&#13;
			if((EF[0x0001]||{}).usz) _usz = ef[0x0001].usz;&#13;
			if((EF[0x0001]||{}).csz) _csz = ef[0x0001].csz;&#13;
		}&#13;
	}&#13;
	blob.l += efsz;&#13;
&#13;
	/* [encryption header] */&#13;
&#13;
	/* [file data] */&#13;
	var data = blob.slice(blob.l, blob.l + _csz);&#13;
	switch(meth) {&#13;
		case 8: data = _inflateRawSync(blob, _usz); break;&#13;
		case 0: break; // TODO: scan for magic number&#13;
		default: throw new Error("Unsupported ZIP Compression method " + meth);&#13;
	}&#13;
&#13;
	/* [data descriptor] */&#13;
	var wrn = false;&#13;
	if(flags &amp; 8) {&#13;
		crc32 = blob.read_shift(4);&#13;
		if(crc32 == 0x08074b50) { crc32 = blob.read_shift(4); wrn = true; }&#13;
		_csz = blob.read_shift(4);&#13;
		_usz = blob.read_shift(4);&#13;
	}&#13;
&#13;
	if(_csz != csz) warn_or_throw(wrn, "Bad compressed size: " + csz + " != " + _csz);&#13;
	if(_usz != usz) warn_or_throw(wrn, "Bad uncompressed size: " + usz + " != " + _usz);&#13;
	//var _crc32 = CRC32.buf(data, 0);&#13;
	//if((crc32&gt;&gt;0) != (_crc32&gt;&gt;0)) warn_or_throw(wrn, "Bad CRC32 checksum: " + crc32 + " != " + _crc32);&#13;
	cfb_add(o, name, data, {unsafe: true, mt: date});&#13;
}&#13;
function write_zip(cfb, options) {&#13;
	var _opts = options || {};&#13;
	var out = [], cdirs = [];&#13;
	var o = new_buf(1);&#13;
	var method = (_opts.compression ? 8 : 0), flags = 0;&#13;
	var desc = false;&#13;
	if(desc) flags |= 8;&#13;
	var i = 0, j = 0;&#13;
&#13;
	var start_cd = 0, fcnt = 0;&#13;
	var root = cfb.FullPaths[0], fp = root, fi = cfb.FileIndex[0];&#13;
	var crcs = [];&#13;
	var sz_cd = 0;&#13;
&#13;
	for(i = 1; i &lt; cfb.FullPaths.length; ++i) {&#13;
		fp = cfb.FullPaths[i].slice(root.length); fi = cfb.FileIndex[i];&#13;
		if(!fi.size || !fi.content || fp == "\u0001Sh33tJ5") continue;&#13;
		var start = start_cd;&#13;
&#13;
		/* TODO: CP437 filename */&#13;
		var namebuf = new_buf(fp.length);&#13;
		for(j = 0; j &lt; fp.length; ++j) namebuf.write_shift(1, fp.charCodeAt(j) &amp; 0x7F);&#13;
		namebuf = namebuf.slice(0, namebuf.l);&#13;
		crcs[fcnt] = typeof fi.content == "string" ? CRC32.bstr(fi.content, 0) : CRC32.buf(fi.content, 0);&#13;
&#13;
		var outbuf = typeof fi.content == "string" ? s2a(fi.content) : fi.content;&#13;
		if(method == 8) outbuf = _deflateRawSync(outbuf);&#13;
&#13;
		/* local file header */&#13;
		o = new_buf(30);&#13;
		o.write_shift(4, 0x04034b50);&#13;
		o.write_shift(2, 20);&#13;
		o.write_shift(2, flags);&#13;
		o.write_shift(2, method);&#13;
		/* TODO: last mod file time/date */&#13;
		if(fi.mt) write_dos_date(o, fi.mt);&#13;
		else o.write_shift(4, 0);&#13;
		o.write_shift(-4, (flags &amp; 8) ? 0 : crcs[fcnt]);&#13;
		o.write_shift(4,  (flags &amp; 8) ? 0 : outbuf.length);&#13;
		o.write_shift(4,  (flags &amp; 8) ? 0 : fi.content.length);&#13;
		o.write_shift(2, namebuf.length);&#13;
		o.write_shift(2, 0);&#13;
&#13;
		start_cd += o.length;&#13;
		out.push(o);&#13;
		start_cd += namebuf.length;&#13;
		out.push(namebuf);&#13;
&#13;
		/* TODO: extra fields? */&#13;
&#13;
		/* TODO: encryption header ? */&#13;
&#13;
		start_cd += outbuf.length;&#13;
		out.push(outbuf);&#13;
&#13;
		/* data descriptor */&#13;
		if(flags &amp; 8) {&#13;
			o = new_buf(12);&#13;
			o.write_shift(-4, crcs[fcnt]);&#13;
			o.write_shift(4, outbuf.length);&#13;
			o.write_shift(4, fi.content.length);&#13;
			start_cd += o.l;&#13;
			out.push(o);&#13;
		}&#13;
&#13;
		/* central directory */&#13;
		o = new_buf(46);&#13;
		o.write_shift(4, 0x02014b50);&#13;
		o.write_shift(2, 0);&#13;
		o.write_shift(2, 20);&#13;
		o.write_shift(2, flags);&#13;
		o.write_shift(2, method);&#13;
		o.write_shift(4, 0); /* TODO: last mod file time/date */&#13;
		o.write_shift(-4, crcs[fcnt]);&#13;
&#13;
		o.write_shift(4, outbuf.length);&#13;
		o.write_shift(4, fi.content.length);&#13;
		o.write_shift(2, namebuf.length);&#13;
		o.write_shift(2, 0);&#13;
		o.write_shift(2, 0);&#13;
		o.write_shift(2, 0);&#13;
		o.write_shift(2, 0);&#13;
		o.write_shift(4, 0);&#13;
		o.write_shift(4, start);&#13;
&#13;
		sz_cd += o.l;&#13;
		cdirs.push(o);&#13;
		sz_cd += namebuf.length;&#13;
		cdirs.push(namebuf);&#13;
		++fcnt;&#13;
	}&#13;
&#13;
	/* end of central directory */&#13;
	o = new_buf(22);&#13;
	o.write_shift(4, 0x06054b50);&#13;
	o.write_shift(2, 0);&#13;
	o.write_shift(2, 0);&#13;
	o.write_shift(2, fcnt);&#13;
	o.write_shift(2, fcnt);&#13;
	o.write_shift(4, sz_cd);&#13;
	o.write_shift(4, start_cd);&#13;
	o.write_shift(2, 0);&#13;
&#13;
	return bconcat(([bconcat((out)), bconcat(cdirs), o]));&#13;
}&#13;
var ContentTypeMap = ({&#13;
	"htm": "text/html",&#13;
	"xml": "text/xml",&#13;
&#13;
	"gif": "image/gif",&#13;
	"jpg": "image/jpeg",&#13;
	"png": "image/png",&#13;
&#13;
	"mso": "application/x-mso",&#13;
	"thmx": "application/vnd.ms-officetheme",&#13;
	"sh33tj5": "application/octet-stream"&#13;
});&#13;
&#13;
function get_content_type(fi, fp) {&#13;
	if(fi.ctype) return fi.ctype;&#13;
&#13;
	var ext = fi.name || "", m = ext.match(/\.([^\.]+)$/);&#13;
	if(m &amp;&amp; ContentTypeMap[m[1]]) return ContentTypeMap[m[1]];&#13;
&#13;
	if(fp) {&#13;
		m = (ext = fp).match(/[\.\\]([^\.\\])+$/);&#13;
		if(m &amp;&amp; ContentTypeMap[m[1]]) return ContentTypeMap[m[1]];&#13;
	}&#13;
&#13;
	return "application/octet-stream";&#13;
}&#13;
&#13;
/* 76 character chunks TODO: intertwine encoding */&#13;
function write_base64_76(bstr) {&#13;
	var data = Base64_encode(bstr);&#13;
	var o = [];&#13;
	for(var i = 0; i &lt; data.length; i+= 76) o.push(data.slice(i, i+76));&#13;
	return o.join("\r\n") + "\r\n";&#13;
}&#13;
&#13;
/*&#13;
Rules for QP:&#13;
	- escape =## applies for all non-display characters and literal "="&#13;
	- space or tab at end of line must be encoded&#13;
	- \r\n newlines can be preserved, but bare \r and \n must be escaped&#13;
	- lines must not exceed 76 characters, use soft breaks =\r\n&#13;
&#13;
TODO: Some files from word appear to write line extensions with bare equals:&#13;
&#13;
```&#13;
&lt;table class=3DMsoTableGrid border=3D1 cellspacing=3D0 cellpadding=3D0 width=&#13;
="70%"&#13;
```&#13;
*/&#13;
function write_quoted_printable(text) {&#13;
	var encoded = text.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7E-\xFF=]/g, function(c) {&#13;
		var w = c.charCodeAt(0).toString(16).toUpperCase();&#13;
		return "=" + (w.length == 1 ? "0" + w : w);&#13;
	});&#13;
&#13;
	encoded = encoded.replace(/ $/mg, "=20").replace(/\t$/mg, "=09");&#13;
&#13;
	if(encoded.charAt(0) == "\n") encoded = "=0D" + encoded.slice(1);&#13;
	encoded = encoded.replace(/\r(?!\n)/mg, "=0D").replace(/\n\n/mg, "\n=0A").replace(/([^\r\n])\n/mg, "$1=0A");&#13;
&#13;
	var o = [], split = encoded.split("\r\n");&#13;
	for(var si = 0; si &lt; split.length; ++si) {&#13;
		var str = split[si];&#13;
		if(str.length == 0) { o.push(""); continue; }&#13;
		for(var i = 0; i &lt; str.length;) {&#13;
			var end = 76;&#13;
			var tmp = str.slice(i, i + end);&#13;
			if(tmp.charAt(end - 1) == "=") end --;&#13;
			else if(tmp.charAt(end - 2) == "=") end -= 2;&#13;
			else if(tmp.charAt(end - 3) == "=") end -= 3;&#13;
			tmp = str.slice(i, i + end);&#13;
			i += end;&#13;
			if(i &lt; str.length) tmp += "=";&#13;
			o.push(tmp);&#13;
		}&#13;
	}&#13;
&#13;
	return o.join("\r\n");&#13;
}&#13;
function parse_quoted_printable(data) {&#13;
	var o = [];&#13;
&#13;
	/* unify long lines */&#13;
	for(var di = 0; di &lt; data.length; ++di) {&#13;
		var line = data[di];&#13;
		while(di &lt;= data.length &amp;&amp; line.charAt(line.length - 1) == "=") line = line.slice(0, line.length - 1) + data[++di];&#13;
		o.push(line);&#13;
	}&#13;
&#13;
	/* decode */&#13;
	for(var oi = 0; oi &lt; o.length; ++oi) o[oi] = o[oi].replace(/[=][0-9A-Fa-f]{2}/g, function($$) { return String.fromCharCode(parseInt($$.slice(1), 16)); });&#13;
	return s2a(o.join("\r\n"));&#13;
}&#13;
&#13;
&#13;
function parse_mime(cfb, data, root) {&#13;
	var fname = "", cte = "", ctype = "", fdata;&#13;
	var di = 0;&#13;
	for(;di &lt; 10; ++di) {&#13;
		var line = data[di];&#13;
		if(!line || line.match(/^\s*$/)) break;&#13;
		var m = line.match(/^(.*?):\s*([^\s].*)$/);&#13;
		if(m) switch(m[1].toLowerCase()) {&#13;
			case "content-location": fname = m[2].trim(); break;&#13;
			case "content-type": ctype = m[2].trim(); break;&#13;
			case "content-transfer-encoding": cte = m[2].trim(); break;&#13;
		}&#13;
	}&#13;
	++di;&#13;
	switch(cte.toLowerCase()) {&#13;
		case 'base64': fdata = s2a(Base64_decode(data.slice(di).join(""))); break;&#13;
		case 'quoted-printable': fdata = parse_quoted_printable(data.slice(di)); break;&#13;
		default: throw new Error("Unsupported Content-Transfer-Encoding " + cte);&#13;
	}&#13;
	var file = cfb_add(cfb, fname.slice(root.length), fdata, {unsafe: true});&#13;
	if(ctype) file.ctype = ctype;&#13;
}&#13;
&#13;
function parse_mad(file, options) {&#13;
	if(a2s(file.slice(0,13)).toLowerCase() != "mime-version:") throw new Error("Unsupported MAD header");&#13;
	var root = (options &amp;&amp; options.root || "");&#13;
	// $FlowIgnore&#13;
	var data = (has_buf &amp;&amp; Buffer.isBuffer(file) ? file.toString("binary") : a2s(file)).split("\r\n");&#13;
	var di = 0, row = "";&#13;
&#13;
	/* if root is not specified, scan for the common prefix */&#13;
	for(di = 0; di &lt; data.length; ++di) {&#13;
		row = data[di];&#13;
		if(!/^Content-Location:/i.test(row)) continue;&#13;
		row = row.slice(row.indexOf("file"));&#13;
		if(!root) root = row.slice(0, row.lastIndexOf("/") + 1);&#13;
		if(row.slice(0, root.length) == root) continue;&#13;
		while(root.length &gt; 0) {&#13;
			root = root.slice(0, root.length - 1);&#13;
			root = root.slice(0, root.lastIndexOf("/") + 1);&#13;
			if(row.slice(0,root.length) == root) break;&#13;
		}&#13;
	}&#13;
&#13;
	var mboundary = (data[1] || "").match(/boundary="(.*?)"/);&#13;
	if(!mboundary) throw new Error("MAD cannot find boundary");&#13;
	var boundary = "--" + (mboundary[1] || "");&#13;
&#13;
	var FileIndex = [], FullPaths = [];&#13;
	var o = {&#13;
		FileIndex: FileIndex,&#13;
		FullPaths: FullPaths&#13;
	};&#13;
	init_cfb(o);&#13;
	var start_di, fcnt = 0;&#13;
	for(di = 0; di &lt; data.length; ++di) {&#13;
		var line = data[di];&#13;
		if(line !== boundary &amp;&amp; line !== boundary + "--") continue;&#13;
		if(fcnt++) parse_mime(o, data.slice(start_di, di), root);&#13;
		start_di = di;&#13;
	}&#13;
	return o;&#13;
}&#13;
&#13;
function write_mad(cfb, options) {&#13;
	var opts = options || {};&#13;
	var boundary = opts.boundary || "xlsx";&#13;
	boundary = '------=' + boundary;&#13;
&#13;
	var out = [&#13;
		'MIME-Version: 1.0',&#13;
		'Content-Type: multipart/related; boundary="' + boundary.slice(2) + '"',&#13;
		'',&#13;
		'',&#13;
		''&#13;
	];&#13;
&#13;
	var root = cfb.FullPaths[0], fp = root, fi = cfb.FileIndex[0];&#13;
	for(var i = 1; i &lt; cfb.FullPaths.length; ++i) {&#13;
		fp = cfb.FullPaths[i].slice(root.length);&#13;
		fi = cfb.FileIndex[i];&#13;
		if(!fi.size || !fi.content || fp == "\u0001Sh33tJ5") continue;&#13;
&#13;
		/* Normalize filename */&#13;
		fp = fp.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7E-\xFF]/g, function(c) {&#13;
			return "_x" + c.charCodeAt(0).toString(16) + "_";&#13;
		}).replace(/[\u0080-\uFFFF]/g, function(u) {&#13;
			return "_u" + u.charCodeAt(0).toString(16) + "_";&#13;
		});&#13;
&#13;
		/* Extract content as binary string */&#13;
		var ca = fi.content;&#13;
		// $FlowIgnore&#13;
		var cstr = has_buf &amp;&amp; Buffer.isBuffer(ca) ? ca.toString("binary") : a2s(ca);&#13;
&#13;
		/* 4/5 of first 1024 chars ascii -&gt; quoted printable, else base64 */&#13;
		var dispcnt = 0, L = Math.min(1024, cstr.length), cc = 0;&#13;
		for(var csl = 0; csl &lt;= L; ++csl) if((cc=cstr.charCodeAt(csl)) &gt;= 0x20 &amp;&amp; cc &lt; 0x80) ++dispcnt;&#13;
		var qp = dispcnt &gt;= L * 4 / 5;&#13;
&#13;
		out.push(boundary);&#13;
		out.push('Content-Location: ' + (opts.root || 'file:///C:/xlsx/') + fp);&#13;
		out.push('Content-Transfer-Encoding: ' + (qp ? 'quoted-printable' : 'base64'));&#13;
		out.push('Content-Type: ' + get_content_type(fi, fp));&#13;
		out.push('');&#13;
&#13;
		out.push(qp ? write_quoted_printable(cstr) : write_base64_76(cstr));&#13;
	}&#13;
	out.push(boundary + '--\r\n');&#13;
	return out.join("\r\n");&#13;
}&#13;
function cfb_new(opts) {&#13;
	var o = ({});&#13;
	init_cfb(o, opts);&#13;
	return o;&#13;
}&#13;
&#13;
function cfb_add(cfb, name, content, opts) {&#13;
	var unsafe = opts &amp;&amp; opts.unsafe;&#13;
	if(!unsafe) init_cfb(cfb);&#13;
	var file = !unsafe &amp;&amp; CFB.find(cfb, name);&#13;
	if(!file) {&#13;
		var fpath = cfb.FullPaths[0];&#13;
		if(name.slice(0, fpath.length) == fpath) fpath = name;&#13;
		else {&#13;
			if(fpath.slice(-1) != "/") fpath += "/";&#13;
			fpath = (fpath + name).replace("//","/");&#13;
		}&#13;
		file = ({name: filename(name), type: 2});&#13;
		cfb.FileIndex.push(file);&#13;
		cfb.FullPaths.push(fpath);&#13;
		if(!unsafe) CFB.utils.cfb_gc(cfb);&#13;
	}&#13;
file.content = (content);&#13;
	file.size = content ? content.length : 0;&#13;
	if(opts) {&#13;
		if(opts.CLSID) file.clsid = opts.CLSID;&#13;
		if(opts.mt) file.mt = opts.mt;&#13;
		if(opts.ct) file.ct = opts.ct;&#13;
	}&#13;
	return file;&#13;
}&#13;
&#13;
function cfb_del(cfb, name) {&#13;
	init_cfb(cfb);&#13;
	var file = CFB.find(cfb, name);&#13;
	if(file) for(var j = 0; j &lt; cfb.FileIndex.length; ++j) if(cfb.FileIndex[j] == file) {&#13;
		cfb.FileIndex.splice(j, 1);&#13;
		cfb.FullPaths.splice(j, 1);&#13;
		return true;&#13;
	}&#13;
	return false;&#13;
}&#13;
&#13;
function cfb_mov(cfb, old_name, new_name) {&#13;
	init_cfb(cfb);&#13;
	var file = CFB.find(cfb, old_name);&#13;
	if(file) for(var j = 0; j &lt; cfb.FileIndex.length; ++j) if(cfb.FileIndex[j] == file) {&#13;
		cfb.FileIndex[j].name = filename(new_name);&#13;
		cfb.FullPaths[j] = new_name;&#13;
		return true;&#13;
	}&#13;
	return false;&#13;
}&#13;
&#13;
function cfb_gc(cfb) { rebuild_cfb(cfb, true); }&#13;
&#13;
exports.find = find;&#13;
exports.read = read;&#13;
exports.parse = parse;&#13;
exports.write = write;&#13;
exports.writeFile = write_file;&#13;
exports.utils = {&#13;
	cfb_new: cfb_new,&#13;
	cfb_add: cfb_add,&#13;
	cfb_del: cfb_del,&#13;
	cfb_mov: cfb_mov,&#13;
	cfb_gc: cfb_gc,&#13;
	ReadShift: ReadShift,&#13;
	CheckField: CheckField,&#13;
	prep_blob: prep_blob,&#13;
	bconcat: bconcat,&#13;
	use_zlib: use_zlib,&#13;
	_deflateRaw: _deflate,&#13;
	_inflateRaw: _inflate,&#13;
	consts: consts&#13;
};&#13;
&#13;
return exports;&#13;
})();&#13;
&#13;
var _fs;&#13;
function set_fs(fs) { _fs = fs; }&#13;
&#13;
/* normalize data for blob ctor */&#13;
function blobify(data) {&#13;
	if(typeof data === "string") return s2ab(data);&#13;
	if(Array.isArray(data)) return a2u(data);&#13;
	return data;&#13;
}&#13;
/* write or download file */&#13;
function write_dl(fname, payload, enc) {&#13;
	/*global IE_SaveFile, Blob, navigator, saveAs, document, File, chrome */&#13;
	if(typeof _fs !== 'undefined' &amp;&amp; _fs.writeFileSync) return enc ? _fs.writeFileSync(fname, payload, enc) : _fs.writeFileSync(fname, payload);&#13;
	if(typeof Deno !== 'undefined') {&#13;
		/* in this spot, it's safe to assume typed arrays and TextEncoder/TextDecoder exist */&#13;
		if(enc &amp;&amp; typeof payload == "string") switch(enc) {&#13;
			case "utf8": payload = new TextEncoder(enc).encode(payload); break;&#13;
			case "binary": payload = s2ab(payload); break;&#13;
			/* TODO: binary equivalent */&#13;
			default: throw new Error("Unsupported encoding " + enc);&#13;
		}&#13;
		return Deno.writeFileSync(fname, payload);&#13;
	}&#13;
	var data = (enc == "utf8") ? utf8write(payload) : payload;&#13;
if(typeof IE_SaveFile !== 'undefined') return IE_SaveFile(data, fname);&#13;
	if(typeof Blob !== 'undefined') {&#13;
		var blob = new Blob([blobify(data)], {type:"application/octet-stream"});&#13;
if(typeof navigator !== 'undefined' &amp;&amp; navigator.msSaveBlob) return navigator.msSaveBlob(blob, fname);&#13;
if(typeof saveAs !== 'undefined') return saveAs(blob, fname);&#13;
		if(typeof URL !== 'undefined' &amp;&amp; typeof document !== 'undefined' &amp;&amp; document.createElement &amp;&amp; URL.createObjectURL) {&#13;
			var url = URL.createObjectURL(blob);&#13;
if(typeof chrome === 'object' &amp;&amp; typeof (chrome.downloads||{}).download == "function") {&#13;
				if(URL.revokeObjectURL &amp;&amp; typeof setTimeout !== 'undefined') setTimeout(function() { URL.revokeObjectURL(url); }, 60000);&#13;
				return chrome.downloads.download({ url: url, filename: fname, saveAs: true});&#13;
			}&#13;
			var a = document.createElement("a");&#13;
			if(a.download != null) {&#13;
a.download = fname; a.href = url; document.body.appendChild(a); a.click();&#13;
document.body.removeChild(a);&#13;
				if(URL.revokeObjectURL &amp;&amp; typeof setTimeout !== 'undefined') setTimeout(function() { URL.revokeObjectURL(url); }, 60000);&#13;
				return url;&#13;
			}&#13;
		}&#13;
	}&#13;
	// $FlowIgnore&#13;
	if(typeof $ !== 'undefined' &amp;&amp; typeof File !== 'undefined' &amp;&amp; typeof Folder !== 'undefined') try { // extendscript&#13;
		// $FlowIgnore&#13;
		var out = File(fname); out.open("w"); out.encoding = "binary";&#13;
		if(Array.isArray(payload)) payload = a2s(payload);&#13;
		out.write(payload); out.close(); return payload;&#13;
	} catch(e) { if(!e.message || !e.message.match(/onstruct/)) throw e; }&#13;
	throw new Error("cannot save file " + fname);&#13;
}&#13;
&#13;
/* read binary data from file */&#13;
function read_binary(path) {&#13;
	if(typeof _fs !== 'undefined') return _fs.readFileSync(path);&#13;
	if(typeof Deno !== 'undefined') return Deno.readFileSync(path);&#13;
	// $FlowIgnore&#13;
	if(typeof $ !== 'undefined' &amp;&amp; typeof File !== 'undefined' &amp;&amp; typeof Folder !== 'undefined') try { // extendscript&#13;
		// $FlowIgnore&#13;
		var infile = File(path); infile.open("r"); infile.encoding = "binary";&#13;
		var data = infile.read(); infile.close();&#13;
		return data;&#13;
	} catch(e) { if(!e.message || !e.message.match(/onstruct/)) throw e; }&#13;
	throw new Error("Cannot access file " + path);&#13;
}&#13;
function keys(o) {&#13;
	var ks = Object.keys(o), o2 = [];&#13;
	for(var i = 0; i &lt; ks.length; ++i) if(Object.prototype.hasOwnProperty.call(o, ks[i])) o2.push(ks[i]);&#13;
	return o2;&#13;
}&#13;
&#13;
function evert_key(obj, key) {&#13;
	var o = ([]), K = keys(obj);&#13;
	for(var i = 0; i !== K.length; ++i) if(o[obj[K[i]][key]] == null) o[obj[K[i]][key]] = K[i];&#13;
	return o;&#13;
}&#13;
&#13;
function evert(obj) {&#13;
	var o = ([]), K = keys(obj);&#13;
	for(var i = 0; i !== K.length; ++i) o[obj[K[i]]] = K[i];&#13;
	return o;&#13;
}&#13;
&#13;
function evert_num(obj) {&#13;
	var o = ([]), K = keys(obj);&#13;
	for(var i = 0; i !== K.length; ++i) o[obj[K[i]]] = parseInt(K[i],10);&#13;
	return o;&#13;
}&#13;
&#13;
function evert_arr(obj) {&#13;
	var o = ([]), K = keys(obj);&#13;
	for(var i = 0; i !== K.length; ++i) {&#13;
		if(o[obj[K[i]]] == null) o[obj[K[i]]] = [];&#13;
		o[obj[K[i]]].push(K[i]);&#13;
	}&#13;
	return o;&#13;
}&#13;
&#13;
var basedate = new Date(1899, 11, 30, 0, 0, 0); // 2209161600000&#13;
function datenum(v, date1904) {&#13;
	var epoch = v.getTime();&#13;
	if(date1904) epoch -= 1462*24*60*60*1000;&#13;
	var dnthresh = basedate.getTime() + (v.getTimezoneOffset() - basedate.getTimezoneOffset()) * 60000;&#13;
	return (epoch - dnthresh) / (24 * 60 * 60 * 1000);&#13;
}&#13;
var refdate = new Date();&#13;
var dnthresh = basedate.getTime() + (refdate.getTimezoneOffset() - basedate.getTimezoneOffset()) * 60000;&#13;
var refoffset = refdate.getTimezoneOffset();&#13;
function numdate(v) {&#13;
	var out = new Date();&#13;
	out.setTime(v * 24 * 60 * 60 * 1000 + dnthresh);&#13;
	if (out.getTimezoneOffset() !== refoffset) {&#13;
		out.setTime(out.getTime() + (out.getTimezoneOffset() - refoffset) * 60000);&#13;
	}&#13;
	return out;&#13;
}&#13;
&#13;
/* ISO 8601 Duration */&#13;
function parse_isodur(s) {&#13;
	var sec = 0, mt = 0, time = false;&#13;
	var m = s.match(/P([0-9\.]+Y)?([0-9\.]+M)?([0-9\.]+D)?T([0-9\.]+H)?([0-9\.]+M)?([0-9\.]+S)?/);&#13;
	if(!m) throw new Error("|" + s + "| is not an ISO8601 Duration");&#13;
	for(var i = 1; i != m.length; ++i) {&#13;
		if(!m[i]) continue;&#13;
		mt = 1;&#13;
		if(i &gt; 3) time = true;&#13;
		switch(m[i].slice(m[i].length-1)) {&#13;
			case 'Y':&#13;
				throw new Error("Unsupported ISO Duration Field: " + m[i].slice(m[i].length-1));&#13;
			case 'D': mt *= 24;&#13;
				/* falls through */&#13;
			case 'H': mt *= 60;&#13;
				/* falls through */&#13;
			case 'M':&#13;
				if(!time) throw new Error("Unsupported ISO Duration Field: M");&#13;
				else mt *= 60;&#13;
				/* falls through */&#13;
			case 'S': break;&#13;
		}&#13;
		sec += mt * parseInt(m[i], 10);&#13;
	}&#13;
	return sec;&#13;
}&#13;
&#13;
var good_pd_date_1 = new Date('2017-02-19T19:06:09.000Z');&#13;
var good_pd_date = isNaN(good_pd_date_1.getFullYear()) ? new Date('2/19/17') : good_pd_date_1;&#13;
var good_pd = good_pd_date.getFullYear() == 2017;&#13;
/* parses a date as a local date */&#13;
function parseDate(str, fixdate) {&#13;
	var d = new Date(str);&#13;
	if(good_pd) {&#13;
if(fixdate &gt; 0) d.setTime(d.getTime() + d.getTimezoneOffset() * 60 * 1000);&#13;
		else if(fixdate &lt; 0) d.setTime(d.getTime() - d.getTimezoneOffset() * 60 * 1000);&#13;
		return d;&#13;
	}&#13;
	if(str instanceof Date) return str;&#13;
	if(good_pd_date.getFullYear() == 1917 &amp;&amp; !isNaN(d.getFullYear())) {&#13;
		var s = d.getFullYear();&#13;
		if(str.indexOf("" + s) &gt; -1) return d;&#13;
		d.setFullYear(d.getFullYear() + 100); return d;&#13;
	}&#13;
	var n = str.match(/\d+/g)||["2017","2","19","0","0","0"];&#13;
	var out = new Date(+n[0], +n[1] - 1, +n[2], (+n[3]||0), (+n[4]||0), (+n[5]||0));&#13;
	if(str.indexOf("Z") &gt; -1) out = new Date(out.getTime() - out.getTimezoneOffset() * 60 * 1000);&#13;
	return out;&#13;
}&#13;
&#13;
function cc2str(arr, debomit) {&#13;
	if(has_buf &amp;&amp; Buffer.isBuffer(arr)) {&#13;
		if(debomit &amp;&amp; buf_utf16le) {&#13;
			// TODO: temporary patch&#13;
			if(arr[0] == 0xFF &amp;&amp; arr[1] == 0xFE) return utf8write(arr.slice(2).toString("utf16le"));&#13;
			if(arr[1] == 0xFE &amp;&amp; arr[2] == 0xFF) return utf8write(utf16beread(arr.slice(2).toString("binary")));&#13;
		}&#13;
		return arr.toString("binary");&#13;
	}&#13;
&#13;
	if(typeof TextDecoder !== "undefined") try {&#13;
		if(debomit) {&#13;
			if(arr[0] == 0xFF &amp;&amp; arr[1] == 0xFE) return utf8write(new TextDecoder("utf-16le").decode(arr.slice(2)));&#13;
			if(arr[0] == 0xFE &amp;&amp; arr[1] == 0xFF) return utf8write(new TextDecoder("utf-16be").decode(arr.slice(2)));&#13;
		}&#13;
		var rev = {&#13;
			"\u20ac": "\x80", "\u201a": "\x82", "\u0192": "\x83", "\u201e": "\x84",&#13;
			"\u2026": "\x85", "\u2020": "\x86", "\u2021": "\x87", "\u02c6": "\x88",&#13;
			"\u2030": "\x89", "\u0160": "\x8a", "\u2039": "\x8b", "\u0152": "\x8c",&#13;
			"\u017d": "\x8e", "\u2018": "\x91", "\u2019": "\x92", "\u201c": "\x93",&#13;
			"\u201d": "\x94", "\u2022": "\x95", "\u2013": "\x96", "\u2014": "\x97",&#13;
			"\u02dc": "\x98", "\u2122": "\x99", "\u0161": "\x9a", "\u203a": "\x9b",&#13;
			"\u0153": "\x9c", "\u017e": "\x9e", "\u0178": "\x9f"&#13;
		};&#13;
		if(Array.isArray(arr)) arr = new Uint8Array(arr);&#13;
		return new TextDecoder("latin1").decode(arr).replace(/[€‚ƒ„…†‡ˆ‰Š‹ŒŽ''""•–—˜™š›œžŸ]/g, function(c) { return rev[c] || c; });&#13;
	} catch(e) {}&#13;
&#13;
	var o = [];&#13;
	for(var i = 0; i != arr.length; ++i) o.push(String.fromCharCode(arr[i]));&#13;
	return o.join("");&#13;
}&#13;
&#13;
function dup(o) {&#13;
	if(typeof JSON != 'undefined' &amp;&amp; !Array.isArray(o)) return JSON.parse(JSON.stringify(o));&#13;
	if(typeof o != 'object' || o == null) return o;&#13;
	if(o instanceof Date) return new Date(o.getTime());&#13;
	var out = {};&#13;
	for(var k in o) if(Object.prototype.hasOwnProperty.call(o, k)) out[k] = dup(o[k]);&#13;
	return out;&#13;
}&#13;
&#13;
function fill(c,l) { var o = ""; while(o.length &lt; l) o+=c; return o; }&#13;
&#13;
/* TODO: stress test */&#13;
function fuzzynum(s) {&#13;
	var v = Number(s);&#13;
	if(!isNaN(v)) return isFinite(v) ? v : NaN;&#13;
	if(!/\d/.test(s)) return v;&#13;
	var wt = 1;&#13;
	var ss = s.replace(/([\d]),([\d])/g,"$1$2").replace(/[$]/g,"").replace(/[%]/g, function() { wt *= 100; return "";});&#13;
	if(!isNaN(v = Number(ss))) return v / wt;&#13;
	ss = ss.replace(/[(](.*)[)]/,function($$, $1) { wt = -wt; return $1;});&#13;
	if(!isNaN(v = Number(ss))) return v / wt;&#13;
	return v;&#13;
}&#13;
&#13;
/* NOTE: Chrome rejects bare times like 1:23 PM */&#13;
var FDRE1 = /^(0?\d|1[0-2])(?:|:([0-5]?\d)(?:|(\.\d+)(?:|:([0-5]?\d))|:([0-5]?\d)(|\.\d+)))\s+([ap])m?$/;&#13;
&#13;
function fuzzytime1(M)  {&#13;
    /* TODO: 1904 adjustment, keep in sync with base date */&#13;
    if(!M[2]) return new Date(1899,11,30,(+M[1]%12) + (M[7] == "p" ? 12 : 0), 0, 0, 0);&#13;
    if(M[3]) {&#13;
        if(M[4]) return new Date(1899,11,30,(+M[1]%12) + (M[7] == "p" ? 12 : 0), +M[2], +M[4], parseFloat(M[3])*1000);&#13;
        else return new Date(1899,11,30,(M[7] == "p" ? 12 : 0), +M[1], +M[2], parseFloat(M[3])*1000);&#13;
    }&#13;
    else if(M[5]) return new Date(1899,11,30, (+M[1]%12) + (M[7] == "p" ? 12 : 0), +M[2], +M[5], M[6] ? parseFloat(M[6]) * 1000 : 0);&#13;
    else return new Date(1899,11,30,(+M[1]%12) + (M[7] == "p" ? 12 : 0), +M[2], 0, 0);&#13;
}&#13;
var lower_months = ['january', 'february', 'march', 'april', 'may', 'june', 'july', 'august', 'september', 'october', 'november', 'december'];&#13;
function fuzzydate(s) {&#13;
	var lower = s.toLowerCase();&#13;
	var lnos = lower.replace(/\s+/g, " ").trim();&#13;
	var M = lnos.match(FDRE1);&#13;
	if(M) return fuzzytime1(M);&#13;
&#13;
	var o = new Date(s), n = new Date(NaN);&#13;
	var y = o.getYear(), m = o.getMonth(), d = o.getDate();&#13;
	if(isNaN(d)) return n;&#13;
	if(lower.match(/jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec/)) {&#13;
		lower = lower.replace(/[^a-z]/g,"").replace(/([^a-z]|^)[ap]m?([^a-z]|$)/,"");&#13;
		if(lower.length &gt; 3 &amp;&amp; lower_months.indexOf(lower) == -1) return n;&#13;
	} else if(lower.replace(/[ap]m?/, "").match(/[a-z]/)) return n;&#13;
	if(y &lt; 0 || y &gt; 8099 || s.match(/[^-0-9:,\/\\]/)) return n;&#13;
	return o;&#13;
}&#13;
&#13;
var split_regex = (function() {&#13;
	var safe_split_regex = "abacaba".split(/(:?b)/i).length == 5;&#13;
	return function split_regex(str, re, def) {&#13;
		if(safe_split_regex || typeof re == "string") return str.split(re);&#13;
		var p = str.split(re), o = [p[0]];&#13;
		for(var i = 1; i &lt; p.length; ++i) { o.push(def); o.push(p[i]); }&#13;
		return o;&#13;
	};&#13;
})();&#13;
function getdatastr(data) {&#13;
	if(!data) return null;&#13;
	if(data.content &amp;&amp; data.type) return cc2str(data.content, true);&#13;
	if(data.data) return debom(data.data);&#13;
	if(data.asNodeBuffer &amp;&amp; has_buf) return debom(data.asNodeBuffer().toString('binary'));&#13;
	if(data.asBinary) return debom(data.asBinary());&#13;
	if(data._data &amp;&amp; data._data.getContent) return debom(cc2str(Array.prototype.slice.call(data._data.getContent(),0)));&#13;
	return null;&#13;
}&#13;
&#13;
function getdatabin(data) {&#13;
	if(!data) return null;&#13;
	if(data.data) return char_codes(data.data);&#13;
	if(data.asNodeBuffer &amp;&amp; has_buf) return data.asNodeBuffer();&#13;
	if(data._data &amp;&amp; data._data.getContent) {&#13;
		var o = data._data.getContent();&#13;
		if(typeof o == "string") return char_codes(o);&#13;
		return Array.prototype.slice.call(o);&#13;
	}&#13;
	if(data.content &amp;&amp; data.type) return data.content;&#13;
	return null;&#13;
}&#13;
&#13;
function getdata(data) { return (data &amp;&amp; data.name.slice(-4) === ".bin") ? getdatabin(data) : getdatastr(data); }&#13;
&#13;
/* Part 2 Section 10.1.2 "Mapping Content Types" Names are case-insensitive */&#13;
/* OASIS does not comment on filename case sensitivity */&#13;
function safegetzipfile(zip, file) {&#13;
	var k = zip.FullPaths || keys(zip.files);&#13;
	var f = file.toLowerCase().replace(/[\/]/g, '\\'), g = f.replace(/\\/g,'\/');&#13;
	for(var i=0; i&lt;k.length; ++i) {&#13;
		var n = k[i].replace(/^Root Entry[\/]/,"").toLowerCase();&#13;
		if(f == n || g == n) return zip.files ? zip.files[k[i]] : zip.FileIndex[i];&#13;
	}&#13;
	return null;&#13;
}&#13;
&#13;
function getzipfile(zip, file) {&#13;
	var o = safegetzipfile(zip, file);&#13;
	if(o == null) throw new Error("Cannot find file " + file + " in zip");&#13;
	return o;&#13;
}&#13;
&#13;
function getzipdata(zip, file, safe) {&#13;
	if(!safe) return getdata(getzipfile(zip, file));&#13;
	if(!file) return null;&#13;
	try { return getzipdata(zip, file); } catch(e) { return null; }&#13;
}&#13;
&#13;
function getzipstr(zip, file, safe) {&#13;
	if(!safe) return getdatastr(getzipfile(zip, file));&#13;
	if(!file) return null;&#13;
	try { return getzipstr(zip, file); } catch(e) { return null; }&#13;
}&#13;
&#13;
function getzipbin(zip, file, safe) {&#13;
	if(!safe) return getdatabin(getzipfile(zip, file));&#13;
	if(!file) return null;&#13;
	try { return getzipbin(zip, file); } catch(e) { return null; }&#13;
}&#13;
&#13;
function zipentries(zip) {&#13;
	var k = zip.FullPaths || keys(zip.files), o = [];&#13;
	for(var i = 0; i &lt; k.length; ++i) if(k[i].slice(-1) != '/') o.push(k[i].replace(/^Root Entry[\/]/, ""));&#13;
	return o.sort();&#13;
}&#13;
&#13;
function zip_add_file(zip, path, content) {&#13;
	if(zip.FullPaths) {&#13;
		if(typeof content == "string") {&#13;
			var res;&#13;
			if(has_buf) res = Buffer_from(content);&#13;
			/* TODO: investigate performance in Edge 13 */&#13;
			//else if(typeof TextEncoder !== "undefined") res = new TextEncoder().encode(content);&#13;
			else res = utf8decode(content);&#13;
			return CFB.utils.cfb_add(zip, path, res);&#13;
		}&#13;
		CFB.utils.cfb_add(zip, path, content);&#13;
	}&#13;
	else zip.file(path, content);&#13;
}&#13;
&#13;
function zip_new() { return CFB.utils.cfb_new(); }&#13;
&#13;
function zip_read(d, o) {&#13;
	switch(o.type) {&#13;
		case "base64": return CFB.read(d, { type: "base64" });&#13;
		case "binary": return CFB.read(d, { type: "binary" });&#13;
		case "buffer": case "array": return CFB.read(d, { type: "buffer" });&#13;
	}&#13;
	throw new Error("Unrecognized type " + o.type);&#13;
}&#13;
&#13;
function resolve_path(path, base) {&#13;
	if(path.charAt(0) == "/") return path.slice(1);&#13;
	var result = base.split('/');&#13;
	if(base.slice(-1) != "/") result.pop(); // folder path&#13;
	var target = path.split('/');&#13;
	while (target.length !== 0) {&#13;
		var step = target.shift();&#13;
		if (step === '..') result.pop();&#13;
		else if (step !== '.') result.push(step);&#13;
	}&#13;
	return result.join('/');&#13;
}&#13;
var XML_HEADER = '&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;\r\n';&#13;
var attregexg=/([^"\s?&gt;\/]+)\s*=\s*((?:")([^"]*)(?:")|(?:')([^']*)(?:')|([^'"&gt;\s]+))/g;&#13;
var tagregex1=/&lt;[\/\?]?[a-zA-Z0-9:_-]+(?:\s+[^"\s?&gt;\/]+\s*=\s*(?:"[^"]*"|'[^']*'|[^'"&gt;\s=]+))*\s*[\/\?]?&gt;/mg, tagregex2 = /&lt;[^&gt;]*&gt;/g;&#13;
var tagregex = XML_HEADER.match(tagregex1) ? tagregex1 : tagregex2;&#13;
var nsregex=/&lt;\w*:/, nsregex2 = /&lt;(\/?)\w+:/;&#13;
function parsexmltag(tag, skip_root, skip_LC) {&#13;
	var z = ({});&#13;
	var eq = 0, c = 0;&#13;
	for(; eq !== tag.length; ++eq) if((c = tag.charCodeAt(eq)) === 32 || c === 10 || c === 13) break;&#13;
	if(!skip_root) z[0] = tag.slice(0, eq);&#13;
	if(eq === tag.length) return z;&#13;
	var m = tag.match(attregexg), j=0, v="", i=0, q="", cc="", quot = 1;&#13;
	if(m) for(i = 0; i != m.length; ++i) {&#13;
		cc = m[i];&#13;
		for(c=0; c != cc.length; ++c) if(cc.charCodeAt(c) === 61) break;&#13;
		q = cc.slice(0,c).trim();&#13;
		while(cc.charCodeAt(c+1) == 32) ++c;&#13;
		quot = ((eq=cc.charCodeAt(c+1)) == 34 || eq == 39) ? 1 : 0;&#13;
		v = cc.slice(c+1+quot, cc.length-quot);&#13;
		for(j=0;j!=q.length;++j) if(q.charCodeAt(j) === 58) break;&#13;
		if(j===q.length) {&#13;
			if(q.indexOf("_") &gt; 0) q = q.slice(0, q.indexOf("_")); // from ods&#13;
			z[q] = v;&#13;
			if(!skip_LC) z[q.toLowerCase()] = v;&#13;
		}&#13;
		else {&#13;
			var k = (j===5 &amp;&amp; q.slice(0,5)==="xmlns"?"xmlns":"")+q.slice(j+1);&#13;
			if(z[k] &amp;&amp; q.slice(j-3,j) == "ext") continue; // from ods&#13;
			z[k] = v;&#13;
			if(!skip_LC) z[k.toLowerCase()] = v;&#13;
		}&#13;
	}&#13;
	return z;&#13;
}&#13;
function strip_ns(x) { return x.replace(nsregex2, "&lt;$1"); }&#13;
&#13;
var encodings = {&#13;
	'&amp;quot;': '"',&#13;
	'&amp;apos;': "'",&#13;
	'&amp;gt;': '&gt;',&#13;
	'&amp;lt;': '&lt;',&#13;
	'&amp;amp;': '&amp;'&#13;
};&#13;
var rencoding = evert(encodings);&#13;
//var rencstr = "&amp;&lt;&gt;'\"".split("");&#13;
&#13;
// TODO: CP remap (need to read file version to determine OS)&#13;
var unescapexml = (function() {&#13;
	/* 22.4.2.4 bstr (Basic String) */&#13;
	var encregex = /&amp;(?:quot|apos|gt|lt|amp|#x?([\da-fA-F]+));/ig, coderegex = /_x([\da-fA-F]{4})_/ig;&#13;
	function raw_unescapexml(text) {&#13;
		var s = text + '', i = s.indexOf("&lt;![CDATA[");&#13;
		if(i == -1) return s.replace(encregex, function($$, $1) { return encodings[$$]||String.fromCharCode(parseInt($1,$$.indexOf("x")&gt;-1?16:10))||$$; }).replace(coderegex,function(m,c) {return String.fromCharCode(parseInt(c,16));});&#13;
		var j = s.indexOf("]]&gt;");&#13;
		return raw_unescapexml(s.slice(0, i)) + s.slice(i+9,j) + raw_unescapexml(s.slice(j+3));&#13;
	}&#13;
	return function unescapexml(text, xlsx) {&#13;
		var out = raw_unescapexml(text);&#13;
		return xlsx ? out.replace(/\r\n/g, "\n") : out;&#13;
	};&#13;
})();&#13;
&#13;
var decregex=/[&amp;&lt;&gt;'"]/g, charegex = /[\u0000-\u0008\u000b-\u001f\uFFFE-\uFFFF]/g;&#13;
function escapexml(text){&#13;
	var s = text + '';&#13;
	return s.replace(decregex, function(y) { return rencoding[y]; }).replace(charegex,function(s) { return "_x" + ("000"+s.charCodeAt(0).toString(16)).slice(-4) + "_";});&#13;
}&#13;
function escapexmltag(text){ return escapexml(text).replace(/ /g,"_x0020_"); }&#13;
&#13;
var htmlcharegex = /[\u0000-\u001f]/g;&#13;
function escapehtml(text){&#13;
	var s = text + '';&#13;
	return s.replace(decregex, function(y) { return rencoding[y]; }).replace(/\n/g, "&lt;br/&gt;").replace(htmlcharegex,function(s) { return "&amp;#x" + ("000"+s.charCodeAt(0).toString(16)).slice(-4) + ";"; });&#13;
}&#13;
&#13;
function escapexlml(text){&#13;
	var s = text + '';&#13;
	return s.replace(decregex, function(y) { return rencoding[y]; }).replace(htmlcharegex,function(s) { return "&amp;#x" + (s.charCodeAt(0).toString(16)).toUpperCase() + ";"; });&#13;
}&#13;
&#13;
/* TODO: handle codepages */&#13;
var xlml_fixstr = (function() {&#13;
	var entregex = /&amp;#(\d+);/g;&#13;
	function entrepl($$,$1) { return String.fromCharCode(parseInt($1,10)); }&#13;
	return function xlml_fixstr(str) { return str.replace(entregex,entrepl); };&#13;
})();&#13;
function xlml_unfixstr(str) { return str.replace(/(\r\n|[\r\n])/g,"\&amp;#10;"); }&#13;
&#13;
/* note: xsd:boolean valid values: true / 1 / false / 0 */&#13;
function parsexmlbool(value) {&#13;
	switch(value) {&#13;
		case 1: case true:  case '1': case 'true':  return true;&#13;
		case 0: case false: case '0': case 'false': return false;&#13;
		//default: throw new Error("Invalid xsd:boolean " + value);&#13;
	}&#13;
	return false;&#13;
}&#13;
&#13;
function utf8reada(orig) {&#13;
	var out = "", i = 0, c = 0, d = 0, e = 0, f = 0, w = 0;&#13;
	while (i &lt; orig.length) {&#13;
		c = orig.charCodeAt(i++);&#13;
		if (c &lt; 128) { out += String.fromCharCode(c); continue; }&#13;
		d = orig.charCodeAt(i++);&#13;
		if (c&gt;191 &amp;&amp; c&lt;224) { f = ((c &amp; 31) &lt;&lt; 6); f |= (d &amp; 63); out += String.fromCharCode(f); continue; }&#13;
		e = orig.charCodeAt(i++);&#13;
		if (c &lt; 240) { out += String.fromCharCode(((c &amp; 15) &lt;&lt; 12) | ((d &amp; 63) &lt;&lt; 6) | (e &amp; 63)); continue; }&#13;
		f = orig.charCodeAt(i++);&#13;
		w = (((c &amp; 7) &lt;&lt; 18) | ((d &amp; 63) &lt;&lt; 12) | ((e &amp; 63) &lt;&lt; 6) | (f &amp; 63))-65536;&#13;
		out += String.fromCharCode(0xD800 + ((w&gt;&gt;&gt;10)&amp;1023));&#13;
		out += String.fromCharCode(0xDC00 + (w&amp;1023));&#13;
	}&#13;
	return out;&#13;
}&#13;
&#13;
function utf8readb(data) {&#13;
	var out = new_raw_buf(2*data.length), w, i, j = 1, k = 0, ww=0, c;&#13;
	for(i = 0; i &lt; data.length; i+=j) {&#13;
		j = 1;&#13;
		if((c=data.charCodeAt(i)) &lt; 128) w = c;&#13;
		else if(c &lt; 224) { w = (c&amp;31)*64+(data.charCodeAt(i+1)&amp;63); j=2; }&#13;
		else if(c &lt; 240) { w=(c&amp;15)*4096+(data.charCodeAt(i+1)&amp;63)*64+(data.charCodeAt(i+2)&amp;63); j=3; }&#13;
		else { j = 4;&#13;
			w = (c &amp; 7)*262144+(data.charCodeAt(i+1)&amp;63)*4096+(data.charCodeAt(i+2)&amp;63)*64+(data.charCodeAt(i+3)&amp;63);&#13;
			w -= 65536; ww = 0xD800 + ((w&gt;&gt;&gt;10)&amp;1023); w = 0xDC00 + (w&amp;1023);&#13;
		}&#13;
		if(ww !== 0) { out[k++] = ww&amp;255; out[k++] = ww&gt;&gt;&gt;8; ww = 0; }&#13;
		out[k++] = w%256; out[k++] = w&gt;&gt;&gt;8;&#13;
	}&#13;
	return out.slice(0,k).toString('ucs2');&#13;
}&#13;
&#13;
function utf8readc(data) { return Buffer_from(data, 'binary').toString('utf8'); }&#13;
&#13;
var utf8corpus = "foo bar baz\u00e2\u0098\u0083\u00f0\u009f\u008d\u00a3";&#13;
var utf8read = has_buf &amp;&amp; (utf8readc(utf8corpus) == utf8reada(utf8corpus) &amp;&amp; utf8readc || utf8readb(utf8corpus) == utf8reada(utf8corpus) &amp;&amp; utf8readb) || utf8reada;&#13;
&#13;
var utf8write = has_buf ? function(data) { return Buffer_from(data, 'utf8').toString("binary"); } : function(orig) {&#13;
	var out = [], i = 0, c = 0, d = 0;&#13;
	while(i &lt; orig.length) {&#13;
		c = orig.charCodeAt(i++);&#13;
		switch(true) {&#13;
			case c &lt; 128: out.push(String.fromCharCode(c)); break;&#13;
			case c &lt; 2048:&#13;
				out.push(String.fromCharCode(192 + (c &gt;&gt; 6)));&#13;
				out.push(String.fromCharCode(128 + (c &amp; 63)));&#13;
				break;&#13;
			case c &gt;= 55296 &amp;&amp; c &lt; 57344:&#13;
				c -= 55296; d = orig.charCodeAt(i++) - 56320 + (c&lt;&lt;10);&#13;
				out.push(String.fromCharCode(240 + ((d &gt;&gt;18) &amp; 7)));&#13;
				out.push(String.fromCharCode(144 + ((d &gt;&gt;12) &amp; 63)));&#13;
				out.push(String.fromCharCode(128 + ((d &gt;&gt; 6) &amp; 63)));&#13;
				out.push(String.fromCharCode(128 + (d &amp; 63)));&#13;
				break;&#13;
			default:&#13;
				out.push(String.fromCharCode(224 + (c &gt;&gt; 12)));&#13;
				out.push(String.fromCharCode(128 + ((c &gt;&gt; 6) &amp; 63)));&#13;
				out.push(String.fromCharCode(128 + (c &amp; 63)));&#13;
		}&#13;
	}&#13;
	return out.join("");&#13;
};&#13;
&#13;
// matches &lt;foo&gt;...&lt;/foo&gt; extracts content&#13;
var matchtag = (function() {&#13;
	var mtcache = ({});&#13;
	return function matchtag(f,g) {&#13;
		var t = f+"|"+(g||"");&#13;
		if(mtcache[t]) return mtcache[t];&#13;
		return (mtcache[t] = new RegExp('&lt;(?:\\w+:)?'+f+'(?: xml:space="preserve")?(?:[^&gt;]*)&gt;([\\s\\S]*?)&lt;/(?:\\w+:)?'+f+'&gt;',((g||""))));&#13;
	};&#13;
})();&#13;
&#13;
var htmldecode = (function() {&#13;
	var entities = [&#13;
		['nbsp', ' '], ['middot', '·'],&#13;
		['quot', '"'], ['apos', "'"], ['gt',   '&gt;'], ['lt',   '&lt;'], ['amp',  '&amp;']&#13;
	].map(function(x) { return [new RegExp('&amp;' + x[0] + ';', "ig"), x[1]]; });&#13;
	return function htmldecode(str) {&#13;
		var o = str&#13;
				// Remove new lines and spaces from start of content&#13;
				.replace(/^[\t\n\r ]+/, "")&#13;
				// Remove new lines and spaces from end of content&#13;
				.replace(/[\t\n\r ]+$/,"")&#13;
				// Added line which removes any white space characters after and before html tags&#13;
				.replace(/&gt;\s+/g,"&gt;").replace(/\s+&lt;/g,"&lt;")&#13;
				// Replace remaining new lines and spaces with space&#13;
				.replace(/[\t\n\r ]+/g, " ")&#13;
				// Replace &lt;br&gt; tags with new lines&#13;
				.replace(/&lt;\s*[bB][rR]\s*\/?&gt;/g,"\n")&#13;
				// Strip HTML elements&#13;
				.replace(/&lt;[^&gt;]*&gt;/g,"");&#13;
		for(var i = 0; i &lt; entities.length; ++i) o = o.replace(entities[i][0], entities[i][1]);&#13;
		return o;&#13;
	};&#13;
})();&#13;
&#13;
var vtregex = (function(){ var vt_cache = {};&#13;
	return function vt_regex(bt) {&#13;
		if(vt_cache[bt] !== undefined) return vt_cache[bt];&#13;
		return (vt_cache[bt] = new RegExp("&lt;(?:vt:)?" + bt + "&gt;([\\s\\S]*?)&lt;/(?:vt:)?" + bt + "&gt;", 'g') );&#13;
};})();&#13;
var vtvregex = /&lt;\/?(?:vt:)?variant&gt;/g, vtmregex = /&lt;(?:vt:)([^&gt;]*)&gt;([\s\S]*)&lt;/;&#13;
function parseVector(data, opts) {&#13;
	var h = parsexmltag(data);&#13;
&#13;
	var matches = data.match(vtregex(h.baseType))||[];&#13;
	var res = [];&#13;
	if(matches.length != h.size) {&#13;
		if(opts.WTF) throw new Error("unexpected vector length " + matches.length + " != " + h.size);&#13;
		return res;&#13;
	}&#13;
	matches.forEach(function(x) {&#13;
		var v = x.replace(vtvregex,"").match(vtmregex);&#13;
		if(v) res.push({v:utf8read(v[2]), t:v[1]});&#13;
	});&#13;
	return res;&#13;
}&#13;
&#13;
var wtregex = /(^\s|\s$|\n)/;&#13;
function writetag(f,g) { return '&lt;' + f + (g.match(wtregex)?' xml:space="preserve"' : "") + '&gt;' + g + '&lt;/' + f + '&gt;'; }&#13;
&#13;
function wxt_helper(h) { return keys(h).map(function(k) { return " " + k + '="' + h[k] + '"';}).join(""); }&#13;
function writextag(f,g,h) { return '&lt;' + f + ((h != null) ? wxt_helper(h) : "") + ((g != null) ? (g.match(wtregex)?' xml:space="preserve"' : "") + '&gt;' + g + '&lt;/' + f : "/") + '&gt;';}&#13;
&#13;
function write_w3cdtf(d, t) { try { return d.toISOString().replace(/\.\d*/,""); } catch(e) { if(t) throw e; } return ""; }&#13;
&#13;
function write_vt(s, xlsx) {&#13;
	switch(typeof s) {&#13;
		case 'string':&#13;
			var o = writextag('vt:lpwstr', escapexml(s));&#13;
			if(xlsx) o = o.replace(/&amp;quot;/g, "_x0022_");&#13;
			return o;&#13;
		case 'number': return writextag((s|0)==s?'vt:i4':'vt:r8', escapexml(String(s)));&#13;
		case 'boolean': return writextag('vt:bool',s?'true':'false');&#13;
	}&#13;
	if(s instanceof Date) return writextag('vt:filetime', write_w3cdtf(s));&#13;
	throw new Error("Unable to serialize " + s);&#13;
}&#13;
&#13;
function xlml_normalize(d) {&#13;
	if(has_buf &amp;&amp; Buffer.isBuffer(d)) return d.toString('utf8');&#13;
	if(typeof d === 'string') return d;&#13;
	/* duktape */&#13;
	if(typeof Uint8Array !== 'undefined' &amp;&amp; d instanceof Uint8Array) return utf8read(a2s(ab2a(d)));&#13;
	throw new Error("Bad input format: expected Buffer or string");&#13;
}&#13;
/* UOS uses CJK in tags */&#13;
var xlmlregex = /&lt;(\/?)([^\s?&gt;&lt;!\/:]*:|)([^\s?&lt;&gt;:\/]+)(?:[\s?:\/](?:[^&gt;=]|="[^"]*?")*)?&gt;/mg;&#13;
//var xlmlregex = /&lt;(\/?)([a-z0-9]*:|)(\w+)[^&gt;]*&gt;/mg;&#13;
&#13;
var XMLNS = ({&#13;
	CORE_PROPS: 'http://schemas.openxmlformats.org/package/2006/metadata/core-properties',&#13;
	CUST_PROPS: "http://schemas.openxmlformats.org/officeDocument/2006/custom-properties",&#13;
	EXT_PROPS: "http://schemas.openxmlformats.org/officeDocument/2006/extended-properties",&#13;
	CT: 'http://schemas.openxmlformats.org/package/2006/content-types',&#13;
	RELS: 'http://schemas.openxmlformats.org/package/2006/relationships',&#13;
	TCMNT: 'http://schemas.microsoft.com/office/spreadsheetml/2018/threadedcomments',&#13;
	'dc': 'http://purl.org/dc/elements/1.1/',&#13;
	'dcterms': 'http://purl.org/dc/terms/',&#13;
	'dcmitype': 'http://purl.org/dc/dcmitype/',&#13;
	'mx': 'http://schemas.microsoft.com/office/mac/excel/2008/main',&#13;
	'r': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships',&#13;
	'sjs': 'http://schemas.openxmlformats.org/package/2006/sheetjs/core-properties',&#13;
	'vt': 'http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes',&#13;
	'xsi': 'http://www.w3.org/2001/XMLSchema-instance',&#13;
	'xsd': 'http://www.w3.org/2001/XMLSchema'&#13;
});&#13;
&#13;
var XMLNS_main = [&#13;
	'http://schemas.openxmlformats.org/spreadsheetml/2006/main',&#13;
	'http://purl.oclc.org/ooxml/spreadsheetml/main',&#13;
	'http://schemas.microsoft.com/office/excel/2006/main',&#13;
	'http://schemas.microsoft.com/office/excel/2006/2'&#13;
];&#13;
&#13;
var XLMLNS = ({&#13;
	'o':    'urn:schemas-microsoft-com:office:office',&#13;
	'x':    'urn:schemas-microsoft-com:office:excel',&#13;
	'ss':   'urn:schemas-microsoft-com:office:spreadsheet',&#13;
	'dt':   'uuid:C2F41010-65B3-11d1-A29F-00AA00C14882',&#13;
	'mv':   'http://macVmlSchemaUri',&#13;
	'v':    'urn:schemas-microsoft-com:vml',&#13;
	'html': 'http://www.w3.org/TR/REC-html40'&#13;
});&#13;
function read_double_le(b, idx) {&#13;
	var s = 1 - 2 * (b[idx + 7] &gt;&gt;&gt; 7);&#13;
	var e = ((b[idx + 7] &amp; 0x7f) &lt;&lt; 4) + ((b[idx + 6] &gt;&gt;&gt; 4) &amp; 0x0f);&#13;
	var m = (b[idx+6]&amp;0x0f);&#13;
	for(var i = 5; i &gt;= 0; --i) m = m * 256 + b[idx + i];&#13;
	if(e == 0x7ff) return m == 0 ? (s * Infinity) : NaN;&#13;
	if(e == 0) e = -1022;&#13;
	else { e -= 1023; m += Math.pow(2,52); }&#13;
	return s * Math.pow(2, e - 52) * m;&#13;
}&#13;
&#13;
function write_double_le(b, v, idx) {&#13;
	var bs = ((((v &lt; 0) || (1/v == -Infinity)) ? 1 : 0) &lt;&lt; 7), e = 0, m = 0;&#13;
	var av = bs ? (-v) : v;&#13;
	if(!isFinite(av)) { e = 0x7ff; m = isNaN(v) ? 0x6969 : 0; }&#13;
	else if(av == 0) e = m = 0;&#13;
	else {&#13;
		e = Math.floor(Math.log(av) / Math.LN2);&#13;
		m = av * Math.pow(2, 52 - e);&#13;
		if((e &lt;= -1023) &amp;&amp; (!isFinite(m) || (m &lt; Math.pow(2,52)))) { e = -1022; }&#13;
		else { m -= Math.pow(2,52); e+=1023; }&#13;
	}&#13;
	for(var i = 0; i &lt;= 5; ++i, m/=256) b[idx + i] = m &amp; 0xff;&#13;
	b[idx + 6] = ((e &amp; 0x0f) &lt;&lt; 4) | (m &amp; 0xf);&#13;
	b[idx + 7] = (e &gt;&gt; 4) | bs;&#13;
}&#13;
&#13;
var ___toBuffer = function(bufs) { var x=[],w=10240; for(var i=0;i&lt;bufs[0].length;++i) if(bufs[0][i]) for(var j=0,L=bufs[0][i].length;j&lt;L;j+=w) x.push.apply(x, bufs[0][i].slice(j,j+w)); return x; };&#13;
var __toBuffer = has_buf ? function(bufs) { return (bufs[0].length &gt; 0 &amp;&amp; Buffer.isBuffer(bufs[0][0])) ? Buffer.concat(bufs[0].map(function(x) { return Buffer.isBuffer(x) ? x : Buffer_from(x); })) : ___toBuffer(bufs);} : ___toBuffer;&#13;
&#13;
var ___utf16le = function(b,s,e) { var ss=[]; for(var i=s; i&lt;e; i+=2) ss.push(String.fromCharCode(__readUInt16LE(b,i))); return ss.join("").replace(chr0,''); };&#13;
var __utf16le = has_buf ? function(b,s,e) { if(!Buffer.isBuffer(b) || !buf_utf16le) return ___utf16le(b,s,e); return b.toString('utf16le',s,e).replace(chr0,'')/*.replace(chr1,'!')*/; } : ___utf16le;&#13;
&#13;
var ___hexlify = function(b,s,l) { var ss=[]; for(var i=s; i&lt;s+l; ++i) ss.push(("0" + b[i].toString(16)).slice(-2)); return ss.join(""); };&#13;
var __hexlify = has_buf ? function(b,s,l) { return Buffer.isBuffer(b) ? b.toString('hex',s,s+l) : ___hexlify(b,s,l); } : ___hexlify;&#13;
&#13;
var ___utf8 = function(b,s,e) { var ss=[]; for(var i=s; i&lt;e; i++) ss.push(String.fromCharCode(__readUInt8(b,i))); return ss.join(""); };&#13;
var __utf8 = has_buf ? function utf8_b(b, s, e) { return (Buffer.isBuffer(b)) ? b.toString('utf8',s,e) : ___utf8(b,s,e); } : ___utf8;&#13;
&#13;
var ___lpstr = function(b,i) { var len = __readUInt32LE(b,i); return len &gt; 0 ? __utf8(b, i+4,i+4+len-1) : "";};&#13;
var __lpstr = ___lpstr;&#13;
&#13;
var ___cpstr = function(b,i) { var len = __readUInt32LE(b,i); return len &gt; 0 ? __utf8(b, i+4,i+4+len-1) : "";};&#13;
var __cpstr = ___cpstr;&#13;
&#13;
var ___lpwstr = function(b,i) { var len = 2*__readUInt32LE(b,i); return len &gt; 0 ? __utf8(b, i+4,i+4+len-1) : "";};&#13;
var __lpwstr = ___lpwstr;&#13;
&#13;
var ___lpp4 = function lpp4_(b,i) { var len = __readUInt32LE(b,i); return len &gt; 0 ? __utf16le(b, i+4,i+4+len) : "";};&#13;
var __lpp4 = ___lpp4;&#13;
&#13;
var ___8lpp4 = function(b,i) { var len = __readUInt32LE(b,i); return len &gt; 0 ? __utf8(b, i+4,i+4+len) : "";};&#13;
var __8lpp4 = ___8lpp4;&#13;
&#13;
var ___double = function(b, idx) { return read_double_le(b, idx);};&#13;
var __double = ___double;&#13;
&#13;
var is_buf = function is_buf_a(a) { return Array.isArray(a) || (typeof Uint8Array !== "undefined" &amp;&amp; a instanceof Uint8Array); };&#13;
&#13;
if(has_buf) {&#13;
	__lpstr = function lpstr_b(b, i) { if(!Buffer.isBuffer(b)) return ___lpstr(b, i); var len = b.readUInt32LE(i); return len &gt; 0 ? b.toString('utf8',i+4,i+4+len-1) : "";};&#13;
	__cpstr = function cpstr_b(b, i) { if(!Buffer.isBuffer(b)) return ___cpstr(b, i); var len = b.readUInt32LE(i); return len &gt; 0 ? b.toString('utf8',i+4,i+4+len-1) : "";};&#13;
	__lpwstr = function lpwstr_b(b, i) { if(!Buffer.isBuffer(b) || !buf_utf16le) return ___lpwstr(b, i); var len = 2*b.readUInt32LE(i); return b.toString('utf16le',i+4,i+4+len-1);};&#13;
	__lpp4 = function lpp4_b(b, i) { if(!Buffer.isBuffer(b) || !buf_utf16le) return ___lpp4(b, i); var len = b.readUInt32LE(i); return b.toString('utf16le',i+4,i+4+len);};&#13;
	__8lpp4 = function lpp4_8b(b, i) { if(!Buffer.isBuffer(b)) return ___8lpp4(b, i); var len = b.readUInt32LE(i); return b.toString('utf8',i+4,i+4+len);};&#13;
	__double = function double_(b, i) { if(Buffer.isBuffer(b)) return b.readDoubleLE(i); return ___double(b,i); };&#13;
	is_buf = function is_buf_b(a) { return Buffer.isBuffer(a) || Array.isArray(a) || (typeof Uint8Array !== "undefined" &amp;&amp; a instanceof Uint8Array); };&#13;
}&#13;
&#13;
/* from js-xls */&#13;
function cpdoit() {&#13;
	__utf16le = function(b,s,e) { return $cptable.utils.decode(1200, b.slice(s,e)).replace(chr0, ''); };&#13;
	__utf8 = function(b,s,e) { return $cptable.utils.decode(65001, b.slice(s,e)); };&#13;
	__lpstr = function(b,i) { var len = __readUInt32LE(b,i); return len &gt; 0 ? $cptable.utils.decode(current_ansi, b.slice(i+4, i+4+len-1)) : "";};&#13;
	__cpstr = function(b,i) { var len = __readUInt32LE(b,i); return len &gt; 0 ? $cptable.utils.decode(current_codepage, b.slice(i+4, i+4+len-1)) : "";};&#13;
	__lpwstr = function(b,i) { var len = 2*__readUInt32LE(b,i); return len &gt; 0 ? $cptable.utils.decode(1200, b.slice(i+4,i+4+len-1)) : "";};&#13;
	__lpp4 = function(b,i) { var len = __readUInt32LE(b,i); return len &gt; 0 ? $cptable.utils.decode(1200, b.slice(i+4,i+4+len)) : "";};&#13;
	__8lpp4 = function(b,i) { var len = __readUInt32LE(b,i); return len &gt; 0 ? $cptable.utils.decode(65001, b.slice(i+4,i+4+len)) : "";};&#13;
}&#13;
if(typeof $cptable !== 'undefined') cpdoit();&#13;
&#13;
var __readUInt8 = function(b, idx) { return b[idx]; };&#13;
var __readUInt16LE = function(b, idx) { return (b[idx+1]*(1&lt;&lt;8))+b[idx]; };&#13;
var __readInt16LE = function(b, idx) { var u = (b[idx+1]*(1&lt;&lt;8))+b[idx]; return (u &lt; 0x8000) ? u : ((0xffff - u + 1) * -1); };&#13;
var __readUInt32LE = function(b, idx) { return b[idx+3]*(1&lt;&lt;24)+(b[idx+2]&lt;&lt;16)+(b[idx+1]&lt;&lt;8)+b[idx]; };&#13;
var __readInt32LE = function(b, idx) { return (b[idx+3]&lt;&lt;24)|(b[idx+2]&lt;&lt;16)|(b[idx+1]&lt;&lt;8)|b[idx]; };&#13;
var __readInt32BE = function(b, idx) { return (b[idx]&lt;&lt;24)|(b[idx+1]&lt;&lt;16)|(b[idx+2]&lt;&lt;8)|b[idx+3]; };&#13;
&#13;
function ReadShift(size, t) {&#13;
	var o="", oI, oR, oo=[], w, vv, i, loc;&#13;
	switch(t) {&#13;
		case 'dbcs':&#13;
			loc = this.l;&#13;
			if(has_buf &amp;&amp; Buffer.isBuffer(this)  &amp;&amp; buf_utf16le) o = this.slice(this.l, this.l+2*size).toString("utf16le");&#13;
			else for(i = 0; i &lt; size; ++i) { o+=String.fromCharCode(__readUInt16LE(this, loc)); loc+=2; }&#13;
			size *= 2;&#13;
			break;&#13;
&#13;
		case 'utf8': o = __utf8(this, this.l, this.l + size); break;&#13;
		case 'utf16le': size *= 2; o = __utf16le(this, this.l, this.l + size); break;&#13;
&#13;
		case 'wstr':&#13;
			if(typeof $cptable !== 'undefined') o = $cptable.utils.decode(current_codepage, this.slice(this.l, this.l+2*size));&#13;
			else return ReadShift.call(this, size, 'dbcs');&#13;
			size = 2 * size; break;&#13;
&#13;
		/* [MS-OLEDS] 2.1.4 LengthPrefixedAnsiString */&#13;
		case 'lpstr-ansi': o = __lpstr(this, this.l); size = 4 + __readUInt32LE(this, this.l); break;&#13;
		case 'lpstr-cp': o = __cpstr(this, this.l); size = 4 + __readUInt32LE(this, this.l); break;&#13;
		/* [MS-OLEDS] 2.1.5 LengthPrefixedUnicodeString */&#13;
		case 'lpwstr': o = __lpwstr(this, this.l); size = 4 + 2 * __readUInt32LE(this, this.l); break;&#13;
		/* [MS-OFFCRYPTO] 2.1.2 Length-Prefixed Padded Unicode String (UNICODE-LP-P4) */&#13;
		case 'lpp4': size = 4 +  __readUInt32LE(this, this.l); o = __lpp4(this, this.l); if(size &amp; 0x02) size += 2; break;&#13;
		/* [MS-OFFCRYPTO] 2.1.3 Length-Prefixed UTF-8 String (UTF-8-LP-P4) */&#13;
		case '8lpp4': size = 4 +  __readUInt32LE(this, this.l); o = __8lpp4(this, this.l); if(size &amp; 0x03) size += 4 - (size &amp; 0x03); break;&#13;
&#13;
		case 'cstr': size = 0; o = "";&#13;
			while((w=__readUInt8(this, this.l + size++))!==0) oo.push(_getchar(w));&#13;
			o = oo.join(""); break;&#13;
		case '_wstr': size = 0; o = "";&#13;
			while((w=__readUInt16LE(this,this.l +size))!==0){oo.push(_getchar(w));size+=2;}&#13;
			size+=2; o = oo.join(""); break;&#13;
&#13;
		/* sbcs and dbcs support continue records in the SST way TODO codepages */&#13;
		case 'dbcs-cont': o = ""; loc = this.l;&#13;
			for(i = 0; i &lt; size; ++i) {&#13;
				if(this.lens &amp;&amp; this.lens.indexOf(loc) !== -1) {&#13;
					w = __readUInt8(this, loc);&#13;
					this.l = loc + 1;&#13;
					vv = ReadShift.call(this, size-i, w ? 'dbcs-cont' : 'sbcs-cont');&#13;
					return oo.join("") + vv;&#13;
				}&#13;
				oo.push(_getchar(__readUInt16LE(this, loc)));&#13;
				loc+=2;&#13;
			} o = oo.join(""); size *= 2; break;&#13;
&#13;
		case 'cpstr':&#13;
			if(typeof $cptable !== 'undefined') {&#13;
				o = $cptable.utils.decode(current_codepage, this.slice(this.l, this.l + size));&#13;
				break;&#13;
			}&#13;
		/* falls through */&#13;
		case 'sbcs-cont': o = ""; loc = this.l;&#13;
			for(i = 0; i != size; ++i) {&#13;
				if(this.lens &amp;&amp; this.lens.indexOf(loc) !== -1) {&#13;
					w = __readUInt8(this, loc);&#13;
					this.l = loc + 1;&#13;
					vv = ReadShift.call(this, size-i, w ? 'dbcs-cont' : 'sbcs-cont');&#13;
					return oo.join("") + vv;&#13;
				}&#13;
				oo.push(_getchar(__readUInt8(this, loc)));&#13;
				loc+=1;&#13;
			} o = oo.join(""); break;&#13;
&#13;
		default:&#13;
	switch(size) {&#13;
		case 1: oI = __readUInt8(this, this.l); this.l++; return oI;&#13;
		case 2: oI = (t === 'i' ? __readInt16LE : __readUInt16LE)(this, this.l); this.l += 2; return oI;&#13;
		case 4: case -4:&#13;
			if(t === 'i' || ((this[this.l+3] &amp; 0x80)===0)) { oI = ((size &gt; 0) ? __readInt32LE : __readInt32BE)(this, this.l); this.l += 4; return oI; }&#13;
			else { oR = __readUInt32LE(this, this.l); this.l += 4; } return oR;&#13;
		case 8: case -8:&#13;
			if(t === 'f') {&#13;
				if(size == 8) oR = __double(this, this.l);&#13;
				else oR = __double([this[this.l+7],this[this.l+6],this[this.l+5],this[this.l+4],this[this.l+3],this[this.l+2],this[this.l+1],this[this.l+0]], 0);&#13;
				this.l += 8; return oR;&#13;
			} else size = 8;&#13;
		/* falls through */&#13;
		case 16: o = __hexlify(this, this.l, size); break;&#13;
	}}&#13;
	this.l+=size; return o;&#13;
}&#13;
&#13;
var __writeUInt32LE = function(b, val, idx) { b[idx] = (val &amp; 0xFF); b[idx+1] = ((val &gt;&gt;&gt; 8) &amp; 0xFF); b[idx+2] = ((val &gt;&gt;&gt; 16) &amp; 0xFF); b[idx+3] = ((val &gt;&gt;&gt; 24) &amp; 0xFF); };&#13;
var __writeInt32LE  = function(b, val, idx) { b[idx] = (val &amp; 0xFF); b[idx+1] = ((val &gt;&gt; 8) &amp; 0xFF); b[idx+2] = ((val &gt;&gt; 16) &amp; 0xFF); b[idx+3] = ((val &gt;&gt; 24) &amp; 0xFF); };&#13;
var __writeUInt16LE = function(b, val, idx) { b[idx] = (val &amp; 0xFF); b[idx+1] = ((val &gt;&gt;&gt; 8) &amp; 0xFF); };&#13;
&#13;
function WriteShift(t, val, f) {&#13;
	var size = 0, i = 0;&#13;
	if(f === 'dbcs') {&#13;
for(i = 0; i != val.length; ++i) __writeUInt16LE(this, val.charCodeAt(i), this.l + 2 * i);&#13;
		size = 2 * val.length;&#13;
	} else if(f === 'sbcs' || f == 'cpstr') {&#13;
		if(typeof $cptable !== 'undefined' &amp;&amp; current_ansi == 874) {&#13;
			/* TODO: use tables directly, don't encode */&#13;
for(i = 0; i != val.length; ++i) {&#13;
				var cpp = $cptable.utils.encode(current_ansi, val.charAt(i));&#13;
				this[this.l + i] = cpp[0];&#13;
			}&#13;
			size = val.length;&#13;
		} else if(typeof $cptable !== 'undefined' &amp;&amp; f == 'cpstr') {&#13;
			cpp = $cptable.utils.encode(current_codepage, val);&#13;
			/* replace null bytes with _ when relevant */&#13;
      if(cpp.length == val.length) for(i = 0; i &lt; val.length; ++i) if(cpp[i] == 0 &amp;&amp; val.charCodeAt(i) != 0) cpp[i] = 0x5F;&#13;
      if(cpp.length == 2 * val.length) for(i = 0; i &lt; val.length; ++i) if(cpp[2*i] == 0 &amp;&amp; cpp[2*i+1] == 0 &amp;&amp; val.charCodeAt(i) != 0) cpp[2*i] = 0x5F;&#13;
			for(i = 0; i &lt; cpp.length; ++i) this[this.l + i] = cpp[i];&#13;
			size = cpp.length;&#13;
		} else {&#13;
val = val.replace(/[^\x00-\x7F]/g, "_");&#13;
for(i = 0; i != val.length; ++i) this[this.l + i] = (val.charCodeAt(i) &amp; 0xFF);&#13;
			size = val.length;&#13;
		}&#13;
	} else if(f === 'hex') {&#13;
		for(; i &lt; t; ++i) {&#13;
this[this.l++] = (parseInt(val.slice(2*i, 2*i+2), 16)||0);&#13;
		} return this;&#13;
	} else if(f === 'utf16le') {&#13;
var end = Math.min(this.l + t, this.length);&#13;
			for(i = 0; i &lt; Math.min(val.length, t); ++i) {&#13;
				var cc = val.charCodeAt(i);&#13;
				this[this.l++] = (cc &amp; 0xff);&#13;
				this[this.l++] = (cc &gt;&gt; 8);&#13;
			}&#13;
			while(this.l &lt; end) this[this.l++] = 0;&#13;
			return this;&#13;
	} else  switch(t) {&#13;
		case  1: size = 1; this[this.l] = val&amp;0xFF; break;&#13;
		case  2: size = 2; this[this.l] = val&amp;0xFF; val &gt;&gt;&gt;= 8; this[this.l+1] = val&amp;0xFF; break;&#13;
		case  3: size = 3; this[this.l] = val&amp;0xFF; val &gt;&gt;&gt;= 8; this[this.l+1] = val&amp;0xFF; val &gt;&gt;&gt;= 8; this[this.l+2] = val&amp;0xFF; break;&#13;
		case  4: size = 4; __writeUInt32LE(this, val, this.l); break;&#13;
		case  8: size = 8; if(f === 'f') { write_double_le(this, val, this.l); break; }&#13;
		/* falls through */&#13;
		case 16: break;&#13;
		case -4: size = 4; __writeInt32LE(this, val, this.l); break;&#13;
	}&#13;
	this.l += size; return this;&#13;
}&#13;
&#13;
function CheckField(hexstr, fld) {&#13;
	var m = __hexlify(this,this.l,hexstr.length&gt;&gt;1);&#13;
	if(m !== hexstr) throw new Error(fld + 'Expected ' + hexstr + ' saw ' + m);&#13;
	this.l += hexstr.length&gt;&gt;1;&#13;
}&#13;
&#13;
function prep_blob(blob, pos) {&#13;
	blob.l = pos;&#13;
	blob.read_shift = ReadShift;&#13;
	blob.chk = CheckField;&#13;
	blob.write_shift = WriteShift;&#13;
}&#13;
&#13;
function parsenoop(blob, length) { blob.l += length; }&#13;
&#13;
function new_buf(sz) {&#13;
	var o = new_raw_buf(sz);&#13;
	prep_blob(o, 0);&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.1.4 Record */&#13;
function recordhopper(data, cb, opts) {&#13;
	if(!data) return;&#13;
	var tmpbyte, cntbyte, length;&#13;
	prep_blob(data, data.l || 0);&#13;
	var L = data.length, RT = 0, tgt = 0;&#13;
	while(data.l &lt; L) {&#13;
		RT = data.read_shift(1);&#13;
		if(RT &amp; 0x80) RT = (RT &amp; 0x7F) + ((data.read_shift(1) &amp; 0x7F)&lt;&lt;7);&#13;
		var R = XLSBRecordEnum[RT] || XLSBRecordEnum[0xFFFF];&#13;
		tmpbyte = data.read_shift(1);&#13;
		length = tmpbyte &amp; 0x7F;&#13;
		for(cntbyte = 1; cntbyte &lt;4 &amp;&amp; (tmpbyte &amp; 0x80); ++cntbyte) length += ((tmpbyte = data.read_shift(1)) &amp; 0x7F)&lt;&lt;(7*cntbyte);&#13;
		tgt = data.l + length;&#13;
		var d = R.f &amp;&amp; R.f(data, length, opts);&#13;
		data.l = tgt;&#13;
		if(cb(d, R, RT)) return;&#13;
	}&#13;
}&#13;
&#13;
/* control buffer usage for fixed-length buffers */&#13;
function buf_array() {&#13;
	var bufs = [], blksz = has_buf ? 256 : 2048;&#13;
	var newblk = function ba_newblk(sz) {&#13;
		var o = (new_buf(sz));&#13;
		prep_blob(o, 0);&#13;
		return o;&#13;
	};&#13;
&#13;
	var curbuf = newblk(blksz);&#13;
&#13;
	var endbuf = function ba_endbuf() {&#13;
		if(!curbuf) return;&#13;
		// workaround for new Buffer(3).slice(0,0) bug in bun 0.1.3&#13;
		if(curbuf.l) {&#13;
			if(curbuf.length &gt; curbuf.l) { curbuf = curbuf.slice(0, curbuf.l); curbuf.l = curbuf.length; }&#13;
			if(curbuf.length &gt; 0) bufs.push(curbuf);&#13;
		}&#13;
		curbuf = null;&#13;
	};&#13;
&#13;
	var next = function ba_next(sz) {&#13;
		if(curbuf &amp;&amp; (sz &lt; (curbuf.length - curbuf.l))) return curbuf;&#13;
		endbuf();&#13;
		return (curbuf = newblk(Math.max(sz+1, blksz)));&#13;
	};&#13;
&#13;
	var end = function ba_end() {&#13;
		endbuf();&#13;
		return bconcat(bufs);&#13;
	};&#13;
&#13;
	var push = function ba_push(buf) { endbuf(); curbuf = buf; if(curbuf.l == null) curbuf.l = curbuf.length; next(blksz); };&#13;
&#13;
	return ({ next:next, push:push, end:end, _bufs:bufs });&#13;
}&#13;
&#13;
function write_record(ba, type, payload, length) {&#13;
	var t = +type, l;&#13;
	if(isNaN(t)) return; // TODO: throw something here?&#13;
	if(!length) length = XLSBRecordEnum[t].p || (payload||[]).length || 0;&#13;
	l = 1 + (t &gt;= 0x80 ? 1 : 0) + 1/* + length*/;&#13;
	if(length &gt;= 0x80) ++l; if(length &gt;= 0x4000) ++l; if(length &gt;= 0x200000) ++l;&#13;
	var o = ba.next(l);&#13;
	if(t &lt;= 0x7F) o.write_shift(1, t);&#13;
	else {&#13;
		o.write_shift(1, (t &amp; 0x7F) + 0x80);&#13;
		o.write_shift(1, (t &gt;&gt; 7));&#13;
	}&#13;
	for(var i = 0; i != 4; ++i) {&#13;
		if(length &gt;= 0x80) { o.write_shift(1, (length &amp; 0x7F)+0x80); length &gt;&gt;= 7; }&#13;
		else { o.write_shift(1, length); break; }&#13;
	}&#13;
	if(length &gt; 0 &amp;&amp; is_buf(payload)) ba.push(payload);&#13;
}&#13;
/* XLS ranges enforced */&#13;
function shift_cell_xls(cell, tgt, opts) {&#13;
	var out = dup(cell);&#13;
	if(tgt.s) {&#13;
		if(out.cRel) out.c += tgt.s.c;&#13;
		if(out.rRel) out.r += tgt.s.r;&#13;
	} else {&#13;
		if(out.cRel) out.c += tgt.c;&#13;
		if(out.rRel) out.r += tgt.r;&#13;
	}&#13;
	if(!opts || opts.biff &lt; 12) {&#13;
		while(out.c &gt;= 0x100) out.c -= 0x100;&#13;
		while(out.r &gt;= 0x10000) out.r -= 0x10000;&#13;
	}&#13;
	return out;&#13;
}&#13;
&#13;
function shift_range_xls(cell, range, opts) {&#13;
	var out = dup(cell);&#13;
	out.s = shift_cell_xls(out.s, range.s, opts);&#13;
	out.e = shift_cell_xls(out.e, range.s, opts);&#13;
	return out;&#13;
}&#13;
&#13;
function encode_cell_xls(c, biff) {&#13;
	if(c.cRel &amp;&amp; c.c &lt; 0) { c = dup(c); while(c.c &lt; 0) c.c += (biff &gt; 8) ? 0x4000 : 0x100; }&#13;
	if(c.rRel &amp;&amp; c.r &lt; 0) { c = dup(c); while(c.r &lt; 0) c.r += (biff &gt; 8) ? 0x100000 : ((biff &gt; 5) ? 0x10000 : 0x4000); }&#13;
	var s = encode_cell(c);&#13;
	if(!c.cRel &amp;&amp; c.cRel != null) s = fix_col(s);&#13;
	if(!c.rRel &amp;&amp; c.rRel != null) s = fix_row(s);&#13;
	return s;&#13;
}&#13;
&#13;
function encode_range_xls(r, opts) {&#13;
	if(r.s.r == 0 &amp;&amp; !r.s.rRel) {&#13;
		if(r.e.r == (opts.biff &gt;= 12 ? 0xFFFFF : (opts.biff &gt;= 8 ? 0x10000 : 0x4000)) &amp;&amp; !r.e.rRel) {&#13;
			return (r.s.cRel ? "" : "$") + encode_col(r.s.c) + ":" + (r.e.cRel ? "" : "$") + encode_col(r.e.c);&#13;
		}&#13;
	}&#13;
	if(r.s.c == 0 &amp;&amp; !r.s.cRel) {&#13;
		if(r.e.c == (opts.biff &gt;= 12 ? 0x3FFF : 0xFF) &amp;&amp; !r.e.cRel) {&#13;
			return (r.s.rRel ? "" : "$") + encode_row(r.s.r) + ":" + (r.e.rRel ? "" : "$") + encode_row(r.e.r);&#13;
		}&#13;
	}&#13;
	return encode_cell_xls(r.s, opts.biff) + ":" + encode_cell_xls(r.e, opts.biff);&#13;
}&#13;
if(typeof cptable !== 'undefined') set_cptable(cptable);&#13;
else if(typeof module !== "undefined" &amp;&amp; typeof require !== 'undefined') {&#13;
	set_cptable(require('./dist/cpexcel.js'));&#13;
}&#13;
function decode_row(rowstr) { return parseInt(unfix_row(rowstr),10) - 1; }&#13;
function encode_row(row) { return "" + (row + 1); }&#13;
function fix_row(cstr) { return cstr.replace(/([A-Z]|^)(\d+)$/,"$1$$$2"); }&#13;
function unfix_row(cstr) { return cstr.replace(/\$(\d+)$/,"$1"); }&#13;
&#13;
function decode_col(colstr) { var c = unfix_col(colstr), d = 0, i = 0; for(; i !== c.length; ++i) d = 26*d + c.charCodeAt(i) - 64; return d - 1; }&#13;
function encode_col(col) { if(col &lt; 0) throw new Error("invalid column " + col); var s=""; for(++col; col; col=Math.floor((col-1)/26)) s = String.fromCharCode(((col-1)%26) + 65) + s; return s; }&#13;
function fix_col(cstr) { return cstr.replace(/^([A-Z])/,"$$$1"); }&#13;
function unfix_col(cstr) { return cstr.replace(/^\$([A-Z])/,"$1"); }&#13;
&#13;
function split_cell(cstr) { return cstr.replace(/(\$?[A-Z]*)(\$?\d*)/,"$1,$2").split(","); }&#13;
//function decode_cell(cstr) { var splt = split_cell(cstr); return { c:decode_col(splt[0]), r:decode_row(splt[1]) }; }&#13;
function decode_cell(cstr) {&#13;
	var R = 0, C = 0;&#13;
	for(var i = 0; i &lt; cstr.length; ++i) {&#13;
		var cc = cstr.charCodeAt(i);&#13;
		if(cc &gt;= 48 &amp;&amp; cc &lt;= 57) R = 10 * R + (cc - 48);&#13;
		else if(cc &gt;= 65 &amp;&amp; cc &lt;= 90) C = 26 * C + (cc - 64);&#13;
	}&#13;
	return { c: C - 1, r:R - 1 };&#13;
}&#13;
//function encode_cell(cell) { return encode_col(cell.c) + encode_row(cell.r); }&#13;
function encode_cell(cell) {&#13;
	var col = cell.c + 1;&#13;
	var s="";&#13;
	for(; col; col=((col-1)/26)|0) s = String.fromCharCode(((col-1)%26) + 65) + s;&#13;
	return s + (cell.r + 1);&#13;
}&#13;
function decode_range(range) {&#13;
	var idx = range.indexOf(":");&#13;
	if(idx == -1) return { s: decode_cell(range), e: decode_cell(range) };&#13;
	return { s: decode_cell(range.slice(0, idx)), e: decode_cell(range.slice(idx + 1)) };&#13;
}&#13;
function encode_range(cs,ce) {&#13;
	if(typeof ce === 'undefined' || typeof ce === 'number') {&#13;
return encode_range(cs.s, cs.e);&#13;
	}&#13;
if(typeof cs !== 'string') cs = encode_cell((cs));&#13;
	if(typeof ce !== 'string') ce = encode_cell((ce));&#13;
return cs == ce ? cs : cs + ":" + ce;&#13;
}&#13;
function fix_range(a1) {&#13;
	var s = decode_range(a1);&#13;
	return "$" + encode_col(s.s.c) + "$" + encode_row(s.s.r) + ":$" + encode_col(s.e.c) + "$" + encode_row(s.e.r);&#13;
}&#13;
&#13;
// List of invalid characters needs to be tested further&#13;
function formula_quote_sheet_name(sname, opts) {&#13;
	if(!sname &amp;&amp; !(opts &amp;&amp; opts.biff &lt;= 5 &amp;&amp; opts.biff &gt;= 2)) throw new Error("empty sheet name");&#13;
	if (/[^\w\u4E00-\u9FFF\u3040-\u30FF]/.test(sname)) return "'" + sname.replace(/'/g, "''") + "'";&#13;
	return sname;&#13;
}&#13;
&#13;
function safe_decode_range(range) {&#13;
	var o = {s:{c:0,r:0},e:{c:0,r:0}};&#13;
	var idx = 0, i = 0, cc = 0;&#13;
	var len = range.length;&#13;
	for(idx = 0; i &lt; len; ++i) {&#13;
		if((cc=range.charCodeAt(i)-64) &lt; 1 || cc &gt; 26) break;&#13;
		idx = 26*idx + cc;&#13;
	}&#13;
	o.s.c = --idx;&#13;
&#13;
	for(idx = 0; i &lt; len; ++i) {&#13;
		if((cc=range.charCodeAt(i)-48) &lt; 0 || cc &gt; 9) break;&#13;
		idx = 10*idx + cc;&#13;
	}&#13;
	o.s.r = --idx;&#13;
&#13;
	if(i === len || cc != 10) { o.e.c=o.s.c; o.e.r=o.s.r; return o; }&#13;
	++i;&#13;
&#13;
	for(idx = 0; i != len; ++i) {&#13;
		if((cc=range.charCodeAt(i)-64) &lt; 1 || cc &gt; 26) break;&#13;
		idx = 26*idx + cc;&#13;
	}&#13;
	o.e.c = --idx;&#13;
&#13;
	for(idx = 0; i != len; ++i) {&#13;
		if((cc=range.charCodeAt(i)-48) &lt; 0 || cc &gt; 9) break;&#13;
		idx = 10*idx + cc;&#13;
	}&#13;
	o.e.r = --idx;&#13;
	return o;&#13;
}&#13;
&#13;
function safe_format_cell(cell, v) {&#13;
	var q = (cell.t == 'd' &amp;&amp; v instanceof Date);&#13;
	if(cell.z != null) try { return (cell.w = SSF_format(cell.z, q ? datenum(v) : v)); } catch(e) { }&#13;
	try { return (cell.w = SSF_format((cell.XF||{}).numFmtId||(q ? 14 : 0),  q ? datenum(v) : v)); } catch(e) { return ''+v; }&#13;
}&#13;
&#13;
function format_cell(cell, v, o) {&#13;
	if(cell == null || cell.t == null || cell.t == 'z') return "";&#13;
	if(cell.w !== undefined) return cell.w;&#13;
	if(cell.t == 'd' &amp;&amp; !cell.z &amp;&amp; o &amp;&amp; o.dateNF) cell.z = o.dateNF;&#13;
	if(cell.t == "e") return BErr[cell.v] || cell.v;&#13;
	if(v == undefined) return safe_format_cell(cell, cell.v);&#13;
	return safe_format_cell(cell, v);&#13;
}&#13;
&#13;
function sheet_to_workbook(sheet, opts) {&#13;
	var n = opts &amp;&amp; opts.sheet ? opts.sheet : "Sheet1";&#13;
	var sheets = {}; sheets[n] = sheet;&#13;
	return { SheetNames: [n], Sheets: sheets };&#13;
}&#13;
&#13;
function sheet_add_aoa(_ws, data, opts) {&#13;
	var o = opts || {};&#13;
	var dense = _ws ? Array.isArray(_ws) : o.dense;&#13;
	if(DENSE != null &amp;&amp; dense == null) dense = DENSE;&#13;
	var ws = _ws || (dense ? ([]) : ({}));&#13;
	var _R = 0, _C = 0;&#13;
	if(ws &amp;&amp; o.origin != null) {&#13;
		if(typeof o.origin == 'number') _R = o.origin;&#13;
		else {&#13;
			var _origin = typeof o.origin == "string" ? decode_cell(o.origin) : o.origin;&#13;
			_R = _origin.r; _C = _origin.c;&#13;
		}&#13;
		if(!ws["!ref"]) ws["!ref"] = "A1:A1";&#13;
	}&#13;
	var range = ({s: {c:10000000, r:10000000}, e: {c:0, r:0}});&#13;
	if(ws['!ref']) {&#13;
		var _range = safe_decode_range(ws['!ref']);&#13;
		range.s.c = _range.s.c;&#13;
		range.s.r = _range.s.r;&#13;
		range.e.c = Math.max(range.e.c, _range.e.c);&#13;
		range.e.r = Math.max(range.e.r, _range.e.r);&#13;
		if(_R == -1) range.e.r = _R = _range.e.r + 1;&#13;
	}&#13;
	for(var R = 0; R != data.length; ++R) {&#13;
		if(!data[R]) continue;&#13;
		if(!Array.isArray(data[R])) throw new Error("aoa_to_sheet expects an array of arrays");&#13;
		for(var C = 0; C != data[R].length; ++C) {&#13;
			if(typeof data[R][C] === 'undefined') continue;&#13;
			var cell = ({v: data[R][C] });&#13;
			var __R = _R + R, __C = _C + C;&#13;
			if(range.s.r &gt; __R) range.s.r = __R;&#13;
			if(range.s.c &gt; __C) range.s.c = __C;&#13;
			if(range.e.r &lt; __R) range.e.r = __R;&#13;
			if(range.e.c &lt; __C) range.e.c = __C;&#13;
			if(data[R][C] &amp;&amp; typeof data[R][C] === 'object' &amp;&amp; !Array.isArray(data[R][C]) &amp;&amp; !(data[R][C] instanceof Date)) cell = data[R][C];&#13;
			else {&#13;
				if(Array.isArray(cell.v)) { cell.f = data[R][C][1]; cell.v = cell.v[0]; }&#13;
				if(cell.v === null) {&#13;
					if(cell.f) cell.t = 'n';&#13;
					else if(o.nullError) { cell.t = 'e'; cell.v = 0; }&#13;
					else if(!o.sheetStubs) continue;&#13;
					else cell.t = 'z';&#13;
				}&#13;
				else if(typeof cell.v === 'number') cell.t = 'n';&#13;
				else if(typeof cell.v === 'boolean') cell.t = 'b';&#13;
				else if(cell.v instanceof Date) {&#13;
					cell.z = o.dateNF || table_fmt[14];&#13;
					if(o.cellDates) { cell.t = 'd'; cell.w = SSF_format(cell.z, datenum(cell.v, o.date1904)); }&#13;
					else { cell.t = 'n'; cell.v = datenum(cell.v, o.date1904); cell.w = SSF_format(cell.z, cell.v); }&#13;
				}&#13;
				else cell.t = 's';&#13;
			}&#13;
			if(dense) {&#13;
				if(!ws[__R]) ws[__R] = [];&#13;
				if(ws[__R][__C] &amp;&amp; ws[__R][__C].z) cell.z = ws[__R][__C].z;&#13;
				ws[__R][__C] = cell;&#13;
			} else {&#13;
				var cell_ref = encode_cell(({c:__C,r:__R}));&#13;
				if(ws[cell_ref] &amp;&amp; ws[cell_ref].z) cell.z = ws[cell_ref].z;&#13;
				ws[cell_ref] = cell;&#13;
			}&#13;
		}&#13;
	}&#13;
	if(range.s.c &lt; 10000000) ws['!ref'] = encode_range(range);&#13;
	return ws;&#13;
}&#13;
function aoa_to_sheet(data, opts) { return sheet_add_aoa(null, data, opts); }&#13;
&#13;
function parse_Int32LE(data) {&#13;
	return data.read_shift(4, 'i');&#13;
}&#13;
function write_UInt32LE(x, o) {&#13;
	if (!o) o = new_buf(4);&#13;
	o.write_shift(4, x);&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.5.168 */&#13;
function parse_XLWideString(data) {&#13;
	var cchCharacters = data.read_shift(4);&#13;
	return cchCharacters === 0 ? "" : data.read_shift(cchCharacters, 'dbcs');&#13;
}&#13;
function write_XLWideString(data, o) {&#13;
	var _null = false; if (o == null) { _null = true; o = new_buf(4 + 2 * data.length); }&#13;
	o.write_shift(4, data.length);&#13;
	if (data.length &gt; 0) o.write_shift(0, data, 'dbcs');&#13;
	return _null ? o.slice(0, o.l) : o;&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.5.91 */&#13;
//function parse_LPWideString(data) {&#13;
//	var cchCharacters = data.read_shift(2);&#13;
//	return cchCharacters === 0 ? "" : data.read_shift(cchCharacters, "utf16le");&#13;
//}&#13;
&#13;
/* [MS-XLSB] 2.5.143 */&#13;
function parse_StrRun(data) {&#13;
	return { ich: data.read_shift(2), ifnt: data.read_shift(2) };&#13;
}&#13;
function write_StrRun(run, o) {&#13;
	if (!o) o = new_buf(4);&#13;
	o.write_shift(2, run.ich || 0);&#13;
	o.write_shift(2, run.ifnt || 0);&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.5.121 */&#13;
function parse_RichStr(data, length) {&#13;
	var start = data.l;&#13;
	var flags = data.read_shift(1);&#13;
	var str = parse_XLWideString(data);&#13;
	var rgsStrRun = [];&#13;
	var z = ({ t: str, h: str });&#13;
	if ((flags &amp; 1) !== 0) { /* fRichStr */&#13;
		/* TODO: formatted string */&#13;
		var dwSizeStrRun = data.read_shift(4);&#13;
		for (var i = 0; i != dwSizeStrRun; ++i) rgsStrRun.push(parse_StrRun(data));&#13;
		z.r = rgsStrRun;&#13;
	}&#13;
	else z.r = [{ ich: 0, ifnt: 0 }];&#13;
	//if((flags &amp; 2) !== 0) { /* fExtStr */&#13;
	//	/* TODO: phonetic string */&#13;
	//}&#13;
	data.l = start + length;&#13;
	return z;&#13;
}&#13;
function write_RichStr(str, o) {&#13;
	/* TODO: formatted string */&#13;
	var _null = false; if (o == null) { _null = true; o = new_buf(15 + 4 * str.t.length); }&#13;
	o.write_shift(1, 0);&#13;
	write_XLWideString(str.t, o);&#13;
	return _null ? o.slice(0, o.l) : o;&#13;
}&#13;
/* [MS-XLSB] 2.4.328 BrtCommentText (RichStr w/1 run) */&#13;
var parse_BrtCommentText = parse_RichStr;&#13;
function write_BrtCommentText(str, o) {&#13;
	/* TODO: formatted string */&#13;
	var _null = false; if (o == null) { _null = true; o = new_buf(23 + 4 * str.t.length); }&#13;
	o.write_shift(1, 1);&#13;
	write_XLWideString(str.t, o);&#13;
	o.write_shift(4, 1);&#13;
	write_StrRun({ ich: 0, ifnt: 0 }, o);&#13;
	return _null ? o.slice(0, o.l) : o;&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.5.9 */&#13;
function parse_XLSBCell(data) {&#13;
	var col = data.read_shift(4);&#13;
	var iStyleRef = data.read_shift(2);&#13;
	iStyleRef += data.read_shift(1) &lt;&lt; 16;&#13;
	data.l++; //var fPhShow = data.read_shift(1);&#13;
	return { c: col, iStyleRef: iStyleRef };&#13;
}&#13;
function write_XLSBCell(cell, o) {&#13;
	if (o == null) o = new_buf(8);&#13;
	o.write_shift(-4, cell.c);&#13;
	o.write_shift(3, cell.iStyleRef || cell.s);&#13;
	o.write_shift(1, 0); /* fPhShow */&#13;
	return o;&#13;
}&#13;
&#13;
/* Short XLSB Cell does not include column */&#13;
function parse_XLSBShortCell(data) {&#13;
	var iStyleRef = data.read_shift(2);&#13;
	iStyleRef += data.read_shift(1) &lt;&lt;16;&#13;
	data.l++; //var fPhShow = data.read_shift(1);&#13;
	return { c:-1, iStyleRef: iStyleRef };&#13;
}&#13;
function write_XLSBShortCell(cell, o) {&#13;
	if(o == null) o = new_buf(4);&#13;
	o.write_shift(3, cell.iStyleRef || cell.s);&#13;
	o.write_shift(1, 0); /* fPhShow */&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.5.21 */&#13;
var parse_XLSBCodeName = parse_XLWideString;&#13;
var write_XLSBCodeName = write_XLWideString;&#13;
&#13;
/* [MS-XLSB] 2.5.166 */&#13;
function parse_XLNullableWideString(data) {&#13;
	var cchCharacters = data.read_shift(4);&#13;
	return cchCharacters === 0 || cchCharacters === 0xFFFFFFFF ? "" : data.read_shift(cchCharacters, 'dbcs');&#13;
}&#13;
function write_XLNullableWideString(data, o) {&#13;
	var _null = false; if (o == null) { _null = true; o = new_buf(127); }&#13;
	o.write_shift(4, data.length &gt; 0 ? data.length : 0xFFFFFFFF);&#13;
	if (data.length &gt; 0) o.write_shift(0, data, 'dbcs');&#13;
	return _null ? o.slice(0, o.l) : o;&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.5.165 */&#13;
var parse_XLNameWideString = parse_XLWideString;&#13;
//var write_XLNameWideString = write_XLWideString;&#13;
&#13;
/* [MS-XLSB] 2.5.114 */&#13;
var parse_RelID = parse_XLNullableWideString;&#13;
var write_RelID = write_XLNullableWideString;&#13;
&#13;
&#13;
/* [MS-XLS] 2.5.217 ; [MS-XLSB] 2.5.122 */&#13;
function parse_RkNumber(data) {&#13;
	var b = data.slice(data.l, data.l + 4);&#13;
	var fX100 = (b[0] &amp; 1), fInt = (b[0] &amp; 2);&#13;
	data.l += 4;&#13;
	var RK = fInt === 0 ? __double([0, 0, 0, 0, (b[0] &amp; 0xFC), b[1], b[2], b[3]], 0) : __readInt32LE(b, 0) &gt;&gt; 2;&#13;
	return fX100 ? (RK / 100) : RK;&#13;
}&#13;
function write_RkNumber(data, o) {&#13;
	if (o == null) o = new_buf(4);&#13;
	var fX100 = 0, fInt = 0, d100 = data * 100;&#13;
	if ((data == (data | 0)) &amp;&amp; (data &gt;= -(1 &lt;&lt; 29)) &amp;&amp; (data &lt; (1 &lt;&lt; 29))) { fInt = 1; }&#13;
	else if ((d100 == (d100 | 0)) &amp;&amp; (d100 &gt;= -(1 &lt;&lt; 29)) &amp;&amp; (d100 &lt; (1 &lt;&lt; 29))) { fInt = 1; fX100 = 1; }&#13;
	if (fInt) o.write_shift(-4, ((fX100 ? d100 : data) &lt;&lt; 2) + (fX100 + 2));&#13;
	else throw new Error("unsupported RkNumber " + data); // TODO&#13;
}&#13;
&#13;
&#13;
/* [MS-XLSB] 2.5.117 RfX */&#13;
function parse_RfX(data ) {&#13;
	var cell = ({ s: {}, e: {} });&#13;
	cell.s.r = data.read_shift(4);&#13;
	cell.e.r = data.read_shift(4);&#13;
	cell.s.c = data.read_shift(4);&#13;
	cell.e.c = data.read_shift(4);&#13;
	return cell;&#13;
}&#13;
function write_RfX(r, o) {&#13;
	if (!o) o = new_buf(16);&#13;
	o.write_shift(4, r.s.r);&#13;
	o.write_shift(4, r.e.r);&#13;
	o.write_shift(4, r.s.c);&#13;
	o.write_shift(4, r.e.c);&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.5.153 UncheckedRfX */&#13;
var parse_UncheckedRfX = parse_RfX;&#13;
var write_UncheckedRfX = write_RfX;&#13;
&#13;
/* [MS-XLSB] 2.5.155 UncheckedSqRfX */&#13;
//function parse_UncheckedSqRfX(data) {&#13;
//	var cnt = data.read_shift(4);&#13;
//	var out = [];&#13;
//	for(var i = 0; i &lt; cnt; ++i) {&#13;
//		var rng = parse_UncheckedRfX(data);&#13;
//		out.push(encode_range(rng));&#13;
//	}&#13;
//	return out.join(",");&#13;
//}&#13;
//function write_UncheckedSqRfX(sqrfx) {&#13;
//	var parts = sqrfx.split(/\s*,\s*/);&#13;
//	var o = new_buf(4); o.write_shift(4, parts.length);&#13;
//	var out = [o];&#13;
//	parts.forEach(function(rng) {&#13;
//		out.push(write_UncheckedRfX(safe_decode_range(rng)));&#13;
//	});&#13;
//	return bconcat(out);&#13;
//}&#13;
&#13;
/* [MS-XLS] 2.5.342 ; [MS-XLSB] 2.5.171 */&#13;
/* TODO: error checking, NaN and Infinity values are not valid Xnum */&#13;
function parse_Xnum(data) {&#13;
	if(data.length - data.l &lt; 8) throw "XLS Xnum Buffer underflow";&#13;
	return data.read_shift(8, 'f');&#13;
}&#13;
function write_Xnum(data, o) { return (o || new_buf(8)).write_shift(8, data, 'f'); }&#13;
&#13;
/* [MS-XLSB] 2.4.324 BrtColor */&#13;
function parse_BrtColor(data) {&#13;
	var out = {};&#13;
	var d = data.read_shift(1);&#13;
&#13;
	//var fValidRGB = d &amp; 1;&#13;
	var xColorType = d &gt;&gt;&gt; 1;&#13;
&#13;
	var index = data.read_shift(1);&#13;
	var nTS = data.read_shift(2, 'i');&#13;
	var bR = data.read_shift(1);&#13;
	var bG = data.read_shift(1);&#13;
	var bB = data.read_shift(1);&#13;
	data.l++; //var bAlpha = data.read_shift(1);&#13;
&#13;
	switch (xColorType) {&#13;
		case 0: out.auto = 1; break;&#13;
		case 1:&#13;
			out.index = index;&#13;
			var icv = XLSIcv[index];&#13;
			/* automatic pseudo index 81 */&#13;
			if (icv) out.rgb = rgb2Hex(icv);&#13;
			break;&#13;
		case 2:&#13;
			/* if(!fValidRGB) throw new Error("invalid"); */&#13;
			out.rgb = rgb2Hex([bR, bG, bB]);&#13;
			break;&#13;
		case 3: out.theme = index; break;&#13;
	}&#13;
	if (nTS != 0) out.tint = nTS &gt; 0 ? nTS / 32767 : nTS / 32768;&#13;
&#13;
	return out;&#13;
}&#13;
function write_BrtColor(color, o) {&#13;
	if (!o) o = new_buf(8);&#13;
	if (!color || color.auto) { o.write_shift(4, 0); o.write_shift(4, 0); return o; }&#13;
	if (color.index != null) {&#13;
		o.write_shift(1, 0x02);&#13;
		o.write_shift(1, color.index);&#13;
	} else if (color.theme != null) {&#13;
		o.write_shift(1, 0x06);&#13;
		o.write_shift(1, color.theme);&#13;
	} else {&#13;
		o.write_shift(1, 0x05);&#13;
		o.write_shift(1, 0);&#13;
	}&#13;
	var nTS = color.tint || 0;&#13;
	if (nTS &gt; 0) nTS *= 32767;&#13;
	else if (nTS &lt; 0) nTS *= 32768;&#13;
	o.write_shift(2, nTS);&#13;
	if (!color.rgb || color.theme != null) {&#13;
		o.write_shift(2, 0);&#13;
		o.write_shift(1, 0);&#13;
		o.write_shift(1, 0);&#13;
	} else {&#13;
		var rgb = (color.rgb || 'FFFFFF');&#13;
		if (typeof rgb == 'number') rgb = ("000000" + rgb.toString(16)).slice(-6);&#13;
		o.write_shift(1, parseInt(rgb.slice(0, 2), 16));&#13;
		o.write_shift(1, parseInt(rgb.slice(2, 4), 16));&#13;
		o.write_shift(1, parseInt(rgb.slice(4, 6), 16));&#13;
		o.write_shift(1, 0xFF);&#13;
	}&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.5.52 */&#13;
function parse_FontFlags(data) {&#13;
	var d = data.read_shift(1);&#13;
	data.l++;&#13;
	var out = {&#13;
		fBold: d &amp; 0x01,&#13;
		fItalic: d &amp; 0x02,&#13;
		fUnderline: d &amp; 0x04,&#13;
		fStrikeout: d &amp; 0x08,&#13;
		fOutline: d &amp; 0x10,&#13;
		fShadow: d &amp; 0x20,&#13;
		fCondense: d &amp; 0x40,&#13;
		fExtend: d &amp; 0x80&#13;
	};&#13;
	return out;&#13;
}&#13;
function write_FontFlags(font, o) {&#13;
	if (!o) o = new_buf(2);&#13;
	var grbit =&#13;
		(font.italic ? 0x02 : 0) |&#13;
		(font.strike ? 0x08 : 0) |&#13;
		(font.outline ? 0x10 : 0) |&#13;
		(font.shadow ? 0x20 : 0) |&#13;
		(font.condense ? 0x40 : 0) |&#13;
		(font.extend ? 0x80 : 0);&#13;
	o.write_shift(1, grbit);&#13;
	o.write_shift(1, 0);&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-OLEDS] 2.3.1 and 2.3.2 */&#13;
function parse_ClipboardFormatOrString(o, w) {&#13;
	// $FlowIgnore&#13;
	var ClipFmt = { 2: "BITMAP", 3: "METAFILEPICT", 8: "DIB", 14: "ENHMETAFILE" };&#13;
	var m = o.read_shift(4);&#13;
	switch (m) {&#13;
		case 0x00000000: return "";&#13;
		case 0xffffffff: case 0xfffffffe: return ClipFmt[o.read_shift(4)] || "";&#13;
	}&#13;
	if (m &gt; 0x190) throw new Error("Unsupported Clipboard: " + m.toString(16));&#13;
	o.l -= 4;&#13;
	return o.read_shift(0, w == 1 ? "lpstr" : "lpwstr");&#13;
}&#13;
function parse_ClipboardFormatOrAnsiString(o) { return parse_ClipboardFormatOrString(o, 1); }&#13;
function parse_ClipboardFormatOrUnicodeString(o) { return parse_ClipboardFormatOrString(o, 2); }&#13;
&#13;
/* [MS-OLEPS] 2.2 PropertyType */&#13;
// Note: some tree shakers cannot handle VT_VECTOR | $CONST, hence extra vars&#13;
//var VT_EMPTY    = 0x0000;&#13;
//var VT_NULL     = 0x0001;&#13;
var VT_I2       = 0x0002;&#13;
var VT_I4       = 0x0003;&#13;
//var VT_R4       = 0x0004;&#13;
//var VT_R8       = 0x0005;&#13;
//var VT_CY       = 0x0006;&#13;
//var VT_DATE     = 0x0007;&#13;
//var VT_BSTR     = 0x0008;&#13;
//var VT_ERROR    = 0x000A;&#13;
var VT_BOOL     = 0x000B;&#13;
var VT_VARIANT  = 0x000C;&#13;
//var VT_DECIMAL  = 0x000E;&#13;
//var VT_I1       = 0x0010;&#13;
//var VT_UI1      = 0x0011;&#13;
//var VT_UI2      = 0x0012;&#13;
var VT_UI4      = 0x0013;&#13;
//var VT_I8       = 0x0014;&#13;
//var VT_UI8      = 0x0015;&#13;
//var VT_INT      = 0x0016;&#13;
//var VT_UINT     = 0x0017;&#13;
//var VT_LPSTR    = 0x001E;&#13;
//var VT_LPWSTR   = 0x001F;&#13;
var VT_FILETIME = 0x0040;&#13;
var VT_BLOB     = 0x0041;&#13;
//var VT_STREAM   = 0x0042;&#13;
//var VT_STORAGE  = 0x0043;&#13;
//var VT_STREAMED_Object  = 0x0044;&#13;
//var VT_STORED_Object    = 0x0045;&#13;
//var VT_BLOB_Object      = 0x0046;&#13;
var VT_CF       = 0x0047;&#13;
//var VT_CLSID    = 0x0048;&#13;
//var VT_VERSIONED_STREAM = 0x0049;&#13;
//var VT_VECTOR   = 0x1000;&#13;
var VT_VECTOR_VARIANT = 0x100C;&#13;
var VT_VECTOR_LPSTR   = 0x101E;&#13;
//var VT_ARRAY    = 0x2000;&#13;
&#13;
var VT_STRING   = 0x0050; // 2.3.3.1.11 VtString&#13;
var VT_USTR     = 0x0051; // 2.3.3.1.12 VtUnalignedString&#13;
var VT_CUSTOM   = [VT_STRING, VT_USTR];&#13;
&#13;
/* [MS-OSHARED] 2.3.3.2.2.1 Document Summary Information PIDDSI */&#13;
var DocSummaryPIDDSI = {&#13;
0x01: { n: 'CodePage', t: VT_I2 },&#13;
0x02: { n: 'Category', t: VT_STRING },&#13;
0x03: { n: 'PresentationFormat', t: VT_STRING },&#13;
0x04: { n: 'ByteCount', t: VT_I4 },&#13;
0x05: { n: 'LineCount', t: VT_I4 },&#13;
0x06: { n: 'ParagraphCount', t: VT_I4 },&#13;
0x07: { n: 'SlideCount', t: VT_I4 },&#13;
0x08: { n: 'NoteCount', t: VT_I4 },&#13;
0x09: { n: 'HiddenCount', t: VT_I4 },&#13;
0x0a: { n: 'MultimediaClipCount', t: VT_I4 },&#13;
0x0b: { n: 'ScaleCrop', t: VT_BOOL },&#13;
0x0c: { n: 'HeadingPairs', t: VT_VECTOR_VARIANT /* VT_VECTOR | VT_VARIANT */ },&#13;
0x0d: { n: 'TitlesOfParts', t: VT_VECTOR_LPSTR /* VT_VECTOR | VT_LPSTR */ },&#13;
0x0e: { n: 'Manager', t: VT_STRING },&#13;
0x0f: { n: 'Company', t: VT_STRING },&#13;
0x10: { n: 'LinksUpToDate', t: VT_BOOL },&#13;
0x11: { n: 'CharacterCount', t: VT_I4 },&#13;
0x13: { n: 'SharedDoc', t: VT_BOOL },&#13;
0x16: { n: 'HyperlinksChanged', t: VT_BOOL },&#13;
0x17: { n: 'AppVersion', t: VT_I4, p: 'version' },&#13;
0x18: { n: 'DigSig', t: VT_BLOB },&#13;
0x1A: { n: 'ContentType', t: VT_STRING },&#13;
0x1B: { n: 'ContentStatus', t: VT_STRING },&#13;
0x1C: { n: 'Language', t: VT_STRING },&#13;
0x1D: { n: 'Version', t: VT_STRING },&#13;
0xFF: {},&#13;
	/* [MS-OLEPS] 2.18 */&#13;
0x80000000: { n: 'Locale', t: VT_UI4 },&#13;
0x80000003: { n: 'Behavior', t: VT_UI4 },&#13;
0x72627262: {}&#13;
};&#13;
&#13;
/* [MS-OSHARED] 2.3.3.2.1.1 Summary Information Property Set PIDSI */&#13;
var SummaryPIDSI = {&#13;
0x01: { n: 'CodePage', t: VT_I2 },&#13;
0x02: { n: 'Title', t: VT_STRING },&#13;
0x03: { n: 'Subject', t: VT_STRING },&#13;
0x04: { n: 'Author', t: VT_STRING },&#13;
0x05: { n: 'Keywords', t: VT_STRING },&#13;
0x06: { n: 'Comments', t: VT_STRING },&#13;
0x07: { n: 'Template', t: VT_STRING },&#13;
0x08: { n: 'LastAuthor', t: VT_STRING },&#13;
0x09: { n: 'RevNumber', t: VT_STRING },&#13;
0x0A: { n: 'EditTime', t: VT_FILETIME },&#13;
0x0B: { n: 'LastPrinted', t: VT_FILETIME },&#13;
0x0C: { n: 'CreatedDate', t: VT_FILETIME },&#13;
0x0D: { n: 'ModifiedDate', t: VT_FILETIME },&#13;
0x0E: { n: 'PageCount', t: VT_I4 },&#13;
0x0F: { n: 'WordCount', t: VT_I4 },&#13;
0x10: { n: 'CharCount', t: VT_I4 },&#13;
0x11: { n: 'Thumbnail', t: VT_CF },&#13;
0x12: { n: 'Application', t: VT_STRING },&#13;
0x13: { n: 'DocSecurity', t: VT_I4 },&#13;
0xFF: {},&#13;
	/* [MS-OLEPS] 2.18 */&#13;
0x80000000: { n: 'Locale', t: VT_UI4 },&#13;
0x80000003: { n: 'Behavior', t: VT_UI4 },&#13;
0x72627262: {}&#13;
};&#13;
&#13;
/* [MS-XLS] 2.4.63 Country/Region codes */&#13;
var CountryEnum = {&#13;
0x0001: "US", // United States&#13;
0x0002: "CA", // Canada&#13;
0x0003: "", // Latin America (except Brazil)&#13;
0x0007: "RU", // Russia&#13;
0x0014: "EG", // Egypt&#13;
0x001E: "GR", // Greece&#13;
0x001F: "NL", // Netherlands&#13;
0x0020: "BE", // Belgium&#13;
0x0021: "FR", // France&#13;
0x0022: "ES", // Spain&#13;
0x0024: "HU", // Hungary&#13;
0x0027: "IT", // Italy&#13;
0x0029: "CH", // Switzerland&#13;
0x002B: "AT", // Austria&#13;
0x002C: "GB", // United Kingdom&#13;
0x002D: "DK", // Denmark&#13;
0x002E: "SE", // Sweden&#13;
0x002F: "NO", // Norway&#13;
0x0030: "PL", // Poland&#13;
0x0031: "DE", // Germany&#13;
0x0034: "MX", // Mexico&#13;
0x0037: "BR", // Brazil&#13;
0x003d: "AU", // Australia&#13;
0x0040: "NZ", // New Zealand&#13;
0x0042: "TH", // Thailand&#13;
0x0051: "JP", // Japan&#13;
0x0052: "KR", // Korea&#13;
0x0054: "VN", // Viet Nam&#13;
0x0056: "CN", // China&#13;
0x005A: "TR", // Turkey&#13;
0x0069: "JS", // Ramastan&#13;
0x00D5: "DZ", // Algeria&#13;
0x00D8: "MA", // Morocco&#13;
0x00DA: "LY", // Libya&#13;
0x015F: "PT", // Portugal&#13;
0x0162: "IS", // Iceland&#13;
0x0166: "FI", // Finland&#13;
0x01A4: "CZ", // Czech Republic&#13;
0x0376: "TW", // Taiwan&#13;
0x03C1: "LB", // Lebanon&#13;
0x03C2: "JO", // Jordan&#13;
0x03C3: "SY", // Syria&#13;
0x03C4: "IQ", // Iraq&#13;
0x03C5: "KW", // Kuwait&#13;
0x03C6: "SA", // Saudi Arabia&#13;
0x03CB: "AE", // United Arab Emirates&#13;
0x03CC: "IL", // Israel&#13;
0x03CE: "QA", // Qatar&#13;
0x03D5: "IR", // Iran&#13;
0xFFFF: "US"  // United States&#13;
};&#13;
&#13;
/* [MS-XLS] 2.5.127 */&#13;
var XLSFillPattern = [&#13;
	null,&#13;
	'solid',&#13;
	'mediumGray',&#13;
	'darkGray',&#13;
	'lightGray',&#13;
	'darkHorizontal',&#13;
	'darkVertical',&#13;
	'darkDown',&#13;
	'darkUp',&#13;
	'darkGrid',&#13;
	'darkTrellis',&#13;
	'lightHorizontal',&#13;
	'lightVertical',&#13;
	'lightDown',&#13;
	'lightUp',&#13;
	'lightGrid',&#13;
	'lightTrellis',&#13;
	'gray125',&#13;
	'gray0625'&#13;
];&#13;
&#13;
function rgbify(arr) { return arr.map(function(x) { return [(x&gt;&gt;16)&amp;255,(x&gt;&gt;8)&amp;255,x&amp;255]; }); }&#13;
&#13;
/* [MS-XLS] 2.5.161 */&#13;
/* [MS-XLSB] 2.5.75 Icv */&#13;
var _XLSIcv =  rgbify([&#13;
	/* Color Constants */&#13;
	0x000000,&#13;
	0xFFFFFF,&#13;
	0xFF0000,&#13;
	0x00FF00,&#13;
	0x0000FF,&#13;
	0xFFFF00,&#13;
	0xFF00FF,&#13;
	0x00FFFF,&#13;
&#13;
	/* Overridable Defaults */&#13;
	0x000000,&#13;
	0xFFFFFF,&#13;
	0xFF0000,&#13;
	0x00FF00,&#13;
	0x0000FF,&#13;
	0xFFFF00,&#13;
	0xFF00FF,&#13;
	0x00FFFF,&#13;
&#13;
	0x800000,&#13;
	0x008000,&#13;
	0x000080,&#13;
	0x808000,&#13;
	0x800080,&#13;
	0x008080,&#13;
	0xC0C0C0,&#13;
	0x808080,&#13;
	0x9999FF,&#13;
	0x993366,&#13;
	0xFFFFCC,&#13;
	0xCCFFFF,&#13;
	0x660066,&#13;
	0xFF8080,&#13;
	0x0066CC,&#13;
	0xCCCCFF,&#13;
&#13;
	0x000080,&#13;
	0xFF00FF,&#13;
	0xFFFF00,&#13;
	0x00FFFF,&#13;
	0x800080,&#13;
	0x800000,&#13;
	0x008080,&#13;
	0x0000FF,&#13;
	0x00CCFF,&#13;
	0xCCFFFF,&#13;
	0xCCFFCC,&#13;
	0xFFFF99,&#13;
	0x99CCFF,&#13;
	0xFF99CC,&#13;
	0xCC99FF,&#13;
	0xFFCC99,&#13;
&#13;
	0x3366FF,&#13;
	0x33CCCC,&#13;
	0x99CC00,&#13;
	0xFFCC00,&#13;
	0xFF9900,&#13;
	0xFF6600,&#13;
	0x666699,&#13;
	0x969696,&#13;
	0x003366,&#13;
	0x339966,&#13;
	0x003300,&#13;
	0x333300,&#13;
	0x993300,&#13;
	0x993366,&#13;
	0x333399,&#13;
	0x333333,&#13;
&#13;
	/* Other entries to appease BIFF8/12 */&#13;
	0x000000, /* 0x40 icvForeground ?? */&#13;
	0xFFFFFF, /* 0x41 icvBackground ?? */&#13;
	0x000000, /* 0x42 icvFrame ?? */&#13;
	0x000000, /* 0x43 icv3D ?? */&#13;
	0x000000, /* 0x44 icv3DText ?? */&#13;
	0x000000, /* 0x45 icv3DHilite ?? */&#13;
	0x000000, /* 0x46 icv3DShadow ?? */&#13;
	0x000000, /* 0x47 icvHilite ?? */&#13;
	0x000000, /* 0x48 icvCtlText ?? */&#13;
	0x000000, /* 0x49 icvCtlScrl ?? */&#13;
	0x000000, /* 0x4A icvCtlInv ?? */&#13;
	0x000000, /* 0x4B icvCtlBody ?? */&#13;
	0x000000, /* 0x4C icvCtlFrame ?? */&#13;
	0x000000, /* 0x4D icvCtlFore ?? */&#13;
	0x000000, /* 0x4E icvCtlBack ?? */&#13;
	0x000000, /* 0x4F icvCtlNeutral */&#13;
	0x000000, /* 0x50 icvInfoBk ?? */&#13;
	0x000000 /* 0x51 icvInfoText ?? */&#13;
]);&#13;
var XLSIcv = dup(_XLSIcv);&#13;
&#13;
/* [MS-XLSB] 2.5.97.2 */&#13;
var BErr = {&#13;
0x00: "#NULL!",&#13;
0x07: "#DIV/0!",&#13;
0x0F: "#VALUE!",&#13;
0x17: "#REF!",&#13;
0x1D: "#NAME?",&#13;
0x24: "#NUM!",&#13;
0x2A: "#N/A",&#13;
0x2B: "#GETTING_DATA",&#13;
0xFF: "#WTF?"&#13;
};&#13;
//var RBErr = evert_num(BErr);&#13;
var RBErr = {&#13;
	"#NULL!":        0x00,&#13;
	"#DIV/0!":       0x07,&#13;
	"#VALUE!":       0x0F,&#13;
	"#REF!":         0x17,&#13;
	"#NAME?":        0x1D,&#13;
	"#NUM!":         0x24,&#13;
	"#N/A":          0x2A,&#13;
	"#GETTING_DATA": 0x2B,&#13;
	"#WTF?":         0xFF&#13;
};&#13;
&#13;
var XLSLblBuiltIn = [&#13;
	"_xlnm.Consolidate_Area",&#13;
	"_xlnm.Auto_Open",&#13;
	"_xlnm.Auto_Close",&#13;
	"_xlnm.Extract",&#13;
	"_xlnm.Database",&#13;
	"_xlnm.Criteria",&#13;
	"_xlnm.Print_Area",&#13;
	"_xlnm.Print_Titles",&#13;
	"_xlnm.Recorder",&#13;
	"_xlnm.Data_Form",&#13;
	"_xlnm.Auto_Activate",&#13;
	"_xlnm.Auto_Deactivate",&#13;
	"_xlnm.Sheet_Title",&#13;
	"_xlnm._FilterDatabase"&#13;
];&#13;
&#13;
/* Parts enumerated in OPC spec, MS-XLSB and MS-XLSX */&#13;
/* 12.3 Part Summary &lt;SpreadsheetML&gt; */&#13;
/* 14.2 Part Summary &lt;DrawingML&gt; */&#13;
/* [MS-XLSX] 2.1 Part Enumerations ; [MS-XLSB] 2.1.7 Part Enumeration */&#13;
var ct2type/*{[string]:string}*/ = ({&#13;
	/* Workbook */&#13;
	"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": "workbooks",&#13;
	"application/vnd.ms-excel.sheet.macroEnabled.main+xml": "workbooks",&#13;
	"application/vnd.ms-excel.sheet.binary.macroEnabled.main": "workbooks",&#13;
	"application/vnd.ms-excel.addin.macroEnabled.main+xml": "workbooks",&#13;
	"application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": "workbooks",&#13;
&#13;
	/* Worksheet */&#13;
	"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": "sheets",&#13;
	"application/vnd.ms-excel.worksheet": "sheets",&#13;
	"application/vnd.ms-excel.binIndexWs": "TODO", /* Binary Index */&#13;
&#13;
	/* Chartsheet */&#13;
	"application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": "charts",&#13;
	"application/vnd.ms-excel.chartsheet": "charts",&#13;
&#13;
	/* Macrosheet */&#13;
	"application/vnd.ms-excel.macrosheet+xml": "macros",&#13;
	"application/vnd.ms-excel.macrosheet": "macros",&#13;
	"application/vnd.ms-excel.intlmacrosheet": "TODO",&#13;
	"application/vnd.ms-excel.binIndexMs": "TODO", /* Binary Index */&#13;
&#13;
	/* Dialogsheet */&#13;
	"application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": "dialogs",&#13;
	"application/vnd.ms-excel.dialogsheet": "dialogs",&#13;
&#13;
	/* Shared Strings */&#13;
	"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml": "strs",&#13;
	"application/vnd.ms-excel.sharedStrings": "strs",&#13;
&#13;
	/* Styles */&#13;
	"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": "styles",&#13;
	"application/vnd.ms-excel.styles": "styles",&#13;
&#13;
	/* File Properties */&#13;
	"application/vnd.openxmlformats-package.core-properties+xml": "coreprops",&#13;
	"application/vnd.openxmlformats-officedocument.custom-properties+xml": "custprops",&#13;
	"application/vnd.openxmlformats-officedocument.extended-properties+xml": "extprops",&#13;
&#13;
	/* Custom Data Properties */&#13;
	"application/vnd.openxmlformats-officedocument.customXmlProperties+xml": "TODO",&#13;
	"application/vnd.openxmlformats-officedocument.spreadsheetml.customProperty": "TODO",&#13;
&#13;
	/* Comments */&#13;
	"application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": "comments",&#13;
	"application/vnd.ms-excel.comments": "comments",&#13;
	"application/vnd.ms-excel.threadedcomments+xml": "threadedcomments",&#13;
	"application/vnd.ms-excel.person+xml": "people",&#13;
&#13;
	/* Metadata (Stock/Geography and Dynamic Array) */&#13;
	"application/vnd.openxmlformats-officedocument.spreadsheetml.sheetMetadata+xml": "metadata",&#13;
	"application/vnd.ms-excel.sheetMetadata": "metadata",&#13;
&#13;
	/* PivotTable */&#13;
	"application/vnd.ms-excel.pivotTable": "TODO",&#13;
	"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotTable+xml": "TODO",&#13;
&#13;
	/* Chart Objects */&#13;
	"application/vnd.openxmlformats-officedocument.drawingml.chart+xml": "TODO",&#13;
&#13;
	/* Chart Colors */&#13;
	"application/vnd.ms-office.chartcolorstyle+xml": "TODO",&#13;
&#13;
	/* Chart Style */&#13;
	"application/vnd.ms-office.chartstyle+xml": "TODO",&#13;
&#13;
	/* Chart Advanced */&#13;
	"application/vnd.ms-office.chartex+xml": "TODO",&#13;
&#13;
	/* Calculation Chain */&#13;
	"application/vnd.ms-excel.calcChain": "calcchains",&#13;
	"application/vnd.openxmlformats-officedocument.spreadsheetml.calcChain+xml": "calcchains",&#13;
&#13;
	/* Printer Settings */&#13;
	"application/vnd.openxmlformats-officedocument.spreadsheetml.printerSettings": "TODO",&#13;
&#13;
	/* ActiveX */&#13;
	"application/vnd.ms-office.activeX": "TODO",&#13;
	"application/vnd.ms-office.activeX+xml": "TODO",&#13;
&#13;
	/* Custom Toolbars */&#13;
	"application/vnd.ms-excel.attachedToolbars": "TODO",&#13;
&#13;
	/* External Data Connections */&#13;
	"application/vnd.ms-excel.connections": "TODO",&#13;
	"application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": "TODO",&#13;
&#13;
	/* External Links */&#13;
	"application/vnd.ms-excel.externalLink": "links",&#13;
	"application/vnd.openxmlformats-officedocument.spreadsheetml.externalLink+xml": "links",&#13;
&#13;
	/* PivotCache */&#13;
	"application/vnd.ms-excel.pivotCacheDefinition": "TODO",&#13;
	"application/vnd.ms-excel.pivotCacheRecords": "TODO",&#13;
	"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotCacheDefinition+xml": "TODO",&#13;
	"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotCacheRecords+xml": "TODO",&#13;
&#13;
	/* Query Table */&#13;
	"application/vnd.ms-excel.queryTable": "TODO",&#13;
	"application/vnd.openxmlformats-officedocument.spreadsheetml.queryTable+xml": "TODO",&#13;
&#13;
	/* Shared Workbook */&#13;
	"application/vnd.ms-excel.userNames": "TODO",&#13;
	"application/vnd.ms-excel.revisionHeaders": "TODO",&#13;
	"application/vnd.ms-excel.revisionLog": "TODO",&#13;
	"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionHeaders+xml": "TODO",&#13;
	"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionLog+xml": "TODO",&#13;
	"application/vnd.openxmlformats-officedocument.spreadsheetml.userNames+xml": "TODO",&#13;
&#13;
	/* Single Cell Table */&#13;
	"application/vnd.ms-excel.tableSingleCells": "TODO",&#13;
	"application/vnd.openxmlformats-officedocument.spreadsheetml.tableSingleCells+xml": "TODO",&#13;
&#13;
	/* Slicer */&#13;
	"application/vnd.ms-excel.slicer": "TODO",&#13;
	"application/vnd.ms-excel.slicerCache": "TODO",&#13;
	"application/vnd.ms-excel.slicer+xml": "TODO",&#13;
	"application/vnd.ms-excel.slicerCache+xml": "TODO",&#13;
&#13;
	/* Sort Map */&#13;
	"application/vnd.ms-excel.wsSortMap": "TODO",&#13;
&#13;
	/* Table */&#13;
	"application/vnd.ms-excel.table": "TODO",&#13;
	"application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": "TODO",&#13;
&#13;
	/* Themes */&#13;
	"application/vnd.openxmlformats-officedocument.theme+xml": "themes",&#13;
&#13;
	/* Theme Override */&#13;
	"application/vnd.openxmlformats-officedocument.themeOverride+xml": "TODO",&#13;
&#13;
	/* Timeline */&#13;
	"application/vnd.ms-excel.Timeline+xml": "TODO", /* verify */&#13;
	"application/vnd.ms-excel.TimelineCache+xml": "TODO", /* verify */&#13;
&#13;
	/* VBA */&#13;
	"application/vnd.ms-office.vbaProject": "vba",&#13;
	"application/vnd.ms-office.vbaProjectSignature": "TODO",&#13;
&#13;
	/* Volatile Dependencies */&#13;
	"application/vnd.ms-office.volatileDependencies": "TODO",&#13;
	"application/vnd.openxmlformats-officedocument.spreadsheetml.volatileDependencies+xml": "TODO",&#13;
&#13;
	/* Control Properties */&#13;
	"application/vnd.ms-excel.controlproperties+xml": "TODO",&#13;
&#13;
	/* Data Model */&#13;
	"application/vnd.openxmlformats-officedocument.model+data": "TODO",&#13;
&#13;
	/* Survey */&#13;
	"application/vnd.ms-excel.Survey+xml": "TODO",&#13;
&#13;
	/* Drawing */&#13;
	"application/vnd.openxmlformats-officedocument.drawing+xml": "drawings",&#13;
	"application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": "TODO",&#13;
	"application/vnd.openxmlformats-officedocument.drawingml.diagramColors+xml": "TODO",&#13;
	"application/vnd.openxmlformats-officedocument.drawingml.diagramData+xml": "TODO",&#13;
	"application/vnd.openxmlformats-officedocument.drawingml.diagramLayout+xml": "TODO",&#13;
	"application/vnd.openxmlformats-officedocument.drawingml.diagramStyle+xml": "TODO",&#13;
&#13;
	/* VML */&#13;
	"application/vnd.openxmlformats-officedocument.vmlDrawing": "TODO",&#13;
&#13;
	"application/vnd.openxmlformats-package.relationships+xml": "rels",&#13;
	"application/vnd.openxmlformats-officedocument.oleObject": "TODO",&#13;
&#13;
	/* Image */&#13;
	"image/png": "TODO",&#13;
&#13;
	"sheet": "js"&#13;
});&#13;
&#13;
var CT_LIST = {&#13;
	workbooks: {&#13;
		xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml",&#13;
		xlsm: "application/vnd.ms-excel.sheet.macroEnabled.main+xml",&#13;
		xlsb: "application/vnd.ms-excel.sheet.binary.macroEnabled.main",&#13;
		xlam: "application/vnd.ms-excel.addin.macroEnabled.main+xml",&#13;
		xltx: "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml"&#13;
	},&#13;
	strs: { /* Shared Strings */&#13;
		xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml",&#13;
		xlsb: "application/vnd.ms-excel.sharedStrings"&#13;
	},&#13;
	comments: { /* Comments */&#13;
		xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml",&#13;
		xlsb: "application/vnd.ms-excel.comments"&#13;
	},&#13;
	sheets: { /* Worksheet */&#13;
		xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml",&#13;
		xlsb: "application/vnd.ms-excel.worksheet"&#13;
	},&#13;
	charts: { /* Chartsheet */&#13;
		xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml",&#13;
		xlsb: "application/vnd.ms-excel.chartsheet"&#13;
	},&#13;
	dialogs: { /* Dialogsheet */&#13;
		xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml",&#13;
		xlsb: "application/vnd.ms-excel.dialogsheet"&#13;
	},&#13;
	macros: { /* Macrosheet (Excel 4.0 Macros) */&#13;
		xlsx: "application/vnd.ms-excel.macrosheet+xml",&#13;
		xlsb: "application/vnd.ms-excel.macrosheet"&#13;
	},&#13;
	metadata: { /* Metadata (Stock/Geography and Dynamic Array) */&#13;
		xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetMetadata+xml",&#13;
		xlsb: "application/vnd.ms-excel.sheetMetadata"&#13;
	},&#13;
	styles: { /* Styles */&#13;
		xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml",&#13;
		xlsb: "application/vnd.ms-excel.styles"&#13;
	}&#13;
};&#13;
&#13;
function new_ct() {&#13;
	return ({&#13;
		workbooks:[], sheets:[], charts:[], dialogs:[], macros:[],&#13;
		rels:[], strs:[], comments:[], threadedcomments:[], links:[],&#13;
		coreprops:[], extprops:[], custprops:[], themes:[], styles:[],&#13;
		calcchains:[], vba: [], drawings: [], metadata: [], people:[],&#13;
		TODO:[], xmlns: "" });&#13;
}&#13;
&#13;
function parse_ct(data) {&#13;
	var ct = new_ct();&#13;
	if(!data || !data.match) return ct;&#13;
	var ctext = {};&#13;
	(data.match(tagregex)||[]).forEach(function(x) {&#13;
		var y = parsexmltag(x);&#13;
		switch(y[0].replace(nsregex,"&lt;")) {&#13;
			case '&lt;?xml': break;&#13;
			case '&lt;Types': ct.xmlns = y['xmlns' + (y[0].match(/&lt;(\w+):/)||["",""])[1] ]; break;&#13;
			case '&lt;Default': ctext[y.Extension.toLowerCase()] = y.ContentType; break;&#13;
			case '&lt;Override':&#13;
				if(ct[ct2type[y.ContentType]] !== undefined) ct[ct2type[y.ContentType]].push(y.PartName);&#13;
				break;&#13;
		}&#13;
	});&#13;
	if(ct.xmlns !== XMLNS.CT) throw new Error("Unknown Namespace: " + ct.xmlns);&#13;
	ct.calcchain = ct.calcchains.length &gt; 0 ? ct.calcchains[0] : "";&#13;
	ct.sst = ct.strs.length &gt; 0 ? ct.strs[0] : "";&#13;
	ct.style = ct.styles.length &gt; 0 ? ct.styles[0] : "";&#13;
	ct.defaults = ctext;&#13;
	delete ct.calcchains;&#13;
	return ct;&#13;
}&#13;
&#13;
function write_ct(ct, opts, raw) {&#13;
	var type2ct/*{[string]:Array&lt;string&gt;}*/ = evert_arr(ct2type);&#13;
&#13;
	var o = [], v;&#13;
&#13;
	if(!raw) {&#13;
		o[o.length] = (XML_HEADER);&#13;
		o[o.length] = writextag('Types', null, {&#13;
			'xmlns': XMLNS.CT,&#13;
			'xmlns:xsd': XMLNS.xsd,&#13;
			'xmlns:xsi': XMLNS.xsi&#13;
		});&#13;
		o = o.concat([&#13;
			['xml', 'application/xml'],&#13;
			['bin', 'application/vnd.ms-excel.sheet.binary.macroEnabled.main'],&#13;
			['vml', 'application/vnd.openxmlformats-officedocument.vmlDrawing'],&#13;
			['data', 'application/vnd.openxmlformats-officedocument.model+data'],&#13;
			/* from test files */&#13;
			['bmp', 'image/bmp'],&#13;
			['png', 'image/png'],&#13;
			['gif', 'image/gif'],&#13;
			['emf', 'image/x-emf'],&#13;
			['wmf', 'image/x-wmf'],&#13;
			['jpg', 'image/jpeg'], ['jpeg', 'image/jpeg'],&#13;
			['tif', 'image/tiff'], ['tiff', 'image/tiff'],&#13;
			['pdf', 'application/pdf'],&#13;
			['rels', 'application/vnd.openxmlformats-package.relationships+xml']&#13;
		].map(function(x) {&#13;
			return writextag('Default', null, {'Extension':x[0], 'ContentType': x[1]});&#13;
		}));&#13;
	}&#13;
&#13;
	/* only write first instance */&#13;
	var f1 = function(w) {&#13;
		if(ct[w] &amp;&amp; ct[w].length &gt; 0) {&#13;
			v = ct[w][0];&#13;
			o[o.length] = (writextag('Override', null, {&#13;
				'PartName': (v[0] == '/' ? "":"/") + v,&#13;
				'ContentType': CT_LIST[w][opts.bookType] || CT_LIST[w]['xlsx']&#13;
			}));&#13;
		}&#13;
	};&#13;
&#13;
	/* book type-specific */&#13;
	var f2 = function(w) {&#13;
		(ct[w]||[]).forEach(function(v) {&#13;
			o[o.length] = (writextag('Override', null, {&#13;
				'PartName': (v[0] == '/' ? "":"/") + v,&#13;
				'ContentType': CT_LIST[w][opts.bookType] || CT_LIST[w]['xlsx']&#13;
			}));&#13;
		});&#13;
	};&#13;
&#13;
	/* standard type */&#13;
	var f3 = function(t) {&#13;
		(ct[t]||[]).forEach(function(v) {&#13;
			o[o.length] = (writextag('Override', null, {&#13;
				'PartName': (v[0] == '/' ? "":"/") + v,&#13;
				'ContentType': type2ct[t][0]&#13;
			}));&#13;
		});&#13;
	};&#13;
&#13;
	f1('workbooks');&#13;
	f2('sheets');&#13;
	f2('charts');&#13;
	f3('themes');&#13;
	['strs', 'styles'].forEach(f1);&#13;
	['coreprops', 'extprops', 'custprops'].forEach(f3);&#13;
	f3('vba');&#13;
	f3('comments');&#13;
	f3('threadedcomments');&#13;
	f3('drawings');&#13;
	f2('metadata');&#13;
	f3('people');&#13;
	if(!raw &amp;&amp; o.length&gt;2){ o[o.length] = ('&lt;/Types&gt;'); o[1]=o[1].replace("/&gt;","&gt;"); }&#13;
	return o.join("");&#13;
}&#13;
/* 9.3 Relationships */&#13;
var RELS = ({&#13;
	WB: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument",&#13;
	SHEET: "http://sheetjs.openxmlformats.org/officeDocument/2006/relationships/officeDocument",&#13;
	HLINK: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink",&#13;
	VML: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/vmlDrawing",&#13;
	XPATH: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/externalLinkPath",&#13;
	XMISS: "http://schemas.microsoft.com/office/2006/relationships/xlExternalLinkPath/xlPathMissing",&#13;
	XLINK: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/externalLink",&#13;
	CXML: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/customXml",&#13;
	CXMLP: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/customXmlProps",&#13;
	CMNT: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/comments",&#13;
	CORE_PROPS: "http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties",&#13;
	EXT_PROPS: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties',&#13;
	CUST_PROPS: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/custom-properties',&#13;
	SST: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings",&#13;
	STY: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles",&#13;
	THEME: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme",&#13;
	CHART: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/chart",&#13;
	CHARTEX: "http://schemas.microsoft.com/office/2014/relationships/chartEx",&#13;
	CS: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/chartsheet",&#13;
	WS: [&#13;
		"http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet",&#13;
		"http://purl.oclc.org/ooxml/officeDocument/relationships/worksheet"&#13;
	],&#13;
	DS: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/dialogsheet",&#13;
	MS: "http://schemas.microsoft.com/office/2006/relationships/xlMacrosheet",&#13;
	IMG: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image",&#13;
	DRAW: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing",&#13;
	XLMETA: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/sheetMetadata",&#13;
	TCMNT: "http://schemas.microsoft.com/office/2017/10/relationships/threadedComment",&#13;
	PEOPLE: "http://schemas.microsoft.com/office/2017/10/relationships/person",&#13;
	CONN: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/connections",&#13;
	VBA: "http://schemas.microsoft.com/office/2006/relationships/vbaProject"&#13;
});&#13;
&#13;
/* 9.3.3 Representing Relationships */&#13;
function get_rels_path(file) {&#13;
	var n = file.lastIndexOf("/");&#13;
	return file.slice(0,n+1) + '_rels/' + file.slice(n+1) + ".rels";&#13;
}&#13;
&#13;
function parse_rels(data, currentFilePath) {&#13;
	var rels = {"!id":{}};&#13;
	if (!data) return rels;&#13;
	if (currentFilePath.charAt(0) !== '/') {&#13;
		currentFilePath = '/'+currentFilePath;&#13;
	}&#13;
	var hash = {};&#13;
&#13;
	(data.match(tagregex)||[]).forEach(function(x) {&#13;
		var y = parsexmltag(x);&#13;
		/* 9.3.2.2 OPC_Relationships */&#13;
		if (y[0] === '&lt;Relationship') {&#13;
			var rel = {}; rel.Type = y.Type; rel.Target = y.Target; rel.Id = y.Id; if(y.TargetMode) rel.TargetMode = y.TargetMode;&#13;
			var canonictarget = y.TargetMode === 'External' ? y.Target : resolve_path(y.Target, currentFilePath);&#13;
			rels[canonictarget] = rel;&#13;
			hash[y.Id] = rel;&#13;
		}&#13;
	});&#13;
	rels["!id"] = hash;&#13;
	return rels;&#13;
}&#13;
&#13;
&#13;
/* TODO */&#13;
function write_rels(rels) {&#13;
	var o = [XML_HEADER, writextag('Relationships', null, {&#13;
		//'xmlns:ns0': XMLNS.RELS,&#13;
		'xmlns': XMLNS.RELS&#13;
	})];&#13;
	keys(rels['!id']).forEach(function(rid) {&#13;
		o[o.length] = (writextag('Relationship', null, rels['!id'][rid]));&#13;
	});&#13;
	if(o.length&gt;2){ o[o.length] = ('&lt;/Relationships&gt;'); o[1]=o[1].replace("/&gt;","&gt;"); }&#13;
	return o.join("");&#13;
}&#13;
&#13;
function add_rels(rels, rId, f, type, relobj, targetmode) {&#13;
	if(!relobj) relobj = {};&#13;
	if(!rels['!id']) rels['!id'] = {};&#13;
	if(!rels['!idx']) rels['!idx'] = 1;&#13;
	if(rId &lt; 0) for(rId = rels['!idx']; rels['!id']['rId' + rId]; ++rId){/* empty */}&#13;
	rels['!idx'] = rId + 1;&#13;
	relobj.Id = 'rId' + rId;&#13;
	relobj.Type = type;&#13;
	relobj.Target = f;&#13;
	if(targetmode) relobj.TargetMode = targetmode;&#13;
	else if([RELS.HLINK, RELS.XPATH, RELS.XMISS].indexOf(relobj.Type) &gt; -1) relobj.TargetMode = "External";&#13;
	if(rels['!id'][relobj.Id]) throw new Error("Cannot rewrite rId " + rId);&#13;
	rels['!id'][relobj.Id] = relobj;&#13;
	rels[('/' + relobj.Target).replace("//","/")] = relobj;&#13;
	return rId;&#13;
}&#13;
/* Open Document Format for Office Applications (OpenDocument) Version 1.2 */&#13;
/* Part 3 Section 4 Manifest File */&#13;
var CT_ODS = "application/vnd.oasis.opendocument.spreadsheet";&#13;
function parse_manifest(d, opts) {&#13;
	var str = xlml_normalize(d);&#13;
	var Rn;&#13;
	var FEtag;&#13;
	while((Rn = xlmlregex.exec(str))) switch(Rn[3]) {&#13;
		case 'manifest': break; // 4.2 &lt;manifest:manifest&gt;&#13;
		case 'file-entry': // 4.3 &lt;manifest:file-entry&gt;&#13;
			FEtag = parsexmltag(Rn[0], false);&#13;
			if(FEtag.path == '/' &amp;&amp; FEtag.type !== CT_ODS) throw new Error("This OpenDocument is not a spreadsheet");&#13;
			break;&#13;
		case 'encryption-data': // 4.4 &lt;manifest:encryption-data&gt;&#13;
		case 'algorithm': // 4.5 &lt;manifest:algorithm&gt;&#13;
		case 'start-key-generation': // 4.6 &lt;manifest:start-key-generation&gt;&#13;
		case 'key-derivation': // 4.7 &lt;manifest:key-derivation&gt;&#13;
			throw new Error("Unsupported ODS Encryption");&#13;
		default: if(opts &amp;&amp; opts.WTF) throw Rn;&#13;
	}&#13;
}&#13;
&#13;
function write_manifest(manifest) {&#13;
	var o = [XML_HEADER];&#13;
	o.push('&lt;manifest:manifest xmlns:manifest="urn:oasis:names:tc:opendocument:xmlns:manifest:1.0" manifest:version="1.2"&gt;\n');&#13;
	o.push('  &lt;manifest:file-entry manifest:full-path="/" manifest:version="1.2" manifest:media-type="application/vnd.oasis.opendocument.spreadsheet"/&gt;\n');&#13;
	for(var i = 0; i &lt; manifest.length; ++i) o.push('  &lt;manifest:file-entry manifest:full-path="' + manifest[i][0] + '" manifest:media-type="' + manifest[i][1] + '"/&gt;\n');&#13;
	o.push('&lt;/manifest:manifest&gt;');&#13;
	return o.join("");&#13;
}&#13;
&#13;
/* Part 3 Section 6 Metadata Manifest File */&#13;
function write_rdf_type(file, res, tag) {&#13;
	return [&#13;
		'  &lt;rdf:Description rdf:about="' + file + '"&gt;\n',&#13;
		'    &lt;rdf:type rdf:resource="http://docs.oasis-open.org/ns/office/1.2/meta/' + (tag || "odf") + '#' + res + '"/&gt;\n',&#13;
		'  &lt;/rdf:Description&gt;\n'&#13;
	].join("");&#13;
}&#13;
function write_rdf_has(base, file) {&#13;
	return [&#13;
		'  &lt;rdf:Description rdf:about="' + base + '"&gt;\n',&#13;
		'    &lt;ns0:hasPart xmlns:ns0="http://docs.oasis-open.org/ns/office/1.2/meta/pkg#" rdf:resource="' + file + '"/&gt;\n',&#13;
		'  &lt;/rdf:Description&gt;\n'&#13;
	].join("");&#13;
}&#13;
function write_rdf(rdf) {&#13;
	var o = [XML_HEADER];&#13;
	o.push('&lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt;\n');&#13;
	for(var i = 0; i != rdf.length; ++i) {&#13;
		o.push(write_rdf_type(rdf[i][0], rdf[i][1]));&#13;
		o.push(write_rdf_has("",rdf[i][0]));&#13;
	}&#13;
	o.push(write_rdf_type("","Document", "pkg"));&#13;
	o.push('&lt;/rdf:RDF&gt;');&#13;
	return o.join("");&#13;
}&#13;
/* TODO: pull properties */&#13;
function write_meta_ods() {&#13;
	return '&lt;office:document-meta xmlns:office="urn:oasis:names:tc:opendocument:xmlns:office:1.0" xmlns:meta="urn:oasis:names:tc:opendocument:xmlns:meta:1.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:xlink="http://www.w3.org/1999/xlink" office:version="1.2"&gt;&lt;office:meta&gt;&lt;meta:generator&gt;Sheet' + 'JS ' + XLSX.version + '&lt;/meta:generator&gt;&lt;/office:meta&gt;&lt;/office:document-meta&gt;';&#13;
}&#13;
&#13;
/* ECMA-376 Part II 11.1 Core Properties Part */&#13;
/* [MS-OSHARED] 2.3.3.2.[1-2].1 (PIDSI/PIDDSI) */&#13;
var CORE_PROPS = [&#13;
	["cp:category", "Category"],&#13;
	["cp:contentStatus", "ContentStatus"],&#13;
	["cp:keywords", "Keywords"],&#13;
	["cp:lastModifiedBy", "LastAuthor"],&#13;
	["cp:lastPrinted", "LastPrinted"],&#13;
	["cp:revision", "RevNumber"],&#13;
	["cp:version", "Version"],&#13;
	["dc:creator", "Author"],&#13;
	["dc:description", "Comments"],&#13;
	["dc:identifier", "Identifier"],&#13;
	["dc:language", "Language"],&#13;
	["dc:subject", "Subject"],&#13;
	["dc:title", "Title"],&#13;
	["dcterms:created", "CreatedDate", 'date'],&#13;
	["dcterms:modified", "ModifiedDate", 'date']&#13;
];&#13;
&#13;
var CORE_PROPS_REGEX = (function() {&#13;
	var r = new Array(CORE_PROPS.length);&#13;
	for(var i = 0; i &lt; CORE_PROPS.length; ++i) {&#13;
		var f = CORE_PROPS[i];&#13;
		var g = "(?:"+ f[0].slice(0,f[0].indexOf(":")) +":)"+ f[0].slice(f[0].indexOf(":")+1);&#13;
		r[i] = new RegExp("&lt;" + g + "[^&gt;]*&gt;([\\s\\S]*?)&lt;\/" + g + "&gt;");&#13;
	}&#13;
	return r;&#13;
})();&#13;
&#13;
function parse_core_props(data) {&#13;
	var p = {};&#13;
	data = utf8read(data);&#13;
&#13;
	for(var i = 0; i &lt; CORE_PROPS.length; ++i) {&#13;
		var f = CORE_PROPS[i], cur = data.match(CORE_PROPS_REGEX[i]);&#13;
		if(cur != null &amp;&amp; cur.length &gt; 0) p[f[1]] = unescapexml(cur[1]);&#13;
		if(f[2] === 'date' &amp;&amp; p[f[1]]) p[f[1]] = parseDate(p[f[1]]);&#13;
	}&#13;
&#13;
	return p;&#13;
}&#13;
&#13;
function cp_doit(f, g, h, o, p) {&#13;
	if(p[f] != null || g == null || g === "") return;&#13;
	p[f] = g;&#13;
	g = escapexml(g);&#13;
	o[o.length] = (h ? writextag(f,g,h) : writetag(f,g));&#13;
}&#13;
&#13;
function write_core_props(cp, _opts) {&#13;
	var opts = _opts || {};&#13;
	var o = [XML_HEADER, writextag('cp:coreProperties', null, {&#13;
		//'xmlns': XMLNS.CORE_PROPS,&#13;
		'xmlns:cp': XMLNS.CORE_PROPS,&#13;
		'xmlns:dc': XMLNS.dc,&#13;
		'xmlns:dcterms': XMLNS.dcterms,&#13;
		'xmlns:dcmitype': XMLNS.dcmitype,&#13;
		'xmlns:xsi': XMLNS.xsi&#13;
	})], p = {};&#13;
	if(!cp &amp;&amp; !opts.Props) return o.join("");&#13;
&#13;
	if(cp) {&#13;
		if(cp.CreatedDate != null) cp_doit("dcterms:created", typeof cp.CreatedDate === "string" ? cp.CreatedDate : write_w3cdtf(cp.CreatedDate, opts.WTF), {"xsi:type":"dcterms:W3CDTF"}, o, p);&#13;
		if(cp.ModifiedDate != null) cp_doit("dcterms:modified", typeof cp.ModifiedDate === "string" ? cp.ModifiedDate : write_w3cdtf(cp.ModifiedDate, opts.WTF), {"xsi:type":"dcterms:W3CDTF"}, o, p);&#13;
	}&#13;
&#13;
	for(var i = 0; i != CORE_PROPS.length; ++i) {&#13;
		var f = CORE_PROPS[i];&#13;
		var v = opts.Props &amp;&amp; opts.Props[f[1]] != null ? opts.Props[f[1]] : cp ? cp[f[1]] : null;&#13;
		if(v === true) v = "1";&#13;
		else if(v === false) v = "0";&#13;
		else if(typeof v == "number") v = String(v);&#13;
		if(v != null) cp_doit(f[0], v, null, o, p);&#13;
	}&#13;
	if(o.length&gt;2){ o[o.length] = ('&lt;/cp:coreProperties&gt;'); o[1]=o[1].replace("/&gt;","&gt;"); }&#13;
	return o.join("");&#13;
}&#13;
/* 15.2.12.3 Extended File Properties Part */&#13;
/* [MS-OSHARED] 2.3.3.2.[1-2].1 (PIDSI/PIDDSI) */&#13;
var EXT_PROPS = [&#13;
	["Application", "Application", "string"],&#13;
	["AppVersion", "AppVersion", "string"],&#13;
	["Company", "Company", "string"],&#13;
	["DocSecurity", "DocSecurity", "string"],&#13;
	["Manager", "Manager", "string"],&#13;
	["HyperlinksChanged", "HyperlinksChanged", "bool"],&#13;
	["SharedDoc", "SharedDoc", "bool"],&#13;
	["LinksUpToDate", "LinksUpToDate", "bool"],&#13;
	["ScaleCrop", "ScaleCrop", "bool"],&#13;
	["HeadingPairs", "HeadingPairs", "raw"],&#13;
	["TitlesOfParts", "TitlesOfParts", "raw"]&#13;
];&#13;
&#13;
var PseudoPropsPairs = [&#13;
	"Worksheets",  "SheetNames",&#13;
	"NamedRanges", "DefinedNames",&#13;
	"Chartsheets", "ChartNames"&#13;
];&#13;
function load_props_pairs(HP, TOP, props, opts) {&#13;
	var v = [];&#13;
	if(typeof HP == "string") v = parseVector(HP, opts);&#13;
	else for(var j = 0; j &lt; HP.length; ++j) v = v.concat(HP[j].map(function(hp) { return {v:hp}; }));&#13;
	var parts = (typeof TOP == "string") ? parseVector(TOP, opts).map(function (x) { return x.v; }) : TOP;&#13;
	var idx = 0, len = 0;&#13;
	if(parts.length &gt; 0) for(var i = 0; i !== v.length; i += 2) {&#13;
		len = +(v[i+1].v);&#13;
		switch(v[i].v) {&#13;
			case "Worksheets":&#13;
			case "工作表":&#13;
			case "Листы":&#13;
			case "أوراق العمل":&#13;
			case "ワークシート":&#13;
			case "גליונות עבודה":&#13;
			case "Arbeitsblätter":&#13;
			case "Çalışma Sayfaları":&#13;
			case "Feuilles de calcul":&#13;
			case "Fogli di lavoro":&#13;
			case "Folhas de cálculo":&#13;
			case "Planilhas":&#13;
			case "Regneark":&#13;
			case "Hojas de cálculo":&#13;
			case "Werkbladen":&#13;
				props.Worksheets = len;&#13;
				props.SheetNames = parts.slice(idx, idx + len);&#13;
				break;&#13;
&#13;
			case "Named Ranges":&#13;
			case "Rangos con nombre":&#13;
			case "名前付き一覧":&#13;
			case "Benannte Bereiche":&#13;
			case "Navngivne områder":&#13;
				props.NamedRanges = len;&#13;
				props.DefinedNames = parts.slice(idx, idx + len);&#13;
				break;&#13;
&#13;
			case "Charts":&#13;
			case "Diagramme":&#13;
				props.Chartsheets = len;&#13;
				props.ChartNames = parts.slice(idx, idx + len);&#13;
				break;&#13;
		}&#13;
		idx += len;&#13;
	}&#13;
}&#13;
&#13;
function parse_ext_props(data, p, opts) {&#13;
	var q = {}; if(!p) p = {};&#13;
	data = utf8read(data);&#13;
&#13;
	EXT_PROPS.forEach(function(f) {&#13;
		var xml = (data.match(matchtag(f[0]))||[])[1];&#13;
		switch(f[2]) {&#13;
			case "string": if(xml) p[f[1]] = unescapexml(xml); break;&#13;
			case "bool": p[f[1]] = xml === "true"; break;&#13;
			case "raw":&#13;
				var cur = data.match(new RegExp("&lt;" + f[0] + "[^&gt;]*&gt;([\\s\\S]*?)&lt;\/" + f[0] + "&gt;"));&#13;
				if(cur &amp;&amp; cur.length &gt; 0) q[f[1]] = cur[1];&#13;
				break;&#13;
		}&#13;
	});&#13;
&#13;
	if(q.HeadingPairs &amp;&amp; q.TitlesOfParts) load_props_pairs(q.HeadingPairs, q.TitlesOfParts, p, opts);&#13;
&#13;
	return p;&#13;
}&#13;
&#13;
function write_ext_props(cp) {&#13;
	var o = [], W = writextag;&#13;
	if(!cp) cp = {};&#13;
	cp.Application = "xlsx";&#13;
	o[o.length] = (XML_HEADER);&#13;
	o[o.length] = (writextag('Properties', null, {&#13;
		'xmlns': XMLNS.EXT_PROPS,&#13;
		'xmlns:vt': XMLNS.vt&#13;
	}));&#13;
&#13;
	EXT_PROPS.forEach(function(f) {&#13;
		if(cp[f[1]] === undefined) return;&#13;
		var v;&#13;
		switch(f[2]) {&#13;
			case 'string': v = escapexml(String(cp[f[1]])); break;&#13;
			case 'bool': v = cp[f[1]] ? 'true' : 'false'; break;&#13;
		}&#13;
		if(v !== undefined) o[o.length] = (W(f[0], v));&#13;
	});&#13;
&#13;
	/* TODO: HeadingPairs, TitlesOfParts */&#13;
	o[o.length] = (W('HeadingPairs', W('vt:vector', W('vt:variant', '&lt;vt:lpstr&gt;Worksheets&lt;/vt:lpstr&gt;')+W('vt:variant', W('vt:i4', String(cp.Worksheets))), {size:2, baseType:"variant"})));&#13;
	o[o.length] = (W('TitlesOfParts', W('vt:vector', cp.SheetNames.map(function(s) { return "&lt;vt:lpstr&gt;" + escapexml(s) + "&lt;/vt:lpstr&gt;"; }).join(""), {size: cp.Worksheets, baseType:"lpstr"})));&#13;
	if(o.length&gt;2){ o[o.length] = ('&lt;/Properties&gt;'); o[1]=o[1].replace("/&gt;","&gt;"); }&#13;
	return o.join("");&#13;
}&#13;
/* 15.2.12.2 Custom File Properties Part */&#13;
var custregex = /&lt;[^&gt;]+&gt;[^&lt;]*/g;&#13;
function parse_cust_props(data, opts) {&#13;
	var p = {}, name = "";&#13;
	var m = data.match(custregex);&#13;
	if(m) for(var i = 0; i != m.length; ++i) {&#13;
		var x = m[i], y = parsexmltag(x);&#13;
		switch(strip_ns(y[0])) {&#13;
			case '&lt;?xml': break;&#13;
			case '&lt;Properties': break;&#13;
			case '&lt;property': name = unescapexml(y.name); break;&#13;
			case '&lt;/property&gt;': name = null; break;&#13;
			default: if (x.indexOf('&lt;vt:') === 0) {&#13;
				var toks = x.split('&gt;');&#13;
				var type = toks[0].slice(4), text = toks[1];&#13;
				/* 22.4.2.32 (CT_Variant). Omit the binary types from 22.4 (Variant Types) */&#13;
				switch(type) {&#13;
					case 'lpstr': case 'bstr': case 'lpwstr':&#13;
						p[name] = unescapexml(text);&#13;
						break;&#13;
					case 'bool':&#13;
						p[name] = parsexmlbool(text);&#13;
						break;&#13;
					case 'i1': case 'i2': case 'i4': case 'i8': case 'int': case 'uint':&#13;
						p[name] = parseInt(text, 10);&#13;
						break;&#13;
					case 'r4': case 'r8': case 'decimal':&#13;
						p[name] = parseFloat(text);&#13;
						break;&#13;
					case 'filetime': case 'date':&#13;
						p[name] = parseDate(text);&#13;
						break;&#13;
					case 'cy': case 'error':&#13;
						p[name] = unescapexml(text);&#13;
						break;&#13;
					default:&#13;
						if(type.slice(-1) == '/') break;&#13;
						if(opts.WTF &amp;&amp; typeof console !== 'undefined') console.warn('Unexpected', x, type, toks);&#13;
				}&#13;
			} else if(x.slice(0,2) === "&lt;/") {/* empty */&#13;
			} else if(opts.WTF) throw new Error(x);&#13;
		}&#13;
	}&#13;
	return p;&#13;
}&#13;
&#13;
function write_cust_props(cp) {&#13;
	var o = [XML_HEADER, writextag('Properties', null, {&#13;
		'xmlns': XMLNS.CUST_PROPS,&#13;
		'xmlns:vt': XMLNS.vt&#13;
	})];&#13;
	if(!cp) return o.join("");&#13;
	var pid = 1;&#13;
	keys(cp).forEach(function custprop(k) { ++pid;&#13;
		o[o.length] = (writextag('property', write_vt(cp[k], true), {&#13;
			'fmtid': '{D5CDD505-2E9C-101B-9397-08002B2CF9AE}',&#13;
			'pid': pid,&#13;
			'name': escapexml(k)&#13;
		}));&#13;
	});&#13;
	if(o.length&gt;2){ o[o.length] = '&lt;/Properties&gt;'; o[1]=o[1].replace("/&gt;","&gt;"); }&#13;
	return o.join("");&#13;
}&#13;
/* Common Name -&gt; XLML Name */&#13;
var XLMLDocPropsMap = {&#13;
	Title: 'Title',&#13;
	Subject: 'Subject',&#13;
	Author: 'Author',&#13;
	Keywords: 'Keywords',&#13;
	Comments: 'Description',&#13;
	LastAuthor: 'LastAuthor',&#13;
	RevNumber: 'Revision',&#13;
	Application: 'AppName',&#13;
	/* TotalTime: 'TotalTime', */&#13;
	LastPrinted: 'LastPrinted',&#13;
	CreatedDate: 'Created',&#13;
	ModifiedDate: 'LastSaved',&#13;
	/* Pages */&#13;
	/* Words */&#13;
	/* Characters */&#13;
	Category: 'Category',&#13;
	/* PresentationFormat */&#13;
	Manager: 'Manager',&#13;
	Company: 'Company',&#13;
	/* Guid */&#13;
	/* HyperlinkBase */&#13;
	/* Bytes */&#13;
	/* Lines */&#13;
	/* Paragraphs */&#13;
	/* CharactersWithSpaces */&#13;
	AppVersion: 'Version',&#13;
&#13;
	ContentStatus: 'ContentStatus', /* NOTE: missing from schema */&#13;
	Identifier: 'Identifier', /* NOTE: missing from schema */&#13;
	Language: 'Language' /* NOTE: missing from schema */&#13;
};&#13;
var evert_XLMLDPM;&#13;
&#13;
function xlml_set_prop(Props, tag, val) {&#13;
	if(!evert_XLMLDPM) evert_XLMLDPM = evert(XLMLDocPropsMap);&#13;
	tag = evert_XLMLDPM[tag] || tag;&#13;
	Props[tag] = val;&#13;
}&#13;
&#13;
function xlml_write_docprops(Props, opts) {&#13;
	var o = [];&#13;
	keys(XLMLDocPropsMap).map(function(m) {&#13;
		for(var i = 0; i &lt; CORE_PROPS.length; ++i) if(CORE_PROPS[i][1] == m) return CORE_PROPS[i];&#13;
		for(i = 0; i &lt; EXT_PROPS.length; ++i) if(EXT_PROPS[i][1] == m) return EXT_PROPS[i];&#13;
		throw m;&#13;
	}).forEach(function(p) {&#13;
		if(Props[p[1]] == null) return;&#13;
		var m = opts &amp;&amp; opts.Props &amp;&amp; opts.Props[p[1]] != null ? opts.Props[p[1]] : Props[p[1]];&#13;
		switch(p[2]) {&#13;
			case 'date': m = new Date(m).toISOString().replace(/\.\d*Z/,"Z"); break;&#13;
		}&#13;
		if(typeof m == 'number') m = String(m);&#13;
		else if(m === true || m === false) { m = m ? "1" : "0"; }&#13;
		else if(m instanceof Date) m = new Date(m).toISOString().replace(/\.\d*Z/,"");&#13;
		o.push(writetag(XLMLDocPropsMap[p[1]] || p[1], m));&#13;
	});&#13;
	return writextag('DocumentProperties', o.join(""), {xmlns:XLMLNS.o });&#13;
}&#13;
function xlml_write_custprops(Props, Custprops) {&#13;
	var BLACKLIST = ["Worksheets","SheetNames"];&#13;
	var T = 'CustomDocumentProperties';&#13;
	var o = [];&#13;
	if(Props) keys(Props).forEach(function(k) {&#13;
if(!Object.prototype.hasOwnProperty.call(Props, k)) return;&#13;
		for(var i = 0; i &lt; CORE_PROPS.length; ++i) if(k == CORE_PROPS[i][1]) return;&#13;
		for(i = 0; i &lt; EXT_PROPS.length; ++i) if(k == EXT_PROPS[i][1]) return;&#13;
		for(i = 0; i &lt; BLACKLIST.length; ++i) if(k == BLACKLIST[i]) return;&#13;
&#13;
		var m = Props[k];&#13;
		var t = "string";&#13;
		if(typeof m == 'number') { t = "float"; m = String(m); }&#13;
		else if(m === true || m === false) { t = "boolean"; m = m ? "1" : "0"; }&#13;
		else m = String(m);&#13;
		o.push(writextag(escapexmltag(k), m, {"dt:dt":t}));&#13;
	});&#13;
	if(Custprops) keys(Custprops).forEach(function(k) {&#13;
if(!Object.prototype.hasOwnProperty.call(Custprops, k)) return;&#13;
		if(Props &amp;&amp; Object.prototype.hasOwnProperty.call(Props, k)) return;&#13;
		var m = Custprops[k];&#13;
		var t = "string";&#13;
		if(typeof m == 'number') { t = "float"; m = String(m); }&#13;
		else if(m === true || m === false) { t = "boolean"; m = m ? "1" : "0"; }&#13;
		else if(m instanceof Date) { t = "dateTime.tz"; m = m.toISOString(); }&#13;
		else m = String(m);&#13;
		o.push(writextag(escapexmltag(k), m, {"dt:dt":t}));&#13;
	});&#13;
	return '&lt;' + T + ' xmlns="' + XLMLNS.o + '"&gt;' + o.join("") + '&lt;/' + T + '&gt;';&#13;
}&#13;
/* [MS-DTYP] 2.3.3 FILETIME */&#13;
/* [MS-OLEDS] 2.1.3 FILETIME (Packet Version) */&#13;
/* [MS-OLEPS] 2.8 FILETIME (Packet Version) */&#13;
function parse_FILETIME(blob) {&#13;
	var dwLowDateTime = blob.read_shift(4), dwHighDateTime = blob.read_shift(4);&#13;
	return new Date(((dwHighDateTime/1e7*Math.pow(2,32) + dwLowDateTime/1e7) - 11644473600)*1000).toISOString().replace(/\.000/,"");&#13;
}&#13;
function write_FILETIME(time) {&#13;
	var date = (typeof time == "string") ? new Date(Date.parse(time)) : time;&#13;
	var t = date.getTime() / 1000 + 11644473600;&#13;
	var l = t % Math.pow(2,32), h = (t - l) / Math.pow(2,32);&#13;
	l *= 1e7; h *= 1e7;&#13;
	var w = (l / Math.pow(2,32)) | 0;&#13;
	if(w &gt; 0) { l = l % Math.pow(2,32); h += w; }&#13;
	var o = new_buf(8); o.write_shift(4, l); o.write_shift(4, h); return o;&#13;
}&#13;
&#13;
/* [MS-OSHARED] 2.3.3.1.4 Lpstr */&#13;
function parse_lpstr(blob, type, pad) {&#13;
	var start = blob.l;&#13;
	var str = blob.read_shift(0, 'lpstr-cp');&#13;
	if(pad) while((blob.l - start) &amp; 3) ++blob.l;&#13;
	return str;&#13;
}&#13;
&#13;
/* [MS-OSHARED] 2.3.3.1.6 Lpwstr */&#13;
function parse_lpwstr(blob, type, pad) {&#13;
	var str = blob.read_shift(0, 'lpwstr');&#13;
	if(pad) blob.l += (4 - ((str.length+1) &amp; 3)) &amp; 3;&#13;
	return str;&#13;
}&#13;
&#13;
&#13;
/* [MS-OSHARED] 2.3.3.1.11 VtString */&#13;
/* [MS-OSHARED] 2.3.3.1.12 VtUnalignedString */&#13;
function parse_VtStringBase(blob, stringType, pad) {&#13;
	if(stringType === 0x1F /*VT_LPWSTR*/) return parse_lpwstr(blob);&#13;
	return parse_lpstr(blob, stringType, pad);&#13;
}&#13;
&#13;
function parse_VtString(blob, t, pad) { return parse_VtStringBase(blob, t, pad === false ? 0: 4); }&#13;
function parse_VtUnalignedString(blob, t) { if(!t) throw new Error("VtUnalignedString must have positive length"); return parse_VtStringBase(blob, t, 0); }&#13;
&#13;
/* [MS-OSHARED] 2.3.3.1.7 VtVecLpwstrValue */&#13;
function parse_VtVecLpwstrValue(blob) {&#13;
	var length = blob.read_shift(4);&#13;
	var ret = [];&#13;
	for(var i = 0; i != length; ++i) {&#13;
		var start = blob.l;&#13;
		ret[i] = blob.read_shift(0, 'lpwstr').replace(chr0,'');&#13;
		if((blob.l - start) &amp; 0x02) blob.l += 2;&#13;
	}&#13;
	return ret;&#13;
}&#13;
&#13;
/* [MS-OSHARED] 2.3.3.1.9 VtVecUnalignedLpstrValue */&#13;
function parse_VtVecUnalignedLpstrValue(blob) {&#13;
	var length = blob.read_shift(4);&#13;
	var ret = [];&#13;
	for(var i = 0; i != length; ++i) ret[i] = blob.read_shift(0, 'lpstr-cp').replace(chr0,'');&#13;
	return ret;&#13;
}&#13;
&#13;
&#13;
/* [MS-OSHARED] 2.3.3.1.13 VtHeadingPair */&#13;
function parse_VtHeadingPair(blob) {&#13;
	var start = blob.l;&#13;
	var headingString = parse_TypedPropertyValue(blob, VT_USTR);&#13;
	if(blob[blob.l] == 0x00 &amp;&amp; blob[blob.l+1] == 0x00 &amp;&amp; ((blob.l - start) &amp; 0x02)) blob.l += 2;&#13;
	var headerParts = parse_TypedPropertyValue(blob, VT_I4);&#13;
	return [headingString, headerParts];&#13;
}&#13;
&#13;
/* [MS-OSHARED] 2.3.3.1.14 VtVecHeadingPairValue */&#13;
function parse_VtVecHeadingPairValue(blob) {&#13;
	var cElements = blob.read_shift(4);&#13;
	var out = [];&#13;
	for(var i = 0; i &lt; cElements / 2; ++i) out.push(parse_VtHeadingPair(blob));&#13;
	return out;&#13;
}&#13;
&#13;
/* [MS-OLEPS] 2.18.1 Dictionary (uses 2.17, 2.16) */&#13;
function parse_dictionary(blob,CodePage) {&#13;
	var cnt = blob.read_shift(4);&#13;
	var dict = ({});&#13;
	for(var j = 0; j != cnt; ++j) {&#13;
		var pid = blob.read_shift(4);&#13;
		var len = blob.read_shift(4);&#13;
		dict[pid] = blob.read_shift(len, (CodePage === 0x4B0 ?'utf16le':'utf8')).replace(chr0,'').replace(chr1,'!');&#13;
		if(CodePage === 0x4B0 &amp;&amp; (len % 2)) blob.l += 2;&#13;
	}&#13;
	if(blob.l &amp; 3) blob.l = (blob.l&gt;&gt;2+1)&lt;&lt;2;&#13;
	return dict;&#13;
}&#13;
&#13;
/* [MS-OLEPS] 2.9 BLOB */&#13;
function parse_BLOB(blob) {&#13;
	var size = blob.read_shift(4);&#13;
	var bytes = blob.slice(blob.l,blob.l+size);&#13;
	blob.l += size;&#13;
	if((size &amp; 3) &gt; 0) blob.l += (4 - (size &amp; 3)) &amp; 3;&#13;
	return bytes;&#13;
}&#13;
&#13;
/* [MS-OLEPS] 2.11 ClipboardData */&#13;
function parse_ClipboardData(blob) {&#13;
	// TODO&#13;
	var o = {};&#13;
	o.Size = blob.read_shift(4);&#13;
	//o.Format = blob.read_shift(4);&#13;
	blob.l += o.Size + 3 - (o.Size - 1) % 4;&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-OLEPS] 2.15 TypedPropertyValue */&#13;
function parse_TypedPropertyValue(blob, type, _opts) {&#13;
	var t = blob.read_shift(2), ret, opts = _opts||{};&#13;
	blob.l += 2;&#13;
	if(type !== VT_VARIANT)&#13;
	if(t !== type &amp;&amp; VT_CUSTOM.indexOf(type)===-1 &amp;&amp; !((type &amp; 0xFFFE) == 0x101E &amp;&amp; (t &amp; 0xFFFE) == 0x101E)) throw new Error('Expected type ' + type + ' saw ' + t);&#13;
	switch(type === VT_VARIANT ? t : type) {&#13;
		case 0x02 /*VT_I2*/: ret = blob.read_shift(2, 'i'); if(!opts.raw) blob.l += 2; return ret;&#13;
		case 0x03 /*VT_I4*/: ret = blob.read_shift(4, 'i'); return ret;&#13;
		case 0x0B /*VT_BOOL*/: return blob.read_shift(4) !== 0x0;&#13;
		case 0x13 /*VT_UI4*/: ret = blob.read_shift(4); return ret;&#13;
		case 0x1E /*VT_LPSTR*/: return parse_lpstr(blob, t, 4).replace(chr0,'');&#13;
		case 0x1F /*VT_LPWSTR*/: return parse_lpwstr(blob);&#13;
		case 0x40 /*VT_FILETIME*/: return parse_FILETIME(blob);&#13;
		case 0x41 /*VT_BLOB*/: return parse_BLOB(blob);&#13;
		case 0x47 /*VT_CF*/: return parse_ClipboardData(blob);&#13;
		case 0x50 /*VT_STRING*/: return parse_VtString(blob, t, !opts.raw).replace(chr0,'');&#13;
		case 0x51 /*VT_USTR*/: return parse_VtUnalignedString(blob, t/*, 4*/).replace(chr0,'');&#13;
		case 0x100C /*VT_VECTOR|VT_VARIANT*/: return parse_VtVecHeadingPairValue(blob);&#13;
		case 0x101E /*VT_VECTOR|VT_LPSTR*/:&#13;
		case 0x101F /*VT_VECTOR|VT_LPWSTR*/:&#13;
			return t == 0x101F ? parse_VtVecLpwstrValue(blob) : parse_VtVecUnalignedLpstrValue(blob);&#13;
		default: throw new Error("TypedPropertyValue unrecognized type " + type + " " + t);&#13;
	}&#13;
}&#13;
function write_TypedPropertyValue(type, value) {&#13;
	var o = new_buf(4), p = new_buf(4);&#13;
	o.write_shift(4, type == 0x50 ? 0x1F : type);&#13;
	switch(type) {&#13;
		case 0x03 /*VT_I4*/: p.write_shift(-4, value); break;&#13;
		case 0x05 /*VT_I4*/: p = new_buf(8); p.write_shift(8, value, 'f'); break;&#13;
		case 0x0B /*VT_BOOL*/: p.write_shift(4, value ? 0x01 : 0x00); break;&#13;
		case 0x40 /*VT_FILETIME*/:  p = write_FILETIME(value); break;&#13;
		case 0x1F /*VT_LPWSTR*/:&#13;
		case 0x50 /*VT_STRING*/:&#13;
p = new_buf(4 + 2 * (value.length + 1) + (value.length % 2 ? 0 : 2));&#13;
			p.write_shift(4, value.length + 1);&#13;
			p.write_shift(0, value, "dbcs");&#13;
			while(p.l != p.length) p.write_shift(1, 0);&#13;
			break;&#13;
		default: throw new Error("TypedPropertyValue unrecognized type " + type + " " + value);&#13;
	}&#13;
	return bconcat([o, p]);&#13;
}&#13;
&#13;
/* [MS-OLEPS] 2.20 PropertySet */&#13;
function parse_PropertySet(blob, PIDSI) {&#13;
	var start_addr = blob.l;&#13;
	var size = blob.read_shift(4);&#13;
	var NumProps = blob.read_shift(4);&#13;
	var Props = [], i = 0;&#13;
	var CodePage = 0;&#13;
	var Dictionary = -1, DictObj = ({});&#13;
	for(i = 0; i != NumProps; ++i) {&#13;
		var PropID = blob.read_shift(4);&#13;
		var Offset = blob.read_shift(4);&#13;
		Props[i] = [PropID, Offset + start_addr];&#13;
	}&#13;
	Props.sort(function(x,y) { return x[1] - y[1]; });&#13;
	var PropH = {};&#13;
	for(i = 0; i != NumProps; ++i) {&#13;
		if(blob.l !== Props[i][1]) {&#13;
			var fail = true;&#13;
			if(i&gt;0 &amp;&amp; PIDSI) switch(PIDSI[Props[i-1][0]].t) {&#13;
				case 0x02 /*VT_I2*/: if(blob.l+2 === Props[i][1]) { blob.l+=2; fail = false; } break;&#13;
				case 0x50 /*VT_STRING*/: if(blob.l &lt;= Props[i][1]) { blob.l=Props[i][1]; fail = false; } break;&#13;
				case 0x100C /*VT_VECTOR|VT_VARIANT*/: if(blob.l &lt;= Props[i][1]) { blob.l=Props[i][1]; fail = false; } break;&#13;
			}&#13;
			if((!PIDSI||i==0) &amp;&amp; blob.l &lt;= Props[i][1]) { fail=false; blob.l = Props[i][1]; }&#13;
			if(fail) throw new Error("Read Error: Expected address " + Props[i][1] + ' at ' + blob.l + ' :' + i);&#13;
		}&#13;
		if(PIDSI) {&#13;
			if(Props[i][0] == 0 &amp;&amp; Props.length &gt; i+1 &amp;&amp; Props[i][1] == Props[i+1][1]) continue; // R9&#13;
			var piddsi = PIDSI[Props[i][0]];&#13;
			PropH[piddsi.n] = parse_TypedPropertyValue(blob, piddsi.t, {raw:true});&#13;
			if(piddsi.p === 'version') PropH[piddsi.n] = String(PropH[piddsi.n] &gt;&gt; 16) + "." + ("0000" + String(PropH[piddsi.n] &amp; 0xFFFF)).slice(-4);&#13;
			if(piddsi.n == "CodePage") switch(PropH[piddsi.n]) {&#13;
				case 0: PropH[piddsi.n] = 1252;&#13;
					/* falls through */&#13;
				case 874:&#13;
				case 932:&#13;
				case 936:&#13;
				case 949:&#13;
				case 950:&#13;
				case 1250:&#13;
				case 1251:&#13;
				case 1253:&#13;
				case 1254:&#13;
				case 1255:&#13;
				case 1256:&#13;
				case 1257:&#13;
				case 1258:&#13;
				case 10000:&#13;
				case 1200:&#13;
				case 1201:&#13;
				case 1252:&#13;
				case 65000: case -536:&#13;
				case 65001: case -535:&#13;
					set_cp(CodePage = (PropH[piddsi.n]&gt;&gt;&gt;0) &amp; 0xFFFF); break;&#13;
				default: throw new Error("Unsupported CodePage: " + PropH[piddsi.n]);&#13;
			}&#13;
		} else {&#13;
			if(Props[i][0] === 0x1) {&#13;
				CodePage = PropH.CodePage = (parse_TypedPropertyValue(blob, VT_I2));&#13;
				set_cp(CodePage);&#13;
				if(Dictionary !== -1) {&#13;
					var oldpos = blob.l;&#13;
					blob.l = Props[Dictionary][1];&#13;
					DictObj = parse_dictionary(blob,CodePage);&#13;
					blob.l = oldpos;&#13;
				}&#13;
			} else if(Props[i][0] === 0) {&#13;
				if(CodePage === 0) { Dictionary = i; blob.l = Props[i+1][1]; continue; }&#13;
				DictObj = parse_dictionary(blob,CodePage);&#13;
			} else {&#13;
				var name = DictObj[Props[i][0]];&#13;
				var val;&#13;
				/* [MS-OSHARED] 2.3.3.2.3.1.2 + PROPVARIANT */&#13;
				switch(blob[blob.l]) {&#13;
					case 0x41 /*VT_BLOB*/: blob.l += 4; val = parse_BLOB(blob); break;&#13;
					case 0x1E /*VT_LPSTR*/: blob.l += 4; val = parse_VtString(blob, blob[blob.l-4]).replace(/\u0000+$/,""); break;&#13;
					case 0x1F /*VT_LPWSTR*/: blob.l += 4; val = parse_VtString(blob, blob[blob.l-4]).replace(/\u0000+$/,""); break;&#13;
					case 0x03 /*VT_I4*/: blob.l += 4; val = blob.read_shift(4, 'i'); break;&#13;
					case 0x13 /*VT_UI4*/: blob.l += 4; val = blob.read_shift(4); break;&#13;
					case 0x05 /*VT_R8*/: blob.l += 4; val = blob.read_shift(8, 'f'); break;&#13;
					case 0x0B /*VT_BOOL*/: blob.l += 4; val = parsebool(blob, 4); break;&#13;
					case 0x40 /*VT_FILETIME*/: blob.l += 4; val = parseDate(parse_FILETIME(blob)); break;&#13;
					default: throw new Error("unparsed value: " + blob[blob.l]);&#13;
				}&#13;
				PropH[name] = val;&#13;
			}&#13;
		}&#13;
	}&#13;
	blob.l = start_addr + size; /* step ahead to skip padding */&#13;
	return PropH;&#13;
}&#13;
var XLSPSSkip = [ "CodePage", "Thumbnail", "_PID_LINKBASE", "_PID_HLINKS", "SystemIdentifier", "FMTID" ];&#13;
function guess_property_type(val) {&#13;
	switch(typeof val) {&#13;
		case "boolean": return 0x0B;&#13;
		case "number": return ((val|0)==val) ? 0x03 : 0x05;&#13;
		case "string": return 0x1F;&#13;
		case "object": if(val instanceof Date) return 0x40; break;&#13;
	}&#13;
	return -1;&#13;
}&#13;
function write_PropertySet(entries, RE, PIDSI) {&#13;
	var hdr = new_buf(8), piao = [], prop = [];&#13;
	var sz = 8, i = 0;&#13;
&#13;
	var pr = new_buf(8), pio = new_buf(8);&#13;
	pr.write_shift(4, 0x0002);&#13;
	pr.write_shift(4, 0x04B0);&#13;
	pio.write_shift(4, 0x0001);&#13;
	prop.push(pr); piao.push(pio);&#13;
	sz += 8 + pr.length;&#13;
&#13;
	if(!RE) {&#13;
		pio = new_buf(8);&#13;
		pio.write_shift(4, 0);&#13;
		piao.unshift(pio);&#13;
&#13;
		var bufs = [new_buf(4)];&#13;
		bufs[0].write_shift(4, entries.length);&#13;
		for(i = 0; i &lt; entries.length; ++i) {&#13;
			var value = entries[i][0];&#13;
			pr = new_buf(4 + 4 + 2 * (value.length + 1) + (value.length % 2 ? 0 : 2));&#13;
			pr.write_shift(4, i+2);&#13;
			pr.write_shift(4, value.length + 1);&#13;
			pr.write_shift(0, value, "dbcs");&#13;
			while(pr.l != pr.length) pr.write_shift(1, 0);&#13;
			bufs.push(pr);&#13;
		}&#13;
		pr = bconcat(bufs);&#13;
		prop.unshift(pr);&#13;
		sz += 8 + pr.length;&#13;
	}&#13;
&#13;
	for(i = 0; i &lt; entries.length; ++i) {&#13;
		if(RE &amp;&amp; !RE[entries[i][0]]) continue;&#13;
		if(XLSPSSkip.indexOf(entries[i][0]) &gt; -1 || PseudoPropsPairs.indexOf(entries[i][0]) &gt; -1) continue;&#13;
		if(entries[i][1] == null) continue;&#13;
&#13;
		var val = entries[i][1], idx = 0;&#13;
		if(RE) {&#13;
			idx = +RE[entries[i][0]];&#13;
			var pinfo = (PIDSI)[idx];&#13;
			if(pinfo.p == "version" &amp;&amp; typeof val == "string") {&#13;
var arr = val.split(".");&#13;
				val = ((+arr[0])&lt;&lt;16) + ((+arr[1])||0);&#13;
			}&#13;
			pr = write_TypedPropertyValue(pinfo.t, val);&#13;
		} else {&#13;
			var T = guess_property_type(val);&#13;
			if(T == -1) { T = 0x1F; val = String(val); }&#13;
			pr = write_TypedPropertyValue(T, val);&#13;
		}&#13;
		prop.push(pr);&#13;
&#13;
		pio = new_buf(8);&#13;
		pio.write_shift(4, !RE ? 2+i : idx);&#13;
		piao.push(pio);&#13;
&#13;
		sz += 8 + pr.length;&#13;
	}&#13;
&#13;
	var w = 8 * (prop.length + 1);&#13;
	for(i = 0; i &lt; prop.length; ++i) { piao[i].write_shift(4, w); w += prop[i].length; }&#13;
	hdr.write_shift(4, sz);&#13;
	hdr.write_shift(4, prop.length);&#13;
	return bconcat([hdr].concat(piao).concat(prop));&#13;
}&#13;
&#13;
/* [MS-OLEPS] 2.21 PropertySetStream */&#13;
function parse_PropertySetStream(file, PIDSI, clsid) {&#13;
	var blob = file.content;&#13;
	if(!blob) return ({});&#13;
	prep_blob(blob, 0);&#13;
&#13;
	var NumSets, FMTID0, FMTID1, Offset0, Offset1 = 0;&#13;
	blob.chk('feff', 'Byte Order: ');&#13;
&#13;
	/*var vers = */blob.read_shift(2); // TODO: check version&#13;
	var SystemIdentifier = blob.read_shift(4);&#13;
	var CLSID = blob.read_shift(16);&#13;
	if(CLSID !== CFB.utils.consts.HEADER_CLSID &amp;&amp; CLSID !== clsid) throw new Error("Bad PropertySet CLSID " + CLSID);&#13;
	NumSets = blob.read_shift(4);&#13;
	if(NumSets !== 1 &amp;&amp; NumSets !== 2) throw new Error("Unrecognized #Sets: " + NumSets);&#13;
	FMTID0 = blob.read_shift(16); Offset0 = blob.read_shift(4);&#13;
&#13;
	if(NumSets === 1 &amp;&amp; Offset0 !== blob.l) throw new Error("Length mismatch: " + Offset0 + " !== " + blob.l);&#13;
	else if(NumSets === 2) { FMTID1 = blob.read_shift(16); Offset1 = blob.read_shift(4); }&#13;
	var PSet0 = parse_PropertySet(blob, PIDSI);&#13;
&#13;
	var rval = ({ SystemIdentifier: SystemIdentifier });&#13;
	for(var y in PSet0) rval[y] = PSet0[y];&#13;
	//rval.blob = blob;&#13;
	rval.FMTID = FMTID0;&#13;
	//rval.PSet0 = PSet0;&#13;
	if(NumSets === 1) return rval;&#13;
	if(Offset1 - blob.l == 2) blob.l += 2;&#13;
	if(blob.l !== Offset1) throw new Error("Length mismatch 2: " + blob.l + " !== " + Offset1);&#13;
	var PSet1;&#13;
	try { PSet1 = parse_PropertySet(blob, null); } catch(e) {/* empty */}&#13;
	for(y in PSet1) rval[y] = PSet1[y];&#13;
	rval.FMTID = [FMTID0, FMTID1]; // TODO: verify FMTID0/1&#13;
	return rval;&#13;
}&#13;
function write_PropertySetStream(entries, clsid, RE, PIDSI, entries2, clsid2) {&#13;
	var hdr = new_buf(entries2 ? 68 : 48);&#13;
	var bufs = [hdr];&#13;
	hdr.write_shift(2, 0xFFFE);&#13;
	hdr.write_shift(2, 0x0000); /* TODO: type 1 props */&#13;
	hdr.write_shift(4, 0x32363237);&#13;
	hdr.write_shift(16, CFB.utils.consts.HEADER_CLSID, "hex");&#13;
	hdr.write_shift(4, (entries2 ? 2 : 1));&#13;
	hdr.write_shift(16, clsid, "hex");&#13;
	hdr.write_shift(4, (entries2 ? 68 : 48));&#13;
	var ps0 = write_PropertySet(entries, RE, PIDSI);&#13;
	bufs.push(ps0);&#13;
&#13;
	if(entries2) {&#13;
		var ps1 = write_PropertySet(entries2, null, null);&#13;
		hdr.write_shift(16, clsid2, "hex");&#13;
		hdr.write_shift(4, 68 + ps0.length);&#13;
		bufs.push(ps1);&#13;
	}&#13;
	return bconcat(bufs);&#13;
}&#13;
&#13;
function parsenoop2(blob, length) { blob.read_shift(length); return null; }&#13;
function writezeroes(n, o) { if(!o) o=new_buf(n); for(var j=0; j&lt;n; ++j) o.write_shift(1, 0); return o; }&#13;
&#13;
function parslurp(blob, length, cb) {&#13;
	var arr = [], target = blob.l + length;&#13;
	while(blob.l &lt; target) arr.push(cb(blob, target - blob.l));&#13;
	if(target !== blob.l) throw new Error("Slurp error");&#13;
	return arr;&#13;
}&#13;
&#13;
function parsebool(blob, length) { return blob.read_shift(length) === 0x1; }&#13;
function writebool(v, o) { if(!o) o=new_buf(2); o.write_shift(2, +!!v); return o; }&#13;
&#13;
function parseuint16(blob) { return blob.read_shift(2, 'u'); }&#13;
function writeuint16(v, o) { if(!o) o=new_buf(2); o.write_shift(2, v); return o; }&#13;
function parseuint16a(blob, length) { return parslurp(blob,length,parseuint16);}&#13;
&#13;
/* --- 2.5 Structures --- */&#13;
&#13;
/* [MS-XLS] 2.5.10 Bes (boolean or error) */&#13;
function parse_Bes(blob) {&#13;
	var v = blob.read_shift(1), t = blob.read_shift(1);&#13;
	return t === 0x01 ? v : v === 0x01;&#13;
}&#13;
function write_Bes(v, t, o) {&#13;
	if(!o) o = new_buf(2);&#13;
	o.write_shift(1, ((t == 'e') ? +v : +!!v));&#13;
	o.write_shift(1, ((t == 'e') ? 1 : 0));&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.240 ShortXLUnicodeString */&#13;
function parse_ShortXLUnicodeString(blob, length, opts) {&#13;
	var cch = blob.read_shift(opts &amp;&amp; opts.biff &gt;= 12 ? 2 : 1);&#13;
	var encoding = 'sbcs-cont';&#13;
	var cp = current_codepage;&#13;
	if(opts &amp;&amp; opts.biff &gt;= 8) current_codepage = 1200;&#13;
	if(!opts || opts.biff == 8 ) {&#13;
		var fHighByte = blob.read_shift(1);&#13;
		if(fHighByte) { encoding = 'dbcs-cont'; }&#13;
	} else if(opts.biff == 12) {&#13;
		encoding = 'wstr';&#13;
	}&#13;
	if(opts.biff &gt;= 2 &amp;&amp; opts.biff &lt;= 5) encoding = 'cpstr';&#13;
	var o = cch ? blob.read_shift(cch, encoding) : "";&#13;
	current_codepage = cp;&#13;
	return o;&#13;
}&#13;
&#13;
/* 2.5.293 XLUnicodeRichExtendedString */&#13;
function parse_XLUnicodeRichExtendedString(blob) {&#13;
	var cp = current_codepage;&#13;
	current_codepage = 1200;&#13;
	var cch = blob.read_shift(2), flags = blob.read_shift(1);&#13;
	var /*fHighByte = flags &amp; 0x1,*/ fExtSt = flags &amp; 0x4, fRichSt = flags &amp; 0x8;&#13;
	var width = 1 + (flags &amp; 0x1); // 0x0 -&gt; utf8, 0x1 -&gt; dbcs&#13;
	var cRun = 0, cbExtRst;&#13;
	var z = {};&#13;
	if(fRichSt) cRun = blob.read_shift(2);&#13;
	if(fExtSt) cbExtRst = blob.read_shift(4);&#13;
	var encoding = width == 2 ? 'dbcs-cont' : 'sbcs-cont';&#13;
	var msg = cch === 0 ? "" : blob.read_shift(cch, encoding);&#13;
	if(fRichSt) blob.l += 4 * cRun; //TODO: parse this&#13;
	if(fExtSt) blob.l += cbExtRst; //TODO: parse this&#13;
	z.t = msg;&#13;
	if(!fRichSt) { z.raw = "&lt;t&gt;" + z.t + "&lt;/t&gt;"; z.r = z.t; }&#13;
	current_codepage = cp;&#13;
	return z;&#13;
}&#13;
function write_XLUnicodeRichExtendedString(xlstr) {&#13;
	var str = (xlstr.t||""), nfmts = 1;&#13;
&#13;
	var hdr = new_buf(3 + (nfmts &gt; 1 ? 2 : 0));&#13;
	hdr.write_shift(2, str.length);&#13;
	hdr.write_shift(1, (nfmts &gt; 1 ? 0x08 : 0x00) | 0x01);&#13;
	if(nfmts &gt; 1) hdr.write_shift(2, nfmts);&#13;
&#13;
	var otext = new_buf(2 * str.length);&#13;
	otext.write_shift(2 * str.length, str, 'utf16le');&#13;
&#13;
	var out = [hdr, otext];&#13;
&#13;
	return bconcat(out);&#13;
}&#13;
&#13;
/* 2.5.296 XLUnicodeStringNoCch */&#13;
function parse_XLUnicodeStringNoCch(blob, cch, opts) {&#13;
	var retval;&#13;
	if(opts) {&#13;
		if(opts.biff &gt;= 2 &amp;&amp; opts.biff &lt;= 5) return blob.read_shift(cch, 'cpstr');&#13;
		if(opts.biff &gt;= 12) return blob.read_shift(cch, 'dbcs-cont');&#13;
	}&#13;
	var fHighByte = blob.read_shift(1);&#13;
	if(fHighByte===0) { retval = blob.read_shift(cch, 'sbcs-cont'); }&#13;
	else { retval = blob.read_shift(cch, 'dbcs-cont'); }&#13;
	return retval;&#13;
}&#13;
&#13;
/* 2.5.294 XLUnicodeString */&#13;
function parse_XLUnicodeString(blob, length, opts) {&#13;
	var cch = blob.read_shift(opts &amp;&amp; opts.biff == 2 ? 1 : 2);&#13;
	if(cch === 0) { blob.l++; return ""; }&#13;
	return parse_XLUnicodeStringNoCch(blob, cch, opts);&#13;
}&#13;
/* BIFF5 override */&#13;
function parse_XLUnicodeString2(blob, length, opts) {&#13;
	if(opts.biff &gt; 5) return parse_XLUnicodeString(blob, length, opts);&#13;
	var cch = blob.read_shift(1);&#13;
	if(cch === 0) { blob.l++; return ""; }&#13;
	return blob.read_shift(cch, (opts.biff &lt;= 4 || !blob.lens ) ? 'cpstr' : 'sbcs-cont');&#13;
}&#13;
/* TODO: BIFF5 and lower, codepage awareness */&#13;
function write_XLUnicodeString(str, opts, o) {&#13;
	if(!o) o = new_buf(3 + 2 * str.length);&#13;
	o.write_shift(2, str.length);&#13;
	o.write_shift(1, 1);&#13;
	o.write_shift(31, str, 'utf16le');&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.61 ControlInfo */&#13;
function parse_ControlInfo(blob) {&#13;
	var flags = blob.read_shift(1);&#13;
	blob.l++;&#13;
	var accel = blob.read_shift(2);&#13;
	blob.l += 2;&#13;
	return [flags, accel];&#13;
}&#13;
&#13;
/* [MS-OSHARED] 2.3.7.6 URLMoniker TODO: flags */&#13;
function parse_URLMoniker(blob) {&#13;
	var len = blob.read_shift(4), start = blob.l;&#13;
	var extra = false;&#13;
	if(len &gt; 24) {&#13;
		/* look ahead */&#13;
		blob.l += len - 24;&#13;
		if(blob.read_shift(16) === "795881f43b1d7f48af2c825dc4852763") extra = true;&#13;
		blob.l = start;&#13;
	}&#13;
	var url = blob.read_shift((extra?len-24:len)&gt;&gt;1, 'utf16le').replace(chr0,"");&#13;
	if(extra) blob.l += 24;&#13;
	return url;&#13;
}&#13;
&#13;
/* [MS-OSHARED] 2.3.7.8 FileMoniker TODO: all fields */&#13;
function parse_FileMoniker(blob) {&#13;
	var cAnti = blob.read_shift(2);&#13;
	var preamble = ""; while(cAnti-- &gt; 0) preamble += "../";&#13;
	var ansiPath = blob.read_shift(0, 'lpstr-ansi');&#13;
	blob.l += 2; //var endServer = blob.read_shift(2);&#13;
	if(blob.read_shift(2) != 0xDEAD) throw new Error("Bad FileMoniker");&#13;
	var sz = blob.read_shift(4);&#13;
	if(sz === 0) return preamble + ansiPath.replace(/\\/g,"/");&#13;
	var bytes = blob.read_shift(4);&#13;
	if(blob.read_shift(2) != 3) throw new Error("Bad FileMoniker");&#13;
	var unicodePath = blob.read_shift(bytes&gt;&gt;1, 'utf16le').replace(chr0,"");&#13;
	return preamble + unicodePath;&#13;
}&#13;
&#13;
/* [MS-OSHARED] 2.3.7.2 HyperlinkMoniker TODO: all the monikers */&#13;
function parse_HyperlinkMoniker(blob, length) {&#13;
	var clsid = blob.read_shift(16); length -= 16;&#13;
	switch(clsid) {&#13;
		case "e0c9ea79f9bace118c8200aa004ba90b": return parse_URLMoniker(blob, length);&#13;
		case "0303000000000000c000000000000046": return parse_FileMoniker(blob, length);&#13;
		default: throw new Error("Unsupported Moniker " + clsid);&#13;
	}&#13;
}&#13;
&#13;
/* [MS-OSHARED] 2.3.7.9 HyperlinkString */&#13;
function parse_HyperlinkString(blob) {&#13;
	var len = blob.read_shift(4);&#13;
	var o = len &gt; 0 ? blob.read_shift(len, 'utf16le').replace(chr0, "") : "";&#13;
	return o;&#13;
}&#13;
function write_HyperlinkString(str, o) {&#13;
	if(!o) o = new_buf(6 + str.length * 2);&#13;
	o.write_shift(4, 1 + str.length);&#13;
	for(var i = 0; i &lt; str.length; ++i) o.write_shift(2, str.charCodeAt(i));&#13;
	o.write_shift(2, 0);&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-OSHARED] 2.3.7.1 Hyperlink Object */&#13;
function parse_Hyperlink(blob, length) {&#13;
	var end = blob.l + length;&#13;
	var sVer = blob.read_shift(4);&#13;
	if(sVer !== 2) throw new Error("Unrecognized streamVersion: " + sVer);&#13;
	var flags = blob.read_shift(2);&#13;
	blob.l += 2;&#13;
	var displayName, targetFrameName, moniker, oleMoniker, Loc="", guid, fileTime;&#13;
	if(flags &amp; 0x0010) displayName = parse_HyperlinkString(blob, end - blob.l);&#13;
	if(flags &amp; 0x0080) targetFrameName = parse_HyperlinkString(blob, end - blob.l);&#13;
	if((flags &amp; 0x0101) === 0x0101) moniker = parse_HyperlinkString(blob, end - blob.l);&#13;
	if((flags &amp; 0x0101) === 0x0001) oleMoniker = parse_HyperlinkMoniker(blob, end - blob.l);&#13;
	if(flags &amp; 0x0008) Loc = parse_HyperlinkString(blob, end - blob.l);&#13;
	if(flags &amp; 0x0020) guid = blob.read_shift(16);&#13;
	if(flags &amp; 0x0040) fileTime = parse_FILETIME(blob/*, 8*/);&#13;
	blob.l = end;&#13;
	var target = targetFrameName||moniker||oleMoniker||"";&#13;
	if(target &amp;&amp; Loc) target+="#"+Loc;&#13;
	if(!target) target = "#" + Loc;&#13;
	if((flags &amp; 0x0002) &amp;&amp; target.charAt(0) == "/" &amp;&amp; target.charAt(1) != "/") target = "file://" + target;&#13;
	var out = ({Target:target});&#13;
	if(guid) out.guid = guid;&#13;
	if(fileTime) out.time = fileTime;&#13;
	if(displayName) out.Tooltip = displayName;&#13;
	return out;&#13;
}&#13;
function write_Hyperlink(hl) {&#13;
	var out = new_buf(512), i = 0;&#13;
	var Target = hl.Target;&#13;
	if(Target.slice(0,7) == "file://") Target = Target.slice(7);&#13;
	var hashidx = Target.indexOf("#");&#13;
	var F = hashidx &gt; -1 ? 0x1f : 0x17;&#13;
	switch(Target.charAt(0)) { case "#": F=0x1c; break; case ".": F&amp;=~2; break; }&#13;
	out.write_shift(4,2); out.write_shift(4, F);&#13;
	var data = [8,6815827,6619237,4849780,83]; for(i = 0; i &lt; data.length; ++i) out.write_shift(4, data[i]);&#13;
	if(F == 0x1C) {&#13;
		Target = Target.slice(1);&#13;
		write_HyperlinkString(Target, out);&#13;
	} else if(F &amp; 0x02) {&#13;
		data = "e0 c9 ea 79 f9 ba ce 11 8c 82 00 aa 00 4b a9 0b".split(" ");&#13;
		for(i = 0; i &lt; data.length; ++i) out.write_shift(1, parseInt(data[i], 16));&#13;
		var Pretarget = hashidx &gt; -1 ? Target.slice(0, hashidx) : Target;&#13;
		out.write_shift(4, 2*(Pretarget.length + 1));&#13;
		for(i = 0; i &lt; Pretarget.length; ++i) out.write_shift(2, Pretarget.charCodeAt(i));&#13;
		out.write_shift(2, 0);&#13;
		if(F &amp; 0x08) write_HyperlinkString(hashidx &gt; -1 ? Target.slice(hashidx+1): "", out);&#13;
	} else {&#13;
		data = "03 03 00 00 00 00 00 00 c0 00 00 00 00 00 00 46".split(" ");&#13;
		for(i = 0; i &lt; data.length; ++i) out.write_shift(1, parseInt(data[i], 16));&#13;
		var P = 0;&#13;
		while(Target.slice(P*3,P*3+3)=="../"||Target.slice(P*3,P*3+3)=="..\\") ++P;&#13;
		out.write_shift(2, P);&#13;
		out.write_shift(4, Target.length - 3 * P + 1);&#13;
		for(i = 0; i &lt; Target.length - 3 * P; ++i) out.write_shift(1, Target.charCodeAt(i + 3 * P) &amp; 0xFF);&#13;
		out.write_shift(1, 0);&#13;
		out.write_shift(2, 0xFFFF);&#13;
		out.write_shift(2, 0xDEAD);&#13;
		for(i = 0; i &lt; 6; ++i) out.write_shift(4, 0);&#13;
	}&#13;
	return out.slice(0, out.l);&#13;
}&#13;
&#13;
/* 2.5.178 LongRGBA */&#13;
function parse_LongRGBA(blob) { var r = blob.read_shift(1), g = blob.read_shift(1), b = blob.read_shift(1), a = blob.read_shift(1); return [r,g,b,a]; }&#13;
&#13;
/* 2.5.177 LongRGB */&#13;
function parse_LongRGB(blob, length) { var x = parse_LongRGBA(blob, length); x[3] = 0; return x; }&#13;
&#13;
&#13;
/* [MS-XLS] 2.5.19 */&#13;
function parse_XLSCell(blob) {&#13;
	var rw = blob.read_shift(2); // 0-indexed&#13;
	var col = blob.read_shift(2);&#13;
	var ixfe = blob.read_shift(2);&#13;
	return ({r:rw, c:col, ixfe:ixfe});&#13;
}&#13;
function write_XLSCell(R, C, ixfe, o) {&#13;
	if(!o) o = new_buf(6);&#13;
	o.write_shift(2, R);&#13;
	o.write_shift(2, C);&#13;
	o.write_shift(2, ixfe||0);&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.134 */&#13;
function parse_frtHeader(blob) {&#13;
	var rt = blob.read_shift(2);&#13;
	var flags = blob.read_shift(2); // TODO: parse these flags&#13;
	blob.l += 8;&#13;
	return {type: rt, flags: flags};&#13;
}&#13;
&#13;
&#13;
&#13;
function parse_OptXLUnicodeString(blob, length, opts) { return length === 0 ? "" : parse_XLUnicodeString2(blob, length, opts); }&#13;
&#13;
/* [MS-XLS] 2.5.344 */&#13;
function parse_XTI(blob, length, opts) {&#13;
	var w = opts.biff &gt; 8 ? 4 : 2;&#13;
	var iSupBook = blob.read_shift(w), itabFirst = blob.read_shift(w,'i'), itabLast = blob.read_shift(w,'i');&#13;
	return [iSupBook, itabFirst, itabLast];&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.218 */&#13;
function parse_RkRec(blob) {&#13;
	var ixfe = blob.read_shift(2);&#13;
	var RK = parse_RkNumber(blob);&#13;
	return [ixfe, RK];&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.1 */&#13;
function parse_AddinUdf(blob, length, opts) {&#13;
	blob.l += 4; length -= 4;&#13;
	var l = blob.l + length;&#13;
	var udfName = parse_ShortXLUnicodeString(blob, length, opts);&#13;
	var cb = blob.read_shift(2);&#13;
	l -= blob.l;&#13;
	if(cb !== l) throw new Error("Malformed AddinUdf: padding = " + l + " != " + cb);&#13;
	blob.l += cb;&#13;
	return udfName;&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.209 TODO: Check sizes */&#13;
function parse_Ref8U(blob) {&#13;
	var rwFirst = blob.read_shift(2);&#13;
	var rwLast = blob.read_shift(2);&#13;
	var colFirst = blob.read_shift(2);&#13;
	var colLast = blob.read_shift(2);&#13;
	return {s:{c:colFirst, r:rwFirst}, e:{c:colLast,r:rwLast}};&#13;
}&#13;
function write_Ref8U(r, o) {&#13;
	if(!o) o = new_buf(8);&#13;
	o.write_shift(2, r.s.r);&#13;
	o.write_shift(2, r.e.r);&#13;
	o.write_shift(2, r.s.c);&#13;
	o.write_shift(2, r.e.c);&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.211 */&#13;
function parse_RefU(blob) {&#13;
	var rwFirst = blob.read_shift(2);&#13;
	var rwLast = blob.read_shift(2);&#13;
	var colFirst = blob.read_shift(1);&#13;
	var colLast = blob.read_shift(1);&#13;
	return {s:{c:colFirst, r:rwFirst}, e:{c:colLast,r:rwLast}};&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.207 */&#13;
var parse_Ref = parse_RefU;&#13;
&#13;
/* [MS-XLS] 2.5.143 */&#13;
function parse_FtCmo(blob) {&#13;
	blob.l += 4;&#13;
	var ot = blob.read_shift(2);&#13;
	var id = blob.read_shift(2);&#13;
	var flags = blob.read_shift(2);&#13;
	blob.l+=12;&#13;
	return [id, ot, flags];&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.149 */&#13;
function parse_FtNts(blob) {&#13;
	var out = {};&#13;
	blob.l += 4;&#13;
	blob.l += 16; // GUID TODO&#13;
	out.fSharedNote = blob.read_shift(2);&#13;
	blob.l += 4;&#13;
	return out;&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.142 */&#13;
function parse_FtCf(blob) {&#13;
	var out = {};&#13;
	blob.l += 4;&#13;
	blob.cf = blob.read_shift(2);&#13;
	return out;&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.140 - 2.5.154 and friends */&#13;
function parse_FtSkip(blob) { blob.l += 2; blob.l += blob.read_shift(2); }&#13;
var FtTab = {&#13;
0x00: parse_FtSkip,      /* FtEnd */&#13;
0x04: parse_FtSkip,      /* FtMacro */&#13;
0x05: parse_FtSkip,      /* FtButton */&#13;
0x06: parse_FtSkip,      /* FtGmo */&#13;
0x07: parse_FtCf,        /* FtCf */&#13;
0x08: parse_FtSkip,      /* FtPioGrbit */&#13;
0x09: parse_FtSkip,      /* FtPictFmla */&#13;
0x0A: parse_FtSkip,      /* FtCbls */&#13;
0x0B: parse_FtSkip,      /* FtRbo */&#13;
0x0C: parse_FtSkip,      /* FtSbs */&#13;
0x0D: parse_FtNts,       /* FtNts */&#13;
0x0E: parse_FtSkip,      /* FtSbsFmla */&#13;
0x0F: parse_FtSkip,      /* FtGboData */&#13;
0x10: parse_FtSkip,      /* FtEdoData */&#13;
0x11: parse_FtSkip,      /* FtRboData */&#13;
0x12: parse_FtSkip,      /* FtCblsData */&#13;
0x13: parse_FtSkip,      /* FtLbsData */&#13;
0x14: parse_FtSkip,      /* FtCblsFmla */&#13;
0x15: parse_FtCmo&#13;
};&#13;
function parse_FtArray(blob, length) {&#13;
	var tgt = blob.l + length;&#13;
	var fts = [];&#13;
	while(blob.l &lt; tgt) {&#13;
		var ft = blob.read_shift(2);&#13;
		blob.l-=2;&#13;
		try {&#13;
			fts.push(FtTab[ft](blob, tgt - blob.l));&#13;
		} catch(e) { blob.l = tgt; return fts; }&#13;
	}&#13;
	if(blob.l != tgt) blob.l = tgt; //throw new Error("bad Object Ft-sequence");&#13;
	return fts;&#13;
}&#13;
&#13;
/* --- 2.4 Records --- */&#13;
&#13;
/* [MS-XLS] 2.4.21 */&#13;
function parse_BOF(blob, length) {&#13;
	var o = {BIFFVer:0, dt:0};&#13;
	o.BIFFVer = blob.read_shift(2); length -= 2;&#13;
	if(length &gt;= 2) { o.dt = blob.read_shift(2); blob.l -= 2; }&#13;
	switch(o.BIFFVer) {&#13;
		case 0x0600: /* BIFF8 */&#13;
		case 0x0500: /* BIFF5 */&#13;
		case 0x0400: /* BIFF4 */&#13;
		case 0x0300: /* BIFF3 */&#13;
		case 0x0200: /* BIFF2 */&#13;
		case 0x0002: case 0x0007: /* BIFF2 */&#13;
			break;&#13;
		default: if(length &gt; 6) throw new Error("Unexpected BIFF Ver " + o.BIFFVer);&#13;
	}&#13;
&#13;
	blob.read_shift(length);&#13;
	return o;&#13;
}&#13;
function write_BOF(wb, t, o) {&#13;
	var h = 0x0600, w = 16;&#13;
	switch(o.bookType) {&#13;
		case 'biff8': break;&#13;
		case 'biff5': h = 0x0500; w = 8; break;&#13;
		case 'biff4': h = 0x0004; w = 6; break;&#13;
		case 'biff3': h = 0x0003; w = 6; break;&#13;
		case 'biff2': h = 0x0002; w = 4; break;&#13;
		case 'xla': break;&#13;
		default: throw new Error("unsupported BIFF version");&#13;
	}&#13;
	var out = new_buf(w);&#13;
	out.write_shift(2, h);&#13;
	out.write_shift(2, t);&#13;
	if(w &gt; 4) out.write_shift(2, 0x7262);&#13;
	if(w &gt; 6) out.write_shift(2, 0x07CD);&#13;
	if(w &gt; 8) {&#13;
		out.write_shift(2, 0xC009);&#13;
		out.write_shift(2, 0x0001);&#13;
		out.write_shift(2, 0x0706);&#13;
		out.write_shift(2, 0x0000);&#13;
	}&#13;
	return out;&#13;
}&#13;
&#13;
&#13;
/* [MS-XLS] 2.4.146 */&#13;
function parse_InterfaceHdr(blob, length) {&#13;
	if(length === 0) return 0x04b0;&#13;
	if((blob.read_shift(2))!==0x04b0){/* empty */}&#13;
	return 0x04b0;&#13;
}&#13;
&#13;
&#13;
/* [MS-XLS] 2.4.349 */&#13;
function parse_WriteAccess(blob, length, opts) {&#13;
	if(opts.enc) { blob.l += length; return ""; }&#13;
	var l = blob.l;&#13;
	// TODO: make sure XLUnicodeString doesnt overrun&#13;
	var UserName = parse_XLUnicodeString2(blob, 0, opts);&#13;
	blob.read_shift(length + l - blob.l);&#13;
	return UserName;&#13;
}&#13;
function write_WriteAccess(s, opts) {&#13;
	var b8 = !opts || opts.biff == 8;&#13;
	var o = new_buf(b8 ? 112 : 54);&#13;
	o.write_shift(opts.biff == 8 ? 2 : 1, 7);&#13;
	if(b8) o.write_shift(1, 0);&#13;
	o.write_shift(4, 0x33336853);&#13;
	o.write_shift(4, (0x00534A74 | (b8 ? 0 : 0x20000000)));&#13;
	while(o.l &lt; o.length) o.write_shift(1, (b8 ? 0 : 32));&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLS] 2.4.351 */&#13;
function parse_WsBool(blob, length, opts) {&#13;
	var flags = opts &amp;&amp; opts.biff == 8 || length == 2 ? blob.read_shift(2) : (blob.l += length, 0);&#13;
	return { fDialog: flags &amp; 0x10, fBelow: flags &amp; 0x40, fRight: flags &amp; 0x80 };&#13;
}&#13;
&#13;
/* [MS-XLS] 2.4.28 */&#13;
function parse_BoundSheet8(blob, length, opts) {&#13;
	var pos = blob.read_shift(4);&#13;
	var hidden = blob.read_shift(1) &amp; 0x03;&#13;
	var dt = blob.read_shift(1);&#13;
	switch(dt) {&#13;
		case 0: dt = 'Worksheet'; break;&#13;
		case 1: dt = 'Macrosheet'; break;&#13;
		case 2: dt = 'Chartsheet'; break;&#13;
		case 6: dt = 'VBAModule'; break;&#13;
	}&#13;
	var name = parse_ShortXLUnicodeString(blob, 0, opts);&#13;
	if(name.length === 0) name = "Sheet1";&#13;
	return { pos:pos, hs:hidden, dt:dt, name:name };&#13;
}&#13;
function write_BoundSheet8(data, opts) {&#13;
	var w = (!opts || opts.biff &gt;= 8 ? 2 : 1);&#13;
	var o = new_buf(8 + w * data.name.length);&#13;
	o.write_shift(4, data.pos);&#13;
	o.write_shift(1, data.hs || 0);&#13;
	o.write_shift(1, data.dt);&#13;
	o.write_shift(1, data.name.length);&#13;
	if(opts.biff &gt;= 8) o.write_shift(1, 1);&#13;
	o.write_shift(w * data.name.length, data.name, opts.biff &lt; 8 ? 'sbcs' : 'utf16le');&#13;
	var out = o.slice(0, o.l);&#13;
	out.l = o.l; return out;&#13;
}&#13;
&#13;
/* [MS-XLS] 2.4.265 TODO */&#13;
function parse_SST(blob, length) {&#13;
	var end = blob.l + length;&#13;
	var cnt = blob.read_shift(4);&#13;
	var ucnt = blob.read_shift(4);&#13;
	var strs = ([]);&#13;
	for(var i = 0; i != ucnt &amp;&amp; blob.l &lt; end; ++i) {&#13;
		strs.push(parse_XLUnicodeRichExtendedString(blob));&#13;
	}&#13;
	strs.Count = cnt; strs.Unique = ucnt;&#13;
	return strs;&#13;
}&#13;
function write_SST(sst, opts) {&#13;
	var header = new_buf(8);&#13;
	header.write_shift(4, sst.Count);&#13;
	header.write_shift(4, sst.Unique);&#13;
	var strs = [];&#13;
	for(var j = 0; j &lt; sst.length; ++j) strs[j] = write_XLUnicodeRichExtendedString(sst[j], opts);&#13;
	var o = bconcat([header].concat(strs));&#13;
o.parts = [header.length].concat(strs.map(function(str) { return str.length; }));&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLS] 2.4.107 */&#13;
function parse_ExtSST(blob, length) {&#13;
	var extsst = {};&#13;
	extsst.dsst = blob.read_shift(2);&#13;
	blob.l += length-2;&#13;
	return extsst;&#13;
}&#13;
&#13;
&#13;
/* [MS-XLS] 2.4.221 TODO: check BIFF2-4 */&#13;
function parse_Row(blob) {&#13;
	var z = ({});&#13;
	z.r = blob.read_shift(2);&#13;
	z.c = blob.read_shift(2);&#13;
	z.cnt = blob.read_shift(2) - z.c;&#13;
	var miyRw = blob.read_shift(2);&#13;
	blob.l += 4; // reserved(2), unused(2)&#13;
	var flags = blob.read_shift(1); // various flags&#13;
	blob.l += 3; // reserved(8), ixfe(12), flags(4)&#13;
	if(flags &amp; 0x07) z.level = flags &amp; 0x07;&#13;
	// collapsed: flags &amp; 0x10&#13;
	if(flags &amp; 0x20) z.hidden = true;&#13;
	if(flags &amp; 0x40) z.hpt = miyRw / 20;&#13;
	return z;&#13;
}&#13;
&#13;
&#13;
/* [MS-XLS] 2.4.125 */&#13;
function parse_ForceFullCalculation(blob) {&#13;
	var header = parse_frtHeader(blob);&#13;
	if(header.type != 0x08A3) throw new Error("Invalid Future Record " + header.type);&#13;
	var fullcalc = blob.read_shift(4);&#13;
	return fullcalc !== 0x0;&#13;
}&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
/* [MS-XLS] 2.4.215 rt */&#13;
function parse_RecalcId(blob) {&#13;
	blob.read_shift(2);&#13;
	return blob.read_shift(4);&#13;
}&#13;
&#13;
/* [MS-XLS] 2.4.87 */&#13;
function parse_DefaultRowHeight(blob, length, opts) {&#13;
	var f = 0;&#13;
	if(!(opts &amp;&amp; opts.biff == 2)) {&#13;
		f = blob.read_shift(2);&#13;
	}&#13;
	var miyRw = blob.read_shift(2);&#13;
	if((opts &amp;&amp; opts.biff == 2)) {&#13;
		f = 1 - (miyRw &gt;&gt; 15); miyRw &amp;= 0x7fff;&#13;
	}&#13;
	var fl = {Unsynced:f&amp;1,DyZero:(f&amp;2)&gt;&gt;1,ExAsc:(f&amp;4)&gt;&gt;2,ExDsc:(f&amp;8)&gt;&gt;3};&#13;
	return [fl, miyRw];&#13;
}&#13;
&#13;
/* [MS-XLS] 2.4.345 TODO */&#13;
function parse_Window1(blob) {&#13;
	var xWn = blob.read_shift(2), yWn = blob.read_shift(2), dxWn = blob.read_shift(2), dyWn = blob.read_shift(2);&#13;
	var flags = blob.read_shift(2), iTabCur = blob.read_shift(2), iTabFirst = blob.read_shift(2);&#13;
	var ctabSel = blob.read_shift(2), wTabRatio = blob.read_shift(2);&#13;
	return { Pos: [xWn, yWn], Dim: [dxWn, dyWn], Flags: flags, CurTab: iTabCur,&#13;
		FirstTab: iTabFirst, Selected: ctabSel, TabRatio: wTabRatio };&#13;
}&#13;
function write_Window1() {&#13;
	var o = new_buf(18);&#13;
	o.write_shift(2, 0);&#13;
	o.write_shift(2, 0);&#13;
	o.write_shift(2, 0x7260);&#13;
	o.write_shift(2, 0x44c0);&#13;
	o.write_shift(2, 0x38);&#13;
	o.write_shift(2, 0);&#13;
	o.write_shift(2, 0);&#13;
	o.write_shift(2, 1);&#13;
	o.write_shift(2, 0x01f4);&#13;
	return o;&#13;
}&#13;
/* [MS-XLS] 2.4.346 TODO */&#13;
function parse_Window2(blob, length, opts) {&#13;
	if(opts &amp;&amp; opts.biff &gt;= 2 &amp;&amp; opts.biff &lt; 5) return {};&#13;
	var f = blob.read_shift(2);&#13;
	return { RTL: f &amp; 0x40 };&#13;
}&#13;
function write_Window2(view) {&#13;
	var o = new_buf(18), f = 0x6b6;&#13;
	if(view &amp;&amp; view.RTL) f |= 0x40;&#13;
	o.write_shift(2, f);&#13;
	o.write_shift(4, 0);&#13;
	o.write_shift(4, 64);&#13;
	o.write_shift(4, 0);&#13;
	o.write_shift(4, 0);&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLS] 2.4.189 TODO */&#13;
function parse_Pane(/*blob, length, opts*/) {&#13;
}&#13;
&#13;
/* [MS-XLS] 2.4.122 TODO */&#13;
function parse_Font(blob, length, opts) {&#13;
	var o = {&#13;
		dyHeight: blob.read_shift(2),&#13;
		fl: blob.read_shift(2)&#13;
	};&#13;
	switch((opts &amp;&amp; opts.biff) || 8) {&#13;
		case 2: break;&#13;
		case 3: case 4: blob.l += 2; break;&#13;
		default: blob.l += 10; break;&#13;
	}&#13;
	o.name = parse_ShortXLUnicodeString(blob, 0, opts);&#13;
	return o;&#13;
}&#13;
function write_Font(data, opts) {&#13;
	var name = data.name || "Arial";&#13;
	var b5 = (opts &amp;&amp; (opts.biff == 5)), w = (b5 ? (15 + name.length) : (16 + 2 * name.length));&#13;
	var o = new_buf(w);&#13;
	o.write_shift(2, (data.sz || 12) * 20);&#13;
	o.write_shift(4, 0);&#13;
	o.write_shift(2, 400);&#13;
	o.write_shift(4, 0);&#13;
	o.write_shift(2, 0);&#13;
	o.write_shift(1, name.length);&#13;
	if(!b5) o.write_shift(1, 1);&#13;
	o.write_shift((b5 ? 1 : 2) * name.length, name, (b5 ? "sbcs" : "utf16le"));&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLS] 2.4.149 */&#13;
function parse_LabelSst(blob) {&#13;
	var cell = parse_XLSCell(blob);&#13;
	cell.isst = blob.read_shift(4);&#13;
	return cell;&#13;
}&#13;
function write_LabelSst(R, C, v, os ) {&#13;
	var o = new_buf(10);&#13;
	write_XLSCell(R, C, os, o);&#13;
	o.write_shift(4, v);&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLS] 2.4.148 */&#13;
function parse_Label(blob, length, opts) {&#13;
	if(opts.biffguess &amp;&amp; opts.biff == 2) opts.biff = 5;&#13;
	var target = blob.l + length;&#13;
	var cell = parse_XLSCell(blob, 6);&#13;
	if(opts.biff == 2) blob.l++;&#13;
	var str = parse_XLUnicodeString(blob, target - blob.l, opts);&#13;
	cell.val = str;&#13;
	return cell;&#13;
}&#13;
function write_Label(R, C, v, os, opts) {&#13;
	var b8 = !opts || opts.biff == 8;&#13;
	var o = new_buf(6 + 2 + (+b8) + (1 + b8) * v.length);&#13;
	write_XLSCell(R, C, os, o);&#13;
	o.write_shift(2, v.length);&#13;
	if(b8) o.write_shift(1, 1);&#13;
	o.write_shift((1 + b8) * v.length, v, b8 ? 'utf16le' : 'sbcs');&#13;
	return o;&#13;
}&#13;
&#13;
&#13;
/* [MS-XLS] 2.4.126 Number Formats */&#13;
function parse_Format(blob, length, opts) {&#13;
	var numFmtId = blob.read_shift(2);&#13;
	var fmtstr = parse_XLUnicodeString2(blob, 0, opts);&#13;
	return [numFmtId, fmtstr];&#13;
}&#13;
function write_Format(i, f, opts, o) {&#13;
	var b5 = (opts &amp;&amp; (opts.biff == 5));&#13;
	if(!o) o = new_buf(b5 ? (3 + f.length) : (5 + 2 * f.length));&#13;
	o.write_shift(2, i);&#13;
	o.write_shift((b5 ? 1 : 2), f.length);&#13;
	if(!b5) o.write_shift(1, 1);&#13;
	o.write_shift((b5 ? 1 : 2) * f.length, f, (b5 ? 'sbcs' : 'utf16le'));&#13;
	var out = (o.length &gt; o.l) ? o.slice(0, o.l) : o;&#13;
	if(out.l == null) out.l = out.length;&#13;
	return out;&#13;
}&#13;
var parse_BIFF2Format = parse_XLUnicodeString2;&#13;
&#13;
/* [MS-XLS] 2.4.90 */&#13;
function parse_Dimensions(blob, length, opts) {&#13;
	var end = blob.l + length;&#13;
	var w = opts.biff == 8 || !opts.biff ? 4 : 2;&#13;
	var r = blob.read_shift(w), R = blob.read_shift(w);&#13;
	var c = blob.read_shift(2), C = blob.read_shift(2);&#13;
	blob.l = end;&#13;
	return {s: {r:r, c:c}, e: {r:R, c:C}};&#13;
}&#13;
function write_Dimensions(range, opts) {&#13;
	var w = opts.biff == 8 || !opts.biff ? 4 : 2;&#13;
	var o = new_buf(2*w + 6);&#13;
	o.write_shift(w, range.s.r);&#13;
	o.write_shift(w, range.e.r + 1);&#13;
	o.write_shift(2, range.s.c);&#13;
	o.write_shift(2, range.e.c + 1);&#13;
	o.write_shift(2, 0);&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLS] 2.4.220 */&#13;
function parse_RK(blob) {&#13;
	var rw = blob.read_shift(2), col = blob.read_shift(2);&#13;
	var rkrec = parse_RkRec(blob);&#13;
	return {r:rw, c:col, ixfe:rkrec[0], rknum:rkrec[1]};&#13;
}&#13;
&#13;
/* [MS-XLS] 2.4.175 */&#13;
function parse_MulRk(blob, length) {&#13;
	var target = blob.l + length - 2;&#13;
	var rw = blob.read_shift(2), col = blob.read_shift(2);&#13;
	var rkrecs = [];&#13;
	while(blob.l &lt; target) rkrecs.push(parse_RkRec(blob));&#13;
	if(blob.l !== target) throw new Error("MulRK read error");&#13;
	var lastcol = blob.read_shift(2);&#13;
	if(rkrecs.length != lastcol - col + 1) throw new Error("MulRK length mismatch");&#13;
	return {r:rw, c:col, C:lastcol, rkrec:rkrecs};&#13;
}&#13;
/* [MS-XLS] 2.4.174 */&#13;
function parse_MulBlank(blob, length) {&#13;
	var target = blob.l + length - 2;&#13;
	var rw = blob.read_shift(2), col = blob.read_shift(2);&#13;
	var ixfes = [];&#13;
	while(blob.l &lt; target) ixfes.push(blob.read_shift(2));&#13;
	if(blob.l !== target) throw new Error("MulBlank read error");&#13;
	var lastcol = blob.read_shift(2);&#13;
	if(ixfes.length != lastcol - col + 1) throw new Error("MulBlank length mismatch");&#13;
	return {r:rw, c:col, C:lastcol, ixfe:ixfes};&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.20 2.5.249 TODO: interpret values here */&#13;
function parse_CellStyleXF(blob, length, style, opts) {&#13;
	var o = {};&#13;
	var a = blob.read_shift(4), b = blob.read_shift(4);&#13;
	var c = blob.read_shift(4), d = blob.read_shift(2);&#13;
	o.patternType = XLSFillPattern[c &gt;&gt; 26];&#13;
&#13;
	if(!opts.cellStyles) return o;&#13;
	o.alc = a &amp; 0x07;&#13;
	o.fWrap = (a &gt;&gt; 3) &amp; 0x01;&#13;
	o.alcV = (a &gt;&gt; 4) &amp; 0x07;&#13;
	o.fJustLast = (a &gt;&gt; 7) &amp; 0x01;&#13;
	o.trot = (a &gt;&gt; 8) &amp; 0xFF;&#13;
	o.cIndent = (a &gt;&gt; 16) &amp; 0x0F;&#13;
	o.fShrinkToFit = (a &gt;&gt; 20) &amp; 0x01;&#13;
	o.iReadOrder = (a &gt;&gt; 22) &amp; 0x02;&#13;
	o.fAtrNum = (a &gt;&gt; 26) &amp; 0x01;&#13;
	o.fAtrFnt = (a &gt;&gt; 27) &amp; 0x01;&#13;
	o.fAtrAlc = (a &gt;&gt; 28) &amp; 0x01;&#13;
	o.fAtrBdr = (a &gt;&gt; 29) &amp; 0x01;&#13;
	o.fAtrPat = (a &gt;&gt; 30) &amp; 0x01;&#13;
	o.fAtrProt = (a &gt;&gt; 31) &amp; 0x01;&#13;
&#13;
	o.dgLeft = b &amp; 0x0F;&#13;
	o.dgRight = (b &gt;&gt; 4) &amp; 0x0F;&#13;
	o.dgTop = (b &gt;&gt; 8) &amp; 0x0F;&#13;
	o.dgBottom = (b &gt;&gt; 12) &amp; 0x0F;&#13;
	o.icvLeft = (b &gt;&gt; 16) &amp; 0x7F;&#13;
	o.icvRight = (b &gt;&gt; 23) &amp; 0x7F;&#13;
	o.grbitDiag = (b &gt;&gt; 30) &amp; 0x03;&#13;
&#13;
	o.icvTop = c &amp; 0x7F;&#13;
	o.icvBottom = (c &gt;&gt; 7) &amp; 0x7F;&#13;
	o.icvDiag = (c &gt;&gt; 14) &amp; 0x7F;&#13;
	o.dgDiag = (c &gt;&gt; 21) &amp; 0x0F;&#13;
&#13;
	o.icvFore = d &amp; 0x7F;&#13;
	o.icvBack = (d &gt;&gt; 7) &amp; 0x7F;&#13;
	o.fsxButton = (d &gt;&gt; 14) &amp; 0x01;&#13;
	return o;&#13;
}&#13;
//function parse_CellXF(blob, length, opts) {return parse_CellStyleXF(blob,length,0, opts);}&#13;
//function parse_StyleXF(blob, length, opts) {return parse_CellStyleXF(blob,length,1, opts);}&#13;
&#13;
/* [MS-XLS] 2.4.353 TODO: actually do this right */&#13;
function parse_XF(blob, length, opts) {&#13;
	var o = {};&#13;
	o.ifnt = blob.read_shift(2); o.numFmtId = blob.read_shift(2); o.flags = blob.read_shift(2);&#13;
	o.fStyle = (o.flags &gt;&gt; 2) &amp; 0x01;&#13;
	length -= 6;&#13;
	o.data = parse_CellStyleXF(blob, length, o.fStyle, opts);&#13;
	return o;&#13;
}&#13;
function write_XF(data, ixfeP, opts, o) {&#13;
	var b5 = (opts &amp;&amp; (opts.biff == 5));&#13;
	if(!o) o = new_buf(b5 ? 16 : 20);&#13;
	o.write_shift(2, 0);&#13;
	if(data.style) {&#13;
		o.write_shift(2, (data.numFmtId||0));&#13;
		o.write_shift(2, 0xFFF4);&#13;
	} else {&#13;
		o.write_shift(2, (data.numFmtId||0));&#13;
		o.write_shift(2, (ixfeP&lt;&lt;4));&#13;
	}&#13;
	var f = 0;&#13;
	if(data.numFmtId &gt; 0 &amp;&amp; b5) f |= 0x0400;&#13;
	o.write_shift(4, f);&#13;
	o.write_shift(4, 0);&#13;
	if(!b5) o.write_shift(4, 0);&#13;
	o.write_shift(2, 0);&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLS] 2.4.134 */&#13;
function parse_Guts(blob) {&#13;
	blob.l += 4;&#13;
	var out = [blob.read_shift(2), blob.read_shift(2)];&#13;
	if(out[0] !== 0) out[0]--;&#13;
	if(out[1] !== 0) out[1]--;&#13;
	if(out[0] &gt; 7 || out[1] &gt; 7) throw new Error("Bad Gutters: " + out.join("|"));&#13;
	return out;&#13;
}&#13;
function write_Guts(guts) {&#13;
	var o = new_buf(8);&#13;
	o.write_shift(4, 0);&#13;
	o.write_shift(2, guts[0] ? guts[0] + 1 : 0);&#13;
	o.write_shift(2, guts[1] ? guts[1] + 1 : 0);&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLS] 2.4.24 */&#13;
function parse_BoolErr(blob, length, opts) {&#13;
	var cell = parse_XLSCell(blob, 6);&#13;
	if(opts.biff == 2 || length == 9) ++blob.l;&#13;
	var val = parse_Bes(blob, 2);&#13;
	cell.val = val;&#13;
	cell.t = (val === true || val === false) ? 'b' : 'e';&#13;
	return cell;&#13;
}&#13;
function write_BoolErr(R, C, v, os, opts, t) {&#13;
	var o = new_buf(8);&#13;
	write_XLSCell(R, C, os, o);&#13;
	write_Bes(v, t, o);&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLS] 2.4.180 Number */&#13;
function parse_Number(blob, length, opts) {&#13;
	if(opts.biffguess &amp;&amp; opts.biff == 2) opts.biff = 5;&#13;
	var cell = parse_XLSCell(blob, 6);&#13;
	var xnum = parse_Xnum(blob, 8);&#13;
	cell.val = xnum;&#13;
	return cell;&#13;
}&#13;
function write_Number(R, C, v, os) {&#13;
	var o = new_buf(14);&#13;
	write_XLSCell(R, C, os, o);&#13;
	write_Xnum(v, o);&#13;
	return o;&#13;
}&#13;
&#13;
var parse_XLHeaderFooter = parse_OptXLUnicodeString; // TODO: parse 2.4.136&#13;
&#13;
/* [MS-XLS] 2.4.271 */&#13;
function parse_SupBook(blob, length, opts) {&#13;
	var end = blob.l + length;&#13;
	var ctab = blob.read_shift(2);&#13;
	var cch = blob.read_shift(2);&#13;
	opts.sbcch = cch;&#13;
	if(cch == 0x0401 || cch == 0x3A01) return [cch, ctab];&#13;
	if(cch &lt; 0x01 || cch &gt;0xff) throw new Error("Unexpected SupBook type: "+cch);&#13;
	var virtPath = parse_XLUnicodeStringNoCch(blob, cch);&#13;
	/* TODO: 2.5.277 Virtual Path */&#13;
	var rgst = [];&#13;
	while(end &gt; blob.l) rgst.push(parse_XLUnicodeString(blob));&#13;
	return [cch, ctab, virtPath, rgst];&#13;
}&#13;
&#13;
/* [MS-XLS] 2.4.105 TODO */&#13;
function parse_ExternName(blob, length, opts) {&#13;
	var flags = blob.read_shift(2);&#13;
	var body;&#13;
	var o = ({&#13;
		fBuiltIn: flags &amp; 0x01,&#13;
		fWantAdvise: (flags &gt;&gt;&gt; 1) &amp; 0x01,&#13;
		fWantPict: (flags &gt;&gt;&gt; 2) &amp; 0x01,&#13;
		fOle: (flags &gt;&gt;&gt; 3) &amp; 0x01,&#13;
		fOleLink: (flags &gt;&gt;&gt; 4) &amp; 0x01,&#13;
		cf: (flags &gt;&gt;&gt; 5) &amp; 0x3FF,&#13;
		fIcon: flags &gt;&gt;&gt; 15 &amp; 0x01&#13;
	});&#13;
	if(opts.sbcch === 0x3A01) body = parse_AddinUdf(blob, length-2, opts);&#13;
	//else throw new Error("unsupported SupBook cch: " + opts.sbcch);&#13;
	o.body = body || blob.read_shift(length-2);&#13;
	if(typeof body === "string") o.Name = body;&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLS] 2.4.150 TODO */&#13;
function parse_Lbl(blob, length, opts) {&#13;
	var target = blob.l + length;&#13;
	var flags = blob.read_shift(2);&#13;
	var chKey = blob.read_shift(1);&#13;
	var cch = blob.read_shift(1);&#13;
	var cce = blob.read_shift(opts &amp;&amp; opts.biff == 2 ? 1 : 2);&#13;
	var itab = 0;&#13;
	if(!opts || opts.biff &gt;= 5) {&#13;
		if(opts.biff != 5) blob.l += 2;&#13;
		itab = blob.read_shift(2);&#13;
		if(opts.biff == 5) blob.l += 2;&#13;
		blob.l += 4;&#13;
	}&#13;
	var name = parse_XLUnicodeStringNoCch(blob, cch, opts);&#13;
	if(flags &amp; 0x20) name = XLSLblBuiltIn[name.charCodeAt(0)];&#13;
	var npflen = target - blob.l; if(opts &amp;&amp; opts.biff == 2) --npflen;&#13;
	/*jshint -W018 */&#13;
	var rgce = (target == blob.l || cce === 0 || !(npflen &gt; 0)) ? [] : parse_NameParsedFormula(blob, npflen, opts, cce);&#13;
	/*jshint +W018 */&#13;
	return {&#13;
		chKey: chKey,&#13;
		Name: name,&#13;
		itab: itab,&#13;
		rgce: rgce&#13;
	};&#13;
}&#13;
&#13;
/* [MS-XLS] 2.4.106 TODO: verify filename encoding */&#13;
function parse_ExternSheet(blob, length, opts) {&#13;
	if(opts.biff &lt; 8) return parse_BIFF5ExternSheet(blob, length, opts);&#13;
	var o = [], target = blob.l + length, len = blob.read_shift(opts.biff &gt; 8 ? 4 : 2);&#13;
	while(len-- !== 0) o.push(parse_XTI(blob, opts.biff &gt; 8 ? 12 : 6, opts));&#13;
		// [iSupBook, itabFirst, itabLast];&#13;
	if(blob.l != target) throw new Error("Bad ExternSheet: " + blob.l + " != " + target);&#13;
	return o;&#13;
}&#13;
function parse_BIFF5ExternSheet(blob, length, opts) {&#13;
	if(blob[blob.l + 1] == 0x03) blob[blob.l]++;&#13;
	var o = parse_ShortXLUnicodeString(blob, length, opts);&#13;
	return o.charCodeAt(0) == 0x03 ? o.slice(1) : o;&#13;
}&#13;
&#13;
/* [MS-XLS] 2.4.176 TODO: check older biff */&#13;
function parse_NameCmt(blob, length, opts) {&#13;
	if(opts.biff &lt; 8) { blob.l += length; return; }&#13;
	var cchName = blob.read_shift(2);&#13;
	var cchComment = blob.read_shift(2);&#13;
	var name = parse_XLUnicodeStringNoCch(blob, cchName, opts);&#13;
	var comment = parse_XLUnicodeStringNoCch(blob, cchComment, opts);&#13;
	return [name, comment];&#13;
}&#13;
&#13;
/* [MS-XLS] 2.4.260 */&#13;
function parse_ShrFmla(blob, length, opts) {&#13;
	var ref = parse_RefU(blob, 6);&#13;
	blob.l++;&#13;
	var cUse = blob.read_shift(1);&#13;
	length -= 8;&#13;
	return [parse_SharedParsedFormula(blob, length, opts), cUse, ref];&#13;
}&#13;
&#13;
/* [MS-XLS] 2.4.4 TODO */&#13;
function parse_Array(blob, length, opts) {&#13;
	var ref = parse_Ref(blob, 6);&#13;
	/* TODO: fAlwaysCalc */&#13;
	switch(opts.biff) {&#13;
		case 2: blob.l ++; length -= 7; break;&#13;
		case 3: case 4: blob.l += 2; length -= 8; break;&#13;
		default: blob.l += 6; length -= 12;&#13;
	}&#13;
	return [ref, parse_ArrayParsedFormula(blob, length, opts, ref)];&#13;
}&#13;
&#13;
/* [MS-XLS] 2.4.173 */&#13;
function parse_MTRSettings(blob) {&#13;
	var fMTREnabled = blob.read_shift(4) !== 0x00;&#13;
	var fUserSetThreadCount = blob.read_shift(4) !== 0x00;&#13;
	var cUserThreadCount = blob.read_shift(4);&#13;
	return [fMTREnabled, fUserSetThreadCount, cUserThreadCount];&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.186 TODO: BIFF5 */&#13;
function parse_NoteSh(blob, length, opts) {&#13;
	if(opts.biff &lt; 8) return;&#13;
	var row = blob.read_shift(2), col = blob.read_shift(2);&#13;
	var flags = blob.read_shift(2), idObj = blob.read_shift(2);&#13;
	var stAuthor = parse_XLUnicodeString2(blob, 0, opts);&#13;
	if(opts.biff &lt; 8) blob.read_shift(1);&#13;
	return [{r:row,c:col}, stAuthor, idObj, flags];&#13;
}&#13;
&#13;
/* [MS-XLS] 2.4.179 */&#13;
function parse_Note(blob, length, opts) {&#13;
	/* TODO: Support revisions */&#13;
	return parse_NoteSh(blob, length, opts);&#13;
}&#13;
&#13;
/* [MS-XLS] 2.4.168 */&#13;
function parse_MergeCells(blob, length) {&#13;
	var merges = [];&#13;
	var cmcs = blob.read_shift(2);&#13;
	while (cmcs--) merges.push(parse_Ref8U(blob,length));&#13;
	return merges;&#13;
}&#13;
function write_MergeCells(merges) {&#13;
	var o = new_buf(2 + merges.length * 8);&#13;
	o.write_shift(2, merges.length);&#13;
	for(var i = 0; i &lt; merges.length; ++i) write_Ref8U(merges[i], o);&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLS] 2.4.181 TODO: parse all the things! */&#13;
function parse_Obj(blob, length, opts) {&#13;
	if(opts &amp;&amp; opts.biff &lt; 8) return parse_BIFF5Obj(blob, length, opts);&#13;
	var cmo = parse_FtCmo(blob, 22); // id, ot, flags&#13;
	var fts = parse_FtArray(blob, length-22, cmo[1]);&#13;
	return { cmo: cmo, ft:fts };&#13;
}&#13;
/* from older spec */&#13;
var parse_BIFF5OT = {&#13;
0x08: function(blob, length) {&#13;
	var tgt = blob.l + length;&#13;
	blob.l += 10; // todo&#13;
	var cf = blob.read_shift(2);&#13;
	blob.l += 4;&#13;
	blob.l += 2; //var cbPictFmla = blob.read_shift(2);&#13;
	blob.l += 2;&#13;
	blob.l += 2; //var grbit = blob.read_shift(2);&#13;
	blob.l += 4;&#13;
	var cchName = blob.read_shift(1);&#13;
	blob.l += cchName; // TODO: stName&#13;
	blob.l = tgt; // TODO: fmla&#13;
	return { fmt:cf };&#13;
}&#13;
};&#13;
&#13;
function parse_BIFF5Obj(blob, length, opts) {&#13;
	blob.l += 4; //var cnt = blob.read_shift(4);&#13;
	var ot = blob.read_shift(2);&#13;
	var id = blob.read_shift(2);&#13;
	var grbit = blob.read_shift(2);&#13;
	blob.l += 2; //var colL = blob.read_shift(2);&#13;
	blob.l += 2; //var dxL = blob.read_shift(2);&#13;
	blob.l += 2; //var rwT = blob.read_shift(2);&#13;
	blob.l += 2; //var dyT = blob.read_shift(2);&#13;
	blob.l += 2; //var colR = blob.read_shift(2);&#13;
	blob.l += 2; //var dxR = blob.read_shift(2);&#13;
	blob.l += 2; //var rwB = blob.read_shift(2);&#13;
	blob.l += 2; //var dyB = blob.read_shift(2);&#13;
	blob.l += 2; //var cbMacro = blob.read_shift(2);&#13;
	blob.l += 6;&#13;
	length -= 36;&#13;
	var fts = [];&#13;
	fts.push((parse_BIFF5OT[ot]||parsenoop)(blob, length, opts));&#13;
	return { cmo: [id, ot, grbit], ft:fts };&#13;
}&#13;
&#13;
/* [MS-XLS] 2.4.329 TODO: parse properly */&#13;
function parse_TxO(blob, length, opts) {&#13;
	var s = blob.l;&#13;
	var texts = "";&#13;
try {&#13;
	blob.l += 4;&#13;
	var ot = (opts.lastobj||{cmo:[0,0]}).cmo[1];&#13;
	var controlInfo; // eslint-disable-line no-unused-vars&#13;
	if([0,5,7,11,12,14].indexOf(ot) == -1) blob.l += 6;&#13;
	else controlInfo = parse_ControlInfo(blob, 6, opts); // eslint-disable-line no-unused-vars&#13;
	var cchText = blob.read_shift(2);&#13;
	/*var cbRuns = */blob.read_shift(2);&#13;
	/*var ifntEmpty = */parseuint16(blob, 2);&#13;
	var len = blob.read_shift(2);&#13;
	blob.l += len;&#13;
	//var fmla = parse_ObjFmla(blob, s + length - blob.l);&#13;
&#13;
	for(var i = 1; i &lt; blob.lens.length-1; ++i) {&#13;
		if(blob.l-s != blob.lens[i]) throw new Error("TxO: bad continue record");&#13;
		var hdr = blob[blob.l];&#13;
		var t = parse_XLUnicodeStringNoCch(blob, blob.lens[i+1]-blob.lens[i]-1);&#13;
		texts += t;&#13;
		if(texts.length &gt;= (hdr ? cchText : 2*cchText)) break;&#13;
	}&#13;
	if(texts.length !== cchText &amp;&amp; texts.length !== cchText*2) {&#13;
		throw new Error("cchText: " + cchText + " != " + texts.length);&#13;
	}&#13;
&#13;
	blob.l = s + length;&#13;
	/* [MS-XLS] 2.5.272 TxORuns */&#13;
//	var rgTxoRuns = [];&#13;
//	for(var j = 0; j != cbRuns/8-1; ++j) blob.l += 8;&#13;
//	var cchText2 = blob.read_shift(2);&#13;
//	if(cchText2 !== cchText) throw new Error("TxOLastRun mismatch: " + cchText2 + " " + cchText);&#13;
//	blob.l += 6;&#13;
//	if(s + length != blob.l) throw new Error("TxO " + (s + length) + ", at " + blob.l);&#13;
	return { t: texts };&#13;
} catch(e) { blob.l = s + length; return { t: texts }; }&#13;
}&#13;
&#13;
/* [MS-XLS] 2.4.140 */&#13;
function parse_HLink(blob, length) {&#13;
	var ref = parse_Ref8U(blob, 8);&#13;
	blob.l += 16; /* CLSID */&#13;
	var hlink = parse_Hyperlink(blob, length-24);&#13;
	return [ref, hlink];&#13;
}&#13;
function write_HLink(hl) {&#13;
	var O = new_buf(24);&#13;
	var ref = decode_cell(hl[0]);&#13;
	O.write_shift(2, ref.r); O.write_shift(2, ref.r);&#13;
	O.write_shift(2, ref.c); O.write_shift(2, ref.c);&#13;
	var clsid = "d0 c9 ea 79 f9 ba ce 11 8c 82 00 aa 00 4b a9 0b".split(" ");&#13;
	for(var i = 0; i &lt; 16; ++i) O.write_shift(1, parseInt(clsid[i], 16));&#13;
	return bconcat([O, write_Hyperlink(hl[1])]);&#13;
}&#13;
&#13;
&#13;
/* [MS-XLS] 2.4.141 */&#13;
function parse_HLinkTooltip(blob, length) {&#13;
	blob.read_shift(2);&#13;
	var ref = parse_Ref8U(blob, 8);&#13;
	var wzTooltip = blob.read_shift((length-10)/2, 'dbcs-cont');&#13;
	wzTooltip = wzTooltip.replace(chr0,"");&#13;
	return [ref, wzTooltip];&#13;
}&#13;
function write_HLinkTooltip(hl) {&#13;
	var TT = hl[1].Tooltip;&#13;
	var O = new_buf(10 + 2 * (TT.length + 1));&#13;
	O.write_shift(2, 0x0800);&#13;
	var ref = decode_cell(hl[0]);&#13;
	O.write_shift(2, ref.r); O.write_shift(2, ref.r);&#13;
	O.write_shift(2, ref.c); O.write_shift(2, ref.c);&#13;
	for(var i = 0; i &lt; TT.length; ++i) O.write_shift(2, TT.charCodeAt(i));&#13;
	O.write_shift(2, 0);&#13;
	return O;&#13;
}&#13;
&#13;
/* [MS-XLS] 2.4.63 */&#13;
function parse_Country(blob) {&#13;
	var o = [0,0], d;&#13;
	d = blob.read_shift(2); o[0] = CountryEnum[d] || d;&#13;
	d = blob.read_shift(2); o[1] = CountryEnum[d] || d;&#13;
	return o;&#13;
}&#13;
function write_Country(o) {&#13;
	if(!o) o = new_buf(4);&#13;
	o.write_shift(2, 0x01);&#13;
	o.write_shift(2, 0x01);&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLS] 2.4.50 ClrtClient */&#13;
function parse_ClrtClient(blob) {&#13;
	var ccv = blob.read_shift(2);&#13;
	var o = [];&#13;
	while(ccv--&gt;0) o.push(parse_LongRGB(blob, 8));&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLS] 2.4.188 */&#13;
function parse_Palette(blob) {&#13;
	var ccv = blob.read_shift(2);&#13;
	var o = [];&#13;
	while(ccv--&gt;0) o.push(parse_LongRGB(blob, 8));&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLS] 2.4.354 */&#13;
function parse_XFCRC(blob) {&#13;
	blob.l += 2;&#13;
	var o = {cxfs:0, crc:0};&#13;
	o.cxfs = blob.read_shift(2);&#13;
	o.crc = blob.read_shift(4);&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLS] 2.4.53 TODO: parse flags */&#13;
/* [MS-XLSB] 2.4.323 TODO: parse flags */&#13;
function parse_ColInfo(blob, length, opts) {&#13;
	if(!opts.cellStyles) return parsenoop(blob, length);&#13;
	var w = opts &amp;&amp; opts.biff &gt;= 12 ? 4 : 2;&#13;
	var colFirst = blob.read_shift(w);&#13;
	var colLast = blob.read_shift(w);&#13;
	var coldx = blob.read_shift(w);&#13;
	var ixfe = blob.read_shift(w);&#13;
	var flags = blob.read_shift(2);&#13;
	if(w == 2) blob.l += 2;&#13;
	var o = ({s:colFirst, e:colLast, w:coldx, ixfe:ixfe, flags:flags});&#13;
	if(opts.biff &gt;= 5 || !opts.biff) o.level = (flags &gt;&gt; 8) &amp; 0x7;&#13;
	return o;&#13;
}&#13;
function write_ColInfo(col, idx) {&#13;
	var o = new_buf(12);&#13;
	o.write_shift(2, idx);&#13;
	o.write_shift(2, idx);&#13;
	o.write_shift(2, col.width * 256);&#13;
	o.write_shift(2, 0);&#13;
	var f = 0;&#13;
	if(col.hidden) f |= 1;&#13;
	o.write_shift(1, f);&#13;
	f = col.level || 0;&#13;
	o.write_shift(1, f);&#13;
	o.write_shift(2, 0);&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLS] 2.4.257 */&#13;
function parse_Setup(blob, length) {&#13;
	var o = {};&#13;
	if(length &lt; 32) return o;&#13;
	blob.l += 16;&#13;
	o.header = parse_Xnum(blob, 8);&#13;
	o.footer = parse_Xnum(blob, 8);&#13;
	blob.l += 2;&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLS] 2.4.261 */&#13;
function parse_ShtProps(blob, length, opts) {&#13;
	var def = {area:false};&#13;
	if(opts.biff != 5) { blob.l += length; return def; }&#13;
	var d = blob.read_shift(1); blob.l += 3;&#13;
	if((d &amp; 0x10)) def.area = true;&#13;
	return def;&#13;
}&#13;
&#13;
/* [MS-XLS] 2.4.241 */&#13;
function write_RRTabId(n) {&#13;
	var out = new_buf(2 * n);&#13;
	for(var i = 0; i &lt; n; ++i) out.write_shift(2, i+1);&#13;
	return out;&#13;
}&#13;
&#13;
var parse_Blank = parse_XLSCell; /* [MS-XLS] 2.4.20 Just the cell */&#13;
var parse_Scl = parseuint16a; /* [MS-XLS] 2.4.247 num, den */&#13;
var parse_String = parse_XLUnicodeString; /* [MS-XLS] 2.4.268 */&#13;
&#13;
/* --- Specific to versions before BIFF8 --- */&#13;
function parse_ImData(blob) {&#13;
	var cf = blob.read_shift(2);&#13;
	var env = blob.read_shift(2);&#13;
	var lcb = blob.read_shift(4);&#13;
	var o = {fmt:cf, env:env, len:lcb, data:blob.slice(blob.l,blob.l+lcb)};&#13;
	blob.l += lcb;&#13;
	return o;&#13;
}&#13;
&#13;
/* BIFF2_??? where ??? is the name from [XLS] */&#13;
function parse_BIFF2STR(blob, length, opts) {&#13;
	if(opts.biffguess &amp;&amp; opts.biff == 5) opts.biff = 2;&#13;
	var cell = parse_XLSCell(blob, 6);&#13;
	++blob.l;&#13;
	var str = parse_XLUnicodeString2(blob, length-7, opts);&#13;
	cell.t = 'str';&#13;
	cell.val = str;&#13;
	return cell;&#13;
}&#13;
&#13;
function parse_BIFF2NUM(blob) {&#13;
	var cell = parse_XLSCell(blob, 6);&#13;
	++blob.l;&#13;
	var num = parse_Xnum(blob, 8);&#13;
	cell.t = 'n';&#13;
	cell.val = num;&#13;
	return cell;&#13;
}&#13;
function write_BIFF2NUM(r, c, val) {&#13;
	var out = new_buf(15);&#13;
	write_BIFF2Cell(out, r, c);&#13;
	out.write_shift(8, val, 'f');&#13;
	return out;&#13;
}&#13;
&#13;
function parse_BIFF2INT(blob) {&#13;
	var cell = parse_XLSCell(blob, 6);&#13;
	++blob.l;&#13;
	var num = blob.read_shift(2);&#13;
	cell.t = 'n';&#13;
	cell.val = num;&#13;
	return cell;&#13;
}&#13;
function write_BIFF2INT(r, c, val) {&#13;
	var out = new_buf(9);&#13;
	write_BIFF2Cell(out, r, c);&#13;
	out.write_shift(2, val);&#13;
	return out;&#13;
}&#13;
&#13;
function parse_BIFF2STRING(blob) {&#13;
	var cch = blob.read_shift(1);&#13;
	if(cch === 0) { blob.l++; return ""; }&#13;
	return blob.read_shift(cch, 'sbcs-cont');&#13;
}&#13;
&#13;
/* TODO: convert to BIFF8 font struct */&#13;
function parse_BIFF2FONTXTRA(blob, length) {&#13;
	blob.l += 6; // unknown&#13;
	blob.l += 2; // font weight "bls"&#13;
	blob.l += 1; // charset&#13;
	blob.l += 3; // unknown&#13;
	blob.l += 1; // font family&#13;
	blob.l += length - 13;&#13;
}&#13;
&#13;
/* TODO: parse rich text runs */&#13;
function parse_RString(blob, length, opts) {&#13;
	var end = blob.l + length;&#13;
	var cell = parse_XLSCell(blob, 6);&#13;
	var cch = blob.read_shift(2);&#13;
	var str = parse_XLUnicodeStringNoCch(blob, cch, opts);&#13;
	blob.l = end;&#13;
	cell.t = 'str';&#13;
	cell.val = str;&#13;
	return cell;&#13;
}&#13;
var DBF_SUPPORTED_VERSIONS = [0x02, 0x03, 0x30, 0x31, 0x83, 0x8B, 0x8C, 0xF5];&#13;
var DBF = (function() {&#13;
var dbf_codepage_map = {&#13;
	/* Code Pages Supported by Visual FoxPro */&#13;
0x01:   437,           0x02:   850,&#13;
0x03:  1252,           0x04: 10000,&#13;
0x64:   852,           0x65:   866,&#13;
0x66:   865,           0x67:   861,&#13;
0x68:   895,           0x69:   620,&#13;
0x6A:   737,           0x6B:   857,&#13;
0x78:   950,           0x79:   949,&#13;
0x7A:   936,           0x7B:   932,&#13;
0x7C:   874,           0x7D:  1255,&#13;
0x7E:  1256,           0x96: 10007,&#13;
0x97: 10029,           0x98: 10006,&#13;
0xC8:  1250,           0xC9:  1251,&#13;
0xCA:  1254,           0xCB:  1253,&#13;
&#13;
	/* shapefile DBF extension */&#13;
0x00: 20127,           0x08:   865,&#13;
0x09:   437,           0x0A:   850,&#13;
0x0B:   437,           0x0D:   437,&#13;
0x0E:   850,           0x0F:   437,&#13;
0x10:   850,           0x11:   437,&#13;
0x12:   850,           0x13:   932,&#13;
0x14:   850,           0x15:   437,&#13;
0x16:   850,           0x17:   865,&#13;
0x18:   437,           0x19:   437,&#13;
0x1A:   850,           0x1B:   437,&#13;
0x1C:   863,           0x1D:   850,&#13;
0x1F:   852,           0x22:   852,&#13;
0x23:   852,           0x24:   860,&#13;
0x25:   850,           0x26:   866,&#13;
0x37:   850,           0x40:   852,&#13;
0x4D:   936,           0x4E:   949,&#13;
0x4F:   950,           0x50:   874,&#13;
0x57:  1252,           0x58:  1252,&#13;
0x59:  1252,           0x6C:   863,&#13;
0x86:   737,           0x87:   852,&#13;
0x88:   857,           0xCC:  1257,&#13;
&#13;
0xFF: 16969&#13;
};&#13;
var dbf_reverse_map = evert({&#13;
0x01:   437,           0x02:   850,&#13;
0x03:  1252,           0x04: 10000,&#13;
0x64:   852,           0x65:   866,&#13;
0x66:   865,           0x67:   861,&#13;
0x68:   895,           0x69:   620,&#13;
0x6A:   737,           0x6B:   857,&#13;
0x78:   950,           0x79:   949,&#13;
0x7A:   936,           0x7B:   932,&#13;
0x7C:   874,           0x7D:  1255,&#13;
0x7E:  1256,           0x96: 10007,&#13;
0x97: 10029,           0x98: 10006,&#13;
0xC8:  1250,           0xC9:  1251,&#13;
0xCA:  1254,           0xCB:  1253,&#13;
0x00: 20127&#13;
});&#13;
/* TODO: find an actual specification */&#13;
function dbf_to_aoa(buf, opts) {&#13;
	var out = [];&#13;
	var d = (new_raw_buf(1));&#13;
	switch(opts.type) {&#13;
		case 'base64': d = s2a(Base64_decode(buf)); break;&#13;
		case 'binary': d = s2a(buf); break;&#13;
		case 'buffer':&#13;
		case 'array': d = buf; break;&#13;
	}&#13;
	prep_blob(d, 0);&#13;
&#13;
	/* header */&#13;
	var ft = d.read_shift(1);&#13;
	var memo = !!(ft &amp; 0x88);&#13;
	var vfp = false, l7 = false;&#13;
	switch(ft) {&#13;
		case 0x02: break; // dBASE II&#13;
		case 0x03: break; // dBASE III&#13;
		case 0x30: vfp = true; memo = true; break; // VFP&#13;
		case 0x31: vfp = true; memo = true; break; // VFP with autoincrement&#13;
		// 0x43 dBASE IV SQL table files&#13;
		// 0x63 dBASE IV SQL system files&#13;
		case 0x83: break; // dBASE III with memo&#13;
		case 0x8B: break; // dBASE IV with memo&#13;
		case 0x8C: l7 = true; break; // dBASE Level 7 with memo&#13;
		// case 0xCB dBASE IV SQL table files with memo&#13;
		case 0xF5: break; // FoxPro 2.x with memo&#13;
		// case 0xFB FoxBASE&#13;
		default: throw new Error("DBF Unsupported Version: " + ft.toString(16));&#13;
	}&#13;
&#13;
	var nrow = 0, fpos = 0x0209;&#13;
	if(ft == 0x02) nrow = d.read_shift(2);&#13;
	d.l += 3; // dBASE II stores DDMMYY date, others use YYMMDD&#13;
	if(ft != 0x02) nrow = d.read_shift(4);&#13;
	if(nrow &gt; 1048576) nrow = 1e6;&#13;
&#13;
	if(ft != 0x02) fpos = d.read_shift(2); // header length&#13;
	var rlen = d.read_shift(2); // record length&#13;
&#13;
	var /*flags = 0,*/ current_cp = opts.codepage || 1252;&#13;
	if(ft != 0x02) { // 20 reserved bytes&#13;
		d.l+=16;&#13;
		/*flags = */d.read_shift(1);&#13;
		//if(memo &amp;&amp; ((flags &amp; 0x02) === 0)) throw new Error("DBF Flags " + flags.toString(16) + " ft " + ft.toString(16));&#13;
&#13;
		/* codepage present in FoxPro and dBASE Level 7 */&#13;
		if(d[d.l] !== 0) current_cp = dbf_codepage_map[d[d.l]];&#13;
		d.l+=1;&#13;
&#13;
		d.l+=2;&#13;
	}&#13;
	if(l7) d.l += 36; // Level 7: 32 byte "Language driver name", 4 byte reserved&#13;
&#13;
var fields = [], field = ({});&#13;
	var hend = Math.min(d.length, (ft == 0x02 ? 0x209 : (fpos - 10 - (vfp ? 264 : 0))));&#13;
	var ww = l7 ? 32 : 11;&#13;
	while(d.l &lt; hend &amp;&amp; d[d.l] != 0x0d) {&#13;
		field = ({});&#13;
		field.name = (typeof $cptable !== "undefined" ? $cptable.utils.decode(current_cp, d.slice(d.l, d.l+ww)) : a2s(d.slice(d.l, d.l + ww))).replace(/[\u0000\r\n].*$/g,"");&#13;
		d.l += ww;&#13;
		field.type = String.fromCharCode(d.read_shift(1));&#13;
		if(ft != 0x02 &amp;&amp; !l7) field.offset = d.read_shift(4);&#13;
		field.len = d.read_shift(1);&#13;
		if(ft == 0x02) field.offset = d.read_shift(2);&#13;
		field.dec = d.read_shift(1);&#13;
		if(field.name.length) fields.push(field);&#13;
		if(ft != 0x02) d.l += l7 ? 13 : 14;&#13;
		switch(field.type) {&#13;
			case 'B': // Double (VFP) / Binary (dBASE L7)&#13;
				if((!vfp || field.len != 8) &amp;&amp; opts.WTF) console.log('Skipping ' + field.name + ':' + field.type);&#13;
				break;&#13;
			case 'G': // General (FoxPro and dBASE L7)&#13;
			case 'P': // Picture (FoxPro and dBASE L7)&#13;
				if(opts.WTF) console.log('Skipping ' + field.name + ':' + field.type);&#13;
				break;&#13;
			case '+': // Autoincrement (dBASE L7 only)&#13;
			case '0': // _NullFlags (VFP only)&#13;
			case '@': // Timestamp (dBASE L7 only)&#13;
			case 'C': // Character (dBASE II)&#13;
			case 'D': // Date (dBASE III)&#13;
			case 'F': // Float (dBASE IV)&#13;
			case 'I': // Long (VFP and dBASE L7)&#13;
			case 'L': // Logical (dBASE II)&#13;
			case 'M': // Memo (dBASE III)&#13;
			case 'N': // Number (dBASE II)&#13;
			case 'O': // Double (dBASE L7 only)&#13;
			case 'T': // Datetime (VFP only)&#13;
			case 'Y': // Currency (VFP only)&#13;
				break;&#13;
			default: throw new Error('Unknown Field Type: ' + field.type);&#13;
		}&#13;
	}&#13;
&#13;
	if(d[d.l] !== 0x0D) d.l = fpos-1;&#13;
	if(d.read_shift(1) !== 0x0D) throw new Error("DBF Terminator not found " + d.l + " " + d[d.l]);&#13;
	d.l = fpos;&#13;
&#13;
	/* data */&#13;
	var R = 0, C = 0;&#13;
	out[0] = [];&#13;
	for(C = 0; C != fields.length; ++C) out[0][C] = fields[C].name;&#13;
	while(nrow-- &gt; 0) {&#13;
		if(d[d.l] === 0x2A) {&#13;
			// TODO: record marked as deleted -- create a hidden row?&#13;
			d.l+=rlen;&#13;
			continue;&#13;
		}&#13;
		++d.l;&#13;
		out[++R] = []; C = 0;&#13;
		for(C = 0; C != fields.length; ++C) {&#13;
			var dd = d.slice(d.l, d.l+fields[C].len); d.l+=fields[C].len;&#13;
			prep_blob(dd, 0);&#13;
			var s = typeof $cptable !== "undefined" ? $cptable.utils.decode(current_cp, dd) : a2s(dd);&#13;
			switch(fields[C].type) {&#13;
				case 'C':&#13;
					// NOTE: it is conventional to write '  /  /  ' for empty dates&#13;
					if(s.trim().length) out[R][C] = s.replace(/\s+$/,"");&#13;
					break;&#13;
				case 'D':&#13;
					if(s.length === 8) out[R][C] = new Date(+s.slice(0,4), +s.slice(4,6)-1, +s.slice(6,8));&#13;
					else out[R][C] = s;&#13;
					break;&#13;
				case 'F': out[R][C] = parseFloat(s.trim()); break;&#13;
				case '+': case 'I': out[R][C] = l7 ? dd.read_shift(-4, 'i') ^ 0x80000000 : dd.read_shift(4, 'i'); break;&#13;
				case 'L': switch(s.trim().toUpperCase()) {&#13;
					case 'Y': case 'T': out[R][C] = true; break;&#13;
					case 'N': case 'F': out[R][C] = false; break;&#13;
					case '': case '?': break;&#13;
					default: throw new Error("DBF Unrecognized L:|" + s + "|");&#13;
					} break;&#13;
				case 'M': /* TODO: handle memo files */&#13;
					if(!memo) throw new Error("DBF Unexpected MEMO for type " + ft.toString(16));&#13;
					out[R][C] = "##MEMO##" + (l7 ? parseInt(s.trim(), 10): dd.read_shift(4));&#13;
					break;&#13;
				case 'N':&#13;
					s = s.replace(/\u0000/g,"").trim();&#13;
					// NOTE: dBASE II interprets "  .  " as 0&#13;
					if(s &amp;&amp; s != ".") out[R][C] = +s || 0; break;&#13;
				case '@':&#13;
					// NOTE: dBASE specs appear to be incorrect&#13;
					out[R][C] = new Date(dd.read_shift(-8, 'f') - 0x388317533400);&#13;
					break;&#13;
				case 'T': out[R][C] = new Date((dd.read_shift(4) - 0x253D8C) * 0x5265C00 + dd.read_shift(4)); break;&#13;
				case 'Y': out[R][C] = dd.read_shift(4,'i')/1e4 + (dd.read_shift(4, 'i')/1e4)*Math.pow(2,32); break;&#13;
				case 'O': out[R][C] = -dd.read_shift(-8, 'f'); break;&#13;
				case 'B': if(vfp &amp;&amp; fields[C].len == 8) { out[R][C] = dd.read_shift(8,'f'); break; }&#13;
					/* falls through */&#13;
				case 'G': case 'P': dd.l += fields[C].len; break;&#13;
				case '0':&#13;
					if(fields[C].name === '_NullFlags') break;&#13;
					/* falls through */&#13;
				default: throw new Error("DBF Unsupported data type " + fields[C].type);&#13;
			}&#13;
		}&#13;
	}&#13;
	if(ft != 0x02) if(d.l &lt; d.length &amp;&amp; d[d.l++] != 0x1A) throw new Error("DBF EOF Marker missing " + (d.l-1) + " of " + d.length + " " + d[d.l-1].toString(16));&#13;
	if(opts &amp;&amp; opts.sheetRows) out = out.slice(0, opts.sheetRows);&#13;
	opts.DBF = fields;&#13;
	return out;&#13;
}&#13;
&#13;
function dbf_to_sheet(buf, opts) {&#13;
	var o = opts || {};&#13;
	if(!o.dateNF) o.dateNF = "yyyymmdd";&#13;
	var ws = aoa_to_sheet(dbf_to_aoa(buf, o), o);&#13;
	ws["!cols"] = o.DBF.map(function(field) { return {&#13;
		wch: field.len,&#13;
		DBF: field&#13;
	};});&#13;
	delete o.DBF;&#13;
	return ws;&#13;
}&#13;
&#13;
function dbf_to_workbook(buf, opts) {&#13;
	try {&#13;
		var o = sheet_to_workbook(dbf_to_sheet(buf, opts), opts);&#13;
		o.bookType = "dbf";&#13;
		return o;&#13;
	} catch(e) { if(opts &amp;&amp; opts.WTF) throw e; }&#13;
	return ({SheetNames:[],Sheets:{}});&#13;
}&#13;
&#13;
var _RLEN = { 'B': 8, 'C': 250, 'L': 1, 'D': 8, '?': 0, '': 0 };&#13;
function sheet_to_dbf(ws, opts) {&#13;
	var o = opts || {};&#13;
	var old_cp = current_codepage;&#13;
	if(+o.codepage &gt;= 0) set_cp(+o.codepage);&#13;
	if(o.type == "string") throw new Error("Cannot write DBF to JS string");&#13;
	var ba = buf_array();&#13;
	var aoa = sheet_to_json(ws, {header:1, raw:true, cellDates:true});&#13;
	var headers = aoa[0], data = aoa.slice(1), cols = ws["!cols"] || [];&#13;
	var i = 0, j = 0, hcnt = 0, rlen = 1;&#13;
	for(i = 0; i &lt; headers.length; ++i) {&#13;
		if(((cols[i]||{}).DBF||{}).name) { headers[i] = cols[i].DBF.name; ++hcnt; continue; }&#13;
		if(headers[i] == null) continue;&#13;
		++hcnt;&#13;
		if(typeof headers[i] === 'number') headers[i] = headers[i].toString(10);&#13;
		if(typeof headers[i] !== 'string') throw new Error("DBF Invalid column name " + headers[i] + " |" + (typeof headers[i]) + "|");&#13;
		if(headers.indexOf(headers[i]) !== i) for(j=0; j&lt;1024;++j)&#13;
			if(headers.indexOf(headers[i] + "_" + j) == -1) { headers[i] += "_" + j; break; }&#13;
	}&#13;
	var range = safe_decode_range(ws['!ref']);&#13;
	var coltypes = [];&#13;
	var colwidths = [];&#13;
	var coldecimals = [];&#13;
	for(i = 0; i &lt;= range.e.c - range.s.c; ++i) {&#13;
		var guess = '', _guess = '', maxlen = 0;&#13;
		var col = [];&#13;
		for(j=0; j &lt; data.length; ++j) {&#13;
			if(data[j][i] != null) col.push(data[j][i]);&#13;
		}&#13;
		if(col.length == 0 || headers[i] == null) { coltypes[i] = '?'; continue; }&#13;
		for(j = 0; j &lt; col.length; ++j) {&#13;
			switch(typeof col[j]) {&#13;
				/* TODO: check if L2 compat is desired */&#13;
				case 'number': _guess = 'B'; break;&#13;
				case 'string': _guess = 'C'; break;&#13;
				case 'boolean': _guess = 'L'; break;&#13;
				case 'object': _guess = col[j] instanceof Date ? 'D' : 'C'; break;&#13;
				default: _guess = 'C';&#13;
			}&#13;
			/* TODO: cache the values instead of encoding twice */&#13;
			maxlen = Math.max(maxlen, (typeof $cptable !== "undefined" &amp;&amp; typeof col[j] == "string" ? $cptable.utils.encode(current_ansi, col[j]): String(col[j])).length);&#13;
			guess = guess &amp;&amp; guess != _guess ? 'C' : _guess;&#13;
			//if(guess == 'C') break;&#13;
		}&#13;
		if(maxlen &gt; 250) maxlen = 250;&#13;
		_guess = ((cols[i]||{}).DBF||{}).type;&#13;
		/* TODO: more fine grained control over DBF type resolution */&#13;
		if(_guess == 'C') {&#13;
			if(cols[i].DBF.len &gt; maxlen) maxlen = cols[i].DBF.len;&#13;
		}&#13;
		if(guess == 'B' &amp;&amp; _guess == 'N') {&#13;
			guess = 'N';&#13;
			coldecimals[i] = cols[i].DBF.dec;&#13;
			maxlen = cols[i].DBF.len;&#13;
		}&#13;
		colwidths[i] = guess == 'C' || _guess == 'N' ? maxlen : (_RLEN[guess] || 0);&#13;
		rlen += colwidths[i];&#13;
		coltypes[i] = guess;&#13;
	}&#13;
&#13;
	var h = ba.next(32);&#13;
	h.write_shift(4, 0x13021130);&#13;
	h.write_shift(4, data.length);&#13;
	h.write_shift(2, 296 + 32 * hcnt);&#13;
	h.write_shift(2, rlen);&#13;
	for(i=0; i &lt; 4; ++i) h.write_shift(4, 0);&#13;
	var cp = +dbf_reverse_map[current_codepage] || 0x03;&#13;
	h.write_shift(4, 0x00000000 | (cp&lt;&lt;8));&#13;
	if(dbf_codepage_map[cp] != +o.codepage) {&#13;
		if(o.codepage) console.error("DBF Unsupported codepage " + current_codepage + ", using 1252");&#13;
		current_codepage = 1252;&#13;
	}&#13;
&#13;
	for(i = 0, j = 0; i &lt; headers.length; ++i) {&#13;
		if(headers[i] == null) continue;&#13;
		var hf = ba.next(32);&#13;
		/* TODO: test how applications handle non-ASCII field names */&#13;
		var _f = (headers[i].slice(-10) + "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00").slice(0, 11);&#13;
		hf.write_shift(1, _f, "sbcs");&#13;
		hf.write_shift(1, coltypes[i] == '?' ? 'C' : coltypes[i], "sbcs");&#13;
		hf.write_shift(4, j);&#13;
		hf.write_shift(1, colwidths[i] || _RLEN[coltypes[i]] || 0);&#13;
		hf.write_shift(1, coldecimals[i] || 0);&#13;
		hf.write_shift(1, 0x02);&#13;
		hf.write_shift(4, 0);&#13;
		hf.write_shift(1, 0);&#13;
		hf.write_shift(4, 0);&#13;
		hf.write_shift(4, 0);&#13;
		j += (colwidths[i] || _RLEN[coltypes[i]] || 0);&#13;
	}&#13;
&#13;
	var hb = ba.next(264);&#13;
	hb.write_shift(4, 0x0000000D);&#13;
	for(i=0; i &lt; 65;++i) hb.write_shift(4, 0x00000000);&#13;
	for(i=0; i &lt; data.length; ++i) {&#13;
		var rout = ba.next(rlen);&#13;
		rout.write_shift(1, 0);&#13;
		for(j=0; j&lt;headers.length; ++j) {&#13;
			if(headers[j] == null) continue;&#13;
			switch(coltypes[j]) {&#13;
				case 'L': rout.write_shift(1, data[i][j] == null ? 0x3F : data[i][j] ? 0x54 : 0x46); break;&#13;
				case 'B': rout.write_shift(8, data[i][j]||0, 'f'); break;&#13;
				case 'N':&#13;
					var _n = "0";&#13;
					if(typeof data[i][j] == "number") _n = data[i][j].toFixed(coldecimals[j]||0);&#13;
					for(hcnt=0; hcnt &lt; colwidths[j]-_n.length; ++hcnt) rout.write_shift(1, 0x20);&#13;
					rout.write_shift(1, _n, "sbcs");&#13;
					break;&#13;
				case 'D':&#13;
					if(!data[i][j]) rout.write_shift(8, "00000000", "sbcs");&#13;
					else {&#13;
						rout.write_shift(4, ("0000"+data[i][j].getFullYear()).slice(-4), "sbcs");&#13;
						rout.write_shift(2, ("00"+(data[i][j].getMonth()+1)).slice(-2), "sbcs");&#13;
						rout.write_shift(2, ("00"+data[i][j].getDate()).slice(-2), "sbcs");&#13;
					} break;&#13;
				case 'C':&#13;
					var _l = rout.l;&#13;
					var _s = String(data[i][j] != null ? data[i][j] : "").slice(0, colwidths[j]);&#13;
					rout.write_shift(1, _s, "cpstr");&#13;
					_l += colwidths[j] - rout.l;&#13;
					for(hcnt=0; hcnt &lt; _l; ++hcnt) rout.write_shift(1, 0x20); break;&#13;
			}&#13;
		}&#13;
		// data&#13;
	}&#13;
	current_codepage = old_cp;&#13;
	ba.next(1).write_shift(1, 0x1A);&#13;
	return ba.end();&#13;
}&#13;
	return {&#13;
		to_workbook: dbf_to_workbook,&#13;
		to_sheet: dbf_to_sheet,&#13;
		from_sheet: sheet_to_dbf&#13;
	};&#13;
})();&#13;
&#13;
var SYLK = (function() {&#13;
	/* TODO: stress test sequences */&#13;
	var sylk_escapes = ({&#13;
		AA:'À', BA:'Á', CA:'Â', DA:195, HA:'Ä', JA:197,&#13;
		AE:'È', BE:'É', CE:'Ê',         HE:'Ë',&#13;
		AI:'Ì', BI:'Í', CI:'Î',         HI:'Ï',&#13;
		AO:'Ò', BO:'Ó', CO:'Ô', DO:213, HO:'Ö',&#13;
		AU:'Ù', BU:'Ú', CU:'Û',         HU:'Ü',&#13;
		Aa:'à', Ba:'á', Ca:'â', Da:227, Ha:'ä', Ja:229,&#13;
		Ae:'è', Be:'é', Ce:'ê',         He:'ë',&#13;
		Ai:'ì', Bi:'í', Ci:'î',         Hi:'ï',&#13;
		Ao:'ò', Bo:'ó', Co:'ô', Do:245, Ho:'ö',&#13;
		Au:'ù', Bu:'ú', Cu:'û',         Hu:'ü',&#13;
		KC:'Ç', Kc:'ç', q:'æ',  z:'œ',  a:'Æ',  j:'Œ',&#13;
		DN:209, Dn:241, Hy:255,&#13;
		S:169,  c:170,  R:174,  "B ":180,&#13;
0:176,    1:177,  2:178,&#13;
3:179,    5:181,  6:182,&#13;
7:183,    Q:185,  k:186,  b:208,  i:216,  l:222,  s:240,  y:248,&#13;
		"!":161, '"':162, "#":163, "(":164, "%":165, "'":167, "H ":168,&#13;
		"+":171, ";":187, "&lt;":188, "=":189, "&gt;":190, "?":191, "{":223&#13;
	});&#13;
	var sylk_char_regex = new RegExp("\u001BN(" + keys(sylk_escapes).join("|").replace(/\|\|\|/, "|\\||").replace(/([?()+])/g,"\\$1") + "|\\|)", "gm");&#13;
	var sylk_char_fn = function(_, $1){ var o = sylk_escapes[$1]; return typeof o == "number" ? _getansi(o) : o; };&#13;
	var decode_sylk_char = function($$, $1, $2) { var newcc = (($1.charCodeAt(0) - 0x20)&lt;&lt;4) | ($2.charCodeAt(0) - 0x30); return newcc == 59 ? $$ : _getansi(newcc); };&#13;
	sylk_escapes["|"] = 254;&#13;
	/* https://oss.sheetjs.com/notes/sylk/ for more details */&#13;
	function sylk_to_aoa(d, opts) {&#13;
		switch(opts.type) {&#13;
			case 'base64': return sylk_to_aoa_str(Base64_decode(d), opts);&#13;
			case 'binary': return sylk_to_aoa_str(d, opts);&#13;
			case 'buffer': return sylk_to_aoa_str(has_buf &amp;&amp; Buffer.isBuffer(d) ? d.toString('binary') : a2s(d), opts);&#13;
			case 'array': return sylk_to_aoa_str(cc2str(d), opts);&#13;
		}&#13;
		throw new Error("Unrecognized type " + opts.type);&#13;
	}&#13;
	function sylk_to_aoa_str(str, opts) {&#13;
		var records = str.split(/[\n\r]+/), R = -1, C = -1, ri = 0, rj = 0, arr = [];&#13;
		var formats = [];&#13;
		var next_cell_format = null;&#13;
		var sht = {}, rowinfo = [], colinfo = [], cw = [];&#13;
		var Mval = 0, j;&#13;
		var wb = { Workbook: { WBProps: {}, Names: [] } };&#13;
		if(+opts.codepage &gt;= 0) set_cp(+opts.codepage);&#13;
		for (; ri !== records.length; ++ri) {&#13;
			Mval = 0;&#13;
			var rstr=records[ri].trim().replace(/\x1B([\x20-\x2F])([\x30-\x3F])/g, decode_sylk_char).replace(sylk_char_regex, sylk_char_fn);&#13;
			var record=rstr.replace(/;;/g, "\u0000").split(";").map(function(x) { return x.replace(/\u0000/g, ";"); });&#13;
			var RT=record[0], val;&#13;
			if(rstr.length &gt; 0) switch(RT) {&#13;
			case 'ID': break; /* header */&#13;
			case 'E': break; /* EOF */&#13;
			case 'B': break; /* dimensions */&#13;
			case 'O': /* workbook options */&#13;
			for(rj=1; rj&lt;record.length; ++rj) switch(record[rj].charAt(0)) {&#13;
				case 'V': {&#13;
					var d1904 = parseInt(record[rj].slice(1), 10);&#13;
					// NOTE: it is technically an error if d1904 &gt;= 5 or &lt; 0&#13;
					if(d1904 &gt;= 1 &amp;&amp; d1904 &lt;= 4) wb.Workbook.WBProps.date1904 = true;&#13;
				} break;&#13;
			} break;&#13;
			case 'W': break; /* window */&#13;
			case 'P':&#13;
				switch(record[1].charAt(0)){&#13;
					case 'P': formats.push(rstr.slice(3).replace(/;;/g, ";")); break;&#13;
				} break;&#13;
			case 'NN': { /* defined name */&#13;
				var nn = {Sheet: 0};&#13;
				for(rj=1; rj&lt;record.length; ++rj) switch(record[rj].charAt(0)) {&#13;
					case 'N': nn.Name = record[rj].slice(1); break;&#13;
					case 'E': nn.Ref = (opts &amp;&amp; opts.sheet || "Sheet1") + "!" + rc_to_a1(record[rj].slice(1)); break;&#13;
				}&#13;
				wb.Workbook.Names.push(nn);&#13;
			} break;&#13;
			// case 'NE': // ??&#13;
			// case 'NU': // ??&#13;
			case 'C': /* cell */&#13;
			var C_seen_K = false, C_seen_X = false, C_seen_S = false, C_seen_E = false, _R = -1, _C = -1, formula = "", cell_t = "z";&#13;
			for(rj=1; rj&lt;record.length; ++rj) switch(record[rj].charAt(0)) {&#13;
				case 'A': break; // TODO: comment&#13;
				case 'X': C = parseInt(record[rj].slice(1), 10)-1; C_seen_X = true; break;&#13;
				case 'Y':&#13;
					R = parseInt(record[rj].slice(1), 10)-1; if(!C_seen_X) C = 0;&#13;
					for(j = arr.length; j &lt;= R; ++j) arr[j] = [];&#13;
					break;&#13;
				case 'K':&#13;
					val = record[rj].slice(1);&#13;
					if(val.charAt(0) === '"') { val = val.slice(1,val.length - 1); cell_t = "s"; }&#13;
					else if(val === 'TRUE' || val === 'FALSE') { val = val === 'TRUE'; cell_t = "b"; }&#13;
					else if(!isNaN(fuzzynum(val))) {&#13;
						val = fuzzynum(val); cell_t = "n";&#13;
						if(next_cell_format !== null &amp;&amp; fmt_is_date(next_cell_format) &amp;&amp; opts.cellDates) { val = numdate(wb.Workbook.WBProps.date1904 ? val + 1462 : val); cell_t = "d"; }&#13;
					} else if(!isNaN(fuzzydate(val).getDate())) {&#13;
						val = parseDate(val); cell_t = "d";&#13;
						if(!opts.cellDates) { cell_t = "n"; val = datenum(val, wb.Workbook.WBProps.date1904); }&#13;
					}&#13;
					if(typeof $cptable !== 'undefined' &amp;&amp; typeof val == "string" &amp;&amp; ((opts||{}).type != "string") &amp;&amp; (opts||{}).codepage) val = $cptable.utils.decode(opts.codepage, val);&#13;
					C_seen_K = true;&#13;
					break;&#13;
				case 'E':&#13;
					C_seen_E = true;&#13;
					formula = rc_to_a1(record[rj].slice(1), {r:R,c:C});&#13;
					break;&#13;
				case 'S':&#13;
					C_seen_S = true;&#13;
					break;&#13;
				case 'G': break; // unknown&#13;
				case 'R': _R = parseInt(record[rj].slice(1), 10)-1; break;&#13;
				case 'C': _C = parseInt(record[rj].slice(1), 10)-1; break;&#13;
				// case 'P': // ??&#13;
				// case 'D': // ??&#13;
				default: if(opts &amp;&amp; opts.WTF) throw new Error("SYLK bad record " + rstr);&#13;
			}&#13;
			if(C_seen_K) {&#13;
				if(!arr[R][C]) arr[R][C] = { t: cell_t, v: val };&#13;
				else { arr[R][C].t = cell_t; arr[R][C].v = val; }&#13;
				if(next_cell_format) arr[R][C].z = next_cell_format;&#13;
				if(opts.cellText !== false &amp;&amp; next_cell_format) arr[R][C].w = SSF_format(arr[R][C].z, arr[R][C].v, { date1904: wb.Workbook.WBProps.date1904 });&#13;
				next_cell_format = null;&#13;
			}&#13;
			if(C_seen_S) {&#13;
				if(C_seen_E) throw new Error("SYLK shared formula cannot have own formula");&#13;
				var shrbase = _R &gt; -1 &amp;&amp; arr[_R][_C];&#13;
				if(!shrbase || !shrbase[1]) throw new Error("SYLK shared formula cannot find base");&#13;
				formula = shift_formula_str(shrbase[1], {r: R - _R, c: C - _C});&#13;
			}&#13;
			if(formula) {&#13;
				if(!arr[R][C]) arr[R][C] = { t: 'n', f: formula };&#13;
				else arr[R][C].f = formula;&#13;
			}&#13;
			break;&#13;
			case 'F': /* Format */&#13;
			var F_seen = 0;&#13;
			for(rj=1; rj&lt;record.length; ++rj) switch(record[rj].charAt(0)) {&#13;
				case 'X': C = parseInt(record[rj].slice(1), 10)-1; ++F_seen; break;&#13;
				case 'Y':&#13;
					R = parseInt(record[rj].slice(1), 10)-1; /*C = 0;*/&#13;
					for(j = arr.length; j &lt;= R; ++j) arr[j] = [];&#13;
					break;&#13;
				case 'M': Mval = parseInt(record[rj].slice(1), 10) / 20; break;&#13;
				case 'F': break; /* ??? */&#13;
				case 'G': break; /* hide grid */&#13;
				case 'P':&#13;
					next_cell_format = formats[parseInt(record[rj].slice(1), 10)];&#13;
					break;&#13;
				case 'S': break; /* cell style */&#13;
				case 'D': break; /* column */&#13;
				case 'N': break; /* font */&#13;
				case 'W':&#13;
					cw = record[rj].slice(1).split(" ");&#13;
					for(j = parseInt(cw[0], 10); j &lt;= parseInt(cw[1], 10); ++j) {&#13;
						Mval = parseInt(cw[2], 10);&#13;
						colinfo[j-1] = Mval === 0 ? {hidden:true}: {wch:Mval};&#13;
					} break;&#13;
				case 'C': /* default column format */&#13;
					C = parseInt(record[rj].slice(1), 10)-1;&#13;
					if(!colinfo[C]) colinfo[C] = {};&#13;
					break;&#13;
				case 'R': /* row properties */&#13;
					R = parseInt(record[rj].slice(1), 10)-1;&#13;
					if(!rowinfo[R]) rowinfo[R] = {};&#13;
					if(Mval &gt; 0) { rowinfo[R].hpt = Mval; rowinfo[R].hpx = pt2px(Mval); }&#13;
					else if(Mval === 0) rowinfo[R].hidden = true;&#13;
					break;&#13;
				// case 'K': // ??&#13;
				// case 'E': // ??&#13;
				default: if(opts &amp;&amp; opts.WTF) throw new Error("SYLK bad record " + rstr);&#13;
			}&#13;
			if(F_seen &lt; 1) next_cell_format = null; break;&#13;
			default: if(opts &amp;&amp; opts.WTF) throw new Error("SYLK bad record " + rstr);&#13;
			}&#13;
		}&#13;
		if(rowinfo.length &gt; 0) sht['!rows'] = rowinfo;&#13;
		if(colinfo.length &gt; 0) sht['!cols'] = colinfo;&#13;
		colinfo.forEach(function(col) { process_col(col); });&#13;
		if(opts &amp;&amp; opts.sheetRows) arr = arr.slice(0, opts.sheetRows);&#13;
		return [arr, sht, wb];&#13;
	}&#13;
&#13;
	function sylk_to_workbook(d, opts) {&#13;
		var aoasht = sylk_to_aoa(d, opts);&#13;
		var aoa = aoasht[0], ws = aoasht[1], wb = aoasht[2];&#13;
		var _opts = dup(opts); _opts.date1904 = (((wb||{}).Workbook || {}).WBProps || {}).date1904;&#13;
		var o = aoa_to_sheet(aoa, _opts);&#13;
		keys(ws).forEach(function(k) { o[k] = ws[k]; });&#13;
		var outwb = sheet_to_workbook(o, opts);&#13;
		keys(wb).forEach(function(k) { outwb[k] = wb[k]; });&#13;
		outwb.bookType = "sylk";&#13;
		return outwb;&#13;
	}&#13;
&#13;
	function write_ws_cell_sylk(cell, ws, R, C) {&#13;
		var o = "C;Y" + (R+1) + ";X" + (C+1) + ";K";&#13;
		switch(cell.t) {&#13;
			case 'n':&#13;
				o += (cell.v||0);&#13;
				if(cell.f &amp;&amp; !cell.F) o += ";E" + a1_to_rc(cell.f, {r:R, c:C}); break;&#13;
			case 'b': o += cell.v ? "TRUE" : "FALSE"; break;&#13;
			case 'e': o += cell.w || cell.v; break;&#13;
			case 'd': o += '"' + (cell.w || cell.v) + '"'; break;&#13;
			case 's': o += '"' + (cell.v == null ? "" : String(cell.v)).replace(/"/g,"").replace(/;/g, ";;") + '"'; break;&#13;
		}&#13;
		return o;&#13;
	}&#13;
&#13;
	function write_ws_cols_sylk(out, cols) {&#13;
		cols.forEach(function(col, i) {&#13;
			var rec = "F;W" + (i+1) + " " + (i+1) + " ";&#13;
			if(col.hidden) rec += "0";&#13;
			else {&#13;
				if(typeof col.width == 'number' &amp;&amp; !col.wpx) col.wpx = width2px(col.width);&#13;
				if(typeof col.wpx == 'number' &amp;&amp; !col.wch) col.wch = px2char(col.wpx);&#13;
				if(typeof col.wch == 'number') rec += Math.round(col.wch);&#13;
			}&#13;
			if(rec.charAt(rec.length - 1) != " ") out.push(rec);&#13;
		});&#13;
	}&#13;
&#13;
	function write_ws_rows_sylk(out, rows) {&#13;
		rows.forEach(function(row, i) {&#13;
			var rec = "F;";&#13;
			if(row.hidden) rec += "M0;";&#13;
			else if(row.hpt) rec += "M" + 20 * row.hpt + ";";&#13;
			else if(row.hpx) rec += "M" + 20 * px2pt(row.hpx) + ";";&#13;
			if(rec.length &gt; 2) out.push(rec + "R" + (i+1));&#13;
		});&#13;
	}&#13;
&#13;
	function sheet_to_sylk(ws, opts, wb) {&#13;
		/* TODO: codepage */&#13;
		var preamble = ["ID;Pxlsx;N;E"], o = [];&#13;
		var r = safe_decode_range(ws['!ref']), cell;&#13;
		var dense = Array.isArray(ws);&#13;
		var RS = "\r\n";&#13;
		var d1904 = (((wb||{}).Workbook||{}).WBProps||{}).date1904;&#13;
&#13;
		preamble.push("P;PGeneral");&#13;
		preamble.push("F;P0;DG0G8;M255");&#13;
		if(ws['!cols']) write_ws_cols_sylk(preamble, ws['!cols']);&#13;
		if(ws['!rows']) write_ws_rows_sylk(preamble, ws['!rows']);&#13;
&#13;
		preamble.push("B;Y" + (r.e.r - r.s.r + 1) + ";X" + (r.e.c - r.s.c + 1) + ";D" + [r.s.c,r.s.r,r.e.c,r.e.r].join(" "));&#13;
		preamble.push("O;L;D;B" + (d1904 ? ";V4" : "") + ";K47;G100 0.001");&#13;
		for(var R = r.s.r; R &lt;= r.e.r; ++R) {&#13;
			var p = [];&#13;
			for(var C = r.s.c; C &lt;= r.e.c; ++C) {&#13;
				var coord = encode_cell({r:R,c:C});&#13;
				cell = dense ? (ws[R]||[])[C]: ws[coord];&#13;
				if(!cell || (cell.v == null &amp;&amp; (!cell.f || cell.F))) continue;&#13;
				p.push(write_ws_cell_sylk(cell, ws, R, C, opts)); // TODO: pass date1904 info&#13;
			}&#13;
			o.push(p.join(RS));&#13;
		}&#13;
		return preamble.join(RS) + RS + o.join(RS) + RS + "E" + RS;&#13;
	}&#13;
&#13;
	return {&#13;
		to_workbook: sylk_to_workbook,&#13;
		from_sheet: sheet_to_sylk&#13;
	};&#13;
})();&#13;
&#13;
var DIF = (function() {&#13;
	function dif_to_aoa(d, opts) {&#13;
		switch(opts.type) {&#13;
			case 'base64': return dif_to_aoa_str(Base64_decode(d), opts);&#13;
			case 'binary': return dif_to_aoa_str(d, opts);&#13;
			case 'buffer': return dif_to_aoa_str(has_buf &amp;&amp; Buffer.isBuffer(d) ? d.toString('binary') : a2s(d), opts);&#13;
			case 'array': return dif_to_aoa_str(cc2str(d), opts);&#13;
		}&#13;
		throw new Error("Unrecognized type " + opts.type);&#13;
	}&#13;
	function dif_to_aoa_str(str, opts) {&#13;
		var records = str.split('\n'), R = -1, C = -1, ri = 0, arr = [];&#13;
		for (; ri !== records.length; ++ri) {&#13;
			if (records[ri].trim() === 'BOT') { arr[++R] = []; C = 0; continue; }&#13;
			if (R &lt; 0) continue;&#13;
			var metadata = records[ri].trim().split(",");&#13;
			var type = metadata[0], value = metadata[1];&#13;
			++ri;&#13;
			var data = records[ri] || "";&#13;
			while(((data.match(/["]/g)||[]).length &amp; 1) &amp;&amp; ri &lt; records.length - 1) data += "\n" + records[++ri];&#13;
			data = data.trim();&#13;
			switch (+type) {&#13;
				case -1:&#13;
					if (data === 'BOT') { arr[++R] = []; C = 0; continue; }&#13;
					else if (data !== 'EOD') throw new Error("Unrecognized DIF special command " + data);&#13;
					break;&#13;
				case 0:&#13;
					if(data === 'TRUE') arr[R][C] = true;&#13;
					else if(data === 'FALSE') arr[R][C] = false;&#13;
					else if(!isNaN(fuzzynum(value))) arr[R][C] = fuzzynum(value);&#13;
					else if(!isNaN(fuzzydate(value).getDate())) arr[R][C] = parseDate(value);&#13;
					else arr[R][C] = value;&#13;
					++C; break;&#13;
				case 1:&#13;
					data = data.slice(1,data.length-1);&#13;
					data = data.replace(/""/g, '"');&#13;
					if(DIF_XL &amp;&amp; data &amp;&amp; data.match(/^=".*"$/)) data = data.slice(2, -1);&#13;
					arr[R][C++] = data !== '' ? data : null;&#13;
					break;&#13;
			}&#13;
			if (data === 'EOD') break;&#13;
		}&#13;
		if(opts &amp;&amp; opts.sheetRows) arr = arr.slice(0, opts.sheetRows);&#13;
		return arr;&#13;
	}&#13;
&#13;
	function dif_to_sheet(str, opts) { return aoa_to_sheet(dif_to_aoa(str, opts), opts); }&#13;
	function dif_to_workbook(str, opts) {&#13;
		var o = sheet_to_workbook(dif_to_sheet(str, opts), opts);&#13;
		o.bookType = "dif";&#13;
		return o;&#13;
	}&#13;
&#13;
	function make_value(v, s) { return "0," + String(v) + "\r\n" + s; }&#13;
	function make_value_str(s) { return "1,0\r\n\"" + s.replace(/"/g,'""') + '"'; }&#13;
	function sheet_to_dif(ws) {&#13;
		var _DIF_XL = DIF_XL;&#13;
		var r = safe_decode_range(ws['!ref']);&#13;
		var dense = Array.isArray(ws);&#13;
		var o = [&#13;
			"TABLE\r\n0,1\r\n\"sheetjs\"\r\n",&#13;
			"VECTORS\r\n0," + (r.e.r - r.s.r + 1) + "\r\n\"\"\r\n",&#13;
			"TUPLES\r\n0," + (r.e.c - r.s.c + 1) + "\r\n\"\"\r\n",&#13;
			"DATA\r\n0,0\r\n\"\"\r\n"&#13;
		];&#13;
		for(var R = r.s.r; R &lt;= r.e.r; ++R) {&#13;
			var p = "-1,0\r\nBOT\r\n";&#13;
			for(var C = r.s.c; C &lt;= r.e.c; ++C) {&#13;
				var cell = dense ? (ws[R] &amp;&amp; ws[R][C]) : ws[encode_cell({r:R,c:C})];&#13;
				if(cell == null) { p +=("1,0\r\n\"\"\r\n"); continue;}&#13;
				switch(cell.t) {&#13;
					case 'n':&#13;
						if(_DIF_XL) {&#13;
							if(cell.w != null) p +=("0," + cell.w + "\r\nV");&#13;
							else if(cell.v != null) p +=(make_value(cell.v, "V")); // TODO: should this call SSF_format?&#13;
							else if(cell.f != null &amp;&amp; !cell.F) p +=(make_value_str("=" + cell.f));&#13;
							else p +=("1,0\r\n\"\"");&#13;
						} else {&#13;
							if(cell.v == null) p +=("1,0\r\n\"\"");&#13;
							else p +=(make_value(cell.v, "V"));&#13;
						}&#13;
						break;&#13;
					case 'b':&#13;
						p +=(cell.v ? make_value(1, "TRUE") : make_value(0, "FALSE"));&#13;
						break;&#13;
					case 's':&#13;
						p +=(make_value_str((!_DIF_XL || isNaN(+cell.v)) ? cell.v : '="' + cell.v + '"'));&#13;
						break;&#13;
					case 'd':&#13;
						if(!cell.w) cell.w = SSF_format(cell.z || table_fmt[14], datenum(parseDate(cell.v)));&#13;
						if(_DIF_XL) p +=(make_value(cell.w, "V"));&#13;
						else p +=(make_value_str(cell.w));&#13;
						break;&#13;
					default: p +=("1,0\r\n\"\"");&#13;
				}&#13;
				p += "\r\n";&#13;
			}&#13;
			o.push(p);&#13;
		}&#13;
		return o.join("") + "-1,0\r\nEOD";&#13;
	}&#13;
	return {&#13;
		to_workbook: dif_to_workbook,&#13;
		to_sheet: dif_to_sheet,&#13;
		from_sheet: sheet_to_dif&#13;
	};&#13;
})();&#13;
&#13;
var ETH = (function() {&#13;
	function decode(s) { return s.replace(/\\b/g,"\\").replace(/\\c/g,":").replace(/\\n/g,"\n"); }&#13;
	function encode(s) { return s.replace(/\\/g, "\\b").replace(/:/g, "\\c").replace(/\n/g,"\\n"); }&#13;
&#13;
	function eth_to_aoa(str, opts) {&#13;
		var records = str.split('\n'), R = -1, C = -1, ri = 0, arr = [];&#13;
		for (; ri !== records.length; ++ri) {&#13;
			var record = records[ri].trim().split(":");&#13;
			if(record[0] !== 'cell') continue;&#13;
			var addr = decode_cell(record[1]);&#13;
			if(arr.length &lt;= addr.r) for(R = arr.length; R &lt;= addr.r; ++R) if(!arr[R]) arr[R] = [];&#13;
			R = addr.r; C = addr.c;&#13;
			switch(record[2]) {&#13;
				case 't': arr[R][C] = decode(record[3]); break;&#13;
				case 'v': arr[R][C] = +record[3]; break;&#13;
				case 'vtf': var _f = record[record.length - 1];&#13;
					/* falls through */&#13;
				case 'vtc':&#13;
					switch(record[3]) {&#13;
						case 'nl': arr[R][C] = +record[4] ? true : false; break;&#13;
						default: arr[R][C] = +record[4]; break;&#13;
					}&#13;
					if(record[2] == 'vtf') arr[R][C] = [arr[R][C], _f];&#13;
			}&#13;
		}&#13;
		if(opts &amp;&amp; opts.sheetRows) arr = arr.slice(0, opts.sheetRows);&#13;
		return arr;&#13;
	}&#13;
&#13;
	function eth_to_sheet(d, opts) { return aoa_to_sheet(eth_to_aoa(d, opts), opts); }&#13;
	function eth_to_workbook(d, opts) { return sheet_to_workbook(eth_to_sheet(d, opts), opts); }&#13;
&#13;
	var header = [&#13;
		"socialcalc:version:1.5",&#13;
		"MIME-Version: 1.0",&#13;
		"Content-Type: multipart/mixed; boundary=SocialCalcSpreadsheetControlSave"&#13;
	].join("\n");&#13;
&#13;
	var sep = [&#13;
		"--SocialCalcSpreadsheetControlSave",&#13;
		"Content-type: text/plain; charset=UTF-8"&#13;
	].join("\n") + "\n";&#13;
&#13;
	/* TODO: the other parts */&#13;
	var meta = [&#13;
		"# SocialCalc Spreadsheet Control Save",&#13;
		"part:sheet"&#13;
	].join("\n");&#13;
&#13;
	var end = "--SocialCalcSpreadsheetControlSave--";&#13;
&#13;
	function sheet_to_eth_data(ws) {&#13;
		if(!ws || !ws['!ref']) return "";&#13;
		var o = [], oo = [], cell, coord = "";&#13;
		var r = decode_range(ws['!ref']);&#13;
		var dense = Array.isArray(ws);&#13;
		for(var R = r.s.r; R &lt;= r.e.r; ++R) {&#13;
			for(var C = r.s.c; C &lt;= r.e.c; ++C) {&#13;
				coord = encode_cell({r:R,c:C});&#13;
				cell = dense ? (ws[R]||[])[C] : ws[coord];&#13;
				if(!cell || cell.v == null || cell.t === 'z') continue;&#13;
				oo = ["cell", coord, 't'];&#13;
				switch(cell.t) {&#13;
					case 's': case 'str': oo.push(encode(cell.v)); break;&#13;
					case 'n':&#13;
						if(!cell.f) { oo[2]='v'; oo[3]=cell.v; }&#13;
						else { oo[2]='vtf'; oo[3]='n'; oo[4]=cell.v; oo[5]=encode(cell.f); }&#13;
						break;&#13;
					case 'b':&#13;
						oo[2] = 'vt'+(cell.f?'f':'c'); oo[3]='nl'; oo[4]=cell.v?"1":"0";&#13;
						oo[5] = encode(cell.f||(cell.v?'TRUE':'FALSE'));&#13;
						break;&#13;
					case 'd':&#13;
						var t = datenum(parseDate(cell.v));&#13;
						oo[2] = 'vtc'; oo[3] = 'nd'; oo[4] = ""+t;&#13;
						oo[5] = cell.w || SSF_format(cell.z || table_fmt[14], t);&#13;
						break;&#13;
					case 'e': continue;&#13;
				}&#13;
				o.push(oo.join(":"));&#13;
			}&#13;
		}&#13;
		o.push("sheet:c:" + (r.e.c-r.s.c+1) + ":r:" + (r.e.r-r.s.r+1) + ":tvf:1");&#13;
		o.push("valueformat:1:text-wiki");&#13;
		//o.push("copiedfrom:" + ws['!ref']); // clipboard only&#13;
		return o.join("\n");&#13;
	}&#13;
&#13;
	function sheet_to_eth(ws) {&#13;
		return [header, sep, meta, sep, sheet_to_eth_data(ws), end].join("\n");&#13;
		// return ["version:1.5", sheet_to_eth_data(ws)].join("\n"); // clipboard form&#13;
	}&#13;
&#13;
	return {&#13;
		to_workbook: eth_to_workbook,&#13;
		to_sheet: eth_to_sheet,&#13;
		from_sheet: sheet_to_eth&#13;
	};&#13;
})();&#13;
&#13;
var PRN = (function() {&#13;
	function set_text_arr(data, arr, R, C, o) {&#13;
		if(o.raw) arr[R][C] = data;&#13;
		else if(data === ""){/* empty */}&#13;
		else if(data === 'TRUE') arr[R][C] = true;&#13;
		else if(data === 'FALSE') arr[R][C] = false;&#13;
		else if(!isNaN(fuzzynum(data))) arr[R][C] = fuzzynum(data);&#13;
		else if(!isNaN(fuzzydate(data).getDate())) arr[R][C] = parseDate(data);&#13;
		else arr[R][C] = data;&#13;
	}&#13;
&#13;
	function prn_to_aoa_str(f, opts) {&#13;
		var o = opts || {};&#13;
		var arr = ([]);&#13;
		if(!f || f.length === 0) return arr;&#13;
		var lines = f.split(/[\r\n]/);&#13;
		var L = lines.length - 1;&#13;
		while(L &gt;= 0 &amp;&amp; lines[L].length === 0) --L;&#13;
		var start = 10, idx = 0;&#13;
		var R = 0;&#13;
		for(; R &lt;= L; ++R) {&#13;
			idx = lines[R].indexOf(" ");&#13;
			if(idx == -1) idx = lines[R].length; else idx++;&#13;
			start = Math.max(start, idx);&#13;
		}&#13;
		for(R = 0; R &lt;= L; ++R) {&#13;
			arr[R] = [];&#13;
			/* TODO: confirm that widths are always 10 */&#13;
			var C = 0;&#13;
			set_text_arr(lines[R].slice(0, start).trim(), arr, R, C, o);&#13;
			for(C = 1; C &lt;= (lines[R].length - start)/10 + 1; ++C)&#13;
				set_text_arr(lines[R].slice(start+(C-1)*10,start+C*10).trim(),arr,R,C,o);&#13;
		}&#13;
		if(o.sheetRows) arr = arr.slice(0, o.sheetRows);&#13;
		return arr;&#13;
	}&#13;
&#13;
	// List of accepted CSV separators&#13;
	var guess_seps = {&#13;
0x2C: ',',&#13;
0x09: "\t",&#13;
0x3B: ';',&#13;
0x7C: '|'&#13;
	};&#13;
&#13;
	// CSV separator weights to be used in case of equal numbers&#13;
	var guess_sep_weights = {&#13;
0x2C: 3,&#13;
0x09: 2,&#13;
0x3B: 1,&#13;
0x7C: 0&#13;
	};&#13;
&#13;
	function guess_sep(str) {&#13;
		var cnt = {}, instr = false, end = 0, cc = 0;&#13;
		for(;end &lt; str.length;++end) {&#13;
			if((cc=str.charCodeAt(end)) == 0x22) instr = !instr;&#13;
			else if(!instr &amp;&amp; cc in guess_seps) cnt[cc] = (cnt[cc]||0)+1;&#13;
		}&#13;
&#13;
		cc = [];&#13;
		for(end in cnt) if ( Object.prototype.hasOwnProperty.call(cnt, end) ) {&#13;
			cc.push([ cnt[end], end ]);&#13;
		}&#13;
&#13;
		if ( !cc.length ) {&#13;
			cnt = guess_sep_weights;&#13;
			for(end in cnt) if ( Object.prototype.hasOwnProperty.call(cnt, end) ) {&#13;
				cc.push([ cnt[end], end ]);&#13;
			}&#13;
		}&#13;
&#13;
		cc.sort(function(a, b) { return a[0] - b[0] || guess_sep_weights[a[1]] - guess_sep_weights[b[1]]; });&#13;
&#13;
		return guess_seps[cc.pop()[1]] || 0x2C;&#13;
	}&#13;
&#13;
	function dsv_to_sheet_str(str, opts) {&#13;
		var o = opts || {};&#13;
		var sep = "";&#13;
		if(DENSE != null &amp;&amp; o.dense == null) o.dense = DENSE;&#13;
		var ws = o.dense ? ([]) : ({});&#13;
		var range = ({s: {c:0, r:0}, e: {c:0, r:0}});&#13;
&#13;
		if(str.slice(0,4) == "sep=") {&#13;
			// If the line ends in \r\n&#13;
			if(str.charCodeAt(5) == 13 &amp;&amp; str.charCodeAt(6) == 10 ) {&#13;
				sep = str.charAt(4); str = str.slice(7);&#13;
			}&#13;
			// If line ends in \r OR \n&#13;
			else if(str.charCodeAt(5) == 13 || str.charCodeAt(5) == 10 ) {&#13;
				sep = str.charAt(4); str = str.slice(6);&#13;
			}&#13;
			else sep = guess_sep(str.slice(0,1024));&#13;
		}&#13;
		else if(o &amp;&amp; o.FS) sep = o.FS;&#13;
		else sep = guess_sep(str.slice(0,1024));&#13;
		var R = 0, C = 0, v = 0;&#13;
		var start = 0, end = 0, sepcc = sep.charCodeAt(0), instr = false, cc=0, startcc=str.charCodeAt(0);&#13;
		var _re = o.dateNF != null ? dateNF_regex(o.dateNF) : null;&#13;
		function finish_cell() {&#13;
			var s = str.slice(start, end); if(s.slice(-1) == "\r") s = s.slice(0, -1);&#13;
			var cell = ({});&#13;
			if(s.charAt(0) == '"' &amp;&amp; s.charAt(s.length - 1) == '"') s = s.slice(1,-1).replace(/""/g,'"');&#13;
			if(s.length === 0) cell.t = 'z';&#13;
			else if(o.raw) { cell.t = 's'; cell.v = s; }&#13;
			else if(s.trim().length === 0) { cell.t = 's'; cell.v = s; }&#13;
			else if(s.charCodeAt(0) == 0x3D) {&#13;
				if(s.charCodeAt(1) == 0x22 &amp;&amp; s.charCodeAt(s.length - 1) == 0x22) { cell.t = 's'; cell.v = s.slice(2,-1).replace(/""/g,'"'); }&#13;
				else if(fuzzyfmla(s)) { cell.t = 'n'; cell.f = s.slice(1); }&#13;
				else { cell.t = 's'; cell.v = s; } }&#13;
			else if(s == "TRUE") { cell.t = 'b'; cell.v = true; }&#13;
			else if(s == "FALSE") { cell.t = 'b'; cell.v = false; }&#13;
			else if(!isNaN(v = fuzzynum(s))) { cell.t = 'n'; if(o.cellText !== false) cell.w = s; cell.v = v; }&#13;
			else if(!isNaN((v = fuzzydate(s)).getDate()) || _re &amp;&amp; s.match(_re)) {&#13;
				cell.z = o.dateNF || table_fmt[14];&#13;
				var k = 0;&#13;
				if(_re &amp;&amp; s.match(_re)){ s=dateNF_fix(s, o.dateNF, (s.match(_re)||[])); k=1; v = parseDate(s, k); }&#13;
				if(o.cellDates) { cell.t = 'd'; cell.v = v; }&#13;
				else { cell.t = 'n'; cell.v = datenum(v); }&#13;
				if(o.cellText !== false) cell.w = SSF_format(cell.z, cell.v instanceof Date ? datenum(cell.v):cell.v);&#13;
				if(!o.cellNF) delete cell.z;&#13;
			} else {&#13;
				cell.t = 's';&#13;
				cell.v = s;&#13;
			}&#13;
			if(cell.t == 'z'){}&#13;
			else if(o.dense) { if(!ws[R]) ws[R] = []; ws[R][C] = cell; }&#13;
			else ws[encode_cell({c:C,r:R})] = cell;&#13;
			start = end+1; startcc = str.charCodeAt(start);&#13;
			if(range.e.c &lt; C) range.e.c = C;&#13;
			if(range.e.r &lt; R) range.e.r = R;&#13;
			if(cc == sepcc) ++C; else { C = 0; ++R; if(o.sheetRows &amp;&amp; o.sheetRows &lt;= R) return true; }&#13;
		}&#13;
		outer: for(;end &lt; str.length;++end) switch((cc=str.charCodeAt(end))) {&#13;
			case 0x22: if(startcc === 0x22) instr = !instr; break;&#13;
			case 0x0d:&#13;
				if(instr) break;&#13;
				if(str.charCodeAt(end+1) == 0x0a) ++end;&#13;
				/* falls through */&#13;
			case sepcc: case 0x0a: if(!instr &amp;&amp; finish_cell()) break outer; break;&#13;
			default: break;&#13;
		}&#13;
		if(end - start &gt; 0) finish_cell();&#13;
&#13;
		ws['!ref'] = encode_range(range);&#13;
		return ws;&#13;
	}&#13;
&#13;
	function prn_to_sheet_str(str, opts) {&#13;
		if(!(opts &amp;&amp; opts.PRN)) return dsv_to_sheet_str(str, opts);&#13;
		if(opts.FS) return dsv_to_sheet_str(str, opts);&#13;
		if(str.slice(0,4) == "sep=") return dsv_to_sheet_str(str, opts);&#13;
		if(str.indexOf("\t") &gt;= 0 || str.indexOf(",") &gt;= 0 || str.indexOf(";") &gt;= 0) return dsv_to_sheet_str(str, opts);&#13;
		return aoa_to_sheet(prn_to_aoa_str(str, opts), opts);&#13;
	}&#13;
&#13;
	function prn_to_sheet(d, opts) {&#13;
		var str = "", bytes = opts.type == 'string' ? [0,0,0,0] : firstbyte(d, opts);&#13;
		switch(opts.type) {&#13;
			case 'base64': str = Base64_decode(d); break;&#13;
			case 'binary': str = d; break;&#13;
			case 'buffer':&#13;
				if(opts.codepage == 65001) str = d.toString('utf8'); // TODO: test if buf&#13;
				else if(opts.codepage &amp;&amp; typeof $cptable !== 'undefined') str = $cptable.utils.decode(opts.codepage, d);&#13;
				else str = has_buf &amp;&amp; Buffer.isBuffer(d) ? d.toString('binary') : a2s(d);&#13;
				break;&#13;
			case 'array': str = cc2str(d); break;&#13;
			case 'string': str = d; break;&#13;
			default: throw new Error("Unrecognized type " + opts.type);&#13;
		}&#13;
		if(bytes[0] == 0xEF &amp;&amp; bytes[1] == 0xBB &amp;&amp; bytes[2] == 0xBF) str = utf8read(str.slice(3));&#13;
		else if(opts.type != 'string' &amp;&amp; opts.type != 'buffer' &amp;&amp; opts.codepage == 65001) str = utf8read(str);&#13;
		else if((opts.type == 'binary') &amp;&amp; typeof $cptable !== 'undefined' &amp;&amp; opts.codepage)  str = $cptable.utils.decode(opts.codepage, $cptable.utils.encode(28591,str));&#13;
		if(str.slice(0,19) == "socialcalc:version:") return ETH.to_sheet(opts.type == 'string' ? str : utf8read(str), opts);&#13;
		return prn_to_sheet_str(str, opts);&#13;
	}&#13;
&#13;
	function prn_to_workbook(d, opts) { return sheet_to_workbook(prn_to_sheet(d, opts), opts); }&#13;
&#13;
	function sheet_to_prn(ws) {&#13;
		var o = [];&#13;
		var r = safe_decode_range(ws['!ref']), cell;&#13;
		var dense = Array.isArray(ws);&#13;
		for(var R = r.s.r; R &lt;= r.e.r; ++R) {&#13;
			var oo = [];&#13;
			for(var C = r.s.c; C &lt;= r.e.c; ++C) {&#13;
				var coord = encode_cell({r:R,c:C});&#13;
				cell = dense ? (ws[R]||[])[C] : ws[coord];&#13;
				if(!cell || cell.v == null) { oo.push("          "); continue; }&#13;
				var w = (cell.w || (format_cell(cell), cell.w) || "").slice(0,10);&#13;
				while(w.length &lt; 10) w += " ";&#13;
				oo.push(w + (C === 0 ? " " : ""));&#13;
			}&#13;
			o.push(oo.join(""));&#13;
		}&#13;
		return o.join("\n");&#13;
	}&#13;
&#13;
	return {&#13;
		to_workbook: prn_to_workbook,&#13;
		to_sheet: prn_to_sheet,&#13;
		from_sheet: sheet_to_prn&#13;
	};&#13;
})();&#13;
&#13;
/* Excel defaults to SYLK but warns if data is not valid */&#13;
function read_wb_ID(d, opts) {&#13;
	var o = opts || {}, OLD_WTF = !!o.WTF; o.WTF = true;&#13;
	try {&#13;
		var out = SYLK.to_workbook(d, o);&#13;
		o.WTF = OLD_WTF;&#13;
		return out;&#13;
	} catch(e) {&#13;
		o.WTF = OLD_WTF;&#13;
		if(!e.message.match(/SYLK bad record ID/) &amp;&amp; OLD_WTF) throw e;&#13;
		return PRN.to_workbook(d, opts);&#13;
	}&#13;
}&#13;
&#13;
var WK_ = (function() {&#13;
	function lotushopper(data, cb, opts) {&#13;
		if(!data) return;&#13;
		prep_blob(data, data.l || 0);&#13;
		var Enum = opts.Enum || WK1Enum;&#13;
		while(data.l &lt; data.length) {&#13;
			var RT = data.read_shift(2);&#13;
			var R = Enum[RT] || Enum[0xFFFF];&#13;
			var length = data.read_shift(2);&#13;
			var tgt = data.l + length;&#13;
			var d = R.f &amp;&amp; R.f(data, length, opts);&#13;
			data.l = tgt;&#13;
			if(cb(d, R, RT)) return;&#13;
		}&#13;
	}&#13;
&#13;
	function lotus_to_workbook(d, opts) {&#13;
		switch(opts.type) {&#13;
			case 'base64': return lotus_to_workbook_buf(s2a(Base64_decode(d)), opts);&#13;
			case 'binary': return lotus_to_workbook_buf(s2a(d), opts);&#13;
			case 'buffer':&#13;
			case 'array': return lotus_to_workbook_buf(d, opts);&#13;
		}&#13;
		throw "Unsupported type " + opts.type;&#13;
	}&#13;
&#13;
	function lotus_to_workbook_buf(d, opts) {&#13;
		if(!d) return d;&#13;
		var o = opts || {};&#13;
		if(DENSE != null &amp;&amp; o.dense == null) o.dense = DENSE;&#13;
		var s = ((o.dense ? [] : {})), n = "Sheet1", next_n = "", sidx = 0;&#13;
		var sheets = {}, snames = [], realnames = [];&#13;
&#13;
		var refguess = {s: {r:0, c:0}, e: {r:0, c:0} };&#13;
		var sheetRows = o.sheetRows || 0;&#13;
&#13;
		if(d[4] == 0x51 &amp;&amp; d[5] == 0x50 &amp;&amp; d[6] == 0x57) return qpw_to_workbook_buf(d, opts);&#13;
		if(d[2] == 0x00) {&#13;
			if(d[3] == 0x08 || d[3] == 0x09) {&#13;
				if(d.length &gt;= 16 &amp;&amp; d[14] == 0x05 &amp;&amp; d[15] === 0x6c) throw new Error("Unsupported Works 3 for Mac file");&#13;
			}&#13;
		}&#13;
&#13;
		if(d[2] == 0x02) {&#13;
			o.Enum = WK1Enum;&#13;
			lotushopper(d, function(val, R, RT) { switch(RT) {&#13;
				case 0x00: /* BOF */&#13;
					o.vers = val;&#13;
					if(val &gt;= 0x1000) o.qpro = true;&#13;
					break;&#13;
				case 0xFF: /* BOF (works 3+) */&#13;
					o.vers = val;&#13;
					o.works = true;&#13;
					break;&#13;
				case 0x06: refguess = val; break; /* RANGE */&#13;
				case 0xCC: if(val) next_n = val; break; /* SHEETNAMECS */&#13;
				case 0xDE: next_n = val; break; /* SHEETNAMELP */&#13;
				case 0x0F: /* LABEL */&#13;
				case 0x33: /* STRING */&#13;
					if((!o.qpro &amp;&amp; !o.works || RT == 0x33) &amp;&amp; val[1].v.charCodeAt(0) &lt; 0x30) val[1].v = val[1].v.slice(1);&#13;
					if(o.works || o.works2) val[1].v = val[1].v.replace(/\r\n/g, "\n");&#13;
					/* falls through */&#13;
				case 0x0D: /* INTEGER */&#13;
				case 0x0E: /* NUMBER */&#13;
				case 0x10: /* FORMULA */&#13;
					/* TODO: actual translation of the format code */&#13;
					if(RT == 0x0E &amp;&amp; (val[2] &amp; 0x70) == 0x70 &amp;&amp; (val[2] &amp; 0x0F) &gt; 1 &amp;&amp; (val[2] &amp; 0x0F) &lt; 15) {&#13;
						val[1].z = o.dateNF || table_fmt[14];&#13;
						if(o.cellDates) { val[1].t = 'd'; val[1].v = numdate(val[1].v); }&#13;
					}&#13;
&#13;
					if(o.qpro) {&#13;
						if(val[3] &gt; sidx) {&#13;
							s["!ref"] = encode_range(refguess);&#13;
							sheets[n] = s;&#13;
							snames.push(n);&#13;
							s = (o.dense ? [] : {});&#13;
							refguess = {s: {r:0, c:0}, e: {r:0, c:0} };&#13;
							sidx = val[3]; n = next_n || "Sheet" + (sidx + 1); next_n = "";&#13;
						}&#13;
					}&#13;
&#13;
					var tmpcell = o.dense ? (s[val[0].r]||[])[val[0].c] : s[encode_cell(val[0])];&#13;
					if(tmpcell) {&#13;
						tmpcell.t = val[1].t; tmpcell.v = val[1].v;&#13;
						if(val[1].z != null) tmpcell.z = val[1].z;&#13;
						if(val[1].f != null) tmpcell.f = val[1].f;&#13;
						break;&#13;
					}&#13;
					if(o.dense) {&#13;
						if(!s[val[0].r]) s[val[0].r] = [];&#13;
						s[val[0].r][val[0].c] = val[1];&#13;
					} else s[encode_cell(val[0])] = val[1];&#13;
					break;&#13;
				case 0x5405: o.works2 = true; break;&#13;
				default:&#13;
			}}, o);&#13;
		} else if(d[2] == 0x1A || d[2] == 0x0E) {&#13;
			o.Enum = WK3Enum;&#13;
			if(d[2] == 0x0E) { o.qpro = true; d.l = 0; }&#13;
			lotushopper(d, function(val, R, RT) { switch(RT) {&#13;
				case 0xCC: n = val; break; /* SHEETNAMECS */&#13;
				case 0x16: /* LABEL16 */&#13;
					if(val[1].v.charCodeAt(0) &lt; 0x30) val[1].v = val[1].v.slice(1);&#13;
					// TODO: R9 appears to encode control codes this way -- verify against other versions&#13;
					val[1].v = val[1].v.replace(/\x0F./g, function($$) { return String.fromCharCode($$.charCodeAt(1) - 0x20); }).replace(/\r\n/g, "\n");&#13;
					/* falls through */&#13;
				case 0x17: /* NUMBER17 */&#13;
				case 0x18: /* NUMBER18 */&#13;
				case 0x19: /* FORMULA19 */&#13;
				case 0x25: /* NUMBER25 */&#13;
				case 0x27: /* NUMBER27 */&#13;
				case 0x28: /* FORMULA28 */&#13;
					if(val[3] &gt; sidx) {&#13;
						s["!ref"] = encode_range(refguess);&#13;
						sheets[n] = s;&#13;
						snames.push(n);&#13;
						s = (o.dense ? [] : {});&#13;
						refguess = {s: {r:0, c:0}, e: {r:0, c:0} };&#13;
						sidx = val[3]; n = "Sheet" + (sidx + 1);&#13;
					}&#13;
					if(sheetRows &gt; 0 &amp;&amp; val[0].r &gt;= sheetRows) break;&#13;
					if(o.dense) {&#13;
						if(!s[val[0].r]) s[val[0].r] = [];&#13;
						s[val[0].r][val[0].c] = val[1];&#13;
					} else s[encode_cell(val[0])] = val[1];&#13;
					if(refguess.e.c &lt; val[0].c) refguess.e.c = val[0].c;&#13;
					if(refguess.e.r &lt; val[0].r) refguess.e.r = val[0].r;&#13;
					break;&#13;
				case 0x1B: /* XFORMAT */&#13;
					if(val[0x36b0]) realnames[val[0x36b0][0]] = val[0x36b0][1];&#13;
					break;&#13;
				case 0x0601: /* SHEETINFOQP */&#13;
					realnames[val[0]] = val[1]; if(val[0] == sidx) n = val[1]; break;&#13;
				default: break;&#13;
			}}, o);&#13;
		} else throw new Error("Unrecognized LOTUS BOF " + d[2]);&#13;
		s["!ref"] = encode_range(refguess);&#13;
		sheets[next_n || n] = s;&#13;
		snames.push(next_n || n);&#13;
		if(!realnames.length) return { SheetNames: snames, Sheets: sheets };&#13;
		var osheets = {}, rnames = [];&#13;
		/* TODO: verify no collisions */&#13;
		for(var i = 0; i &lt; realnames.length; ++i) if(sheets[snames[i]]) {&#13;
			rnames.push(realnames[i] || snames[i]);&#13;
			osheets[realnames[i]] = sheets[realnames[i]] || sheets[snames[i]];&#13;
		} else {&#13;
			rnames.push(realnames[i]);&#13;
			osheets[realnames[i]] = ({ "!ref": "A1" });&#13;
		}&#13;
		return { SheetNames: rnames, Sheets: osheets };&#13;
	}&#13;
&#13;
	function sheet_to_wk1(ws, opts) {&#13;
		var o = opts || {};&#13;
		if(+o.codepage &gt;= 0) set_cp(+o.codepage);&#13;
		if(o.type == "string") throw new Error("Cannot write WK1 to JS string");&#13;
		var ba = buf_array();&#13;
		var range = safe_decode_range(ws["!ref"]);&#13;
		var dense = Array.isArray(ws);&#13;
		var cols = [];&#13;
&#13;
		write_biff_rec(ba, 0x00, write_BOF_WK1(0x0406));&#13;
		write_biff_rec(ba, 0x06, write_RANGE(range));&#13;
		var max_R = Math.min(range.e.r, 8191);&#13;
		for(var R = range.s.r; R &lt;= max_R; ++R) {&#13;
			var rr = encode_row(R);&#13;
			for(var C = range.s.c; C &lt;= range.e.c; ++C) {&#13;
				if(R === range.s.r) cols[C] = encode_col(C);&#13;
				var ref = cols[C] + rr;&#13;
				var cell = dense ? (ws[R]||[])[C] : ws[ref];&#13;
				if(!cell || cell.t == "z") continue;&#13;
				/* TODO: formula records */&#13;
				if(cell.t == "n") {&#13;
					if((cell.v|0)==cell.v &amp;&amp; cell.v &gt;= -32768 &amp;&amp; cell.v &lt;= 32767) write_biff_rec(ba, 0x0d, write_INTEGER(R, C, cell.v));&#13;
					else write_biff_rec(ba, 0x0e, write_NUMBER(R, C, cell.v));&#13;
				} else {&#13;
					var str = format_cell(cell);&#13;
					write_biff_rec(ba, 0x0F, write_LABEL(R, C, str.slice(0, 239)));&#13;
				}&#13;
			}&#13;
		}&#13;
&#13;
		write_biff_rec(ba, 0x01);&#13;
		return ba.end();&#13;
	}&#13;
&#13;
	function book_to_wk3(wb, opts) {&#13;
		var o = opts || {};&#13;
		if(+o.codepage &gt;= 0) set_cp(+o.codepage);&#13;
		if(o.type == "string") throw new Error("Cannot write WK3 to JS string");&#13;
		var ba = buf_array();&#13;
&#13;
		write_biff_rec(ba, 0x00, write_BOF_WK3(wb));&#13;
&#13;
		for(var i = 0, cnt = 0; i &lt; wb.SheetNames.length; ++i) if((wb.Sheets[wb.SheetNames[i]] || {})["!ref"]) write_biff_rec(ba, 0x1b, write_XFORMAT_SHEETNAME(wb.SheetNames[i], cnt++));&#13;
&#13;
		var wsidx = 0;&#13;
		for(i = 0; i &lt; wb.SheetNames.length; ++i) {&#13;
			var ws = wb.Sheets[wb.SheetNames[i]];&#13;
			if(!ws || !ws["!ref"]) continue;&#13;
			var range = safe_decode_range(ws["!ref"]);&#13;
			var dense = Array.isArray(ws);&#13;
			var cols = [];&#13;
			var max_R = Math.min(range.e.r, 8191);&#13;
			for(var R = range.s.r; R &lt;= max_R; ++R) {&#13;
				var rr = encode_row(R);&#13;
				for(var C = range.s.c; C &lt;= range.e.c; ++C) {&#13;
					if(R === range.s.r) cols[C] = encode_col(C);&#13;
					var ref = cols[C] + rr;&#13;
					var cell = dense ? (ws[R]||[])[C] : ws[ref];&#13;
					if(!cell || cell.t == "z") continue;&#13;
					/* TODO: FORMULA19 NUMBER18 records */&#13;
					if(cell.t == "n") {&#13;
						write_biff_rec(ba, 0x17, write_NUMBER_17(R, C, wsidx, cell.v));&#13;
					} else {&#13;
						var str = format_cell(cell);&#13;
						/* TODO: max len? */&#13;
						write_biff_rec(ba, 0x16, write_LABEL_16(R, C, wsidx, str.slice(0, 239)));&#13;
					}&#13;
				}&#13;
			}&#13;
			++wsidx;&#13;
		}&#13;
&#13;
		write_biff_rec(ba, 0x01);&#13;
		return ba.end();&#13;
	}&#13;
&#13;
&#13;
	function write_BOF_WK1(v) {&#13;
		var out = new_buf(2);&#13;
		out.write_shift(2, v);&#13;
		return out;&#13;
	}&#13;
&#13;
	function write_BOF_WK3(wb) {&#13;
		var out = new_buf(26);&#13;
		out.write_shift(2, 0x1000);&#13;
		out.write_shift(2, 0x0004);&#13;
		out.write_shift(4, 0x0000);&#13;
		var rows = 0, cols = 0, wscnt = 0;&#13;
		for(var i = 0; i &lt; wb.SheetNames.length; ++i) {&#13;
			var name = wb.SheetNames[i];&#13;
			var ws = wb.Sheets[name];&#13;
			if(!ws || !ws["!ref"]) continue;&#13;
			++wscnt;&#13;
			var range = decode_range(ws["!ref"]);&#13;
			if(rows &lt; range.e.r) rows = range.e.r;&#13;
			if(cols &lt; range.e.c) cols = range.e.c;&#13;
		}&#13;
		if(rows &gt; 8191) rows = 8191;&#13;
		out.write_shift(2, rows);&#13;
		out.write_shift(1, wscnt);&#13;
		out.write_shift(1, cols);&#13;
		out.write_shift(2, 0x00);&#13;
		out.write_shift(2, 0x00);&#13;
		out.write_shift(1, 0x01);&#13;
		out.write_shift(1, 0x02);&#13;
		out.write_shift(4, 0);&#13;
		out.write_shift(4, 0);&#13;
		return out;&#13;
	}&#13;
&#13;
	function parse_RANGE(blob, length, opts) {&#13;
		var o = {s:{c:0,r:0},e:{c:0,r:0}};&#13;
		if(length == 8 &amp;&amp; opts.qpro) {&#13;
			o.s.c = blob.read_shift(1);&#13;
			blob.l++;&#13;
			o.s.r = blob.read_shift(2);&#13;
			o.e.c = blob.read_shift(1);&#13;
			blob.l++;&#13;
			o.e.r = blob.read_shift(2);&#13;
			return o;&#13;
		}&#13;
		o.s.c = blob.read_shift(2);&#13;
		o.s.r = blob.read_shift(2);&#13;
		if(length == 12 &amp;&amp; opts.qpro) blob.l += 2;&#13;
		o.e.c = blob.read_shift(2);&#13;
		o.e.r = blob.read_shift(2);&#13;
		if(length == 12 &amp;&amp; opts.qpro) blob.l += 2;&#13;
		if(o.s.c == 0xFFFF) o.s.c = o.e.c = o.s.r = o.e.r = 0;&#13;
		return o;&#13;
	}&#13;
	function write_RANGE(range) {&#13;
		var out = new_buf(8);&#13;
		out.write_shift(2, range.s.c);&#13;
		out.write_shift(2, range.s.r);&#13;
		out.write_shift(2, range.e.c);&#13;
		out.write_shift(2, range.e.r);&#13;
		return out;&#13;
	}&#13;
&#13;
	function parse_cell(blob, length, opts) {&#13;
		var o = [{c:0,r:0}, {t:'n',v:0}, 0, 0];&#13;
		if(opts.qpro &amp;&amp; opts.vers != 0x5120) {&#13;
			o[0].c = blob.read_shift(1);&#13;
			o[3] = blob.read_shift(1);&#13;
			o[0].r = blob.read_shift(2);&#13;
			blob.l+=2;&#13;
		} else if(opts.works) { // TODO: verify with more complex works3-4 examples&#13;
			o[0].c = blob.read_shift(2); o[0].r = blob.read_shift(2);&#13;
			o[2] = blob.read_shift(2);&#13;
		} else {&#13;
			o[2] = blob.read_shift(1);&#13;
			o[0].c = blob.read_shift(2); o[0].r = blob.read_shift(2);&#13;
		}&#13;
		return o;&#13;
	}&#13;
&#13;
	function parse_LABEL(blob, length, opts) {&#13;
		var tgt = blob.l + length;&#13;
		var o = parse_cell(blob, length, opts);&#13;
		o[1].t = 's';&#13;
		if(opts.vers == 0x5120) {&#13;
			blob.l++;&#13;
			var len = blob.read_shift(1);&#13;
			o[1].v = blob.read_shift(len, 'utf8');&#13;
			return o;&#13;
		}&#13;
		if(opts.qpro) blob.l++;&#13;
		o[1].v = blob.read_shift(tgt - blob.l, 'cstr');&#13;
		return o;&#13;
	}&#13;
	function write_LABEL(R, C, s) {&#13;
		/* TODO: encoding */&#13;
		var o = new_buf(7 + s.length);&#13;
		o.write_shift(1, 0xFF);&#13;
		o.write_shift(2, C);&#13;
		o.write_shift(2, R);&#13;
		o.write_shift(1, 0x27); // ??&#13;
		for(var i = 0; i &lt; o.length; ++i) {&#13;
			var cc = s.charCodeAt(i);&#13;
			o.write_shift(1, cc &gt;= 0x80 ? 0x5F : cc);&#13;
		}&#13;
		o.write_shift(1, 0);&#13;
		return o;&#13;
	}&#13;
	function parse_STRING(blob, length, opts) {&#13;
		var tgt = blob.l + length;&#13;
		var o = parse_cell(blob, length, opts);&#13;
		o[1].t = 's';&#13;
		if(opts.vers == 0x5120) {&#13;
			var len = blob.read_shift(1);&#13;
			o[1].v = blob.read_shift(len, 'utf8');&#13;
			return o;&#13;
		}&#13;
		o[1].v = blob.read_shift(tgt - blob.l, 'cstr');&#13;
		return o;&#13;
	}&#13;
&#13;
	function parse_INTEGER(blob, length, opts) {&#13;
		var o = parse_cell(blob, length, opts);&#13;
		o[1].v = blob.read_shift(2, 'i');&#13;
		return o;&#13;
	}&#13;
	function write_INTEGER(R, C, v) {&#13;
		var o = new_buf(7);&#13;
		o.write_shift(1, 0xFF);&#13;
		o.write_shift(2, C);&#13;
		o.write_shift(2, R);&#13;
		o.write_shift(2, v, 'i');&#13;
		return o;&#13;
	}&#13;
&#13;
	function parse_NUMBER(blob, length, opts) {&#13;
		var o = parse_cell(blob, length, opts);&#13;
		o[1].v = blob.read_shift(8, 'f');&#13;
		return o;&#13;
	}&#13;
	function write_NUMBER(R, C, v) {&#13;
		var o = new_buf(13);&#13;
		o.write_shift(1, 0xFF);&#13;
		o.write_shift(2, C);&#13;
		o.write_shift(2, R);&#13;
		o.write_shift(8, v, 'f');&#13;
		return o;&#13;
	}&#13;
&#13;
	function parse_FORMULA(blob, length, opts) {&#13;
		var tgt = blob.l + length;&#13;
		var o = parse_cell(blob, length, opts);&#13;
		/* TODO: formula */&#13;
		o[1].v = blob.read_shift(8, 'f');&#13;
		if(opts.qpro) blob.l = tgt;&#13;
		else {&#13;
			var flen = blob.read_shift(2);&#13;
			wk1_fmla_to_csf(blob.slice(blob.l, blob.l + flen), o);&#13;
			blob.l += flen;&#13;
		}&#13;
		return o;&#13;
	}&#13;
&#13;
	function wk1_parse_rc(B, V, col) {&#13;
		var rel = V &amp; 0x8000;&#13;
		V &amp;= ~0x8000;&#13;
		V = (rel ? B : 0) + ((V &gt;= 0x2000) ? V - 0x4000 : V);&#13;
		return (rel ? "" : "$") + (col ? encode_col(V) : encode_row(V));&#13;
	}&#13;
	/* var oprec = [&#13;
		8, 8, 8, 8, 8, 8, 8, 8, 6, 4, 4, 5, 5, 7, 3, 3,&#13;
		3, 3, 3, 3, 1, 1, 2, 6, 8, 8, 8, 8, 8, 8, 8, 8&#13;
	]; */&#13;
	/* TODO: flesh out */&#13;
	var FuncTab = {&#13;
		0x1F: ["NA", 0],&#13;
		// 0x20: ["ERR", 0],&#13;
		0x21: ["ABS", 1],&#13;
		0x22: ["TRUNC", 1],&#13;
		0x23: ["SQRT", 1],&#13;
		0x24: ["LOG", 1],&#13;
		0x25: ["LN", 1],&#13;
		0x26: ["PI", 0],&#13;
		0x27: ["SIN", 1],&#13;
		0x28: ["COS", 1],&#13;
		0x29: ["TAN", 1],&#13;
		0x2A: ["ATAN2", 2],&#13;
		0x2B: ["ATAN", 1],&#13;
		0x2C: ["ASIN", 1],&#13;
		0x2D: ["ACOS", 1],&#13;
		0x2E: ["EXP", 1],&#13;
		0x2F: ["MOD", 2],&#13;
		// 0x30&#13;
		0x31: ["ISNA", 1],&#13;
		0x32: ["ISERR", 1],&#13;
		0x33: ["FALSE", 0],&#13;
		0x34: ["TRUE", 0],&#13;
		0x35: ["RAND", 0],&#13;
		// 0x36 DATE&#13;
		// 0x37 NOW&#13;
		// 0x38 PMT&#13;
		// 0x39 PV&#13;
		// 0x3A FV&#13;
		// 0x3B IF&#13;
		// 0x3C DAY&#13;
		// 0x3D MONTH&#13;
		// 0x3E YEAR&#13;
		0x3F: ["ROUND", 2],&#13;
		// 0x40 TIME&#13;
		// 0x41 HOUR&#13;
		// 0x42 MINUTE&#13;
		// 0x43 SECOND&#13;
		0x44: ["ISNUMBER", 1],&#13;
		0x45: ["ISTEXT", 1],&#13;
		0x46: ["LEN", 1],&#13;
		0x47: ["VALUE", 1],&#13;
		// 0x48: ["FIXED", ?? 1],&#13;
		0x49: ["MID", 3],&#13;
		0x4A: ["CHAR", 1],&#13;
		// 0x4B&#13;
		// 0x4C FIND&#13;
		// 0x4D DATEVALUE&#13;
		// 0x4E TIMEVALUE&#13;
		// 0x4F CELL&#13;
		0x50: ["SUM", 69],&#13;
		0x51: ["AVERAGEA", 69],&#13;
		0x52: ["COUNTA", 69],&#13;
		0x53: ["MINA", 69],&#13;
		0x54: ["MAXA", 69],&#13;
		// 0x55 VLOOKUP&#13;
		// 0x56 NPV&#13;
		// 0x57 VAR&#13;
		// 0x58 STD&#13;
		// 0x59 IRR&#13;
		// 0x5A HLOOKUP&#13;
		// 0x5B DSUM&#13;
		// 0x5C DAVERAGE&#13;
		// 0x5D DCOUNTA&#13;
		// 0x5E DMIN&#13;
		// 0x5F DMAX&#13;
		// 0x60 DVARP&#13;
		// 0x61 DSTDEVP&#13;
		// 0x62 INDEX&#13;
		// 0x63 COLS&#13;
		// 0x64 ROWS&#13;
		// 0x65 REPEAT&#13;
		0x66: ["UPPER", 1],&#13;
		0x67: ["LOWER", 1],&#13;
		// 0x68 LEFT&#13;
		// 0x69 RIGHT&#13;
		// 0x6A REPLACE&#13;
		0x6B: ["PROPER", 1],&#13;
		// 0x6C CELL&#13;
		0x6D: ["TRIM", 1],&#13;
		// 0x6E CLEAN&#13;
		0x6F: ["T", 1]&#13;
		// 0x70 V&#13;
	};&#13;
	var BinOpTab = [&#13;
		  "",   "",   "",   "",   "",   "",   "",   "", // eslint-disable-line no-mixed-spaces-and-tabs&#13;
		  "",  "+",  "-",  "*",  "/",  "^",  "=", "&lt;&gt;", // eslint-disable-line no-mixed-spaces-and-tabs&#13;
		"&lt;=", "&gt;=",  "&lt;",  "&gt;",   "",   "",   "",   "", // eslint-disable-line no-mixed-spaces-and-tabs&#13;
		 "&amp;",   "",   "",   "",   "",   "",   "",   ""  // eslint-disable-line no-mixed-spaces-and-tabs&#13;
	];&#13;
&#13;
	function wk1_fmla_to_csf(blob, o) {&#13;
		prep_blob(blob, 0);&#13;
		var out = [], argc = 0, R = "", C = "", argL = "", argR = "";&#13;
		while(blob.l &lt; blob.length) {&#13;
			var cc = blob[blob.l++];&#13;
			switch(cc) {&#13;
				case 0x00: out.push(blob.read_shift(8, 'f')); break;&#13;
				case 0x01: {&#13;
					C = wk1_parse_rc(o[0].c, blob.read_shift(2), true);&#13;
					R = wk1_parse_rc(o[0].r, blob.read_shift(2), false);&#13;
					out.push(C + R);&#13;
				} break;&#13;
				case 0x02: {&#13;
					var c = wk1_parse_rc(o[0].c, blob.read_shift(2), true);&#13;
					var r = wk1_parse_rc(o[0].r, blob.read_shift(2), false);&#13;
					C = wk1_parse_rc(o[0].c, blob.read_shift(2), true);&#13;
					R = wk1_parse_rc(o[0].r, blob.read_shift(2), false);&#13;
					out.push(c + r + ":" + C + R);&#13;
				} break;&#13;
				case 0x03:&#13;
					if(blob.l &lt; blob.length) { console.error("WK1 premature formula end"); return; }&#13;
					break;&#13;
				case 0x04: out.push("(" + out.pop() + ")"); break;&#13;
				case 0x05: out.push(blob.read_shift(2)); break;&#13;
				case 0x06: {&#13;
					/* TODO: text encoding */&#13;
					var Z = ""; while((cc = blob[blob.l++])) Z += String.fromCharCode(cc);&#13;
					out.push('"' + Z.replace(/"/g, '""') + '"');&#13;
				} break;&#13;
&#13;
				case 0x08: out.push("-" + out.pop()); break;&#13;
				case 0x17: out.push("+" + out.pop()); break;&#13;
				case 0x16: out.push("NOT(" + out.pop() + ")"); break;&#13;
&#13;
				case 0x14: case 0x15: {&#13;
					argR = out.pop(); argL = out.pop();&#13;
					out.push(["AND", "OR"][cc - 0x14] + "(" + argL + "," + argR + ")");&#13;
				} break;&#13;
&#13;
				default:&#13;
					if(cc &lt; 0x20 &amp;&amp; BinOpTab[cc]) {&#13;
						argR = out.pop(); argL = out.pop();&#13;
						out.push(argL + BinOpTab[cc] + argR);&#13;
					} else if(FuncTab[cc]) {&#13;
						argc = FuncTab[cc][1];&#13;
						if(argc == 69) argc = blob[blob.l++];&#13;
						if(argc &gt; out.length) { console.error("WK1 bad formula parse 0x" + cc.toString(16) + ":|" + out.join("|") + "|"); return; }&#13;
						var args = out.slice(-argc);&#13;
						out.length -= argc;&#13;
						out.push(FuncTab[cc][0] + "(" + args.join(",") + ")");&#13;
					}&#13;
					else if(cc &lt;= 0x07) return console.error("WK1 invalid opcode " + cc.toString(16));&#13;
					else if(cc &lt;= 0x18) return console.error("WK1 unsupported op " + cc.toString(16));&#13;
					else if(cc &lt;= 0x1E) return console.error("WK1 invalid opcode " + cc.toString(16));&#13;
					else if(cc &lt;= 0x73) return console.error("WK1 unsupported function opcode " + cc.toString(16));&#13;
					// possible future functions ??&#13;
					else return console.error("WK1 unrecognized opcode " + cc.toString(16));&#13;
			}&#13;
		}&#13;
		if(out.length == 1) o[1].f = "" + out[0];&#13;
		else console.error("WK1 bad formula parse |" + out.join("|") + "|");&#13;
	}&#13;
&#13;
&#13;
	function parse_cell_3(blob) {&#13;
		var o = [{c:0,r:0}, {t:'n',v:0}, 0];&#13;
		o[0].r = blob.read_shift(2); o[3] = blob[blob.l++]; o[0].c = blob[blob.l++];&#13;
		return o;&#13;
	}&#13;
&#13;
	function parse_LABEL_16(blob, length) {&#13;
		var o = parse_cell_3(blob, length);&#13;
		o[1].t = 's';&#13;
		o[1].v = blob.read_shift(length - 4, 'cstr');&#13;
		return o;&#13;
	}&#13;
	function write_LABEL_16(R, C, wsidx, s) {&#13;
		/* TODO: encoding */&#13;
		var o = new_buf(6 + s.length);&#13;
		o.write_shift(2, R);&#13;
		o.write_shift(1, wsidx);&#13;
		o.write_shift(1, C);&#13;
		o.write_shift(1, 0x27);&#13;
		for(var i = 0; i &lt; s.length; ++i) {&#13;
			var cc = s.charCodeAt(i);&#13;
			o.write_shift(1, cc &gt;= 0x80 ? 0x5F : cc);&#13;
		}&#13;
		o.write_shift(1, 0);&#13;
		return o;&#13;
	}&#13;
&#13;
	function parse_NUMBER_18(blob, length) {&#13;
		var o = parse_cell_3(blob, length);&#13;
		o[1].v = blob.read_shift(2);&#13;
		var v = o[1].v &gt;&gt; 1;&#13;
		if(o[1].v &amp; 0x1) {&#13;
			switch(v &amp; 0x07) {&#13;
				case 0: v = (v &gt;&gt; 3) * 5000; break;&#13;
				case 1: v = (v &gt;&gt; 3) * 500; break;&#13;
				case 2: v = (v &gt;&gt; 3) / 20; break;&#13;
				case 3: v = (v &gt;&gt; 3) / 200; break;&#13;
				case 4: v = (v &gt;&gt; 3) / 2000; break;&#13;
				case 5: v = (v &gt;&gt; 3) / 20000; break;&#13;
				case 6: v = (v &gt;&gt; 3) / 16; break;&#13;
				case 7: v = (v &gt;&gt; 3) / 64; break;&#13;
			}&#13;
		}&#13;
		o[1].v = v;&#13;
		return o;&#13;
	}&#13;
&#13;
	function parse_NUMBER_17(blob, length) {&#13;
		var o = parse_cell_3(blob, length);&#13;
		var v1 = blob.read_shift(4);&#13;
		var v2 = blob.read_shift(4);&#13;
		var e = blob.read_shift(2);&#13;
		if(e == 0xFFFF) {&#13;
			if(v1 === 0 &amp;&amp; v2 === 0xC0000000) { o[1].t = "e"; o[1].v = 0x0F; } // ERR -&gt; #VALUE!&#13;
			else if(v1 === 0 &amp;&amp; v2 === 0xD0000000) { o[1].t = "e"; o[1].v = 0x2A; } // NA -&gt; #N/A&#13;
			else o[1].v = 0;&#13;
			return o;&#13;
		}&#13;
		var s = e &amp; 0x8000; e = (e&amp;0x7FFF) - 16446;&#13;
		o[1].v = (1 - s*2) * (v2 * Math.pow(2, e+32) + v1 * Math.pow(2, e));&#13;
		return o;&#13;
	}&#13;
	function write_NUMBER_17(R, C, wsidx, v) {&#13;
		var o = new_buf(14);&#13;
		o.write_shift(2, R);&#13;
		o.write_shift(1, wsidx);&#13;
		o.write_shift(1, C);&#13;
		if(v == 0) {&#13;
			o.write_shift(4, 0);&#13;
			o.write_shift(4, 0);&#13;
			o.write_shift(2, 0xFFFF);&#13;
			return o;&#13;
		}&#13;
		var s = 0, e = 0, v1 = 0, v2 = 0;&#13;
		if(v &lt; 0) { s = 1; v = -v; }&#13;
		e = Math.log2(v) | 0;&#13;
		v /= Math.pow(2, e-31);&#13;
		v2 = (v)&gt;&gt;&gt;0;&#13;
		if((v2&amp;0x80000000) == 0) { v/=2; ++e; v2 = v &gt;&gt;&gt; 0; }&#13;
		v -= v2;&#13;
		v2 |= 0x80000000;&#13;
		v2 &gt;&gt;&gt;= 0;&#13;
		v *= Math.pow(2, 32);&#13;
		v1 = v&gt;&gt;&gt;0;&#13;
		o.write_shift(4, v1);&#13;
		o.write_shift(4, v2);&#13;
		e += 0x3FFF + (s ? 0x8000 : 0);&#13;
		o.write_shift(2, e);&#13;
		return o;&#13;
	}&#13;
&#13;
	function parse_FORMULA_19(blob, length) {&#13;
		var o = parse_NUMBER_17(blob, 14);&#13;
		blob.l += length - 14; /* TODO: WK3 formula */&#13;
		return o;&#13;
	}&#13;
&#13;
	function parse_NUMBER_25(blob, length) {&#13;
		var o = parse_cell_3(blob, length);&#13;
		var v1 = blob.read_shift(4);&#13;
		o[1].v = v1 &gt;&gt; 6;&#13;
		return o;&#13;
	}&#13;
&#13;
	function parse_NUMBER_27(blob, length) {&#13;
		var o = parse_cell_3(blob, length);&#13;
		var v1 = blob.read_shift(8,'f');&#13;
		o[1].v = v1;&#13;
		return o;&#13;
	}&#13;
&#13;
	function parse_FORMULA_28(blob, length) {&#13;
		var o = parse_NUMBER_27(blob, 12);&#13;
		blob.l += length - 12; /* TODO: formula */&#13;
		return o;&#13;
	}&#13;
&#13;
	function parse_SHEETNAMECS(blob, length) {&#13;
		return blob[blob.l + length - 1] == 0 ? blob.read_shift(length, 'cstr') : "";&#13;
	}&#13;
&#13;
	function parse_SHEETNAMELP(blob, length) {&#13;
		var len = blob[blob.l++];&#13;
		if(len &gt; length - 1) len = length - 1;&#13;
		var o = ""; while(o.length &lt; len) o += String.fromCharCode(blob[blob.l++]);&#13;
		return o;&#13;
	}&#13;
&#13;
	function parse_SHEETINFOQP(blob, length, opts) {&#13;
		if(!opts.qpro || length &lt; 21) return;&#13;
		var id = blob.read_shift(1);&#13;
		blob.l += 17;&#13;
		blob.l += 1; //var len = blob.read_shift(1);&#13;
		blob.l += 2;&#13;
		var nm = blob.read_shift(length - 21, 'cstr');&#13;
		return [id, nm];&#13;
	}&#13;
&#13;
	function parse_XFORMAT(blob, length) {&#13;
		var o = {}, tgt = blob.l + length;&#13;
		while(blob.l &lt; tgt) {&#13;
			var dt = blob.read_shift(2);&#13;
			if(dt == 0x36b0) {&#13;
				o[dt] = [0, ""];&#13;
				o[dt][0] = blob.read_shift(2);&#13;
				while(blob[blob.l]) { o[dt][1] += String.fromCharCode(blob[blob.l]); blob.l++; } blob.l++;&#13;
			}&#13;
			// TODO: 0x3a99 ??&#13;
		}&#13;
		return o;&#13;
	}&#13;
	function write_XFORMAT_SHEETNAME(name, wsidx) {&#13;
		var out = new_buf(5 + name.length);&#13;
		out.write_shift(2, 0x36b0);&#13;
		out.write_shift(2, wsidx);&#13;
		for(var i = 0; i &lt; name.length; ++i) {&#13;
			var cc = name.charCodeAt(i);&#13;
			out[out.l++] = cc &gt; 0x7F ? 0x5F : cc;&#13;
		}&#13;
		out[out.l++] = 0;&#13;
		return out;&#13;
	}&#13;
&#13;
	var WK1Enum = {&#13;
0x0000: { n:"BOF", f:parseuint16 },&#13;
0x0001: { n:"EOF" },&#13;
0x0002: { n:"CALCMODE" },&#13;
0x0003: { n:"CALCORDER" },&#13;
0x0004: { n:"SPLIT" },&#13;
0x0005: { n:"SYNC" },&#13;
0x0006: { n:"RANGE", f:parse_RANGE },&#13;
0x0007: { n:"WINDOW1" },&#13;
0x0008: { n:"COLW1" },&#13;
0x0009: { n:"WINTWO" },&#13;
0x000A: { n:"COLW2" },&#13;
0x000B: { n:"NAME" },&#13;
0x000C: { n:"BLANK" },&#13;
0x000D: { n:"INTEGER", f:parse_INTEGER },&#13;
0x000E: { n:"NUMBER", f:parse_NUMBER },&#13;
0x000F: { n:"LABEL", f:parse_LABEL },&#13;
0x0010: { n:"FORMULA", f:parse_FORMULA },&#13;
0x0018: { n:"TABLE" },&#13;
0x0019: { n:"ORANGE" },&#13;
0x001A: { n:"PRANGE" },&#13;
0x001B: { n:"SRANGE" },&#13;
0x001C: { n:"FRANGE" },&#13;
0x001D: { n:"KRANGE1" },&#13;
0x0020: { n:"HRANGE" },&#13;
0x0023: { n:"KRANGE2" },&#13;
0x0024: { n:"PROTEC" },&#13;
0x0025: { n:"FOOTER" },&#13;
0x0026: { n:"HEADER" },&#13;
0x0027: { n:"SETUP" },&#13;
0x0028: { n:"MARGINS" },&#13;
0x0029: { n:"LABELFMT" },&#13;
0x002A: { n:"TITLES" },&#13;
0x002B: { n:"SHEETJS" },&#13;
0x002D: { n:"GRAPH" },&#13;
0x002E: { n:"NGRAPH" },&#13;
0x002F: { n:"CALCCOUNT" },&#13;
0x0030: { n:"UNFORMATTED" },&#13;
0x0031: { n:"CURSORW12" },&#13;
0x0032: { n:"WINDOW" },&#13;
0x0033: { n:"STRING", f:parse_STRING },&#13;
0x0037: { n:"PASSWORD" },&#13;
0x0038: { n:"LOCKED" },&#13;
0x003C: { n:"QUERY" },&#13;
0x003D: { n:"QUERYNAME" },&#13;
0x003E: { n:"PRINT" },&#13;
0x003F: { n:"PRINTNAME" },&#13;
0x0040: { n:"GRAPH2" },&#13;
0x0041: { n:"GRAPHNAME" },&#13;
0x0042: { n:"ZOOM" },&#13;
0x0043: { n:"SYMSPLIT" },&#13;
0x0044: { n:"NSROWS" },&#13;
0x0045: { n:"NSCOLS" },&#13;
0x0046: { n:"RULER" },&#13;
0x0047: { n:"NNAME" },&#13;
0x0048: { n:"ACOMM" },&#13;
0x0049: { n:"AMACRO" },&#13;
0x004A: { n:"PARSE" },&#13;
0x0066: { n:"PRANGES??" },&#13;
0x0067: { n:"RRANGES??" },&#13;
0x0068: { n:"FNAME??" },&#13;
0x0069: { n:"MRANGES??" },&#13;
0x00CC: { n:"SHEETNAMECS", f:parse_SHEETNAMECS },&#13;
0x00DE: { n:"SHEETNAMELP", f:parse_SHEETNAMELP },&#13;
0x00FF: { n:"BOF", f:parseuint16 },&#13;
0xFFFF: { n:"" }&#13;
	};&#13;
&#13;
	var WK3Enum = {&#13;
0x0000: { n:"BOF" },&#13;
0x0001: { n:"EOF" },&#13;
0x0002: { n:"PASSWORD" },&#13;
0x0003: { n:"CALCSET" },&#13;
0x0004: { n:"WINDOWSET" },&#13;
0x0005: { n:"SHEETCELLPTR" },&#13;
0x0006: { n:"SHEETLAYOUT" },&#13;
0x0007: { n:"COLUMNWIDTH" },&#13;
0x0008: { n:"HIDDENCOLUMN" },&#13;
0x0009: { n:"USERRANGE" },&#13;
0x000A: { n:"SYSTEMRANGE" },&#13;
0x000B: { n:"ZEROFORCE" },&#13;
0x000C: { n:"SORTKEYDIR" },&#13;
0x000D: { n:"FILESEAL" },&#13;
0x000E: { n:"DATAFILLNUMS" },&#13;
0x000F: { n:"PRINTMAIN" },&#13;
0x0010: { n:"PRINTSTRING" },&#13;
0x0011: { n:"GRAPHMAIN" },&#13;
0x0012: { n:"GRAPHSTRING" },&#13;
0x0013: { n:"??" },&#13;
0x0014: { n:"ERRCELL" },&#13;
0x0015: { n:"NACELL" },&#13;
0x0016: { n:"LABEL16", f:parse_LABEL_16},&#13;
0x0017: { n:"NUMBER17", f:parse_NUMBER_17 },&#13;
0x0018: { n:"NUMBER18", f:parse_NUMBER_18 },&#13;
0x0019: { n:"FORMULA19", f:parse_FORMULA_19},&#13;
0x001A: { n:"FORMULA1A" },&#13;
0x001B: { n:"XFORMAT", f:parse_XFORMAT },&#13;
0x001C: { n:"DTLABELMISC" },&#13;
0x001D: { n:"DTLABELCELL" },&#13;
0x001E: { n:"GRAPHWINDOW" },&#13;
0x001F: { n:"CPA" },&#13;
0x0020: { n:"LPLAUTO" },&#13;
0x0021: { n:"QUERY" },&#13;
0x0022: { n:"HIDDENSHEET" },&#13;
0x0023: { n:"??" },&#13;
0x0025: { n:"NUMBER25", f:parse_NUMBER_25 },&#13;
0x0026: { n:"??" },&#13;
0x0027: { n:"NUMBER27", f:parse_NUMBER_27 },&#13;
0x0028: { n:"FORMULA28", f:parse_FORMULA_28 },&#13;
0x008E: { n:"??" },&#13;
0x0093: { n:"??" },&#13;
0x0096: { n:"??" },&#13;
0x0097: { n:"??" },&#13;
0x0098: { n:"??" },&#13;
0x0099: { n:"??" },&#13;
0x009A: { n:"??" },&#13;
0x009B: { n:"??" },&#13;
0x009C: { n:"??" },&#13;
0x00A3: { n:"??" },&#13;
0x00AE: { n:"??" },&#13;
0x00AF: { n:"??" },&#13;
0x00B0: { n:"??" },&#13;
0x00B1: { n:"??" },&#13;
0x00B8: { n:"??" },&#13;
0x00B9: { n:"??" },&#13;
0x00BA: { n:"??" },&#13;
0x00BB: { n:"??" },&#13;
0x00BC: { n:"??" },&#13;
0x00C3: { n:"??" },&#13;
0x00C9: { n:"??" },&#13;
0x00CC: { n:"SHEETNAMECS", f:parse_SHEETNAMECS },&#13;
0x00CD: { n:"??" },&#13;
0x00CE: { n:"??" },&#13;
0x00CF: { n:"??" },&#13;
0x00D0: { n:"??" },&#13;
0x0100: { n:"??" },&#13;
0x0103: { n:"??" },&#13;
0x0104: { n:"??" },&#13;
0x0105: { n:"??" },&#13;
0x0106: { n:"??" },&#13;
0x0107: { n:"??" },&#13;
0x0109: { n:"??" },&#13;
0x010A: { n:"??" },&#13;
0x010B: { n:"??" },&#13;
0x010C: { n:"??" },&#13;
0x010E: { n:"??" },&#13;
0x010F: { n:"??" },&#13;
0x0180: { n:"??" },&#13;
0x0185: { n:"??" },&#13;
0x0186: { n:"??" },&#13;
0x0189: { n:"??" },&#13;
0x018C: { n:"??" },&#13;
0x0200: { n:"??" },&#13;
0x0202: { n:"??" },&#13;
0x0201: { n:"??" },&#13;
0x0204: { n:"??" },&#13;
0x0205: { n:"??" },&#13;
0x0280: { n:"??" },&#13;
0x0281: { n:"??" },&#13;
0x0282: { n:"??" },&#13;
0x0283: { n:"??" },&#13;
0x0284: { n:"??" },&#13;
0x0285: { n:"??" },&#13;
0x0286: { n:"??" },&#13;
0x0287: { n:"??" },&#13;
0x0288: { n:"??" },&#13;
0x0292: { n:"??" },&#13;
0x0293: { n:"??" },&#13;
0x0294: { n:"??" },&#13;
0x0295: { n:"??" },&#13;
0x0296: { n:"??" },&#13;
0x0299: { n:"??" },&#13;
0x029A: { n:"??" },&#13;
0x0300: { n:"??" },&#13;
0x0304: { n:"??" },&#13;
0x0601: { n:"SHEETINFOQP", f:parse_SHEETINFOQP },&#13;
0x0640: { n:"??" },&#13;
0x0642: { n:"??" },&#13;
0x0701: { n:"??" },&#13;
0x0702: { n:"??" },&#13;
0x0703: { n:"??" },&#13;
0x0704: { n:"??" },&#13;
0x0780: { n:"??" },&#13;
0x0800: { n:"??" },&#13;
0x0801: { n:"??" },&#13;
0x0804: { n:"??" },&#13;
0x0A80: { n:"??" },&#13;
0x2AF6: { n:"??" },&#13;
0x3231: { n:"??" },&#13;
0x6E49: { n:"??" },&#13;
0x6F44: { n:"??" },&#13;
0xFFFF: { n:"" }&#13;
	};&#13;
&#13;
	/* QPW uses a different set of record types */&#13;
	function qpw_to_workbook_buf(d, opts) {&#13;
		prep_blob(d, 0);&#13;
		var o = opts || {};&#13;
		if(DENSE != null &amp;&amp; o.dense == null) o.dense = DENSE;&#13;
		var s = ((o.dense ? [] : {}));&#13;
		var SST = [], sname = "", formulae = [];&#13;
		var range = {s:{r:-1,c:-1}, e:{r:-1,c:-1}};&#13;
		var cnt = 0, type = 0, C = 0, R = 0;&#13;
		var wb = { SheetNames: [], Sheets: {} };&#13;
		outer: while(d.l &lt; d.length) {&#13;
			var RT = d.read_shift(2), length = d.read_shift(2);&#13;
			var p = d.slice(d.l, d.l + length);&#13;
			prep_blob(p, 0);&#13;
			switch(RT) {&#13;
				case 0x01: /* BOF */&#13;
					if(p.read_shift(4) != 0x39575051) throw "Bad QPW9 BOF!";&#13;
					break;&#13;
				case 0x02: /* EOF */ break outer;&#13;
&#13;
				/* TODO: The behavior here should be consistent with Numbers: QP Notebook ~ .TN.SheetArchive, QP Sheet ~ .TST.TableModelArchive */&#13;
				case 0x0401: /* BON */ break;&#13;
				case 0x0402: /* EON */ /* TODO: backfill missing sheets based on BON cnt */ break;&#13;
&#13;
				case 0x0407: { /* SST */&#13;
					p.l += 12;&#13;
					while(p.l &lt; p.length) {&#13;
						cnt = p.read_shift(2);&#13;
						type = p.read_shift(1);&#13;
						SST.push(p.read_shift(cnt, 'cstr'));&#13;
					}&#13;
				} break;&#13;
				case 0x0408: { /* FORMULAE */&#13;
					//p.l += 12;&#13;
					//while(p.l &lt; p.length) {&#13;
					//	cnt = p.read_shift(2);&#13;
					//	formulae.push(p.slice(p.l, p.l + cnt + 1)); p.l += cnt + 1;&#13;
					//}&#13;
				} break;&#13;
&#13;
				case 0x0601: { /* BOS */&#13;
					var sidx = p.read_shift(2);&#13;
					s = ((o.dense ? [] : {}));&#13;
					range.s.c = p.read_shift(2);&#13;
					range.e.c = p.read_shift(2);&#13;
					range.s.r = p.read_shift(4);&#13;
					range.e.r = p.read_shift(4);&#13;
					p.l += 4;&#13;
					if(p.l + 2 &lt; p.length) {&#13;
						cnt = p.read_shift(2);&#13;
						type = p.read_shift(1);&#13;
						sname = cnt == 0 ? "" : p.read_shift(cnt, 'cstr');&#13;
					}&#13;
					if(!sname) sname = encode_col(sidx);&#13;
					/* TODO: backfill empty sheets */&#13;
				} break;&#13;
				case 0x0602: { /* EOS */&#13;
					/* NOTE: QP valid range A1:IV1000000 */&#13;
					if(range.s.c &gt; 0xFF || range.s.r &gt; 999999) break;&#13;
					if(range.e.c &lt; range.s.c) range.e.c = range.s.c;&#13;
					if(range.e.r &lt; range.s.r) range.e.r = range.s.r;&#13;
					s["!ref"] = encode_range(range);&#13;
					book_append_sheet(wb, s, sname); // TODO: a barrel roll&#13;
				} break;&#13;
&#13;
				case 0x0A01: { /* COL (like XLS Row, modulo the layout transposition) */&#13;
					C = p.read_shift(2);&#13;
					if(range.e.c &lt; C) range.e.c = C;&#13;
					if(range.s.c &gt; C) range.s.c = C;&#13;
					R = p.read_shift(4);&#13;
					if(range.s.r &gt; R) range.s.r = R;&#13;
					R = p.read_shift(4);&#13;
					if(range.e.r &lt; R) range.e.r = R;&#13;
				} break;&#13;
&#13;
				case 0x0C01: { /* MulCells (like XLS MulRK, but takes advantage of common column data patterns) */&#13;
					R = p.read_shift(4), cnt = p.read_shift(4);&#13;
					if(range.s.r &gt; R) range.s.r = R;&#13;
					if(range.e.r &lt; R + cnt - 1) range.e.r = R + cnt - 1;&#13;
					while(p.l &lt; p.length) {&#13;
						var cell = { t: "z" };&#13;
						var flags = p.read_shift(1);&#13;
						if(flags &amp; 0x80) p.l += 2;&#13;
						var mul = (flags &amp; 0x40) ? p.read_shift(2) - 1: 0;&#13;
						switch(flags &amp; 0x1F) {&#13;
							case 1: break;&#13;
							case 2: cell = { t: "n", v: p.read_shift(2) }; break;&#13;
							case 3: cell = { t: "n", v: p.read_shift(2, 'i') }; break;&#13;
							case 5: cell = { t: "n", v: p.read_shift(8, 'f') }; break;&#13;
							case 7: cell = { t: "s", v: SST[type = p.read_shift(4) - 1] }; break;&#13;
							case 8: cell = { t: "n", v: p.read_shift(8, 'f') }; p.l += 2; /* cell.f = formulae[p.read_shift(4)]; */ p.l += 4; break;&#13;
							default: throw "Unrecognized QPW cell type " + (flags &amp; 0x1F);&#13;
						}&#13;
						var delta = 0;&#13;
						if(flags &amp; 0x20) switch(flags &amp; 0x1F) {&#13;
							case 2: delta = p.read_shift(2); break;&#13;
							case 3: delta = p.read_shift(2, 'i'); break;&#13;
							case 7: delta = p.read_shift(2); break;&#13;
							default: throw "Unsupported delta for QPW cell type " + (flags &amp; 0x1F);&#13;
						}&#13;
						if(!(!o.sheetStubs &amp;&amp; cell.t == "z")) {&#13;
							if(Array.isArray(s)) {&#13;
								if(!s[R]) s[R] = [];&#13;
								s[R][C] = cell;&#13;
							} else s[encode_cell({r:R, c:C})] = cell;&#13;
						}&#13;
						++R; --cnt;&#13;
						while(mul-- &gt; 0 &amp;&amp; cnt &gt;= 0) {&#13;
							if(flags &amp; 0x20) switch(flags &amp; 0x1F) {&#13;
								case 2: cell = { t: "n", v: (cell.v + delta) &amp; 0xFFFF }; break;&#13;
								case 3: cell = { t: "n", v: (cell.v + delta) &amp; 0xFFFF }; if(cell.v &gt; 0x7FFF) cell.v -= 0x10000; break;&#13;
								case 7: cell = { t: "s", v: SST[type = (type + delta) &gt;&gt;&gt; 0] }; break;&#13;
								default: throw "Cannot apply delta for QPW cell type " + (flags &amp; 0x1F);&#13;
							} else switch(flags &amp; 0x1F) {&#13;
								case 1: cell = { t: "z" }; break;&#13;
								case 2: cell = { t: "n", v: p.read_shift(2) }; break;&#13;
								case 7: cell = { t: "s", v: SST[type = p.read_shift(4) - 1] }; break;&#13;
								default: throw "Cannot apply repeat for QPW cell type " + (flags &amp; 0x1F);&#13;
							}&#13;
							if(!(!o.sheetStubs &amp;&amp; cell.t == "z")) {&#13;
								if(Array.isArray(s)) {&#13;
									if(!s[R]) s[R] = [];&#13;
									s[R][C] = cell;&#13;
								} else s[encode_cell({r:R, c:C})] = cell;&#13;
							}&#13;
							++R; --cnt;&#13;
						}&#13;
					}&#13;
				} break;&#13;
&#13;
				default: break;&#13;
			}&#13;
			d.l += length;&#13;
		}&#13;
		return wb;&#13;
	}&#13;
&#13;
	return {&#13;
		sheet_to_wk1: sheet_to_wk1,&#13;
		book_to_wk3: book_to_wk3,&#13;
		to_workbook: lotus_to_workbook&#13;
	};&#13;
})();&#13;
/* 18.4.7 rPr CT_RPrElt */&#13;
function parse_rpr(rpr) {&#13;
	var font = {}, m = rpr.match(tagregex), i = 0;&#13;
	var pass = false;&#13;
	if(m) for(;i!=m.length; ++i) {&#13;
		var y = parsexmltag(m[i]);&#13;
		switch(y[0].replace(/\w*:/g,"")) {&#13;
			/* 18.8.12 condense CT_BooleanProperty */&#13;
			/* ** not required . */&#13;
			case '&lt;condense': break;&#13;
			/* 18.8.17 extend CT_BooleanProperty */&#13;
			/* ** not required . */&#13;
			case '&lt;extend': break;&#13;
			/* 18.8.36 shadow CT_BooleanProperty */&#13;
			/* ** not required . */&#13;
			case '&lt;shadow':&#13;
				if(!y.val) break;&#13;
				/* falls through */&#13;
			case '&lt;shadow&gt;':&#13;
			case '&lt;shadow/&gt;': font.shadow = 1; break;&#13;
			case '&lt;/shadow&gt;': break;&#13;
&#13;
			/* 18.4.1 charset CT_IntProperty TODO */&#13;
			case '&lt;charset':&#13;
				if(y.val == '1') break;&#13;
				font.cp = CS2CP[parseInt(y.val, 10)];&#13;
				break;&#13;
&#13;
			/* 18.4.2 outline CT_BooleanProperty TODO */&#13;
			case '&lt;outline':&#13;
				if(!y.val) break;&#13;
				/* falls through */&#13;
			case '&lt;outline&gt;':&#13;
			case '&lt;outline/&gt;': font.outline = 1; break;&#13;
			case '&lt;/outline&gt;': break;&#13;
&#13;
			/* 18.4.5 rFont CT_FontName */&#13;
			case '&lt;rFont': font.name = y.val; break;&#13;
&#13;
			/* 18.4.11 sz CT_FontSize */&#13;
			case '&lt;sz': font.sz = y.val; break;&#13;
&#13;
			/* 18.4.10 strike CT_BooleanProperty */&#13;
			case '&lt;strike':&#13;
				if(!y.val) break;&#13;
				/* falls through */&#13;
			case '&lt;strike&gt;':&#13;
			case '&lt;strike/&gt;': font.strike = 1; break;&#13;
			case '&lt;/strike&gt;': break;&#13;
&#13;
			/* 18.4.13 u CT_UnderlineProperty */&#13;
			case '&lt;u':&#13;
				if(!y.val) break;&#13;
				switch(y.val) {&#13;
					case 'double': font.uval = "double"; break;&#13;
					case 'singleAccounting': font.uval = "single-accounting"; break;&#13;
					case 'doubleAccounting': font.uval = "double-accounting"; break;&#13;
				}&#13;
				/* falls through */&#13;
			case '&lt;u&gt;':&#13;
			case '&lt;u/&gt;': font.u = 1; break;&#13;
			case '&lt;/u&gt;': break;&#13;
&#13;
			/* 18.8.2 b */&#13;
			case '&lt;b':&#13;
				if(y.val == '0') break;&#13;
				/* falls through */&#13;
			case '&lt;b&gt;':&#13;
			case '&lt;b/&gt;': font.b = 1; break;&#13;
			case '&lt;/b&gt;': break;&#13;
&#13;
			/* 18.8.26 i */&#13;
			case '&lt;i':&#13;
				if(y.val == '0') break;&#13;
				/* falls through */&#13;
			case '&lt;i&gt;':&#13;
			case '&lt;i/&gt;': font.i = 1; break;&#13;
			case '&lt;/i&gt;': break;&#13;
&#13;
			/* 18.3.1.15 color CT_Color TODO: tint, theme, auto, indexed */&#13;
			case '&lt;color':&#13;
				if(y.rgb) font.color = y.rgb.slice(2,8);&#13;
				break;&#13;
			case '&lt;color&gt;': case '&lt;color/&gt;': case '&lt;/color&gt;': break;&#13;
&#13;
			/* 18.8.18 family ST_FontFamily */&#13;
			case '&lt;family': font.family = y.val; break;&#13;
			case '&lt;family&gt;': case '&lt;family/&gt;': case '&lt;/family&gt;': break;&#13;
&#13;
			/* 18.4.14 vertAlign CT_VerticalAlignFontProperty TODO */&#13;
			case '&lt;vertAlign': font.valign = y.val; break;&#13;
			case '&lt;vertAlign&gt;': case '&lt;vertAlign/&gt;': case '&lt;/vertAlign&gt;': break;&#13;
&#13;
			/* 18.8.35 scheme CT_FontScheme TODO */&#13;
			case '&lt;scheme': break;&#13;
			case '&lt;scheme&gt;': case '&lt;scheme/&gt;': case '&lt;/scheme&gt;': break;&#13;
&#13;
			/* 18.2.10 extLst CT_ExtensionList ? */&#13;
			case '&lt;extLst': case '&lt;extLst&gt;': case '&lt;/extLst&gt;': break;&#13;
			case '&lt;ext': pass = true; break;&#13;
			case '&lt;/ext&gt;': pass = false; break;&#13;
			default:&#13;
				if(y[0].charCodeAt(1) !== 47 &amp;&amp; !pass) throw new Error('Unrecognized rich format ' + y[0]);&#13;
		}&#13;
	}&#13;
	return font;&#13;
}&#13;
&#13;
var parse_rs = (function() {&#13;
	var tregex = matchtag("t"), rpregex = matchtag("rPr");&#13;
	/* 18.4.4 r CT_RElt */&#13;
	function parse_r(r) {&#13;
		/* 18.4.12 t ST_Xstring */&#13;
		var t = r.match(tregex)/*, cp = 65001*/;&#13;
		if(!t) return {t:"s", v:""};&#13;
&#13;
		var o = ({t:'s', v:unescapexml(t[1])});&#13;
		var rpr = r.match(rpregex);&#13;
		if(rpr) o.s = parse_rpr(rpr[1]);&#13;
		return o;&#13;
	}&#13;
	var rregex = /&lt;(?:\w+:)?r&gt;/g, rend = /&lt;\/(?:\w+:)?r&gt;/;&#13;
	return function parse_rs(rs) {&#13;
		return rs.replace(rregex,"").split(rend).map(parse_r).filter(function(r) { return r.v; });&#13;
	};&#13;
})();&#13;
&#13;
&#13;
/* Parse a list of &lt;r&gt; tags */&#13;
var rs_to_html = (function parse_rs_factory() {&#13;
	var nlregex = /(\r\n|\n)/g;&#13;
	function parse_rpr2(font, intro, outro) {&#13;
		var style = [];&#13;
&#13;
		if(font.u) style.push("text-decoration: underline;");&#13;
		if(font.uval) style.push("text-underline-style:" + font.uval + ";");&#13;
		if(font.sz) style.push("font-size:" + font.sz + "pt;");&#13;
		if(font.outline) style.push("text-effect: outline;");&#13;
		if(font.shadow) style.push("text-shadow: auto;");&#13;
		intro.push('&lt;span style="' + style.join("") + '"&gt;');&#13;
&#13;
		if(font.b) { intro.push("&lt;b&gt;"); outro.push("&lt;/b&gt;"); }&#13;
		if(font.i) { intro.push("&lt;i&gt;"); outro.push("&lt;/i&gt;"); }&#13;
		if(font.strike) { intro.push("&lt;s&gt;"); outro.push("&lt;/s&gt;"); }&#13;
&#13;
		var align = font.valign || "";&#13;
		if(align == "superscript" || align == "super") align = "sup";&#13;
		else if(align == "subscript") align = "sub";&#13;
		if(align != "") { intro.push("&lt;" + align + "&gt;"); outro.push("&lt;/" + align + "&gt;"); }&#13;
&#13;
		outro.push("&lt;/span&gt;");&#13;
		return font;&#13;
	}&#13;
&#13;
	/* 18.4.4 r CT_RElt */&#13;
	function r_to_html(r) {&#13;
		var terms = [[],r.v,[]];&#13;
		if(!r.v) return "";&#13;
&#13;
		if(r.s) parse_rpr2(r.s, terms[0], terms[2]);&#13;
&#13;
		return terms[0].join("") + terms[1].replace(nlregex,'&lt;br/&gt;') + terms[2].join("");&#13;
	}&#13;
&#13;
	return function parse_rs(rs) {&#13;
		return rs.map(r_to_html).join("");&#13;
	};&#13;
})();&#13;
&#13;
/* 18.4.8 si CT_Rst */&#13;
var sitregex = /&lt;(?:\w+:)?t[^&gt;]*&gt;([^&lt;]*)&lt;\/(?:\w+:)?t&gt;/g, sirregex = /&lt;(?:\w+:)?r&gt;/;&#13;
var sirphregex = /&lt;(?:\w+:)?rPh.*?&gt;([\s\S]*?)&lt;\/(?:\w+:)?rPh&gt;/g;&#13;
function parse_si(x, opts) {&#13;
	var html = opts ? opts.cellHTML : true;&#13;
	var z = {};&#13;
	if(!x) return { t: "" };&#13;
	//var y;&#13;
	/* 18.4.12 t ST_Xstring (Plaintext String) */&#13;
	// TODO: is whitespace actually valid here?&#13;
	if(x.match(/^\s*&lt;(?:\w+:)?t[^&gt;]*&gt;/)) {&#13;
		z.t = unescapexml(utf8read(x.slice(x.indexOf("&gt;")+1).split(/&lt;\/(?:\w+:)?t&gt;/)[0]||""), true);&#13;
		z.r = utf8read(x);&#13;
		if(html) z.h = escapehtml(z.t);&#13;
	}&#13;
	/* 18.4.4 r CT_RElt (Rich Text Run) */&#13;
	else if((/*y = */x.match(sirregex))) {&#13;
		z.r = utf8read(x);&#13;
		z.t = unescapexml(utf8read((x.replace(sirphregex, '').match(sitregex)||[]).join("").replace(tagregex,"")), true);&#13;
		if(html) z.h = rs_to_html(parse_rs(z.r));&#13;
	}&#13;
	/* 18.4.3 phoneticPr CT_PhoneticPr (TODO: needed for Asian support) */&#13;
	/* 18.4.6 rPh CT_PhoneticRun (TODO: needed for Asian support) */&#13;
	return z;&#13;
}&#13;
&#13;
/* 18.4 Shared String Table */&#13;
var sstr0 = /&lt;(?:\w+:)?sst([^&gt;]*)&gt;([\s\S]*)&lt;\/(?:\w+:)?sst&gt;/;&#13;
var sstr1 = /&lt;(?:\w+:)?(?:si|sstItem)&gt;/g;&#13;
var sstr2 = /&lt;\/(?:\w+:)?(?:si|sstItem)&gt;/;&#13;
function parse_sst_xml(data, opts) {&#13;
	var s = ([]), ss = "";&#13;
	if(!data) return s;&#13;
	/* 18.4.9 sst CT_Sst */&#13;
	var sst = data.match(sstr0);&#13;
	if(sst) {&#13;
		ss = sst[2].replace(sstr1,"").split(sstr2);&#13;
		for(var i = 0; i != ss.length; ++i) {&#13;
			var o = parse_si(ss[i].trim(), opts);&#13;
			if(o != null) s[s.length] = o;&#13;
		}&#13;
		sst = parsexmltag(sst[1]); s.Count = sst.count; s.Unique = sst.uniqueCount;&#13;
	}&#13;
	return s;&#13;
}&#13;
&#13;
var straywsregex = /^\s|\s$|[\t\n\r]/;&#13;
function write_sst_xml(sst, opts) {&#13;
	if(!opts.bookSST) return "";&#13;
	var o = [XML_HEADER];&#13;
	o[o.length] = (writextag('sst', null, {&#13;
		xmlns: XMLNS_main[0],&#13;
		count: sst.Count,&#13;
		uniqueCount: sst.Unique&#13;
	}));&#13;
	for(var i = 0; i != sst.length; ++i) { if(sst[i] == null) continue;&#13;
		var s = sst[i];&#13;
		var sitag = "&lt;si&gt;";&#13;
		if(s.r) sitag += s.r;&#13;
		else {&#13;
			sitag += "&lt;t";&#13;
			if(!s.t) s.t = "";&#13;
			if(typeof s.t !== "string") s.t = String(s.t);&#13;
			if(s.t.match(straywsregex)) sitag += ' xml:space="preserve"';&#13;
			sitag += "&gt;" + escapexml(s.t) + "&lt;/t&gt;";&#13;
		}&#13;
		sitag += "&lt;/si&gt;";&#13;
		o[o.length] = (sitag);&#13;
	}&#13;
	if(o.length&gt;2){ o[o.length] = ('&lt;/sst&gt;'); o[1]=o[1].replace("/&gt;","&gt;"); }&#13;
	return o.join("");&#13;
}&#13;
/* [MS-XLSB] 2.4.221 BrtBeginSst */&#13;
function parse_BrtBeginSst(data) {&#13;
	return [data.read_shift(4), data.read_shift(4)];&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.1.7.45 Shared Strings */&#13;
function parse_sst_bin(data, opts) {&#13;
	var s = ([]);&#13;
	var pass = false;&#13;
	recordhopper(data, function hopper_sst(val, R, RT) {&#13;
		switch(RT) {&#13;
			case 0x009F: /* BrtBeginSst */&#13;
				s.Count = val[0]; s.Unique = val[1]; break;&#13;
			case 0x0013: /* BrtSSTItem */&#13;
				s.push(val); break;&#13;
			case 0x00A0: /* BrtEndSst */&#13;
				return true;&#13;
&#13;
			case 0x0023: /* BrtFRTBegin */&#13;
				pass = true; break;&#13;
			case 0x0024: /* BrtFRTEnd */&#13;
				pass = false; break;&#13;
&#13;
			default:&#13;
				if(R.T){}&#13;
				if(!pass || opts.WTF) throw new Error("Unexpected record 0x" + RT.toString(16));&#13;
		}&#13;
	});&#13;
	return s;&#13;
}&#13;
&#13;
function write_BrtBeginSst(sst, o) {&#13;
	if(!o) o = new_buf(8);&#13;
	o.write_shift(4, sst.Count);&#13;
	o.write_shift(4, sst.Unique);&#13;
	return o;&#13;
}&#13;
&#13;
var write_BrtSSTItem = write_RichStr;&#13;
&#13;
function write_sst_bin(sst) {&#13;
	var ba = buf_array();&#13;
	write_record(ba, 0x009F /* BrtBeginSst */, write_BrtBeginSst(sst));&#13;
	for(var i = 0; i &lt; sst.length; ++i) write_record(ba, 0x0013 /* BrtSSTItem */, write_BrtSSTItem(sst[i]));&#13;
	/* FRTSST */&#13;
	write_record(ba, 0x00A0 /* BrtEndSst */);&#13;
	return ba.end();&#13;
}&#13;
function _JS2ANSI(str) {&#13;
	if(typeof $cptable !== 'undefined') return $cptable.utils.encode(current_ansi, str);&#13;
	var o = [], oo = str.split("");&#13;
	for(var i = 0; i &lt; oo.length; ++i) o[i] = oo[i].charCodeAt(0);&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-OFFCRYPTO] 2.1.4 Version */&#13;
function parse_CRYPTOVersion(blob, length) {&#13;
	var o = {};&#13;
	o.Major = blob.read_shift(2);&#13;
	o.Minor = blob.read_shift(2);&#13;
if(length &gt;= 4) blob.l += length - 4;&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-OFFCRYPTO] 2.1.5 DataSpaceVersionInfo */&#13;
function parse_DataSpaceVersionInfo(blob) {&#13;
	var o = {};&#13;
	o.id = blob.read_shift(0, 'lpp4');&#13;
	o.R = parse_CRYPTOVersion(blob, 4);&#13;
	o.U = parse_CRYPTOVersion(blob, 4);&#13;
	o.W = parse_CRYPTOVersion(blob, 4);&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-OFFCRYPTO] 2.1.6.1 DataSpaceMapEntry Structure */&#13;
function parse_DataSpaceMapEntry(blob) {&#13;
	var len = blob.read_shift(4);&#13;
	var end = blob.l + len - 4;&#13;
	var o = {};&#13;
	var cnt = blob.read_shift(4);&#13;
	var comps = [];&#13;
	/* [MS-OFFCRYPTO] 2.1.6.2 DataSpaceReferenceComponent Structure */&#13;
	while(cnt-- &gt; 0) comps.push({ t: blob.read_shift(4), v: blob.read_shift(0, 'lpp4') });&#13;
	o.name = blob.read_shift(0, 'lpp4');&#13;
	o.comps = comps;&#13;
	if(blob.l != end) throw new Error("Bad DataSpaceMapEntry: " + blob.l + " != " + end);&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-OFFCRYPTO] 2.1.6 DataSpaceMap */&#13;
function parse_DataSpaceMap(blob) {&#13;
	var o = [];&#13;
	blob.l += 4; // must be 0x8&#13;
	var cnt = blob.read_shift(4);&#13;
	while(cnt-- &gt; 0) o.push(parse_DataSpaceMapEntry(blob));&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-OFFCRYPTO] 2.1.7 DataSpaceDefinition */&#13;
function parse_DataSpaceDefinition(blob) {&#13;
	var o = [];&#13;
	blob.l += 4; // must be 0x8&#13;
	var cnt = blob.read_shift(4);&#13;
	while(cnt-- &gt; 0) o.push(blob.read_shift(0, 'lpp4'));&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-OFFCRYPTO] 2.1.8 DataSpaceDefinition */&#13;
function parse_TransformInfoHeader(blob) {&#13;
	var o = {};&#13;
	/*var len = */blob.read_shift(4);&#13;
	blob.l += 4; // must be 0x1&#13;
	o.id = blob.read_shift(0, 'lpp4');&#13;
	o.name = blob.read_shift(0, 'lpp4');&#13;
	o.R = parse_CRYPTOVersion(blob, 4);&#13;
	o.U = parse_CRYPTOVersion(blob, 4);&#13;
	o.W = parse_CRYPTOVersion(blob, 4);&#13;
	return o;&#13;
}&#13;
&#13;
function parse_Primary(blob) {&#13;
	/* [MS-OFFCRYPTO] 2.2.6 IRMDSTransformInfo */&#13;
	var hdr = parse_TransformInfoHeader(blob);&#13;
	/* [MS-OFFCRYPTO] 2.1.9 EncryptionTransformInfo */&#13;
	hdr.ename = blob.read_shift(0, '8lpp4');&#13;
	hdr.blksz = blob.read_shift(4);&#13;
	hdr.cmode = blob.read_shift(4);&#13;
	if(blob.read_shift(4) != 0x04) throw new Error("Bad !Primary record");&#13;
	return hdr;&#13;
}&#13;
&#13;
/* [MS-OFFCRYPTO] 2.3.2 Encryption Header */&#13;
function parse_EncryptionHeader(blob, length) {&#13;
	var tgt = blob.l + length;&#13;
	var o = {};&#13;
	o.Flags = (blob.read_shift(4) &amp; 0x3F);&#13;
	blob.l += 4;&#13;
	o.AlgID = blob.read_shift(4);&#13;
	var valid = false;&#13;
	switch(o.AlgID) {&#13;
		case 0x660E: case 0x660F: case 0x6610: valid = (o.Flags == 0x24); break;&#13;
		case 0x6801: valid = (o.Flags == 0x04); break;&#13;
		case 0: valid = (o.Flags == 0x10 || o.Flags == 0x04 || o.Flags == 0x24); break;&#13;
		default: throw 'Unrecognized encryption algorithm: ' + o.AlgID;&#13;
	}&#13;
	if(!valid) throw new Error("Encryption Flags/AlgID mismatch");&#13;
	o.AlgIDHash = blob.read_shift(4);&#13;
	o.KeySize = blob.read_shift(4);&#13;
	o.ProviderType = blob.read_shift(4);&#13;
	blob.l += 8;&#13;
	o.CSPName = blob.read_shift((tgt-blob.l)&gt;&gt;1, 'utf16le');&#13;
	blob.l = tgt;&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-OFFCRYPTO] 2.3.3 Encryption Verifier */&#13;
function parse_EncryptionVerifier(blob, length) {&#13;
	var o = {}, tgt = blob.l + length;&#13;
	blob.l += 4; // SaltSize must be 0x10&#13;
	o.Salt = blob.slice(blob.l, blob.l+16); blob.l += 16;&#13;
	o.Verifier = blob.slice(blob.l, blob.l+16); blob.l += 16;&#13;
	/*var sz = */blob.read_shift(4);&#13;
	o.VerifierHash = blob.slice(blob.l, tgt); blob.l = tgt;&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-OFFCRYPTO] 2.3.4.* EncryptionInfo Stream */&#13;
function parse_EncryptionInfo(blob) {&#13;
	var vers = parse_CRYPTOVersion(blob);&#13;
	switch(vers.Minor) {&#13;
		case 0x02: return [vers.Minor, parse_EncInfoStd(blob, vers)];&#13;
		case 0x03: return [vers.Minor, parse_EncInfoExt(blob, vers)];&#13;
		case 0x04: return [vers.Minor, parse_EncInfoAgl(blob, vers)];&#13;
	}&#13;
	throw new Error("ECMA-376 Encrypted file unrecognized Version: " + vers.Minor);&#13;
}&#13;
&#13;
/* [MS-OFFCRYPTO] 2.3.4.5  EncryptionInfo Stream (Standard Encryption) */&#13;
function parse_EncInfoStd(blob) {&#13;
	var flags = blob.read_shift(4);&#13;
	if((flags &amp; 0x3F) != 0x24) throw new Error("EncryptionInfo mismatch");&#13;
	var sz = blob.read_shift(4);&#13;
	//var tgt = blob.l + sz;&#13;
	var hdr = parse_EncryptionHeader(blob, sz);&#13;
	var verifier = parse_EncryptionVerifier(blob, blob.length - blob.l);&#13;
	return { t:"Std", h:hdr, v:verifier };&#13;
}&#13;
/* [MS-OFFCRYPTO] 2.3.4.6  EncryptionInfo Stream (Extensible Encryption) */&#13;
function parse_EncInfoExt() { throw new Error("File is password-protected: ECMA-376 Extensible"); }&#13;
/* [MS-OFFCRYPTO] 2.3.4.10 EncryptionInfo Stream (Agile Encryption) */&#13;
function parse_EncInfoAgl(blob) {&#13;
	var KeyData = ["saltSize","blockSize","keyBits","hashSize","cipherAlgorithm","cipherChaining","hashAlgorithm","saltValue"];&#13;
	blob.l+=4;&#13;
	var xml = blob.read_shift(blob.length - blob.l, 'utf8');&#13;
	var o = {};&#13;
	xml.replace(tagregex, function xml_agile(x) {&#13;
		var y = parsexmltag(x);&#13;
		switch(strip_ns(y[0])) {&#13;
			case '&lt;?xml': break;&#13;
			case '&lt;encryption': case '&lt;/encryption&gt;': break;&#13;
			case '&lt;keyData': KeyData.forEach(function(k) { o[k] = y[k]; }); break;&#13;
			case '&lt;dataIntegrity': o.encryptedHmacKey = y.encryptedHmacKey; o.encryptedHmacValue = y.encryptedHmacValue; break;&#13;
			case '&lt;keyEncryptors&gt;': case '&lt;keyEncryptors': o.encs = []; break;&#13;
			case '&lt;/keyEncryptors&gt;': break;&#13;
&#13;
			case '&lt;keyEncryptor': o.uri = y.uri; break;&#13;
			case '&lt;/keyEncryptor&gt;': break;&#13;
			case '&lt;encryptedKey': o.encs.push(y); break;&#13;
			default: throw y[0];&#13;
		}&#13;
	});&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-OFFCRYPTO] 2.3.5.1 RC4 CryptoAPI Encryption Header */&#13;
function parse_RC4CryptoHeader(blob, length) {&#13;
	var o = {};&#13;
	var vers = o.EncryptionVersionInfo = parse_CRYPTOVersion(blob, 4); length -= 4;&#13;
	if(vers.Minor != 2) throw new Error('unrecognized minor version code: ' + vers.Minor);&#13;
	if(vers.Major &gt; 4 || vers.Major &lt; 2) throw new Error('unrecognized major version code: ' + vers.Major);&#13;
	o.Flags = blob.read_shift(4); length -= 4;&#13;
	var sz = blob.read_shift(4); length -= 4;&#13;
	o.EncryptionHeader = parse_EncryptionHeader(blob, sz); length -= sz;&#13;
	o.EncryptionVerifier = parse_EncryptionVerifier(blob, length);&#13;
	return o;&#13;
}&#13;
/* [MS-OFFCRYPTO] 2.3.6.1 RC4 Encryption Header */&#13;
function parse_RC4Header(blob) {&#13;
	var o = {};&#13;
	var vers = o.EncryptionVersionInfo = parse_CRYPTOVersion(blob, 4);&#13;
	if(vers.Major != 1 || vers.Minor != 1) throw 'unrecognized version code ' + vers.Major + ' : ' + vers.Minor;&#13;
	o.Salt = blob.read_shift(16);&#13;
	o.EncryptedVerifier = blob.read_shift(16);&#13;
	o.EncryptedVerifierHash = blob.read_shift(16);&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-OFFCRYPTO] 2.3.7.1 Binary Document Password Verifier Derivation */&#13;
function crypto_CreatePasswordVerifier_Method1(Password) {&#13;
	var Verifier = 0x0000, PasswordArray;&#13;
	var PasswordDecoded = _JS2ANSI(Password);&#13;
	var len = PasswordDecoded.length + 1, i, PasswordByte;&#13;
	var Intermediate1, Intermediate2, Intermediate3;&#13;
	PasswordArray = new_raw_buf(len);&#13;
	PasswordArray[0] = PasswordDecoded.length;&#13;
	for(i = 1; i != len; ++i) PasswordArray[i] = PasswordDecoded[i-1];&#13;
	for(i = len-1; i &gt;= 0; --i) {&#13;
		PasswordByte = PasswordArray[i];&#13;
		Intermediate1 = ((Verifier &amp; 0x4000) === 0x0000) ? 0 : 1;&#13;
		Intermediate2 = (Verifier &lt;&lt; 1) &amp; 0x7FFF;&#13;
		Intermediate3 = Intermediate1 | Intermediate2;&#13;
		Verifier = Intermediate3 ^ PasswordByte;&#13;
	}&#13;
	return Verifier ^ 0xCE4B;&#13;
}&#13;
&#13;
/* [MS-OFFCRYPTO] 2.3.7.2 Binary Document XOR Array Initialization */&#13;
var crypto_CreateXorArray_Method1 = (function() {&#13;
	var PadArray = [0xBB, 0xFF, 0xFF, 0xBA, 0xFF, 0xFF, 0xB9, 0x80, 0x00, 0xBE, 0x0F, 0x00, 0xBF, 0x0F, 0x00];&#13;
	var InitialCode = [0xE1F0, 0x1D0F, 0xCC9C, 0x84C0, 0x110C, 0x0E10, 0xF1CE, 0x313E, 0x1872, 0xE139, 0xD40F, 0x84F9, 0x280C, 0xA96A, 0x4EC3];&#13;
	var XorMatrix = [0xAEFC, 0x4DD9, 0x9BB2, 0x2745, 0x4E8A, 0x9D14, 0x2A09, 0x7B61, 0xF6C2, 0xFDA5, 0xEB6B, 0xC6F7, 0x9DCF, 0x2BBF, 0x4563, 0x8AC6, 0x05AD, 0x0B5A, 0x16B4, 0x2D68, 0x5AD0, 0x0375, 0x06EA, 0x0DD4, 0x1BA8, 0x3750, 0x6EA0, 0xDD40, 0xD849, 0xA0B3, 0x5147, 0xA28E, 0x553D, 0xAA7A, 0x44D5, 0x6F45, 0xDE8A, 0xAD35, 0x4A4B, 0x9496, 0x390D, 0x721A, 0xEB23, 0xC667, 0x9CEF, 0x29FF, 0x53FE, 0xA7FC, 0x5FD9, 0x47D3, 0x8FA6, 0x0F6D, 0x1EDA, 0x3DB4, 0x7B68, 0xF6D0, 0xB861, 0x60E3, 0xC1C6, 0x93AD, 0x377B, 0x6EF6, 0xDDEC, 0x45A0, 0x8B40, 0x06A1, 0x0D42, 0x1A84, 0x3508, 0x6A10, 0xAA51, 0x4483, 0x8906, 0x022D, 0x045A, 0x08B4, 0x1168, 0x76B4, 0xED68, 0xCAF1, 0x85C3, 0x1BA7, 0x374E, 0x6E9C, 0x3730, 0x6E60, 0xDCC0, 0xA9A1, 0x4363, 0x86C6, 0x1DAD, 0x3331, 0x6662, 0xCCC4, 0x89A9, 0x0373, 0x06E6, 0x0DCC, 0x1021, 0x2042, 0x4084, 0x8108, 0x1231, 0x2462, 0x48C4];&#13;
	var Ror = function(Byte) { return ((Byte/2) | (Byte*128)) &amp; 0xFF; };&#13;
	var XorRor = function(byte1, byte2) { return Ror(byte1 ^ byte2); };&#13;
	var CreateXorKey_Method1 = function(Password) {&#13;
		var XorKey = InitialCode[Password.length - 1];&#13;
		var CurrentElement = 0x68;&#13;
		for(var i = Password.length-1; i &gt;= 0; --i) {&#13;
			var Char = Password[i];&#13;
			for(var j = 0; j != 7; ++j) {&#13;
				if(Char &amp; 0x40) XorKey ^= XorMatrix[CurrentElement];&#13;
				Char *= 2; --CurrentElement;&#13;
			}&#13;
		}&#13;
		return XorKey;&#13;
	};&#13;
	return function(password) {&#13;
		var Password = _JS2ANSI(password);&#13;
		var XorKey = CreateXorKey_Method1(Password);&#13;
		var Index = Password.length;&#13;
		var ObfuscationArray = new_raw_buf(16);&#13;
		for(var i = 0; i != 16; ++i) ObfuscationArray[i] = 0x00;&#13;
		var Temp, PasswordLastChar, PadIndex;&#13;
		if((Index &amp; 1) === 1) {&#13;
			Temp = XorKey &gt;&gt; 8;&#13;
			ObfuscationArray[Index] = XorRor(PadArray[0], Temp);&#13;
			--Index;&#13;
			Temp = XorKey &amp; 0xFF;&#13;
			PasswordLastChar = Password[Password.length - 1];&#13;
			ObfuscationArray[Index] = XorRor(PasswordLastChar, Temp);&#13;
		}&#13;
		while(Index &gt; 0) {&#13;
			--Index;&#13;
			Temp = XorKey &gt;&gt; 8;&#13;
			ObfuscationArray[Index] = XorRor(Password[Index], Temp);&#13;
			--Index;&#13;
			Temp = XorKey &amp; 0xFF;&#13;
			ObfuscationArray[Index] = XorRor(Password[Index], Temp);&#13;
		}&#13;
		Index = 15;&#13;
		PadIndex = 15 - Password.length;&#13;
		while(PadIndex &gt; 0) {&#13;
			Temp = XorKey &gt;&gt; 8;&#13;
			ObfuscationArray[Index] = XorRor(PadArray[PadIndex], Temp);&#13;
			--Index;&#13;
			--PadIndex;&#13;
			Temp = XorKey &amp; 0xFF;&#13;
			ObfuscationArray[Index] = XorRor(Password[Index], Temp);&#13;
			--Index;&#13;
			--PadIndex;&#13;
		}&#13;
		return ObfuscationArray;&#13;
	};&#13;
})();&#13;
&#13;
/* [MS-OFFCRYPTO] 2.3.7.3 Binary Document XOR Data Transformation Method 1 */&#13;
var crypto_DecryptData_Method1 = function(password, Data, XorArrayIndex, XorArray, O) {&#13;
	/* If XorArray is set, use it; if O is not set, make changes in-place */&#13;
	if(!O) O = Data;&#13;
	if(!XorArray) XorArray = crypto_CreateXorArray_Method1(password);&#13;
	var Index, Value;&#13;
	for(Index = 0; Index != Data.length; ++Index) {&#13;
		Value = Data[Index];&#13;
		Value ^= XorArray[XorArrayIndex];&#13;
		Value = ((Value&gt;&gt;5) | (Value&lt;&lt;3)) &amp; 0xFF;&#13;
		O[Index] = Value;&#13;
		++XorArrayIndex;&#13;
	}&#13;
	return [O, XorArrayIndex, XorArray];&#13;
};&#13;
&#13;
var crypto_MakeXorDecryptor = function(password) {&#13;
	var XorArrayIndex = 0, XorArray = crypto_CreateXorArray_Method1(password);&#13;
	return function(Data) {&#13;
		var O = crypto_DecryptData_Method1("", Data, XorArrayIndex, XorArray);&#13;
		XorArrayIndex = O[1];&#13;
		return O[0];&#13;
	};&#13;
};&#13;
&#13;
/* 2.5.343 */&#13;
function parse_XORObfuscation(blob, length, opts, out) {&#13;
	var o = ({ key: parseuint16(blob), verificationBytes: parseuint16(blob) });&#13;
	if(opts.password) o.verifier = crypto_CreatePasswordVerifier_Method1(opts.password);&#13;
	out.valid = o.verificationBytes === o.verifier;&#13;
	if(out.valid) out.insitu = crypto_MakeXorDecryptor(opts.password);&#13;
	return o;&#13;
}&#13;
&#13;
/* 2.4.117 */&#13;
function parse_FilePassHeader(blob, length, oo) {&#13;
	var o = oo || {}; o.Info = blob.read_shift(2); blob.l -= 2;&#13;
	if(o.Info === 1) o.Data = parse_RC4Header(blob, length);&#13;
	else o.Data = parse_RC4CryptoHeader(blob, length);&#13;
	return o;&#13;
}&#13;
function parse_FilePass(blob, length, opts) {&#13;
	var o = ({ Type: opts.biff &gt;= 8 ? blob.read_shift(2) : 0 }); /* wEncryptionType */&#13;
	if(o.Type) parse_FilePassHeader(blob, length-2, o);&#13;
	else parse_XORObfuscation(blob, opts.biff &gt;= 8 ? length : length - 2, opts, o);&#13;
	return o;&#13;
}&#13;
&#13;
&#13;
function rtf_to_sheet(d, opts) {&#13;
  switch (opts.type) {&#13;
    case "base64":&#13;
      return rtf_to_sheet_str(Base64_decode(d), opts);&#13;
    case "binary":&#13;
      return rtf_to_sheet_str(d, opts);&#13;
    case "buffer":&#13;
      return rtf_to_sheet_str(has_buf &amp;&amp; Buffer.isBuffer(d) ? d.toString("binary") : a2s(d), opts);&#13;
    case "array":&#13;
      return rtf_to_sheet_str(cc2str(d), opts);&#13;
  }&#13;
  throw new Error("Unrecognized type " + opts.type);&#13;
}&#13;
function rtf_to_sheet_str(str, opts) {&#13;
  var o = opts || {};&#13;
  var ws = o.dense ? [] : {};&#13;
  var rows = str.match(/\\trowd[\s\S]*?\\row\b/g);&#13;
  if (!rows)&#13;
    throw new Error("RTF missing table");&#13;
  var range = { s: { c: 0, r: 0 }, e: { c: 0, r: rows.length - 1 } };&#13;
  rows.forEach(function(rowtf, R) {&#13;
    if (Array.isArray(ws))&#13;
      ws[R] = [];&#13;
    var rtfre = /\\[\w\-]+\b/g;&#13;
    var last_index = 0;&#13;
    var res;&#13;
    var C = -1;&#13;
    var payload = [];&#13;
    while ((res = rtfre.exec(rowtf)) != null) {&#13;
      var data = rowtf.slice(last_index, rtfre.lastIndex - res[0].length);&#13;
      if (data.charCodeAt(0) == 32)&#13;
        data = data.slice(1);&#13;
      if (data.length)&#13;
        payload.push(data);&#13;
      switch (res[0]) {&#13;
        case "\\cell":&#13;
          ++C;&#13;
          if (payload.length) {&#13;
            var cell = { v: payload.join(""), t: "s" };&#13;
            if (cell.v == "TRUE" || cell.v == "FALSE") {&#13;
              cell.v = cell.v == "TRUE";&#13;
              cell.t = "b";&#13;
            } else if (!isNaN(fuzzynum(cell.v))) {&#13;
              cell.t = "n";&#13;
              if (o.cellText !== false)&#13;
                cell.w = cell.v;&#13;
              cell.v = fuzzynum(cell.v);&#13;
            }&#13;
            if (Array.isArray(ws))&#13;
              ws[R][C] = cell;&#13;
            else&#13;
              ws[encode_cell({ r: R, c: C })] = cell;&#13;
          }&#13;
          payload = [];&#13;
          break;&#13;
        case "\\par":&#13;
          payload.push("\n");&#13;
          break;&#13;
      }&#13;
      last_index = rtfre.lastIndex;&#13;
    }&#13;
    if (C &gt; range.e.c)&#13;
      range.e.c = C;&#13;
  });&#13;
  ws["!ref"] = encode_range(range);&#13;
  return ws;&#13;
}&#13;
function rtf_to_workbook(d, opts) {&#13;
  var wb = sheet_to_workbook(rtf_to_sheet(d, opts), opts);&#13;
  wb.bookType = "rtf";&#13;
  return wb;&#13;
}&#13;
function sheet_to_rtf(ws, opts) {&#13;
  var o = ["{\\rtf1\\ansi"];&#13;
  if (!ws["!ref"])&#13;
    return o[0] + "}";&#13;
  var r = safe_decode_range(ws["!ref"]), cell;&#13;
  var dense = Array.isArray(ws);&#13;
  for (var R = r.s.r; R &lt;= r.e.r; ++R) {&#13;
    o.push("\\trowd\\trautofit1");&#13;
    for (var C = r.s.c; C &lt;= r.e.c; ++C)&#13;
      o.push("\\cellx" + (C + 1));&#13;
    o.push("\\pard\\intbl");&#13;
    for (C = r.s.c; C &lt;= r.e.c; ++C) {&#13;
      var coord = encode_cell({ r: R, c: C });&#13;
      cell = dense ? (ws[R] || [])[C] : ws[coord];&#13;
      if (!cell || cell.v == null &amp;&amp; (!cell.f || cell.F)) {&#13;
        o.push(" \\cell");&#13;
        continue;&#13;
      }&#13;
      o.push(" " + (cell.w || (format_cell(cell), cell.w) || "").replace(/[\r\n]/g, "\\par "));&#13;
      o.push("\\cell");&#13;
    }&#13;
    o.push("\\pard\\intbl\\row");&#13;
  }&#13;
  return o.join("") + "}";&#13;
}&#13;
function hex2RGB(h) {&#13;
	var o = h.slice(h[0]==="#"?1:0).slice(0,6);&#13;
	return [parseInt(o.slice(0,2),16),parseInt(o.slice(2,4),16),parseInt(o.slice(4,6),16)];&#13;
}&#13;
function rgb2Hex(rgb) {&#13;
	for(var i=0,o=1; i!=3; ++i) o = o*256 + (rgb[i]&gt;255?255:rgb[i]&lt;0?0:rgb[i]);&#13;
	return o.toString(16).toUpperCase().slice(1);&#13;
}&#13;
&#13;
function rgb2HSL(rgb) {&#13;
	var R = rgb[0]/255, G = rgb[1]/255, B=rgb[2]/255;&#13;
	var M = Math.max(R, G, B), m = Math.min(R, G, B), C = M - m;&#13;
	if(C === 0) return [0, 0, R];&#13;
&#13;
	var H6 = 0, S = 0, L2 = (M + m);&#13;
	S = C / (L2 &gt; 1 ? 2 - L2 : L2);&#13;
	switch(M){&#13;
		case R: H6 = ((G - B) / C + 6)%6; break;&#13;
		case G: H6 = ((B - R) / C + 2); break;&#13;
		case B: H6 = ((R - G) / C + 4); break;&#13;
	}&#13;
	return [H6 / 6, S, L2 / 2];&#13;
}&#13;
&#13;
function hsl2RGB(hsl){&#13;
	var H = hsl[0], S = hsl[1], L = hsl[2];&#13;
	var C = S * 2 * (L &lt; 0.5 ? L : 1 - L), m = L - C/2;&#13;
	var rgb = [m,m,m], h6 = 6*H;&#13;
&#13;
	var X;&#13;
	if(S !== 0) switch(h6|0) {&#13;
		case 0: case 6: X = C * h6; rgb[0] += C; rgb[1] += X; break;&#13;
		case 1: X = C * (2 - h6);   rgb[0] += X; rgb[1] += C; break;&#13;
		case 2: X = C * (h6 - 2);   rgb[1] += C; rgb[2] += X; break;&#13;
		case 3: X = C * (4 - h6);   rgb[1] += X; rgb[2] += C; break;&#13;
		case 4: X = C * (h6 - 4);   rgb[2] += C; rgb[0] += X; break;&#13;
		case 5: X = C * (6 - h6);   rgb[2] += X; rgb[0] += C; break;&#13;
	}&#13;
	for(var i = 0; i != 3; ++i) rgb[i] = Math.round(rgb[i]*255);&#13;
	return rgb;&#13;
}&#13;
&#13;
/* 18.8.3 bgColor tint algorithm */&#13;
function rgb_tint(hex, tint) {&#13;
	if(tint === 0) return hex;&#13;
	var hsl = rgb2HSL(hex2RGB(hex));&#13;
	if (tint &lt; 0) hsl[2] = hsl[2] * (1 + tint);&#13;
	else hsl[2] = 1 - (1 - hsl[2]) * (1 - tint);&#13;
	return rgb2Hex(hsl2RGB(hsl));&#13;
}&#13;
&#13;
/* 18.3.1.13 width calculations */&#13;
/* [MS-OI29500] 2.1.595 Column Width &amp; Formatting */&#13;
var DEF_MDW = 6, MAX_MDW = 15, MIN_MDW = 1, MDW = DEF_MDW;&#13;
function width2px(width) { return Math.floor(( width + (Math.round(128/MDW))/256 )* MDW ); }&#13;
function px2char(px) { return (Math.floor((px - 5)/MDW * 100 + 0.5))/100; }&#13;
function char2width(chr) { return (Math.round((chr * MDW + 5)/MDW*256))/256; }&#13;
//function px2char_(px) { return (((px - 5)/MDW * 100 + 0.5))/100; }&#13;
//function char2width_(chr) { return (((chr * MDW + 5)/MDW*256))/256; }&#13;
function cycle_width(collw) { return char2width(px2char(width2px(collw))); }&#13;
/* XLSX/XLSB/XLS specify width in units of MDW */&#13;
function find_mdw_colw(collw) {&#13;
	var delta = Math.abs(collw - cycle_width(collw)), _MDW = MDW;&#13;
	if(delta &gt; 0.005) for(MDW=MIN_MDW; MDW&lt;MAX_MDW; ++MDW) if(Math.abs(collw - cycle_width(collw)) &lt;= delta) { delta = Math.abs(collw - cycle_width(collw)); _MDW = MDW; }&#13;
	MDW = _MDW;&#13;
}&#13;
/* XLML specifies width in terms of pixels */&#13;
/*function find_mdw_wpx(wpx) {&#13;
	var delta = Infinity, guess = 0, _MDW = MIN_MDW;&#13;
	for(MDW=MIN_MDW; MDW&lt;MAX_MDW; ++MDW) {&#13;
		guess = char2width_(px2char_(wpx))*256;&#13;
		guess = (guess) % 1;&#13;
		if(guess &gt; 0.5) guess--;&#13;
		if(Math.abs(guess) &lt; delta) { delta = Math.abs(guess); _MDW = MDW; }&#13;
	}&#13;
	MDW = _MDW;&#13;
}*/&#13;
&#13;
function process_col(coll) {&#13;
	if(coll.width) {&#13;
		coll.wpx = width2px(coll.width);&#13;
		coll.wch = px2char(coll.wpx);&#13;
		coll.MDW = MDW;&#13;
	} else if(coll.wpx) {&#13;
		coll.wch = px2char(coll.wpx);&#13;
		coll.width = char2width(coll.wch);&#13;
		coll.MDW = MDW;&#13;
	} else if(typeof coll.wch == 'number') {&#13;
		coll.width = char2width(coll.wch);&#13;
		coll.wpx = width2px(coll.width);&#13;
		coll.MDW = MDW;&#13;
	}&#13;
	if(coll.customWidth) delete coll.customWidth;&#13;
}&#13;
&#13;
var DEF_PPI = 96, PPI = DEF_PPI;&#13;
function px2pt(px) { return px * 96 / PPI; }&#13;
function pt2px(pt) { return pt * PPI / 96; }&#13;
&#13;
/* [MS-EXSPXML3] 2.4.54 ST_enmPattern */&#13;
var XLMLPatternTypeMap = {&#13;
	"None": "none",&#13;
	"Solid": "solid",&#13;
	"Gray50": "mediumGray",&#13;
	"Gray75": "darkGray",&#13;
	"Gray25": "lightGray",&#13;
	"HorzStripe": "darkHorizontal",&#13;
	"VertStripe": "darkVertical",&#13;
	"ReverseDiagStripe": "darkDown",&#13;
	"DiagStripe": "darkUp",&#13;
	"DiagCross": "darkGrid",&#13;
	"ThickDiagCross": "darkTrellis",&#13;
	"ThinHorzStripe": "lightHorizontal",&#13;
	"ThinVertStripe": "lightVertical",&#13;
	"ThinReverseDiagStripe": "lightDown",&#13;
	"ThinHorzCross": "lightGrid"&#13;
};&#13;
&#13;
/* 18.8.5 borders CT_Borders */&#13;
function parse_borders(t, styles, themes, opts) {&#13;
	styles.Borders = [];&#13;
	var border = {};&#13;
	var pass = false;&#13;
	(t[0].match(tagregex)||[]).forEach(function(x) {&#13;
		var y = parsexmltag(x);&#13;
		switch(strip_ns(y[0])) {&#13;
			case '&lt;borders': case '&lt;borders&gt;': case '&lt;/borders&gt;': break;&#13;
&#13;
			/* 18.8.4 border CT_Border */&#13;
			case '&lt;border': case '&lt;border&gt;': case '&lt;border/&gt;':&#13;
				border = {};&#13;
				if(y.diagonalUp) border.diagonalUp = parsexmlbool(y.diagonalUp);&#13;
				if(y.diagonalDown) border.diagonalDown = parsexmlbool(y.diagonalDown);&#13;
				styles.Borders.push(border);&#13;
				break;&#13;
			case '&lt;/border&gt;': break;&#13;
&#13;
			/* note: not in spec, appears to be CT_BorderPr */&#13;
			case '&lt;left/&gt;': break;&#13;
			case '&lt;left': case '&lt;left&gt;': break;&#13;
			case '&lt;/left&gt;': break;&#13;
&#13;
			/* note: not in spec, appears to be CT_BorderPr */&#13;
			case '&lt;right/&gt;': break;&#13;
			case '&lt;right': case '&lt;right&gt;': break;&#13;
			case '&lt;/right&gt;': break;&#13;
&#13;
			/* 18.8.43 top CT_BorderPr */&#13;
			case '&lt;top/&gt;': break;&#13;
			case '&lt;top': case '&lt;top&gt;': break;&#13;
			case '&lt;/top&gt;': break;&#13;
&#13;
			/* 18.8.6 bottom CT_BorderPr */&#13;
			case '&lt;bottom/&gt;': break;&#13;
			case '&lt;bottom': case '&lt;bottom&gt;': break;&#13;
			case '&lt;/bottom&gt;': break;&#13;
&#13;
			/* 18.8.13 diagonal CT_BorderPr */&#13;
			case '&lt;diagonal': case '&lt;diagonal&gt;': case '&lt;diagonal/&gt;': break;&#13;
			case '&lt;/diagonal&gt;': break;&#13;
&#13;
			/* 18.8.25 horizontal CT_BorderPr */&#13;
			case '&lt;horizontal': case '&lt;horizontal&gt;': case '&lt;horizontal/&gt;': break;&#13;
			case '&lt;/horizontal&gt;': break;&#13;
&#13;
			/* 18.8.44 vertical CT_BorderPr */&#13;
			case '&lt;vertical': case '&lt;vertical&gt;': case '&lt;vertical/&gt;': break;&#13;
			case '&lt;/vertical&gt;': break;&#13;
&#13;
			/* 18.8.37 start CT_BorderPr */&#13;
			case '&lt;start': case '&lt;start&gt;': case '&lt;start/&gt;': break;&#13;
			case '&lt;/start&gt;': break;&#13;
&#13;
			/* 18.8.16 end CT_BorderPr */&#13;
			case '&lt;end': case '&lt;end&gt;': case '&lt;end/&gt;': break;&#13;
			case '&lt;/end&gt;': break;&#13;
&#13;
			/* 18.8.? color CT_Color */&#13;
			case '&lt;color': case '&lt;color&gt;':&#13;
				break;&#13;
			case '&lt;color/&gt;': case '&lt;/color&gt;': break;&#13;
&#13;
			/* 18.2.10 extLst CT_ExtensionList ? */&#13;
			case '&lt;extLst': case '&lt;extLst&gt;': case '&lt;/extLst&gt;': break;&#13;
			case '&lt;ext': pass = true; break;&#13;
			case '&lt;/ext&gt;': pass = false; break;&#13;
			default: if(opts &amp;&amp; opts.WTF) {&#13;
				if(!pass) throw new Error('unrecognized ' + y[0] + ' in borders');&#13;
			}&#13;
		}&#13;
	});&#13;
}&#13;
&#13;
/* 18.8.21 fills CT_Fills */&#13;
function parse_fills(t, styles, themes, opts) {&#13;
	styles.Fills = [];&#13;
	var fill = {};&#13;
	var pass = false;&#13;
	(t[0].match(tagregex)||[]).forEach(function(x) {&#13;
		var y = parsexmltag(x);&#13;
		switch(strip_ns(y[0])) {&#13;
			case '&lt;fills': case '&lt;fills&gt;': case '&lt;/fills&gt;': break;&#13;
&#13;
			/* 18.8.20 fill CT_Fill */&#13;
			case '&lt;fill&gt;': case '&lt;fill': case '&lt;fill/&gt;':&#13;
				fill = {}; styles.Fills.push(fill); break;&#13;
			case '&lt;/fill&gt;': break;&#13;
&#13;
			/* 18.8.24 gradientFill CT_GradientFill */&#13;
			case '&lt;gradientFill&gt;': break;&#13;
			case '&lt;gradientFill':&#13;
			case '&lt;/gradientFill&gt;': styles.Fills.push(fill); fill = {}; break;&#13;
&#13;
			/* 18.8.32 patternFill CT_PatternFill */&#13;
			case '&lt;patternFill': case '&lt;patternFill&gt;':&#13;
				if(y.patternType) fill.patternType = y.patternType;&#13;
				break;&#13;
			case '&lt;patternFill/&gt;': case '&lt;/patternFill&gt;': break;&#13;
&#13;
			/* 18.8.3 bgColor CT_Color */&#13;
			case '&lt;bgColor':&#13;
				if(!fill.bgColor) fill.bgColor = {};&#13;
				if(y.indexed) fill.bgColor.indexed = parseInt(y.indexed, 10);&#13;
				if(y.theme) fill.bgColor.theme = parseInt(y.theme, 10);&#13;
				if(y.tint) fill.bgColor.tint = parseFloat(y.tint);&#13;
				/* Excel uses ARGB strings */&#13;
				if(y.rgb) fill.bgColor.rgb = y.rgb.slice(-6);&#13;
				break;&#13;
			case '&lt;bgColor/&gt;': case '&lt;/bgColor&gt;': break;&#13;
&#13;
			/* 18.8.19 fgColor CT_Color */&#13;
			case '&lt;fgColor':&#13;
				if(!fill.fgColor) fill.fgColor = {};&#13;
				if(y.theme) fill.fgColor.theme = parseInt(y.theme, 10);&#13;
				if(y.tint) fill.fgColor.tint = parseFloat(y.tint);&#13;
				/* Excel uses ARGB strings */&#13;
				if(y.rgb != null) fill.fgColor.rgb = y.rgb.slice(-6);&#13;
				break;&#13;
			case '&lt;fgColor/&gt;': case '&lt;/fgColor&gt;': break;&#13;
&#13;
			/* 18.8.38 stop CT_GradientStop */&#13;
			case '&lt;stop': case '&lt;stop/&gt;': break;&#13;
			case '&lt;/stop&gt;': break;&#13;
&#13;
			/* 18.8.? color CT_Color */&#13;
			case '&lt;color': case '&lt;color/&gt;': break;&#13;
			case '&lt;/color&gt;': break;&#13;
&#13;
			/* 18.2.10 extLst CT_ExtensionList ? */&#13;
			case '&lt;extLst': case '&lt;extLst&gt;': case '&lt;/extLst&gt;': break;&#13;
			case '&lt;ext': pass = true; break;&#13;
			case '&lt;/ext&gt;': pass = false; break;&#13;
			default: if(opts &amp;&amp; opts.WTF) {&#13;
				if(!pass) throw new Error('unrecognized ' + y[0] + ' in fills');&#13;
			}&#13;
		}&#13;
	});&#13;
}&#13;
&#13;
/* 18.8.23 fonts CT_Fonts */&#13;
function parse_fonts(t, styles, themes, opts) {&#13;
	styles.Fonts = [];&#13;
	var font = {};&#13;
	var pass = false;&#13;
	(t[0].match(tagregex)||[]).forEach(function(x) {&#13;
		var y = parsexmltag(x);&#13;
		switch(strip_ns(y[0])) {&#13;
			case '&lt;fonts': case '&lt;fonts&gt;': case '&lt;/fonts&gt;': break;&#13;
&#13;
			/* 18.8.22 font CT_Font */&#13;
			case '&lt;font': case '&lt;font&gt;': break;&#13;
			case '&lt;/font&gt;': case '&lt;font/&gt;':&#13;
				styles.Fonts.push(font);&#13;
				font = {};&#13;
				break;&#13;
&#13;
			/* 18.8.29 name CT_FontName */&#13;
			case '&lt;name': if(y.val) font.name = utf8read(y.val); break;&#13;
			case '&lt;name/&gt;': case '&lt;/name&gt;': break;&#13;
&#13;
			/* 18.8.2  b CT_BooleanProperty */&#13;
			case '&lt;b': font.bold = y.val ? parsexmlbool(y.val) : 1; break;&#13;
			case '&lt;b/&gt;': font.bold = 1; break;&#13;
&#13;
			/* 18.8.26 i CT_BooleanProperty */&#13;
			case '&lt;i': font.italic = y.val ? parsexmlbool(y.val) : 1; break;&#13;
			case '&lt;i/&gt;': font.italic = 1; break;&#13;
&#13;
			/* 18.4.13 u CT_UnderlineProperty */&#13;
			case '&lt;u':&#13;
				switch(y.val) {&#13;
					case "none": font.underline = 0x00; break;&#13;
					case "single": font.underline = 0x01; break;&#13;
					case "double": font.underline = 0x02; break;&#13;
					case "singleAccounting": font.underline = 0x21; break;&#13;
					case "doubleAccounting": font.underline = 0x22; break;&#13;
				} break;&#13;
			case '&lt;u/&gt;': font.underline = 1; break;&#13;
&#13;
			/* 18.4.10 strike CT_BooleanProperty */&#13;
			case '&lt;strike': font.strike = y.val ? parsexmlbool(y.val) : 1; break;&#13;
			case '&lt;strike/&gt;': font.strike = 1; break;&#13;
&#13;
			/* 18.4.2  outline CT_BooleanProperty */&#13;
			case '&lt;outline': font.outline = y.val ? parsexmlbool(y.val) : 1; break;&#13;
			case '&lt;outline/&gt;': font.outline = 1; break;&#13;
&#13;
			/* 18.8.36 shadow CT_BooleanProperty */&#13;
			case '&lt;shadow': font.shadow = y.val ? parsexmlbool(y.val) : 1; break;&#13;
			case '&lt;shadow/&gt;': font.shadow = 1; break;&#13;
&#13;
			/* 18.8.12 condense CT_BooleanProperty */&#13;
			case '&lt;condense': font.condense = y.val ? parsexmlbool(y.val) : 1; break;&#13;
			case '&lt;condense/&gt;': font.condense = 1; break;&#13;
&#13;
			/* 18.8.17 extend CT_BooleanProperty */&#13;
			case '&lt;extend': font.extend = y.val ? parsexmlbool(y.val) : 1; break;&#13;
			case '&lt;extend/&gt;': font.extend = 1; break;&#13;
&#13;
			/* 18.4.11 sz CT_FontSize */&#13;
			case '&lt;sz': if(y.val) font.sz = +y.val; break;&#13;
			case '&lt;sz/&gt;': case '&lt;/sz&gt;': break;&#13;
&#13;
			/* 18.4.14 vertAlign CT_VerticalAlignFontProperty */&#13;
			case '&lt;vertAlign': if(y.val) font.vertAlign = y.val; break;&#13;
			case '&lt;vertAlign/&gt;': case '&lt;/vertAlign&gt;': break;&#13;
&#13;
			/* 18.8.18 family CT_FontFamily */&#13;
			case '&lt;family': if(y.val) font.family = parseInt(y.val,10); break;&#13;
			case '&lt;family/&gt;': case '&lt;/family&gt;': break;&#13;
&#13;
			/* 18.8.35 scheme CT_FontScheme */&#13;
			case '&lt;scheme': if(y.val) font.scheme = y.val; break;&#13;
			case '&lt;scheme/&gt;': case '&lt;/scheme&gt;': break;&#13;
&#13;
			/* 18.4.1 charset CT_IntProperty */&#13;
			case '&lt;charset':&#13;
				if(y.val == '1') break;&#13;
				y.codepage = CS2CP[parseInt(y.val, 10)];&#13;
				break;&#13;
&#13;
			/* 18.?.? color CT_Color */&#13;
			case '&lt;color':&#13;
				if(!font.color) font.color = {};&#13;
				if(y.auto) font.color.auto = parsexmlbool(y.auto);&#13;
&#13;
				if(y.rgb) font.color.rgb = y.rgb.slice(-6);&#13;
				else if(y.indexed) {&#13;
					font.color.index = parseInt(y.indexed, 10);&#13;
					var icv = XLSIcv[font.color.index];&#13;
					if(font.color.index == 81) icv = XLSIcv[1];&#13;
					if(!icv) icv = XLSIcv[1]; //throw new Error(x); // note: 206 is valid&#13;
					font.color.rgb = icv[0].toString(16) + icv[1].toString(16) + icv[2].toString(16);&#13;
				} else if(y.theme) {&#13;
					font.color.theme = parseInt(y.theme, 10);&#13;
					if(y.tint) font.color.tint = parseFloat(y.tint);&#13;
					if(y.theme &amp;&amp; themes.themeElements &amp;&amp; themes.themeElements.clrScheme) {&#13;
						font.color.rgb = rgb_tint(themes.themeElements.clrScheme[font.color.theme].rgb, font.color.tint || 0);&#13;
					}&#13;
				}&#13;
&#13;
				break;&#13;
			case '&lt;color/&gt;': case '&lt;/color&gt;': break;&#13;
&#13;
			/* note: sometimes mc:AlternateContent appears bare */&#13;
			case '&lt;AlternateContent': pass = true; break;&#13;
			case '&lt;/AlternateContent&gt;': pass = false; break;&#13;
&#13;
			/* 18.2.10 extLst CT_ExtensionList ? */&#13;
			case '&lt;extLst': case '&lt;extLst&gt;': case '&lt;/extLst&gt;': break;&#13;
			case '&lt;ext': pass = true; break;&#13;
			case '&lt;/ext&gt;': pass = false; break;&#13;
			default: if(opts &amp;&amp; opts.WTF) {&#13;
				if(!pass) throw new Error('unrecognized ' + y[0] + ' in fonts');&#13;
			}&#13;
		}&#13;
	});&#13;
}&#13;
&#13;
/* 18.8.31 numFmts CT_NumFmts */&#13;
function parse_numFmts(t, styles, opts) {&#13;
	styles.NumberFmt = [];&#13;
	var k/*Array&lt;number&gt;*/ = (keys(table_fmt));&#13;
	for(var i=0; i &lt; k.length; ++i) styles.NumberFmt[k[i]] = table_fmt[k[i]];&#13;
	var m = t[0].match(tagregex);&#13;
	if(!m) return;&#13;
	for(i=0; i &lt; m.length; ++i) {&#13;
		var y = parsexmltag(m[i]);&#13;
		switch(strip_ns(y[0])) {&#13;
			case '&lt;numFmts': case '&lt;/numFmts&gt;': case '&lt;numFmts/&gt;': case '&lt;numFmts&gt;': break;&#13;
			case '&lt;numFmt': {&#13;
				var f=unescapexml(utf8read(y.formatCode)), j=parseInt(y.numFmtId,10);&#13;
				styles.NumberFmt[j] = f;&#13;
				if(j&gt;0) {&#13;
					if(j &gt; 0x188) {&#13;
						for(j = 0x188; j &gt; 0x3c; --j) if(styles.NumberFmt[j] == null) break;&#13;
						styles.NumberFmt[j] = f;&#13;
					}&#13;
					SSF__load(f,j);&#13;
				}&#13;
			} break;&#13;
			case '&lt;/numFmt&gt;': break;&#13;
			default: if(opts.WTF) throw new Error('unrecognized ' + y[0] + ' in numFmts');&#13;
		}&#13;
	}&#13;
}&#13;
&#13;
function write_numFmts(NF) {&#13;
	var o = ["&lt;numFmts&gt;"];&#13;
	[[5,8],[23,26],[41,44],[/*63*/50,/*66],[164,*/392]].forEach(function(r) {&#13;
		for(var i = r[0]; i &lt;= r[1]; ++i) if(NF[i] != null) o[o.length] = (writextag('numFmt',null,{numFmtId:i,formatCode:escapexml(NF[i])}));&#13;
	});&#13;
	if(o.length === 1) return "";&#13;
	o[o.length] = ("&lt;/numFmts&gt;");&#13;
	o[0] = writextag('numFmts', null, { count:o.length-2 }).replace("/&gt;", "&gt;");&#13;
	return o.join("");&#13;
}&#13;
&#13;
/* 18.8.10 cellXfs CT_CellXfs */&#13;
var cellXF_uint = [ "numFmtId", "fillId", "fontId", "borderId", "xfId" ];&#13;
var cellXF_bool = [ "applyAlignment", "applyBorder", "applyFill", "applyFont", "applyNumberFormat", "applyProtection", "pivotButton", "quotePrefix" ];&#13;
function parse_cellXfs(t, styles, opts) {&#13;
	styles.CellXf = [];&#13;
	var xf;&#13;
	var pass = false;&#13;
	(t[0].match(tagregex)||[]).forEach(function(x) {&#13;
		var y = parsexmltag(x), i = 0;&#13;
		switch(strip_ns(y[0])) {&#13;
			case '&lt;cellXfs': case '&lt;cellXfs&gt;': case '&lt;cellXfs/&gt;': case '&lt;/cellXfs&gt;': break;&#13;
&#13;
			/* 18.8.45 xf CT_Xf */&#13;
			case '&lt;xf': case '&lt;xf/&gt;':&#13;
				xf = y;&#13;
				delete xf[0];&#13;
				for(i = 0; i &lt; cellXF_uint.length; ++i) if(xf[cellXF_uint[i]])&#13;
					xf[cellXF_uint[i]] = parseInt(xf[cellXF_uint[i]], 10);&#13;
				for(i = 0; i &lt; cellXF_bool.length; ++i) if(xf[cellXF_bool[i]])&#13;
					xf[cellXF_bool[i]] = parsexmlbool(xf[cellXF_bool[i]]);&#13;
				if(styles.NumberFmt &amp;&amp; xf.numFmtId &gt; 0x188) {&#13;
					for(i = 0x188; i &gt; 0x3c; --i) if(styles.NumberFmt[xf.numFmtId] == styles.NumberFmt[i]) { xf.numFmtId = i; break; }&#13;
				}&#13;
				styles.CellXf.push(xf); break;&#13;
			case '&lt;/xf&gt;': break;&#13;
&#13;
			/* 18.8.1 alignment CT_CellAlignment */&#13;
			case '&lt;alignment': case '&lt;alignment/&gt;':&#13;
				var alignment = {};&#13;
				if(y.vertical) alignment.vertical = y.vertical;&#13;
				if(y.horizontal) alignment.horizontal = y.horizontal;&#13;
				if(y.textRotation != null) alignment.textRotation = y.textRotation;&#13;
				if(y.indent) alignment.indent = y.indent;&#13;
				if(y.wrapText) alignment.wrapText = parsexmlbool(y.wrapText);&#13;
				xf.alignment = alignment;&#13;
				break;&#13;
			case '&lt;/alignment&gt;': break;&#13;
&#13;
			/* 18.8.33 protection CT_CellProtection */&#13;
			case '&lt;protection':&#13;
				break;&#13;
			case '&lt;/protection&gt;': case '&lt;protection/&gt;': break;&#13;
&#13;
			/* note: sometimes mc:AlternateContent appears bare */&#13;
			case '&lt;AlternateContent': pass = true; break;&#13;
			case '&lt;/AlternateContent&gt;': pass = false; break;&#13;
&#13;
			/* 18.2.10 extLst CT_ExtensionList ? */&#13;
			case '&lt;extLst': case '&lt;extLst&gt;': case '&lt;/extLst&gt;': break;&#13;
			case '&lt;ext': pass = true; break;&#13;
			case '&lt;/ext&gt;': pass = false; break;&#13;
			default: if(opts &amp;&amp; opts.WTF) {&#13;
				if(!pass) throw new Error('unrecognized ' + y[0] + ' in cellXfs');&#13;
			}&#13;
		}&#13;
	});&#13;
}&#13;
&#13;
function write_cellXfs(cellXfs) {&#13;
	var o = [];&#13;
	o[o.length] = (writextag('cellXfs',null));&#13;
	cellXfs.forEach(function(c) {&#13;
		o[o.length] = (writextag('xf', null, c));&#13;
	});&#13;
	o[o.length] = ("&lt;/cellXfs&gt;");&#13;
	if(o.length === 2) return "";&#13;
	o[0] = writextag('cellXfs',null, {count:o.length-2}).replace("/&gt;","&gt;");&#13;
	return o.join("");&#13;
}&#13;
&#13;
/* 18.8 Styles CT_Stylesheet*/&#13;
var parse_sty_xml= (function make_pstyx() {&#13;
var numFmtRegex = /&lt;(?:\w+:)?numFmts([^&gt;]*)&gt;[\S\s]*?&lt;\/(?:\w+:)?numFmts&gt;/;&#13;
var cellXfRegex = /&lt;(?:\w+:)?cellXfs([^&gt;]*)&gt;[\S\s]*?&lt;\/(?:\w+:)?cellXfs&gt;/;&#13;
var fillsRegex = /&lt;(?:\w+:)?fills([^&gt;]*)&gt;[\S\s]*?&lt;\/(?:\w+:)?fills&gt;/;&#13;
var fontsRegex = /&lt;(?:\w+:)?fonts([^&gt;]*)&gt;[\S\s]*?&lt;\/(?:\w+:)?fonts&gt;/;&#13;
var bordersRegex = /&lt;(?:\w+:)?borders([^&gt;]*)&gt;[\S\s]*?&lt;\/(?:\w+:)?borders&gt;/;&#13;
&#13;
return function parse_sty_xml(data, themes, opts) {&#13;
	var styles = {};&#13;
	if(!data) return styles;&#13;
	data = data.replace(/&lt;!--([\s\S]*?)--&gt;/mg,"").replace(/&lt;!DOCTYPE[^\[]*\[[^\]]*\]&gt;/gm,"");&#13;
	/* 18.8.39 styleSheet CT_Stylesheet */&#13;
	var t;&#13;
&#13;
	/* 18.8.31 numFmts CT_NumFmts ? */&#13;
	if((t=data.match(numFmtRegex))) parse_numFmts(t, styles, opts);&#13;
&#13;
	/* 18.8.23 fonts CT_Fonts ? */&#13;
	if((t=data.match(fontsRegex))) parse_fonts(t, styles, themes, opts);&#13;
&#13;
	/* 18.8.21 fills CT_Fills ? */&#13;
	if((t=data.match(fillsRegex))) parse_fills(t, styles, themes, opts);&#13;
&#13;
	/* 18.8.5  borders CT_Borders ? */&#13;
	if((t=data.match(bordersRegex))) parse_borders(t, styles, themes, opts);&#13;
&#13;
	/* 18.8.9  cellStyleXfs CT_CellStyleXfs ? */&#13;
	/* 18.8.8  cellStyles CT_CellStyles ? */&#13;
&#13;
	/* 18.8.10 cellXfs CT_CellXfs ? */&#13;
	if((t=data.match(cellXfRegex))) parse_cellXfs(t, styles, opts);&#13;
&#13;
	/* 18.8.15 dxfs CT_Dxfs ? */&#13;
	/* 18.8.42 tableStyles CT_TableStyles ? */&#13;
	/* 18.8.11 colors CT_Colors ? */&#13;
	/* 18.2.10 extLst CT_ExtensionList ? */&#13;
&#13;
	return styles;&#13;
};&#13;
})();&#13;
&#13;
function write_sty_xml(wb, opts) {&#13;
	var o = [XML_HEADER, writextag('styleSheet', null, {&#13;
		'xmlns': XMLNS_main[0],&#13;
		'xmlns:vt': XMLNS.vt&#13;
	})], w;&#13;
	if(wb.SSF &amp;&amp; (w = write_numFmts(wb.SSF)) != null) o[o.length] = w;&#13;
	o[o.length] = ('&lt;fonts count="1"&gt;&lt;font&gt;&lt;sz val="12"/&gt;&lt;color theme="1"/&gt;&lt;name val="Calibri"/&gt;&lt;family val="2"/&gt;&lt;scheme val="minor"/&gt;&lt;/font&gt;&lt;/fonts&gt;');&#13;
	o[o.length] = ('&lt;fills count="2"&gt;&lt;fill&gt;&lt;patternFill patternType="none"/&gt;&lt;/fill&gt;&lt;fill&gt;&lt;patternFill patternType="gray125"/&gt;&lt;/fill&gt;&lt;/fills&gt;');&#13;
	o[o.length] = ('&lt;borders count="1"&gt;&lt;border&gt;&lt;left/&gt;&lt;right/&gt;&lt;top/&gt;&lt;bottom/&gt;&lt;diagonal/&gt;&lt;/border&gt;&lt;/borders&gt;');&#13;
	o[o.length] = ('&lt;cellStyleXfs count="1"&gt;&lt;xf numFmtId="0" fontId="0" fillId="0" borderId="0"/&gt;&lt;/cellStyleXfs&gt;');&#13;
	if((w = write_cellXfs(opts.cellXfs))) o[o.length] = (w);&#13;
	o[o.length] = ('&lt;cellStyles count="1"&gt;&lt;cellStyle name="Normal" xfId="0" builtinId="0"/&gt;&lt;/cellStyles&gt;');&#13;
	o[o.length] = ('&lt;dxfs count="0"/&gt;');&#13;
	o[o.length] = ('&lt;tableStyles count="0" defaultTableStyle="TableStyleMedium9" defaultPivotStyle="PivotStyleMedium4"/&gt;');&#13;
&#13;
	if(o.length&gt;2){ o[o.length] = ('&lt;/styleSheet&gt;'); o[1]=o[1].replace("/&gt;","&gt;"); }&#13;
	return o.join("");&#13;
}&#13;
/* [MS-XLSB] 2.4.657 BrtFmt */&#13;
function parse_BrtFmt(data, length) {&#13;
	var numFmtId = data.read_shift(2);&#13;
	var stFmtCode = parse_XLWideString(data,length-2);&#13;
	return [numFmtId, stFmtCode];&#13;
}&#13;
function write_BrtFmt(i, f, o) {&#13;
	if(!o) o = new_buf(6 + 4 * f.length);&#13;
	o.write_shift(2, i);&#13;
	write_XLWideString(f, o);&#13;
	var out = (o.length &gt; o.l) ? o.slice(0, o.l) : o;&#13;
	if(o.l == null) o.l = o.length;&#13;
	return out;&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.4.659 BrtFont TODO */&#13;
function parse_BrtFont(data, length, opts) {&#13;
	var out = ({});&#13;
&#13;
	out.sz = data.read_shift(2) / 20;&#13;
&#13;
	var grbit = parse_FontFlags(data, 2, opts);&#13;
	if(grbit.fItalic) out.italic = 1;&#13;
	if(grbit.fCondense) out.condense = 1;&#13;
	if(grbit.fExtend) out.extend = 1;&#13;
	if(grbit.fShadow) out.shadow = 1;&#13;
	if(grbit.fOutline) out.outline = 1;&#13;
	if(grbit.fStrikeout) out.strike = 1;&#13;
&#13;
	var bls = data.read_shift(2);&#13;
	if(bls === 0x02BC) out.bold = 1;&#13;
&#13;
	switch(data.read_shift(2)) {&#13;
		/* case 0: out.vertAlign = "baseline"; break; */&#13;
		case 1: out.vertAlign = "superscript"; break;&#13;
		case 2: out.vertAlign = "subscript"; break;&#13;
	}&#13;
&#13;
	var underline = data.read_shift(1);&#13;
	if(underline != 0) out.underline = underline;&#13;
&#13;
	var family = data.read_shift(1);&#13;
	if(family &gt; 0) out.family = family;&#13;
&#13;
	var bCharSet = data.read_shift(1);&#13;
	if(bCharSet &gt; 0) out.charset = bCharSet;&#13;
&#13;
	data.l++;&#13;
	out.color = parse_BrtColor(data, 8);&#13;
&#13;
	switch(data.read_shift(1)) {&#13;
		/* case 0: out.scheme = "none": break; */&#13;
		case 1: out.scheme = "major"; break;&#13;
		case 2: out.scheme = "minor"; break;&#13;
	}&#13;
&#13;
	out.name = parse_XLWideString(data, length - 21);&#13;
&#13;
	return out;&#13;
}&#13;
function write_BrtFont(font, o) {&#13;
	if(!o) o = new_buf(25+4*32);&#13;
	o.write_shift(2, font.sz * 20);&#13;
	write_FontFlags(font, o);&#13;
	o.write_shift(2, font.bold ? 0x02BC : 0x0190);&#13;
	var sss = 0;&#13;
	if(font.vertAlign == "superscript") sss = 1;&#13;
	else if(font.vertAlign == "subscript") sss = 2;&#13;
	o.write_shift(2, sss);&#13;
	o.write_shift(1, font.underline || 0);&#13;
	o.write_shift(1, font.family || 0);&#13;
	o.write_shift(1, font.charset || 0);&#13;
	o.write_shift(1, 0);&#13;
	write_BrtColor(font.color, o);&#13;
	var scheme = 0;&#13;
	if(font.scheme == "major") scheme = 1;&#13;
	if(font.scheme == "minor") scheme = 2;&#13;
	o.write_shift(1, scheme);&#13;
	write_XLWideString(font.name, o);&#13;
	return o.length &gt; o.l ? o.slice(0, o.l) : o;&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.4.650 BrtFill */&#13;
var XLSBFillPTNames = [&#13;
	"none",&#13;
	"solid",&#13;
	"mediumGray",&#13;
	"darkGray",&#13;
	"lightGray",&#13;
	"darkHorizontal",&#13;
	"darkVertical",&#13;
	"darkDown",&#13;
	"darkUp",&#13;
	"darkGrid",&#13;
	"darkTrellis",&#13;
	"lightHorizontal",&#13;
	"lightVertical",&#13;
	"lightDown",&#13;
	"lightUp",&#13;
	"lightGrid",&#13;
	"lightTrellis",&#13;
	"gray125",&#13;
	"gray0625"&#13;
];&#13;
var rev_XLSBFillPTNames;&#13;
/* TODO: gradient fill representation */&#13;
var parse_BrtFill = parsenoop;&#13;
function write_BrtFill(fill, o) {&#13;
	if(!o) o = new_buf(4*3 + 8*7 + 16*1);&#13;
	if(!rev_XLSBFillPTNames) rev_XLSBFillPTNames = (evert(XLSBFillPTNames));&#13;
	var fls = rev_XLSBFillPTNames[fill.patternType];&#13;
	if(fls == null) fls = 0x28;&#13;
	o.write_shift(4, fls);&#13;
	var j = 0;&#13;
	if(fls != 0x28) {&#13;
		/* TODO: custom FG Color */&#13;
		write_BrtColor({auto:1}, o);&#13;
		/* TODO: custom BG Color */&#13;
		write_BrtColor({auto:1}, o);&#13;
&#13;
		for(; j &lt; 12; ++j) o.write_shift(4, 0);&#13;
	} else {&#13;
		for(; j &lt; 4; ++j) o.write_shift(4, 0);&#13;
&#13;
		for(; j &lt; 12; ++j) o.write_shift(4, 0); /* TODO */&#13;
		/* iGradientType */&#13;
		/* xnumDegree */&#13;
		/* xnumFillToLeft */&#13;
		/* xnumFillToRight */&#13;
		/* xnumFillToTop */&#13;
		/* xnumFillToBottom */&#13;
		/* cNumStop */&#13;
		/* xfillGradientStop */&#13;
	}&#13;
	return o.length &gt; o.l ? o.slice(0, o.l) : o;&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.4.824 BrtXF */&#13;
function parse_BrtXF(data, length) {&#13;
	var tgt = data.l + length;&#13;
	var ixfeParent = data.read_shift(2);&#13;
	var ifmt = data.read_shift(2);&#13;
	data.l = tgt;&#13;
	return {ixfe:ixfeParent, numFmtId:ifmt };&#13;
}&#13;
function write_BrtXF(data, ixfeP, o) {&#13;
	if(!o) o = new_buf(16);&#13;
	o.write_shift(2, ixfeP||0);&#13;
	o.write_shift(2, data.numFmtId||0);&#13;
	o.write_shift(2, 0); /* iFont */&#13;
	o.write_shift(2, 0); /* iFill */&#13;
	o.write_shift(2, 0); /* ixBorder */&#13;
	o.write_shift(1, 0); /* trot */&#13;
	o.write_shift(1, 0); /* indent */&#13;
	var flow = 0;&#13;
	o.write_shift(1, flow); /* flags */&#13;
	o.write_shift(1, 0); /* flags */&#13;
	o.write_shift(1, 0); /* xfGrbitAtr */&#13;
	o.write_shift(1, 0);&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.5.4 Blxf TODO */&#13;
function write_Blxf(data, o) {&#13;
	if(!o) o = new_buf(10);&#13;
	o.write_shift(1, 0); /* dg */&#13;
	o.write_shift(1, 0);&#13;
	o.write_shift(4, 0); /* color */&#13;
	o.write_shift(4, 0); /* color */&#13;
	return o;&#13;
}&#13;
/* [MS-XLSB] 2.4.302 BrtBorder TODO */&#13;
var parse_BrtBorder = parsenoop;&#13;
function write_BrtBorder(border, o) {&#13;
	if(!o) o = new_buf(51);&#13;
	o.write_shift(1, 0); /* diagonal */&#13;
	write_Blxf(null, o); /* top */&#13;
	write_Blxf(null, o); /* bottom */&#13;
	write_Blxf(null, o); /* left */&#13;
	write_Blxf(null, o); /* right */&#13;
	write_Blxf(null, o); /* diag */&#13;
	return o.length &gt; o.l ? o.slice(0, o.l) : o;&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.4.763 BrtStyle TODO */&#13;
function write_BrtStyle(style, o) {&#13;
	if(!o) o = new_buf(12+4*10);&#13;
	o.write_shift(4, style.xfId);&#13;
	o.write_shift(2, 1);&#13;
	o.write_shift(1, +style.builtinId);&#13;
	o.write_shift(1, 0); /* iLevel */&#13;
	write_XLNullableWideString(style.name || "", o);&#13;
	return o.length &gt; o.l ? o.slice(0, o.l) : o;&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.4.272 BrtBeginTableStyles */&#13;
function write_BrtBeginTableStyles(cnt, defTableStyle, defPivotStyle) {&#13;
	var o = new_buf(4+256*2*4);&#13;
	o.write_shift(4, cnt);&#13;
	write_XLNullableWideString(defTableStyle, o);&#13;
	write_XLNullableWideString(defPivotStyle, o);&#13;
	return o.length &gt; o.l ? o.slice(0, o.l) : o;&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.1.7.50 Styles */&#13;
function parse_sty_bin(data, themes, opts) {&#13;
	var styles = {};&#13;
	styles.NumberFmt = ([]);&#13;
	for(var y in table_fmt) styles.NumberFmt[y] = table_fmt[y];&#13;
&#13;
	styles.CellXf = [];&#13;
	styles.Fonts = [];&#13;
	var state = [];&#13;
	var pass = false;&#13;
	recordhopper(data, function hopper_sty(val, R, RT) {&#13;
		switch(RT) {&#13;
			case 0x002C: /* BrtFmt */&#13;
				styles.NumberFmt[val[0]] = val[1]; SSF__load(val[1], val[0]);&#13;
				break;&#13;
			case 0x002B: /* BrtFont */&#13;
				styles.Fonts.push(val);&#13;
				if(val.color.theme != null &amp;&amp; themes &amp;&amp; themes.themeElements &amp;&amp; themes.themeElements.clrScheme) {&#13;
					val.color.rgb = rgb_tint(themes.themeElements.clrScheme[val.color.theme].rgb, val.color.tint || 0);&#13;
				}&#13;
				break;&#13;
			case 0x0401: /* BrtKnownFonts */ break;&#13;
			case 0x002D: /* BrtFill */&#13;
				break;&#13;
			case 0x002E: /* BrtBorder */&#13;
				break;&#13;
			case 0x002F: /* BrtXF */&#13;
				if(state[state.length - 1] == 0x0269 /* BrtBeginCellXFs */) {&#13;
					styles.CellXf.push(val);&#13;
				}&#13;
				break;&#13;
			case 0x0030: /* BrtStyle */&#13;
			case 0x01FB: /* BrtDXF */&#13;
			case 0x023C: /* BrtMRUColor */&#13;
			case 0x01DB: /* BrtIndexedColor */&#13;
				break;&#13;
&#13;
			case 0x0493: /* BrtDXF14 */&#13;
			case 0x0836: /* BrtDXF15 */&#13;
			case 0x046A: /* BrtSlicerStyleElement */&#13;
			case 0x0200: /* BrtTableStyleElement */&#13;
			case 0x082F: /* BrtTimelineStyleElement */&#13;
			case 0x0C00: /* BrtUid */&#13;
				break;&#13;
&#13;
			case 0x0023: /* BrtFRTBegin */&#13;
				pass = true; break;&#13;
			case 0x0024: /* BrtFRTEnd */&#13;
				pass = false; break;&#13;
			case 0x0025: /* BrtACBegin */&#13;
				state.push(RT); pass = true; break;&#13;
			case 0x0026: /* BrtACEnd */&#13;
				state.pop(); pass = false; break;&#13;
&#13;
			default:&#13;
				if(R.T &gt; 0) state.push(RT);&#13;
				else if(R.T &lt; 0) state.pop();&#13;
				else if(!pass || (opts.WTF &amp;&amp; state[state.length-1] != 0x0025 /* BrtACBegin */)) throw new Error("Unexpected record 0x" + RT.toString(16));&#13;
		}&#13;
	});&#13;
	return styles;&#13;
}&#13;
&#13;
function write_FMTS_bin(ba, NF) {&#13;
	if(!NF) return;&#13;
	var cnt = 0;&#13;
	[[5,8],[23,26],[41,44],[/*63*/50,/*66],[164,*/392]].forEach(function(r) {&#13;
for(var i = r[0]; i &lt;= r[1]; ++i) if(NF[i] != null) ++cnt;&#13;
	});&#13;
&#13;
	if(cnt == 0) return;&#13;
	write_record(ba, 0x0267 /* BrtBeginFmts */, write_UInt32LE(cnt));&#13;
	[[5,8],[23,26],[41,44],[/*63*/50,/*66],[164,*/392]].forEach(function(r) {&#13;
for(var i = r[0]; i &lt;= r[1]; ++i) if(NF[i] != null) write_record(ba, 0x002C /* BrtFmt */, write_BrtFmt(i, NF[i]));&#13;
	});&#13;
	write_record(ba, 0x0268 /* BrtEndFmts */);&#13;
}&#13;
&#13;
function write_FONTS_bin(ba) {&#13;
	var cnt = 1;&#13;
&#13;
	if(cnt == 0) return;&#13;
	write_record(ba, 0x0263 /* BrtBeginFonts */, write_UInt32LE(cnt));&#13;
	write_record(ba, 0x002B /* BrtFont */, write_BrtFont({&#13;
		sz:12,&#13;
		color: {theme:1},&#13;
		name: "Calibri",&#13;
		family: 2,&#13;
		scheme: "minor"&#13;
	}));&#13;
	/* 1*65491BrtFont [ACFONTS] */&#13;
	write_record(ba, 0x0264 /* BrtEndFonts */);&#13;
}&#13;
&#13;
function write_FILLS_bin(ba) {&#13;
	var cnt = 2;&#13;
&#13;
	if(cnt == 0) return;&#13;
	write_record(ba, 0x025B /* BrtBeginFills */, write_UInt32LE(cnt));&#13;
	write_record(ba, 0x002D /* BrtFill */, write_BrtFill({patternType:"none"}));&#13;
	write_record(ba, 0x002D /* BrtFill */, write_BrtFill({patternType:"gray125"}));&#13;
	/* 1*65431BrtFill */&#13;
	write_record(ba, 0x025C /* BrtEndFills */);&#13;
}&#13;
&#13;
function write_BORDERS_bin(ba) {&#13;
	var cnt = 1;&#13;
&#13;
	if(cnt == 0) return;&#13;
	write_record(ba, 0x0265 /* BrtBeginBorders */, write_UInt32LE(cnt));&#13;
	write_record(ba, 0x002E /* BrtBorder */, write_BrtBorder({}));&#13;
	/* 1*65430BrtBorder */&#13;
	write_record(ba, 0x0266 /* BrtEndBorders */);&#13;
}&#13;
&#13;
function write_CELLSTYLEXFS_bin(ba) {&#13;
	var cnt = 1;&#13;
	write_record(ba, 0x0272 /* BrtBeginCellStyleXFs */, write_UInt32LE(cnt));&#13;
	write_record(ba, 0x002F /* BrtXF */, write_BrtXF({&#13;
		numFmtId: 0,&#13;
		fontId:   0,&#13;
		fillId:   0,&#13;
		borderId: 0&#13;
	}, 0xFFFF));&#13;
	/* 1*65430(BrtXF *FRT) */&#13;
	write_record(ba, 0x0273 /* BrtEndCellStyleXFs */);&#13;
}&#13;
&#13;
function write_CELLXFS_bin(ba, data) {&#13;
	write_record(ba, 0x0269 /* BrtBeginCellXFs */, write_UInt32LE(data.length));&#13;
	data.forEach(function(c) { write_record(ba, 0x002F /* BrtXF */, write_BrtXF(c,0)); });&#13;
	/* 1*65430(BrtXF *FRT) */&#13;
	write_record(ba, 0x026A /* BrtEndCellXFs */);&#13;
}&#13;
&#13;
function write_STYLES_bin(ba) {&#13;
	var cnt = 1;&#13;
&#13;
	write_record(ba, 0x026B /* BrtBeginStyles */, write_UInt32LE(cnt));&#13;
	write_record(ba, 0x0030 /* BrtStyle */, write_BrtStyle({&#13;
		xfId:0,&#13;
		builtinId:0,&#13;
		name:"Normal"&#13;
	}));&#13;
	/* 1*65430(BrtStyle *FRT) */&#13;
	write_record(ba, 0x026C /* BrtEndStyles */);&#13;
}&#13;
&#13;
function write_DXFS_bin(ba) {&#13;
	var cnt = 0;&#13;
&#13;
	write_record(ba, 0x01F9 /* BrtBeginDXFs */, write_UInt32LE(cnt));&#13;
	/* *2147483647(BrtDXF *FRT) */&#13;
	write_record(ba, 0x01FA /* BrtEndDXFs */);&#13;
}&#13;
&#13;
function write_TABLESTYLES_bin(ba) {&#13;
	var cnt = 0;&#13;
&#13;
	write_record(ba, 0x01FC /* BrtBeginTableStyles */, write_BrtBeginTableStyles(cnt, "TableStyleMedium9", "PivotStyleMedium4"));&#13;
	/* *TABLESTYLE */&#13;
	write_record(ba, 0x01FD /* BrtEndTableStyles */);&#13;
}&#13;
&#13;
function write_COLORPALETTE_bin() {&#13;
	return;&#13;
	/* BrtBeginColorPalette [INDEXEDCOLORS] [MRUCOLORS] BrtEndColorPalette */&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.1.7.50 Styles */&#13;
function write_sty_bin(wb, opts) {&#13;
	var ba = buf_array();&#13;
	write_record(ba, 0x0116 /* BrtBeginStyleSheet */);&#13;
	write_FMTS_bin(ba, wb.SSF);&#13;
	write_FONTS_bin(ba, wb);&#13;
	write_FILLS_bin(ba, wb);&#13;
	write_BORDERS_bin(ba, wb);&#13;
	write_CELLSTYLEXFS_bin(ba, wb);&#13;
	write_CELLXFS_bin(ba, opts.cellXfs);&#13;
	write_STYLES_bin(ba, wb);&#13;
	write_DXFS_bin(ba, wb);&#13;
	write_TABLESTYLES_bin(ba, wb);&#13;
	write_COLORPALETTE_bin(ba, wb);&#13;
	/* FRTSTYLESHEET*/&#13;
	write_record(ba, 0x0117 /* BrtEndStyleSheet */);&#13;
	return ba.end();&#13;
}&#13;
/* Even though theme layout is dk1 lt1 dk2 lt2, true order is lt1 dk1 lt2 dk2 */&#13;
var XLSXThemeClrScheme = [&#13;
	'&lt;/a:lt1&gt;', '&lt;/a:dk1&gt;', '&lt;/a:lt2&gt;', '&lt;/a:dk2&gt;',&#13;
	'&lt;/a:accent1&gt;', '&lt;/a:accent2&gt;', '&lt;/a:accent3&gt;',&#13;
	'&lt;/a:accent4&gt;', '&lt;/a:accent5&gt;', '&lt;/a:accent6&gt;',&#13;
	'&lt;/a:hlink&gt;', '&lt;/a:folHlink&gt;'&#13;
];&#13;
/* 20.1.6.2 clrScheme CT_ColorScheme */&#13;
function parse_clrScheme(t, themes, opts) {&#13;
	themes.themeElements.clrScheme = [];&#13;
	var color = {};&#13;
	(t[0].match(tagregex)||[]).forEach(function(x) {&#13;
		var y = parsexmltag(x);&#13;
		switch(y[0]) {&#13;
			/* 20.1.6.2 clrScheme (Color Scheme) CT_ColorScheme */&#13;
			case '&lt;a:clrScheme': case '&lt;/a:clrScheme&gt;': break;&#13;
&#13;
			/* 20.1.2.3.32 srgbClr CT_SRgbColor */&#13;
			case '&lt;a:srgbClr':&#13;
				color.rgb = y.val; break;&#13;
&#13;
			/* 20.1.2.3.33 sysClr CT_SystemColor */&#13;
			case '&lt;a:sysClr':&#13;
				color.rgb = y.lastClr; break;&#13;
&#13;
			/* 20.1.4.1.1 accent1 (Accent 1) */&#13;
			/* 20.1.4.1.2 accent2 (Accent 2) */&#13;
			/* 20.1.4.1.3 accent3 (Accent 3) */&#13;
			/* 20.1.4.1.4 accent4 (Accent 4) */&#13;
			/* 20.1.4.1.5 accent5 (Accent 5) */&#13;
			/* 20.1.4.1.6 accent6 (Accent 6) */&#13;
			/* 20.1.4.1.9 dk1 (Dark 1) */&#13;
			/* 20.1.4.1.10 dk2 (Dark 2) */&#13;
			/* 20.1.4.1.15 folHlink (Followed Hyperlink) */&#13;
			/* 20.1.4.1.19 hlink (Hyperlink) */&#13;
			/* 20.1.4.1.22 lt1 (Light 1) */&#13;
			/* 20.1.4.1.23 lt2 (Light 2) */&#13;
			case '&lt;a:dk1&gt;': case '&lt;/a:dk1&gt;':&#13;
			case '&lt;a:lt1&gt;': case '&lt;/a:lt1&gt;':&#13;
			case '&lt;a:dk2&gt;': case '&lt;/a:dk2&gt;':&#13;
			case '&lt;a:lt2&gt;': case '&lt;/a:lt2&gt;':&#13;
			case '&lt;a:accent1&gt;': case '&lt;/a:accent1&gt;':&#13;
			case '&lt;a:accent2&gt;': case '&lt;/a:accent2&gt;':&#13;
			case '&lt;a:accent3&gt;': case '&lt;/a:accent3&gt;':&#13;
			case '&lt;a:accent4&gt;': case '&lt;/a:accent4&gt;':&#13;
			case '&lt;a:accent5&gt;': case '&lt;/a:accent5&gt;':&#13;
			case '&lt;a:accent6&gt;': case '&lt;/a:accent6&gt;':&#13;
			case '&lt;a:hlink&gt;': case '&lt;/a:hlink&gt;':&#13;
			case '&lt;a:folHlink&gt;': case '&lt;/a:folHlink&gt;':&#13;
				if (y[0].charAt(1) === '/') {&#13;
					themes.themeElements.clrScheme[XLSXThemeClrScheme.indexOf(y[0])] = color;&#13;
					color = {};&#13;
				} else {&#13;
					color.name = y[0].slice(3, y[0].length - 1);&#13;
				}&#13;
				break;&#13;
&#13;
			default: if(opts &amp;&amp; opts.WTF) throw new Error('Unrecognized ' + y[0] + ' in clrScheme');&#13;
		}&#13;
	});&#13;
}&#13;
&#13;
/* 20.1.4.1.18 fontScheme CT_FontScheme */&#13;
function parse_fontScheme() { }&#13;
&#13;
/* 20.1.4.1.15 fmtScheme CT_StyleMatrix */&#13;
function parse_fmtScheme() { }&#13;
&#13;
var clrsregex = /&lt;a:clrScheme([^&gt;]*)&gt;[\s\S]*&lt;\/a:clrScheme&gt;/;&#13;
var fntsregex = /&lt;a:fontScheme([^&gt;]*)&gt;[\s\S]*&lt;\/a:fontScheme&gt;/;&#13;
var fmtsregex = /&lt;a:fmtScheme([^&gt;]*)&gt;[\s\S]*&lt;\/a:fmtScheme&gt;/;&#13;
&#13;
/* 20.1.6.10 themeElements CT_BaseStyles */&#13;
function parse_themeElements(data, themes, opts) {&#13;
	themes.themeElements = {};&#13;
&#13;
	var t;&#13;
&#13;
	[&#13;
		/* clrScheme CT_ColorScheme */&#13;
		['clrScheme', clrsregex, parse_clrScheme],&#13;
		/* fontScheme CT_FontScheme */&#13;
		['fontScheme', fntsregex, parse_fontScheme],&#13;
		/* fmtScheme CT_StyleMatrix */&#13;
		['fmtScheme', fmtsregex, parse_fmtScheme]&#13;
	].forEach(function(m) {&#13;
		if(!(t=data.match(m[1]))) throw new Error(m[0] + ' not found in themeElements');&#13;
		m[2](t, themes, opts);&#13;
	});&#13;
}&#13;
&#13;
var themeltregex = /&lt;a:themeElements([^&gt;]*)&gt;[\s\S]*&lt;\/a:themeElements&gt;/;&#13;
&#13;
/* 14.2.7 Theme Part */&#13;
function parse_theme_xml(data, opts) {&#13;
	/* 20.1.6.9 theme CT_OfficeStyleSheet */&#13;
	if(!data || data.length === 0) data = write_theme();&#13;
&#13;
	var t;&#13;
	var themes = {};&#13;
&#13;
	/* themeElements CT_BaseStyles */&#13;
	if(!(t=data.match(themeltregex))) throw new Error('themeElements not found in theme');&#13;
	parse_themeElements(t[0], themes, opts);&#13;
	themes.raw = data;&#13;
	return themes;&#13;
}&#13;
&#13;
function write_theme(Themes, opts) {&#13;
	if(opts &amp;&amp; opts.themeXLSX) return opts.themeXLSX;&#13;
	if(Themes &amp;&amp; typeof Themes.raw == "string") return Themes.raw;&#13;
	var o = [XML_HEADER];&#13;
	o[o.length] = '&lt;a:theme xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" name="Office Theme"&gt;';&#13;
	o[o.length] =  '&lt;a:themeElements&gt;';&#13;
&#13;
	o[o.length] =   '&lt;a:clrScheme name="Office"&gt;';&#13;
	o[o.length] =    '&lt;a:dk1&gt;&lt;a:sysClr val="windowText" lastClr="000000"/&gt;&lt;/a:dk1&gt;';&#13;
	o[o.length] =    '&lt;a:lt1&gt;&lt;a:sysClr val="window" lastClr="FFFFFF"/&gt;&lt;/a:lt1&gt;';&#13;
	o[o.length] =    '&lt;a:dk2&gt;&lt;a:srgbClr val="1F497D"/&gt;&lt;/a:dk2&gt;';&#13;
	o[o.length] =    '&lt;a:lt2&gt;&lt;a:srgbClr val="EEECE1"/&gt;&lt;/a:lt2&gt;';&#13;
	o[o.length] =    '&lt;a:accent1&gt;&lt;a:srgbClr val="4F81BD"/&gt;&lt;/a:accent1&gt;';&#13;
	o[o.length] =    '&lt;a:accent2&gt;&lt;a:srgbClr val="C0504D"/&gt;&lt;/a:accent2&gt;';&#13;
	o[o.length] =    '&lt;a:accent3&gt;&lt;a:srgbClr val="9BBB59"/&gt;&lt;/a:accent3&gt;';&#13;
	o[o.length] =    '&lt;a:accent4&gt;&lt;a:srgbClr val="8064A2"/&gt;&lt;/a:accent4&gt;';&#13;
	o[o.length] =    '&lt;a:accent5&gt;&lt;a:srgbClr val="4BACC6"/&gt;&lt;/a:accent5&gt;';&#13;
	o[o.length] =    '&lt;a:accent6&gt;&lt;a:srgbClr val="F79646"/&gt;&lt;/a:accent6&gt;';&#13;
	o[o.length] =    '&lt;a:hlink&gt;&lt;a:srgbClr val="0000FF"/&gt;&lt;/a:hlink&gt;';&#13;
	o[o.length] =    '&lt;a:folHlink&gt;&lt;a:srgbClr val="800080"/&gt;&lt;/a:folHlink&gt;';&#13;
	o[o.length] =   '&lt;/a:clrScheme&gt;';&#13;
&#13;
	o[o.length] =   '&lt;a:fontScheme name="Office"&gt;';&#13;
	o[o.length] =    '&lt;a:majorFont&gt;';&#13;
	o[o.length] =     '&lt;a:latin typeface="Cambria"/&gt;';&#13;
	o[o.length] =     '&lt;a:ea typeface=""/&gt;';&#13;
	o[o.length] =     '&lt;a:cs typeface=""/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Jpan" typeface="ＭＳ Ｐゴシック"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Hang" typeface="맑은 고딕"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Hans" typeface="宋体"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Hant" typeface="新細明體"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Arab" typeface="Times New Roman"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Hebr" typeface="Times New Roman"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Thai" typeface="Tahoma"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Ethi" typeface="Nyala"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Beng" typeface="Vrinda"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Gujr" typeface="Shruti"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Khmr" typeface="MoolBoran"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Knda" typeface="Tunga"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Guru" typeface="Raavi"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Cans" typeface="Euphemia"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Cher" typeface="Plantagenet Cherokee"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Yiii" typeface="Microsoft Yi Baiti"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Tibt" typeface="Microsoft Himalaya"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Thaa" typeface="MV Boli"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Deva" typeface="Mangal"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Telu" typeface="Gautami"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Taml" typeface="Latha"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Syrc" typeface="Estrangelo Edessa"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Orya" typeface="Kalinga"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Mlym" typeface="Kartika"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Laoo" typeface="DokChampa"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Sinh" typeface="Iskoola Pota"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Mong" typeface="Mongolian Baiti"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Viet" typeface="Times New Roman"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Uigh" typeface="Microsoft Uighur"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Geor" typeface="Sylfaen"/&gt;';&#13;
	o[o.length] =    '&lt;/a:majorFont&gt;';&#13;
	o[o.length] =    '&lt;a:minorFont&gt;';&#13;
	o[o.length] =     '&lt;a:latin typeface="Calibri"/&gt;';&#13;
	o[o.length] =     '&lt;a:ea typeface=""/&gt;';&#13;
	o[o.length] =     '&lt;a:cs typeface=""/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Jpan" typeface="ＭＳ Ｐゴシック"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Hang" typeface="맑은 고딕"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Hans" typeface="宋体"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Hant" typeface="新細明體"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Arab" typeface="Arial"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Hebr" typeface="Arial"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Thai" typeface="Tahoma"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Ethi" typeface="Nyala"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Beng" typeface="Vrinda"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Gujr" typeface="Shruti"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Khmr" typeface="DaunPenh"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Knda" typeface="Tunga"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Guru" typeface="Raavi"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Cans" typeface="Euphemia"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Cher" typeface="Plantagenet Cherokee"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Yiii" typeface="Microsoft Yi Baiti"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Tibt" typeface="Microsoft Himalaya"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Thaa" typeface="MV Boli"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Deva" typeface="Mangal"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Telu" typeface="Gautami"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Taml" typeface="Latha"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Syrc" typeface="Estrangelo Edessa"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Orya" typeface="Kalinga"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Mlym" typeface="Kartika"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Laoo" typeface="DokChampa"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Sinh" typeface="Iskoola Pota"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Mong" typeface="Mongolian Baiti"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Viet" typeface="Arial"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Uigh" typeface="Microsoft Uighur"/&gt;';&#13;
	o[o.length] =     '&lt;a:font script="Geor" typeface="Sylfaen"/&gt;';&#13;
	o[o.length] =    '&lt;/a:minorFont&gt;';&#13;
	o[o.length] =   '&lt;/a:fontScheme&gt;';&#13;
&#13;
	o[o.length] =   '&lt;a:fmtScheme name="Office"&gt;';&#13;
	o[o.length] =    '&lt;a:fillStyleLst&gt;';&#13;
	o[o.length] =     '&lt;a:solidFill&gt;&lt;a:schemeClr val="phClr"/&gt;&lt;/a:solidFill&gt;';&#13;
	o[o.length] =     '&lt;a:gradFill rotWithShape="1"&gt;';&#13;
	o[o.length] =      '&lt;a:gsLst&gt;';&#13;
	o[o.length] =       '&lt;a:gs pos="0"&gt;&lt;a:schemeClr val="phClr"&gt;&lt;a:tint val="50000"/&gt;&lt;a:satMod val="300000"/&gt;&lt;/a:schemeClr&gt;&lt;/a:gs&gt;';&#13;
	o[o.length] =       '&lt;a:gs pos="35000"&gt;&lt;a:schemeClr val="phClr"&gt;&lt;a:tint val="37000"/&gt;&lt;a:satMod val="300000"/&gt;&lt;/a:schemeClr&gt;&lt;/a:gs&gt;';&#13;
	o[o.length] =       '&lt;a:gs pos="100000"&gt;&lt;a:schemeClr val="phClr"&gt;&lt;a:tint val="15000"/&gt;&lt;a:satMod val="350000"/&gt;&lt;/a:schemeClr&gt;&lt;/a:gs&gt;';&#13;
	o[o.length] =      '&lt;/a:gsLst&gt;';&#13;
	o[o.length] =      '&lt;a:lin ang="16200000" scaled="1"/&gt;';&#13;
	o[o.length] =     '&lt;/a:gradFill&gt;';&#13;
	o[o.length] =     '&lt;a:gradFill rotWithShape="1"&gt;';&#13;
	o[o.length] =      '&lt;a:gsLst&gt;';&#13;
	o[o.length] =       '&lt;a:gs pos="0"&gt;&lt;a:schemeClr val="phClr"&gt;&lt;a:tint val="100000"/&gt;&lt;a:shade val="100000"/&gt;&lt;a:satMod val="130000"/&gt;&lt;/a:schemeClr&gt;&lt;/a:gs&gt;';&#13;
	o[o.length] =       '&lt;a:gs pos="100000"&gt;&lt;a:schemeClr val="phClr"&gt;&lt;a:tint val="50000"/&gt;&lt;a:shade val="100000"/&gt;&lt;a:satMod val="350000"/&gt;&lt;/a:schemeClr&gt;&lt;/a:gs&gt;';&#13;
	o[o.length] =      '&lt;/a:gsLst&gt;';&#13;
	o[o.length] =      '&lt;a:lin ang="16200000" scaled="0"/&gt;';&#13;
	o[o.length] =     '&lt;/a:gradFill&gt;';&#13;
	o[o.length] =    '&lt;/a:fillStyleLst&gt;';&#13;
	o[o.length] =    '&lt;a:lnStyleLst&gt;';&#13;
	o[o.length] =     '&lt;a:ln w="9525" cap="flat" cmpd="sng" algn="ctr"&gt;&lt;a:solidFill&gt;&lt;a:schemeClr val="phClr"&gt;&lt;a:shade val="95000"/&gt;&lt;a:satMod val="105000"/&gt;&lt;/a:schemeClr&gt;&lt;/a:solidFill&gt;&lt;a:prstDash val="solid"/&gt;&lt;/a:ln&gt;';&#13;
	o[o.length] =     '&lt;a:ln w="25400" cap="flat" cmpd="sng" algn="ctr"&gt;&lt;a:solidFill&gt;&lt;a:schemeClr val="phClr"/&gt;&lt;/a:solidFill&gt;&lt;a:prstDash val="solid"/&gt;&lt;/a:ln&gt;';&#13;
	o[o.length] =     '&lt;a:ln w="38100" cap="flat" cmpd="sng" algn="ctr"&gt;&lt;a:solidFill&gt;&lt;a:schemeClr val="phClr"/&gt;&lt;/a:solidFill&gt;&lt;a:prstDash val="solid"/&gt;&lt;/a:ln&gt;';&#13;
	o[o.length] =    '&lt;/a:lnStyleLst&gt;';&#13;
	o[o.length] =    '&lt;a:effectStyleLst&gt;';&#13;
	o[o.length] =     '&lt;a:effectStyle&gt;';&#13;
	o[o.length] =      '&lt;a:effectLst&gt;';&#13;
	o[o.length] =       '&lt;a:outerShdw blurRad="40000" dist="20000" dir="5400000" rotWithShape="0"&gt;&lt;a:srgbClr val="000000"&gt;&lt;a:alpha val="38000"/&gt;&lt;/a:srgbClr&gt;&lt;/a:outerShdw&gt;';&#13;
	o[o.length] =      '&lt;/a:effectLst&gt;';&#13;
	o[o.length] =     '&lt;/a:effectStyle&gt;';&#13;
	o[o.length] =     '&lt;a:effectStyle&gt;';&#13;
	o[o.length] =      '&lt;a:effectLst&gt;';&#13;
	o[o.length] =       '&lt;a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"&gt;&lt;a:srgbClr val="000000"&gt;&lt;a:alpha val="35000"/&gt;&lt;/a:srgbClr&gt;&lt;/a:outerShdw&gt;';&#13;
	o[o.length] =      '&lt;/a:effectLst&gt;';&#13;
	o[o.length] =     '&lt;/a:effectStyle&gt;';&#13;
	o[o.length] =     '&lt;a:effectStyle&gt;';&#13;
	o[o.length] =      '&lt;a:effectLst&gt;';&#13;
	o[o.length] =       '&lt;a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"&gt;&lt;a:srgbClr val="000000"&gt;&lt;a:alpha val="35000"/&gt;&lt;/a:srgbClr&gt;&lt;/a:outerShdw&gt;';&#13;
	o[o.length] =      '&lt;/a:effectLst&gt;';&#13;
	o[o.length] =      '&lt;a:scene3d&gt;&lt;a:camera prst="orthographicFront"&gt;&lt;a:rot lat="0" lon="0" rev="0"/&gt;&lt;/a:camera&gt;&lt;a:lightRig rig="threePt" dir="t"&gt;&lt;a:rot lat="0" lon="0" rev="1200000"/&gt;&lt;/a:lightRig&gt;&lt;/a:scene3d&gt;';&#13;
	o[o.length] =      '&lt;a:sp3d&gt;&lt;a:bevelT w="63500" h="25400"/&gt;&lt;/a:sp3d&gt;';&#13;
	o[o.length] =     '&lt;/a:effectStyle&gt;';&#13;
	o[o.length] =    '&lt;/a:effectStyleLst&gt;';&#13;
	o[o.length] =    '&lt;a:bgFillStyleLst&gt;';&#13;
	o[o.length] =     '&lt;a:solidFill&gt;&lt;a:schemeClr val="phClr"/&gt;&lt;/a:solidFill&gt;';&#13;
	o[o.length] =     '&lt;a:gradFill rotWithShape="1"&gt;';&#13;
	o[o.length] =      '&lt;a:gsLst&gt;';&#13;
	o[o.length] =       '&lt;a:gs pos="0"&gt;&lt;a:schemeClr val="phClr"&gt;&lt;a:tint val="40000"/&gt;&lt;a:satMod val="350000"/&gt;&lt;/a:schemeClr&gt;&lt;/a:gs&gt;';&#13;
	o[o.length] =       '&lt;a:gs pos="40000"&gt;&lt;a:schemeClr val="phClr"&gt;&lt;a:tint val="45000"/&gt;&lt;a:shade val="99000"/&gt;&lt;a:satMod val="350000"/&gt;&lt;/a:schemeClr&gt;&lt;/a:gs&gt;';&#13;
	o[o.length] =       '&lt;a:gs pos="100000"&gt;&lt;a:schemeClr val="phClr"&gt;&lt;a:shade val="20000"/&gt;&lt;a:satMod val="255000"/&gt;&lt;/a:schemeClr&gt;&lt;/a:gs&gt;';&#13;
	o[o.length] =      '&lt;/a:gsLst&gt;';&#13;
	o[o.length] =      '&lt;a:path path="circle"&gt;&lt;a:fillToRect l="50000" t="-80000" r="50000" b="180000"/&gt;&lt;/a:path&gt;';&#13;
	o[o.length] =     '&lt;/a:gradFill&gt;';&#13;
	o[o.length] =     '&lt;a:gradFill rotWithShape="1"&gt;';&#13;
	o[o.length] =      '&lt;a:gsLst&gt;';&#13;
	o[o.length] =       '&lt;a:gs pos="0"&gt;&lt;a:schemeClr val="phClr"&gt;&lt;a:tint val="80000"/&gt;&lt;a:satMod val="300000"/&gt;&lt;/a:schemeClr&gt;&lt;/a:gs&gt;';&#13;
	o[o.length] =       '&lt;a:gs pos="100000"&gt;&lt;a:schemeClr val="phClr"&gt;&lt;a:shade val="30000"/&gt;&lt;a:satMod val="200000"/&gt;&lt;/a:schemeClr&gt;&lt;/a:gs&gt;';&#13;
	o[o.length] =      '&lt;/a:gsLst&gt;';&#13;
	o[o.length] =      '&lt;a:path path="circle"&gt;&lt;a:fillToRect l="50000" t="50000" r="50000" b="50000"/&gt;&lt;/a:path&gt;';&#13;
	o[o.length] =     '&lt;/a:gradFill&gt;';&#13;
	o[o.length] =    '&lt;/a:bgFillStyleLst&gt;';&#13;
	o[o.length] =   '&lt;/a:fmtScheme&gt;';&#13;
	o[o.length] =  '&lt;/a:themeElements&gt;';&#13;
&#13;
	o[o.length] =  '&lt;a:objectDefaults&gt;';&#13;
	o[o.length] =   '&lt;a:spDef&gt;';&#13;
	o[o.length] =    '&lt;a:spPr/&gt;&lt;a:bodyPr/&gt;&lt;a:lstStyle/&gt;&lt;a:style&gt;&lt;a:lnRef idx="1"&gt;&lt;a:schemeClr val="accent1"/&gt;&lt;/a:lnRef&gt;&lt;a:fillRef idx="3"&gt;&lt;a:schemeClr val="accent1"/&gt;&lt;/a:fillRef&gt;&lt;a:effectRef idx="2"&gt;&lt;a:schemeClr val="accent1"/&gt;&lt;/a:effectRef&gt;&lt;a:fontRef idx="minor"&gt;&lt;a:schemeClr val="lt1"/&gt;&lt;/a:fontRef&gt;&lt;/a:style&gt;';&#13;
	o[o.length] =   '&lt;/a:spDef&gt;';&#13;
	o[o.length] =   '&lt;a:lnDef&gt;';&#13;
	o[o.length] =    '&lt;a:spPr/&gt;&lt;a:bodyPr/&gt;&lt;a:lstStyle/&gt;&lt;a:style&gt;&lt;a:lnRef idx="2"&gt;&lt;a:schemeClr val="accent1"/&gt;&lt;/a:lnRef&gt;&lt;a:fillRef idx="0"&gt;&lt;a:schemeClr val="accent1"/&gt;&lt;/a:fillRef&gt;&lt;a:effectRef idx="1"&gt;&lt;a:schemeClr val="accent1"/&gt;&lt;/a:effectRef&gt;&lt;a:fontRef idx="minor"&gt;&lt;a:schemeClr val="tx1"/&gt;&lt;/a:fontRef&gt;&lt;/a:style&gt;';&#13;
	o[o.length] =   '&lt;/a:lnDef&gt;';&#13;
	o[o.length] =  '&lt;/a:objectDefaults&gt;';&#13;
	o[o.length] =  '&lt;a:extraClrSchemeLst/&gt;';&#13;
	o[o.length] = '&lt;/a:theme&gt;';&#13;
	return o.join("");&#13;
}&#13;
/* [MS-XLS] 2.4.326 TODO: payload is a zip file */&#13;
function parse_Theme(blob, length, opts) {&#13;
	var end = blob.l + length;&#13;
	var dwThemeVersion = blob.read_shift(4);&#13;
	if(dwThemeVersion === 124226) return;&#13;
	if(!opts.cellStyles) { blob.l = end; return; }&#13;
	var data = blob.slice(blob.l);&#13;
	blob.l = end;&#13;
	var zip; try { zip = zip_read(data, {type: "array"}); } catch(e) { return; }&#13;
	var themeXML = getzipstr(zip, "theme/theme/theme1.xml", true);&#13;
	if(!themeXML) return;&#13;
	return parse_theme_xml(themeXML, opts);&#13;
}&#13;
&#13;
/* 2.5.49 */&#13;
function parse_ColorTheme(blob) { return blob.read_shift(4); }&#13;
&#13;
/* 2.5.155 */&#13;
function parse_FullColorExt(blob) {&#13;
	var o = {};&#13;
	o.xclrType = blob.read_shift(2);&#13;
	o.nTintShade = blob.read_shift(2);&#13;
	switch(o.xclrType) {&#13;
		case 0: blob.l += 4; break;&#13;
		case 1: o.xclrValue = parse_IcvXF(blob, 4); break;&#13;
		case 2: o.xclrValue = parse_LongRGBA(blob, 4); break;&#13;
		case 3: o.xclrValue = parse_ColorTheme(blob, 4); break;&#13;
		case 4: blob.l += 4; break;&#13;
	}&#13;
	blob.l += 8;&#13;
	return o;&#13;
}&#13;
&#13;
/* 2.5.164 TODO: read 7 bits*/&#13;
function parse_IcvXF(blob, length) {&#13;
	return parsenoop(blob, length);&#13;
}&#13;
&#13;
/* 2.5.280 */&#13;
function parse_XFExtGradient(blob, length) {&#13;
	return parsenoop(blob, length);&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.108 */&#13;
function parse_ExtProp(blob) {&#13;
	var extType = blob.read_shift(2);&#13;
	var cb = blob.read_shift(2) - 4;&#13;
	var o = [extType];&#13;
	switch(extType) {&#13;
		case 0x04: case 0x05: case 0x07: case 0x08:&#13;
		case 0x09: case 0x0A: case 0x0B: case 0x0D:&#13;
			o[1] = parse_FullColorExt(blob, cb); break;&#13;
		case 0x06: o[1] = parse_XFExtGradient(blob, cb); break;&#13;
		case 0x0E: case 0x0F: o[1] = blob.read_shift(cb === 1 ? 1 : 2); break;&#13;
		default: throw new Error("Unrecognized ExtProp type: " + extType + " " + cb);&#13;
	}&#13;
	return o;&#13;
}&#13;
&#13;
/* 2.4.355 */&#13;
function parse_XFExt(blob, length) {&#13;
	var end = blob.l + length;&#13;
	blob.l += 2;&#13;
	var ixfe = blob.read_shift(2);&#13;
	blob.l += 2;&#13;
	var cexts = blob.read_shift(2);&#13;
	var ext = [];&#13;
	while(cexts-- &gt; 0) ext.push(parse_ExtProp(blob, end-blob.l));&#13;
	return {ixfe:ixfe, ext:ext};&#13;
}&#13;
&#13;
/* xf is an XF, see parse_XFExt for xfext */&#13;
function update_xfext(xf, xfext) {&#13;
	xfext.forEach(function(xfe) {&#13;
		switch(xfe[0]) { /* 2.5.108 extPropData */&#13;
			case 0x04: break; /* foreground color */&#13;
			case 0x05: break; /* background color */&#13;
			case 0x06: break; /* gradient fill */&#13;
			case 0x07: break; /* top cell border color */&#13;
			case 0x08: break; /* bottom cell border color */&#13;
			case 0x09: break; /* left cell border color */&#13;
			case 0x0a: break; /* right cell border color */&#13;
			case 0x0b: break; /* diagonal cell border color */&#13;
			case 0x0d: /* text color */&#13;
				break;&#13;
			case 0x0e: break; /* font scheme */&#13;
			case 0x0f: break; /* indentation level */&#13;
		}&#13;
	});&#13;
}&#13;
&#13;
function parse_BrtMdtinfo(data, length) {&#13;
  return {&#13;
    flags: data.read_shift(4),&#13;
    version: data.read_shift(4),&#13;
    name: parse_XLWideString(data, length - 8)&#13;
  };&#13;
}&#13;
function write_BrtMdtinfo(data) {&#13;
  var o = new_buf(12 + 2 * data.name.length);&#13;
  o.write_shift(4, data.flags);&#13;
  o.write_shift(4, data.version);&#13;
  write_XLWideString(data.name, o);&#13;
  return o.slice(0, o.l);&#13;
}&#13;
function parse_BrtMdb(data) {&#13;
  var out = [];&#13;
  var cnt = data.read_shift(4);&#13;
  while (cnt-- &gt; 0)&#13;
    out.push([data.read_shift(4), data.read_shift(4)]);&#13;
  return out;&#13;
}&#13;
function write_BrtMdb(mdb) {&#13;
  var o = new_buf(4 + 8 * mdb.length);&#13;
  o.write_shift(4, mdb.length);&#13;
  for (var i = 0; i &lt; mdb.length; ++i) {&#13;
    o.write_shift(4, mdb[i][0]);&#13;
    o.write_shift(4, mdb[i][1]);&#13;
  }&#13;
  return o;&#13;
}&#13;
function write_BrtBeginEsfmd(cnt, name) {&#13;
  var o = new_buf(8 + 2 * name.length);&#13;
  o.write_shift(4, cnt);&#13;
  write_XLWideString(name, o);&#13;
  return o.slice(0, o.l);&#13;
}&#13;
function parse_BrtBeginEsmdb(data) {&#13;
  data.l += 4;&#13;
  return data.read_shift(4) != 0;&#13;
}&#13;
function write_BrtBeginEsmdb(cnt, cm) {&#13;
  var o = new_buf(8);&#13;
  o.write_shift(4, cnt);&#13;
  o.write_shift(4, cm ? 1 : 0);&#13;
  return o;&#13;
}&#13;
function parse_xlmeta_bin(data, name, _opts) {&#13;
  var out = { Types: [], Cell: [], Value: [] };&#13;
  var opts = _opts || {};&#13;
  var state = [];&#13;
  var pass = false;&#13;
  var metatype = 2;&#13;
  recordhopper(data, function(val, R, RT) {&#13;
    switch (RT) {&#13;
      case 335:&#13;
        out.Types.push({ name: val.name });&#13;
        break;&#13;
      case 51:&#13;
        val.forEach(function(r) {&#13;
          if (metatype == 1)&#13;
            out.Cell.push({ type: out.Types[r[0] - 1].name, index: r[1] });&#13;
          else if (metatype == 0)&#13;
            out.Value.push({ type: out.Types[r[0] - 1].name, index: r[1] });&#13;
        });&#13;
        break;&#13;
      case 337:&#13;
        metatype = val ? 1 : 0;&#13;
        break;&#13;
      case 338:&#13;
        metatype = 2;&#13;
        break;&#13;
      case 35:&#13;
        state.push(RT);&#13;
        pass = true;&#13;
        break;&#13;
      case 36:&#13;
        state.pop();&#13;
        pass = false;&#13;
        break;&#13;
      default:&#13;
        if (R.T) {&#13;
        } else if (!pass || opts.WTF &amp;&amp; state[state.length - 1] != 35)&#13;
          throw new Error("Unexpected record 0x" + RT.toString(16));&#13;
    }&#13;
  });&#13;
  return out;&#13;
}&#13;
function write_xlmeta_bin() {&#13;
  var ba = buf_array();&#13;
  write_record(ba, 332);&#13;
  write_record(ba, 334, write_UInt32LE(1));&#13;
  write_record(ba, 335, write_BrtMdtinfo({&#13;
    name: "XLDAPR",&#13;
    version: 12e4,&#13;
    flags: 3496657072&#13;
  }));&#13;
  write_record(ba, 336);&#13;
  write_record(ba, 339, write_BrtBeginEsfmd(1, "XLDAPR"));&#13;
  write_record(ba, 52);&#13;
  write_record(ba, 35, write_UInt32LE(514));&#13;
  write_record(ba, 4096, write_UInt32LE(0));&#13;
  write_record(ba, 4097, writeuint16(1));&#13;
  write_record(ba, 36);&#13;
  write_record(ba, 53);&#13;
  write_record(ba, 340);&#13;
  write_record(ba, 337, write_BrtBeginEsmdb(1, true));&#13;
  write_record(ba, 51, write_BrtMdb([[1, 0]]));&#13;
  write_record(ba, 338);&#13;
  write_record(ba, 333);&#13;
  return ba.end();&#13;
}&#13;
function parse_xlmeta_xml(data, name, opts) {&#13;
  var out = { Types: [], Cell: [], Value: [] };&#13;
  if (!data)&#13;
    return out;&#13;
  var pass = false;&#13;
  var metatype = 2;&#13;
  var lastmeta;&#13;
  data.replace(tagregex, function(x) {&#13;
    var y = parsexmltag(x);&#13;
    switch (strip_ns(y[0])) {&#13;
      case "&lt;?xml":&#13;
        break;&#13;
      case "&lt;metadata":&#13;
      case "&lt;/metadata&gt;":&#13;
        break;&#13;
      case "&lt;metadataTypes":&#13;
      case "&lt;/metadataTypes&gt;":&#13;
        break;&#13;
      case "&lt;metadataType":&#13;
        out.Types.push({ name: y.name });&#13;
        break;&#13;
      case "&lt;/metadataType&gt;":&#13;
        break;&#13;
      case "&lt;futureMetadata":&#13;
        for (var j = 0; j &lt; out.Types.length; ++j)&#13;
          if (out.Types[j].name == y.name)&#13;
            lastmeta = out.Types[j];&#13;
        break;&#13;
      case "&lt;/futureMetadata&gt;":&#13;
        break;&#13;
      case "&lt;bk&gt;":&#13;
        break;&#13;
      case "&lt;/bk&gt;":&#13;
        break;&#13;
      case "&lt;rc":&#13;
        if (metatype == 1)&#13;
          out.Cell.push({ type: out.Types[y.t - 1].name, index: +y.v });&#13;
        else if (metatype == 0)&#13;
          out.Value.push({ type: out.Types[y.t - 1].name, index: +y.v });&#13;
        break;&#13;
      case "&lt;/rc&gt;":&#13;
        break;&#13;
      case "&lt;cellMetadata":&#13;
        metatype = 1;&#13;
        break;&#13;
      case "&lt;/cellMetadata&gt;":&#13;
        metatype = 2;&#13;
        break;&#13;
      case "&lt;valueMetadata":&#13;
        metatype = 0;&#13;
        break;&#13;
      case "&lt;/valueMetadata&gt;":&#13;
        metatype = 2;&#13;
        break;&#13;
      case "&lt;extLst":&#13;
      case "&lt;extLst&gt;":&#13;
      case "&lt;/extLst&gt;":&#13;
      case "&lt;extLst/&gt;":&#13;
        break;&#13;
      case "&lt;ext":&#13;
        pass = true;&#13;
        break;&#13;
      case "&lt;/ext&gt;":&#13;
        pass = false;&#13;
        break;&#13;
      case "&lt;rvb":&#13;
        if (!lastmeta)&#13;
          break;&#13;
        if (!lastmeta.offsets)&#13;
          lastmeta.offsets = [];&#13;
        lastmeta.offsets.push(+y.i);&#13;
        break;&#13;
      default:&#13;
        if (!pass &amp;&amp; (opts == null ? void 0 : opts.WTF))&#13;
          throw new Error("unrecognized " + y[0] + " in metadata");&#13;
    }&#13;
    return x;&#13;
  });&#13;
  return out;&#13;
}&#13;
function write_xlmeta_xml() {&#13;
  var o = [XML_HEADER];&#13;
  o.push('&lt;metadata xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:xlrd="http://schemas.microsoft.com/office/spreadsheetml/2017/richdata" xmlns:xda="http://schemas.microsoft.com/office/spreadsheetml/2017/dynamicarray"&gt;\n  &lt;metadataTypes count="1"&gt;\n    &lt;metadataType name="XLDAPR" minSupportedVersion="120000" copy="1" pasteAll="1" pasteValues="1" merge="1" splitFirst="1" rowColShift="1" clearFormats="1" clearComments="1" assign="1" coerce="1" cellMeta="1"/&gt;\n  &lt;/metadataTypes&gt;\n  &lt;futureMetadata name="XLDAPR" count="1"&gt;\n    &lt;bk&gt;\n      &lt;extLst&gt;\n        &lt;ext uri="{bdbb8cdc-fa1e-496e-a857-3c3f30c029c3}"&gt;\n          &lt;xda:dynamicArrayProperties fDynamic="1" fCollapsed="0"/&gt;\n        &lt;/ext&gt;\n      &lt;/extLst&gt;\n    &lt;/bk&gt;\n  &lt;/futureMetadata&gt;\n  &lt;cellMetadata count="1"&gt;\n    &lt;bk&gt;\n      &lt;rc t="1" v="0"/&gt;\n    &lt;/bk&gt;\n  &lt;/cellMetadata&gt;\n&lt;/metadata&gt;');&#13;
  return o.join("");&#13;
}&#13;
/* 18.6 Calculation Chain */&#13;
function parse_cc_xml(data) {&#13;
	var d = [];&#13;
	if(!data) return d;&#13;
	var i = 1;&#13;
	(data.match(tagregex)||[]).forEach(function(x) {&#13;
		var y = parsexmltag(x);&#13;
		switch(y[0]) {&#13;
			case '&lt;?xml': break;&#13;
			/* 18.6.2  calcChain CT_CalcChain 1 */&#13;
			case '&lt;calcChain': case '&lt;calcChain&gt;': case '&lt;/calcChain&gt;': break;&#13;
			/* 18.6.1  c CT_CalcCell 1 */&#13;
			case '&lt;c': delete y[0]; if(y.i) i = y.i; else y.i = i; d.push(y); break;&#13;
		}&#13;
	});&#13;
	return d;&#13;
}&#13;
&#13;
//function write_cc_xml(data, opts) { }&#13;
&#13;
/* [MS-XLSB] 2.6.4.1 */&#13;
function parse_BrtCalcChainItem$(data) {&#13;
	var out = {};&#13;
	out.i = data.read_shift(4);&#13;
	var cell = {};&#13;
	cell.r = data.read_shift(4);&#13;
	cell.c = data.read_shift(4);&#13;
	out.r = encode_cell(cell);&#13;
	var flags = data.read_shift(1);&#13;
	if(flags &amp; 0x2) out.l = '1';&#13;
	if(flags &amp; 0x8) out.a = '1';&#13;
	return out;&#13;
}&#13;
&#13;
/* 18.6 Calculation Chain */&#13;
function parse_cc_bin(data, name, opts) {&#13;
	var out = [];&#13;
	var pass = false;&#13;
	recordhopper(data, function hopper_cc(val, R, RT) {&#13;
		switch(RT) {&#13;
			case 0x003F: /* 'BrtCalcChainItem$' */&#13;
				out.push(val); break;&#13;
&#13;
			default:&#13;
				if(R.T){/* empty */}&#13;
				else if(!pass || opts.WTF) throw new Error("Unexpected record 0x" + RT.toString(16));&#13;
		}&#13;
	});&#13;
	return out;&#13;
}&#13;
&#13;
//function write_cc_bin(data, opts) { }&#13;
/* 18.14 Supplementary Workbook Data */&#13;
function parse_xlink_xml() {&#13;
	//var opts = _opts || {};&#13;
	//if(opts.WTF) throw "XLSX External Link";&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.1.7.25 External Link */&#13;
function parse_xlink_bin(data, rel, name, _opts) {&#13;
	if(!data) return data;&#13;
	var opts = _opts || {};&#13;
&#13;
	var pass = false, end = false;&#13;
&#13;
	recordhopper(data, function xlink_parse(val, R, RT) {&#13;
		if(end) return;&#13;
		switch(RT) {&#13;
			case 0x0167: /* 'BrtSupTabs' */&#13;
			case 0x016B: /* 'BrtExternTableStart' */&#13;
			case 0x016C: /* 'BrtExternTableEnd' */&#13;
			case 0x016E: /* 'BrtExternRowHdr' */&#13;
			case 0x016F: /* 'BrtExternCellBlank' */&#13;
			case 0x0170: /* 'BrtExternCellReal' */&#13;
			case 0x0171: /* 'BrtExternCellBool' */&#13;
			case 0x0172: /* 'BrtExternCellError' */&#13;
			case 0x0173: /* 'BrtExternCellString' */&#13;
			case 0x01D8: /* 'BrtExternValueMeta' */&#13;
			case 0x0241: /* 'BrtSupNameStart' */&#13;
			case 0x0242: /* 'BrtSupNameValueStart' */&#13;
			case 0x0243: /* 'BrtSupNameValueEnd' */&#13;
			case 0x0244: /* 'BrtSupNameNum' */&#13;
			case 0x0245: /* 'BrtSupNameErr' */&#13;
			case 0x0246: /* 'BrtSupNameSt' */&#13;
			case 0x0247: /* 'BrtSupNameNil' */&#13;
			case 0x0248: /* 'BrtSupNameBool' */&#13;
			case 0x0249: /* 'BrtSupNameFmla' */&#13;
			case 0x024A: /* 'BrtSupNameBits' */&#13;
			case 0x024B: /* 'BrtSupNameEnd' */&#13;
				break;&#13;
&#13;
			case 0x0023: /* 'BrtFRTBegin' */&#13;
				pass = true; break;&#13;
			case 0x0024: /* 'BrtFRTEnd' */&#13;
				pass = false; break;&#13;
&#13;
			default:&#13;
				if(R.T){/* empty */}&#13;
				else if(!pass || opts.WTF) throw new Error("Unexpected record 0x" + RT.toString(16));&#13;
		}&#13;
	}, opts);&#13;
}&#13;
/* 20.5 DrawingML - SpreadsheetML Drawing */&#13;
/* 20.5.2.35 wsDr CT_Drawing */&#13;
function parse_drawing(data, rels) {&#13;
	if(!data) return "??";&#13;
	/*&#13;
	  Chartsheet Drawing:&#13;
	   - 20.5.2.35 wsDr CT_Drawing&#13;
	    - 20.5.2.1  absoluteAnchor CT_AbsoluteAnchor&#13;
	     - 20.5.2.16 graphicFrame CT_GraphicalObjectFrame&#13;
	      - 20.1.2.2.16 graphic CT_GraphicalObject&#13;
	       - 20.1.2.2.17 graphicData CT_GraphicalObjectData&#13;
          - chart reference&#13;
	   the actual type is based on the URI of the graphicData&#13;
		TODO: handle embedded charts and other types of graphics&#13;
	*/&#13;
	var id = (data.match(/&lt;c:chart [^&gt;]*r:id="([^"]*)"/)||["",""])[1];&#13;
&#13;
	return rels['!id'][id].Target;&#13;
}&#13;
&#13;
/* L.5.5.2 SpreadsheetML Comments + VML Schema */&#13;
function write_vml(rId, comments) {&#13;
	var csize = [21600, 21600];&#13;
	/* L.5.2.1.2 Path Attribute */&#13;
	var bbox = ["m0,0l0",csize[1],csize[0],csize[1],csize[0],"0xe"].join(",");&#13;
	var o = [&#13;
		writextag("xml", null, { 'xmlns:v': XLMLNS.v, 'xmlns:o': XLMLNS.o, 'xmlns:x': XLMLNS.x, 'xmlns:mv': XLMLNS.mv }).replace(/\/&gt;/,"&gt;"),&#13;
		writextag("o:shapelayout", writextag("o:idmap", null, {'v:ext':"edit", 'data':rId}), {'v:ext':"edit"})&#13;
	];&#13;
&#13;
	var _shapeid = 65536 * rId;&#13;
&#13;
	var _comments = comments || [];&#13;
	if(_comments.length &gt; 0) o.push(writextag("v:shapetype", [&#13;
		writextag("v:stroke", null, {joinstyle:"miter"}),&#13;
		writextag("v:path", null, {gradientshapeok:"t", 'o:connecttype':"rect"})&#13;
	].join(""), {id:"_x0000_t202", coordsize:csize.join(","), 'o:spt':202, path:bbox}));&#13;
&#13;
	_comments.forEach(function(x) { ++_shapeid; o.push(write_vml_comment(x, _shapeid)); });&#13;
	o.push('&lt;/xml&gt;');&#13;
	return o.join("");&#13;
}&#13;
&#13;
function write_vml_comment(x, _shapeid) {&#13;
	var c = decode_cell(x[0]);&#13;
	var fillopts = {'color2':"#BEFF82", 'type':"gradient"};&#13;
	if(fillopts.type == "gradient") fillopts.angle = "-180";&#13;
	var fillparm = fillopts.type == "gradient" ? writextag("o:fill", null, {type:"gradientUnscaled", 'v:ext':"view"}) : null;&#13;
	var fillxml = writextag('v:fill', fillparm, fillopts);&#13;
&#13;
	var shadata = ({on:"t", 'obscured':"t"});&#13;
&#13;
	return [&#13;
	'&lt;v:shape' + wxt_helper({&#13;
		id:'_x0000_s' + _shapeid,&#13;
		type:"#_x0000_t202",&#13;
		style:"position:absolute; margin-left:80pt;margin-top:5pt;width:104pt;height:64pt;z-index:10" + (x[1].hidden ? ";visibility:hidden" : "") ,&#13;
		fillcolor:"#ECFAD4",&#13;
		strokecolor:"#edeaa1"&#13;
	}) + '&gt;',&#13;
		fillxml,&#13;
		writextag("v:shadow", null, shadata),&#13;
		writextag("v:path", null, {'o:connecttype':"none"}),&#13;
		'&lt;v:textbox&gt;&lt;div style="text-align:left"&gt;&lt;/div&gt;&lt;/v:textbox&gt;',&#13;
		'&lt;x:ClientData ObjectType="Note"&gt;',&#13;
			'&lt;x:MoveWithCells/&gt;',&#13;
			'&lt;x:SizeWithCells/&gt;',&#13;
			/* Part 4 19.4.2.3 Anchor (Anchor) */&#13;
			writetag('x:Anchor', [c.c+1, 0, c.r+1, 0, c.c+3, 20, c.r+5, 20].join(",")),&#13;
			writetag('x:AutoFill', "False"),&#13;
			writetag('x:Row', String(c.r)),&#13;
			writetag('x:Column', String(c.c)),&#13;
			x[1].hidden ? '' : '&lt;x:Visible/&gt;',&#13;
		'&lt;/x:ClientData&gt;',&#13;
	'&lt;/v:shape&gt;'&#13;
	].join("");&#13;
}&#13;
function sheet_insert_comments(sheet, comments, threaded, people) {&#13;
	var dense = Array.isArray(sheet);&#13;
	var cell;&#13;
	comments.forEach(function(comment) {&#13;
		var r = decode_cell(comment.ref);&#13;
		if(dense) {&#13;
			if(!sheet[r.r]) sheet[r.r] = [];&#13;
			cell = sheet[r.r][r.c];&#13;
		} else cell = sheet[comment.ref];&#13;
		if (!cell) {&#13;
			cell = ({t:"z"});&#13;
			if(dense) sheet[r.r][r.c] = cell;&#13;
			else sheet[comment.ref] = cell;&#13;
			var range = safe_decode_range(sheet["!ref"]||"BDWGO1000001:A1");&#13;
			if(range.s.r &gt; r.r) range.s.r = r.r;&#13;
			if(range.e.r &lt; r.r) range.e.r = r.r;&#13;
			if(range.s.c &gt; r.c) range.s.c = r.c;&#13;
			if(range.e.c &lt; r.c) range.e.c = r.c;&#13;
			var encoded = encode_range(range);&#13;
			if (encoded !== sheet["!ref"]) sheet["!ref"] = encoded;&#13;
		}&#13;
&#13;
		if (!cell.c) cell.c = [];&#13;
		var o = ({a: comment.author, t: comment.t, r: comment.r, T: threaded});&#13;
		if(comment.h) o.h = comment.h;&#13;
&#13;
		/* threaded comments always override */&#13;
		for(var i = cell.c.length - 1; i &gt;= 0; --i) {&#13;
			if(!threaded &amp;&amp; cell.c[i].T) return;&#13;
			if(threaded &amp;&amp; !cell.c[i].T) cell.c.splice(i, 1);&#13;
		}&#13;
		if(threaded &amp;&amp; people) for(i = 0; i &lt; people.length; ++i) {&#13;
			if(o.a == people[i].id) { o.a = people[i].name || o.a; break; }&#13;
		}&#13;
		cell.c.push(o);&#13;
	});&#13;
}&#13;
&#13;
/* 18.7 Comments */&#13;
function parse_comments_xml(data, opts) {&#13;
	/* 18.7.6 CT_Comments */&#13;
	if(data.match(/&lt;(?:\w+:)?comments *\/&gt;/)) return [];&#13;
	var authors = [];&#13;
	var commentList = [];&#13;
	var authtag = data.match(/&lt;(?:\w+:)?authors&gt;([\s\S]*)&lt;\/(?:\w+:)?authors&gt;/);&#13;
	if(authtag &amp;&amp; authtag[1]) authtag[1].split(/&lt;\/\w*:?author&gt;/).forEach(function(x) {&#13;
		if(x === "" || x.trim() === "") return;&#13;
		var a = x.match(/&lt;(?:\w+:)?author[^&gt;]*&gt;(.*)/);&#13;
		if(a) authors.push(a[1]);&#13;
	});&#13;
	var cmnttag = data.match(/&lt;(?:\w+:)?commentList&gt;([\s\S]*)&lt;\/(?:\w+:)?commentList&gt;/);&#13;
	if(cmnttag &amp;&amp; cmnttag[1]) cmnttag[1].split(/&lt;\/\w*:?comment&gt;/).forEach(function(x) {&#13;
		if(x === "" || x.trim() === "") return;&#13;
		var cm = x.match(/&lt;(?:\w+:)?comment[^&gt;]*&gt;/);&#13;
		if(!cm) return;&#13;
		var y = parsexmltag(cm[0]);&#13;
		var comment = ({ author: y.authorId &amp;&amp; authors[y.authorId] || "sheetjsghost", ref: y.ref, guid: y.guid });&#13;
		var cell = decode_cell(y.ref);&#13;
		if(opts.sheetRows &amp;&amp; opts.sheetRows &lt;= cell.r) return;&#13;
		var textMatch = x.match(/&lt;(?:\w+:)?text&gt;([\s\S]*)&lt;\/(?:\w+:)?text&gt;/);&#13;
		var rt = !!textMatch &amp;&amp; !!textMatch[1] &amp;&amp; parse_si(textMatch[1]) || {r:"",t:"",h:""};&#13;
		comment.r = rt.r;&#13;
		if(rt.r == "&lt;t&gt;&lt;/t&gt;") rt.t = rt.h = "";&#13;
		comment.t = (rt.t||"").replace(/\r\n/g,"\n").replace(/\r/g,"\n");&#13;
		if(opts.cellHTML) comment.h = rt.h;&#13;
		commentList.push(comment);&#13;
	});&#13;
	return commentList;&#13;
}&#13;
&#13;
function write_comments_xml(data) {&#13;
	var o = [XML_HEADER, writextag('comments', null, { 'xmlns': XMLNS_main[0] })];&#13;
&#13;
	var iauthor = [];&#13;
	o.push("&lt;authors&gt;");&#13;
	data.forEach(function(x) { x[1].forEach(function(w) { var a = escapexml(w.a);&#13;
		if(iauthor.indexOf(a) == -1) {&#13;
			iauthor.push(a);&#13;
			o.push("&lt;author&gt;" + a + "&lt;/author&gt;");&#13;
		}&#13;
		if(w.T &amp;&amp; w.ID &amp;&amp; iauthor.indexOf("tc=" + w.ID) == -1) {&#13;
			iauthor.push("tc=" + w.ID);&#13;
			o.push("&lt;author&gt;" + "tc=" + w.ID + "&lt;/author&gt;");&#13;
		}&#13;
	}); });&#13;
	if(iauthor.length == 0) { iauthor.push("SheetJ5"); o.push("&lt;author&gt;SheetJ5&lt;/author&gt;"); }&#13;
	o.push("&lt;/authors&gt;");&#13;
	o.push("&lt;commentList&gt;");&#13;
	data.forEach(function(d) {&#13;
		/* 18.7.3 CT_Comment */&#13;
		var lastauthor = 0, ts = [], tcnt = 0;&#13;
		if(d[1][0] &amp;&amp; d[1][0].T &amp;&amp; d[1][0].ID) lastauthor = iauthor.indexOf("tc=" + d[1][0].ID);&#13;
		d[1].forEach(function(c) {&#13;
			if(c.a) lastauthor = iauthor.indexOf(escapexml(c.a));&#13;
			if(c.T) ++tcnt;&#13;
			ts.push(c.t == null ? "" : escapexml(c.t));&#13;
		});&#13;
		if(tcnt === 0) {&#13;
			d[1].forEach(function(c) {&#13;
				o.push('&lt;comment ref="' + d[0] + '" authorId="' + iauthor.indexOf(escapexml(c.a)) + '"&gt;&lt;text&gt;');&#13;
				o.push(writetag("t", c.t == null ? "" : escapexml(c.t)));&#13;
				o.push('&lt;/text&gt;&lt;/comment&gt;');&#13;
			});&#13;
		} else {&#13;
			/* based on Threaded Comments -&gt; Comments projection */&#13;
			o.push('&lt;comment ref="' + d[0] + '" authorId="' + lastauthor + '"&gt;&lt;text&gt;');&#13;
			var t = "Comment:\n    " + (ts[0]) + "\n";&#13;
			for(var i = 1; i &lt; ts.length; ++i) t += "Reply:\n    " + ts[i] + "\n";&#13;
			o.push(writetag("t", escapexml(t)));&#13;
			o.push('&lt;/text&gt;&lt;/comment&gt;');&#13;
		}&#13;
	});&#13;
	o.push("&lt;/commentList&gt;");&#13;
	if(o.length&gt;2) { o[o.length] = ('&lt;/comments&gt;'); o[1]=o[1].replace("/&gt;","&gt;"); }&#13;
	return o.join("");&#13;
}&#13;
&#13;
/* [MS-XLSX] 2.1.17 */&#13;
function parse_tcmnt_xml(data, opts) {&#13;
	var out = [];&#13;
	var pass = false, comment = {}, tidx = 0;&#13;
	data.replace(tagregex, function xml_tcmnt(x, idx) {&#13;
		var y = parsexmltag(x);&#13;
		switch(strip_ns(y[0])) {&#13;
			case '&lt;?xml': break;&#13;
&#13;
			/* 2.6.207 ThreadedComments CT_ThreadedComments */&#13;
			case '&lt;ThreadedComments': break;&#13;
			case '&lt;/ThreadedComments&gt;': break;&#13;
&#13;
			/* 2.6.205 threadedComment CT_ThreadedComment */&#13;
			case '&lt;threadedComment': comment = {author: y.personId, guid: y.id, ref: y.ref, T: 1}; break;&#13;
			case '&lt;/threadedComment&gt;': if(comment.t != null) out.push(comment); break;&#13;
&#13;
			case '&lt;text&gt;': case '&lt;text': tidx = idx + x.length; break;&#13;
			case '&lt;/text&gt;': comment.t = data.slice(tidx, idx).replace(/\r\n/g, "\n").replace(/\r/g, "\n"); break;&#13;
&#13;
			/* 2.6.206 mentions CT_ThreadedCommentMentions TODO */&#13;
			case '&lt;mentions': case '&lt;mentions&gt;': pass = true; break;&#13;
			case '&lt;/mentions&gt;': pass = false; break;&#13;
&#13;
			/* 2.6.202 mention CT_Mention TODO */&#13;
&#13;
			/* 18.2.10 extLst CT_ExtensionList ? */&#13;
			case '&lt;extLst': case '&lt;extLst&gt;': case '&lt;/extLst&gt;': case '&lt;extLst/&gt;': break;&#13;
			/* 18.2.7  ext CT_Extension + */&#13;
			case '&lt;ext': pass=true; break;&#13;
			case '&lt;/ext&gt;': pass=false; break;&#13;
&#13;
			default: if(!pass &amp;&amp; opts.WTF) throw new Error('unrecognized ' + y[0] + ' in threaded comments');&#13;
		}&#13;
		return x;&#13;
	});&#13;
	return out;&#13;
}&#13;
&#13;
function write_tcmnt_xml(comments, people, opts) {&#13;
	var o = [XML_HEADER, writextag('ThreadedComments', null, { 'xmlns': XMLNS.TCMNT }).replace(/[\/]&gt;/, "&gt;")];&#13;
	comments.forEach(function(carr) {&#13;
		var rootid = "";&#13;
		(carr[1] || []).forEach(function(c, idx) {&#13;
			if(!c.T) { delete c.ID; return; }&#13;
			if(c.a &amp;&amp; people.indexOf(c.a) == -1) people.push(c.a);&#13;
			var tcopts = {&#13;
				ref: carr[0],&#13;
				id: "{54EE7951-7262-4200-6969-" + ("000000000000" + opts.tcid++).slice(-12) + "}"&#13;
			};&#13;
			if(idx == 0) rootid = tcopts.id;&#13;
			else tcopts.parentId = rootid;&#13;
			c.ID = tcopts.id;&#13;
			if(c.a) tcopts.personId = "{54EE7950-7262-4200-6969-" + ("000000000000" + people.indexOf(c.a)).slice(-12) + "}";&#13;
			o.push(writextag('threadedComment', writetag('text', c.t||""), tcopts));&#13;
		});&#13;
	});&#13;
	o.push('&lt;/ThreadedComments&gt;');&#13;
	return o.join("");&#13;
}&#13;
&#13;
/* [MS-XLSX] 2.1.18 */&#13;
function parse_people_xml(data, opts) {&#13;
	var out = [];&#13;
	var pass = false;&#13;
	data.replace(tagregex, function xml_tcmnt(x) {&#13;
		var y = parsexmltag(x);&#13;
		switch(strip_ns(y[0])) {&#13;
			case '&lt;?xml': break;&#13;
&#13;
			/* 2.4.85 personList CT_PersonList */&#13;
			case '&lt;personList': break;&#13;
			case '&lt;/personList&gt;': break;&#13;
&#13;
			/* 2.6.203 person CT_Person TODO: providers */&#13;
			case '&lt;person': out.push({name: y.displayname, id: y.id }); break;&#13;
			case '&lt;/person&gt;': break;&#13;
&#13;
			/* 18.2.10 extLst CT_ExtensionList ? */&#13;
			case '&lt;extLst': case '&lt;extLst&gt;': case '&lt;/extLst&gt;': case '&lt;extLst/&gt;': break;&#13;
			/* 18.2.7  ext CT_Extension + */&#13;
			case '&lt;ext': pass=true; break;&#13;
			case '&lt;/ext&gt;': pass=false; break;&#13;
&#13;
			default: if(!pass &amp;&amp; opts.WTF) throw new Error('unrecognized ' + y[0] + ' in threaded comments');&#13;
		}&#13;
		return x;&#13;
	});&#13;
	return out;&#13;
}&#13;
function write_people_xml(people/*, opts*/) {&#13;
	var o = [XML_HEADER, writextag('personList', null, {&#13;
		'xmlns': XMLNS.TCMNT,&#13;
		'xmlns:x': XMLNS_main[0]&#13;
	}).replace(/[\/]&gt;/, "&gt;")];&#13;
	people.forEach(function(person, idx) {&#13;
		o.push(writextag('person', null, {&#13;
			displayName: person,&#13;
			id: "{54EE7950-7262-4200-6969-" + ("000000000000" + idx).slice(-12) + "}",&#13;
			userId: person,&#13;
			providerId: "None"&#13;
		}));&#13;
	});&#13;
	o.push("&lt;/personList&gt;");&#13;
	return o.join("");&#13;
}&#13;
/* [MS-XLSB] 2.4.28 BrtBeginComment */&#13;
function parse_BrtBeginComment(data) {&#13;
	var out = {};&#13;
	out.iauthor = data.read_shift(4);&#13;
	var rfx = parse_UncheckedRfX(data, 16);&#13;
	out.rfx = rfx.s;&#13;
	out.ref = encode_cell(rfx.s);&#13;
	data.l += 16; /*var guid = parse_GUID(data); */&#13;
	return out;&#13;
}&#13;
function write_BrtBeginComment(data, o) {&#13;
	if(o == null) o = new_buf(36);&#13;
	o.write_shift(4, data[1].iauthor);&#13;
	write_UncheckedRfX((data[0]), o);&#13;
	o.write_shift(4, 0);&#13;
	o.write_shift(4, 0);&#13;
	o.write_shift(4, 0);&#13;
	o.write_shift(4, 0);&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.4.327 BrtCommentAuthor */&#13;
var parse_BrtCommentAuthor = parse_XLWideString;&#13;
function write_BrtCommentAuthor(data) { return write_XLWideString(data.slice(0, 54)); }&#13;
&#13;
/* [MS-XLSB] 2.1.7.8 Comments */&#13;
function parse_comments_bin(data, opts) {&#13;
	var out = [];&#13;
	var authors = [];&#13;
	var c = {};&#13;
	var pass = false;&#13;
	recordhopper(data, function hopper_cmnt(val, R, RT) {&#13;
		switch(RT) {&#13;
			case 0x0278: /* 'BrtCommentAuthor' */&#13;
				authors.push(val); break;&#13;
			case 0x027B: /* 'BrtBeginComment' */&#13;
				c = val; break;&#13;
			case 0x027D: /* 'BrtCommentText' */&#13;
				c.t = val.t; c.h = val.h; c.r = val.r; break;&#13;
			case 0x027C: /* 'BrtEndComment' */&#13;
				c.author = authors[c.iauthor];&#13;
				delete (c).iauthor;&#13;
				if(opts.sheetRows &amp;&amp; c.rfx &amp;&amp; opts.sheetRows &lt;= c.rfx.r) break;&#13;
				if(!c.t) c.t = "";&#13;
				delete c.rfx; out.push(c); break;&#13;
&#13;
			case 0x0C00: /* 'BrtUid' */&#13;
				break;&#13;
&#13;
			case 0x0023: /* 'BrtFRTBegin' */&#13;
				pass = true; break;&#13;
			case 0x0024: /* 'BrtFRTEnd' */&#13;
				pass = false; break;&#13;
			case 0x0025: /* 'BrtACBegin' */ break;&#13;
			case 0x0026: /* 'BrtACEnd' */ break;&#13;
&#13;
&#13;
			default:&#13;
				if(R.T){/* empty */}&#13;
				else if(!pass || opts.WTF) throw new Error("Unexpected record 0x" + RT.toString(16));&#13;
		}&#13;
	});&#13;
	return out;&#13;
}&#13;
&#13;
function write_comments_bin(data) {&#13;
	var ba = buf_array();&#13;
	var iauthor = [];&#13;
	write_record(ba, 0x0274 /* BrtBeginComments */);&#13;
&#13;
	write_record(ba, 0x0276 /* BrtBeginCommentAuthors */);&#13;
	data.forEach(function(comment) {&#13;
		comment[1].forEach(function(c) {&#13;
			if(iauthor.indexOf(c.a) &gt; -1) return;&#13;
			iauthor.push(c.a.slice(0,54));&#13;
			write_record(ba, 0x0278 /* BrtCommentAuthor */, write_BrtCommentAuthor(c.a));&#13;
		});&#13;
	});&#13;
	write_record(ba, 0x0277 /* BrtEndCommentAuthors */);&#13;
&#13;
	write_record(ba, 0x0279 /* BrtBeginCommentList */);&#13;
	data.forEach(function(comment) {&#13;
		comment[1].forEach(function(c) {&#13;
			c.iauthor = iauthor.indexOf(c.a);&#13;
			var range = {s:decode_cell(comment[0]),e:decode_cell(comment[0])};&#13;
			write_record(ba, 0x027B /* BrtBeginComment */, write_BrtBeginComment([range, c]));&#13;
			if(c.t &amp;&amp; c.t.length &gt; 0) write_record(ba, 0x027D /* BrtCommentText */, write_BrtCommentText(c));&#13;
			write_record(ba, 0x027C /* BrtEndComment */);&#13;
			delete c.iauthor;&#13;
		});&#13;
	});&#13;
	write_record(ba, 0x027A /* BrtEndCommentList */);&#13;
&#13;
	write_record(ba, 0x0275 /* BrtEndComments */);&#13;
	return ba.end();&#13;
}&#13;
var CT_VBA = "application/vnd.ms-office.vbaProject";&#13;
function make_vba_xls(cfb) {&#13;
  var newcfb = CFB.utils.cfb_new({ root: "R" });&#13;
  cfb.FullPaths.forEach(function(p, i) {&#13;
    if (p.slice(-1) === "/" || !p.match(/_VBA_PROJECT_CUR/))&#13;
      return;&#13;
    var newpath = p.replace(/^[^\/]*/, "R").replace(/\/_VBA_PROJECT_CUR\u0000*/, "");&#13;
    CFB.utils.cfb_add(newcfb, newpath, cfb.FileIndex[i].content);&#13;
  });&#13;
  return CFB.write(newcfb);&#13;
}&#13;
function fill_vba_xls(cfb, vba) {&#13;
  vba.FullPaths.forEach(function(p, i) {&#13;
    if (i == 0)&#13;
      return;&#13;
    var newpath = p.replace(/[^\/]*[\/]/, "/_VBA_PROJECT_CUR/");&#13;
    if (newpath.slice(-1) !== "/")&#13;
      CFB.utils.cfb_add(cfb, newpath, vba.FileIndex[i].content);&#13;
  });&#13;
}&#13;
var VBAFMTS = ["xlsb", "xlsm", "xlam", "biff8", "xla"];&#13;
/* macro and dialog sheet stubs */&#13;
function parse_ds_bin() { return {'!type':'dialog'}; }&#13;
function parse_ds_xml() { return {'!type':'dialog'}; }&#13;
function parse_ms_bin() { return {'!type':'macro'}; }&#13;
function parse_ms_xml() { return {'!type':'macro'}; }&#13;
/* TODO: it will be useful to parse the function str */&#13;
var rc_to_a1 = (function(){&#13;
	var rcregex = /(^|[^A-Za-z_])R(\[?-?\d+\]|[1-9]\d*|)C(\[?-?\d+\]|[1-9]\d*|)(?![A-Za-z0-9_])/g;&#13;
	var rcbase = ({r:0,c:0});&#13;
	function rcfunc($$,$1,$2,$3) {&#13;
		var cRel = false, rRel = false;&#13;
&#13;
		if($2.length == 0) rRel = true;&#13;
		else if($2.charAt(0) == "[") { rRel = true; $2 = $2.slice(1, -1); }&#13;
&#13;
		if($3.length == 0) cRel = true;&#13;
		else if($3.charAt(0) == "[") { cRel = true; $3 = $3.slice(1, -1); }&#13;
&#13;
		var R = $2.length&gt;0?parseInt($2,10)|0:0, C = $3.length&gt;0?parseInt($3,10)|0:0;&#13;
&#13;
		if(cRel) C += rcbase.c; else --C;&#13;
		if(rRel) R += rcbase.r; else --R;&#13;
		return $1 + (cRel ? "" : "$") + encode_col(C) + (rRel ? "" : "$") + encode_row(R);&#13;
	}&#13;
	return function rc_to_a1(fstr, base) {&#13;
		rcbase = base;&#13;
		return fstr.replace(rcregex, rcfunc);&#13;
	};&#13;
})();&#13;
&#13;
var crefregex = /(^|[^._A-Z0-9])([$]?)([A-Z]{1,2}|[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D])([$]?)(10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5})(?![_.\(A-Za-z0-9])/g;&#13;
var a1_to_rc = (function(){&#13;
	return function a1_to_rc(fstr, base) {&#13;
		return fstr.replace(crefregex, function($0, $1, $2, $3, $4, $5) {&#13;
			var c = decode_col($3) - ($2 ? 0 : base.c);&#13;
			var r = decode_row($5) - ($4 ? 0 : base.r);&#13;
			var R = $4 == "$" ? (r+1) : (r == 0 ? "" : "[" + r + "]");&#13;
			var C = $2 == "$" ? (c+1) : (c == 0 ? "" : "[" + c + "]");&#13;
			return $1 + "R" + R + "C" + C;&#13;
		});&#13;
	};&#13;
})();&#13;
&#13;
/* no defined name can collide with a valid cell address A1:XFD1048576 ... except LOG10! */&#13;
function shift_formula_str(f, delta) {&#13;
	return f.replace(crefregex, function($0, $1, $2, $3, $4, $5) {&#13;
		return $1+($2=="$" ? $2+$3 : encode_col(decode_col($3)+delta.c))+($4=="$" ? $4+$5 : encode_row(decode_row($5) + delta.r));&#13;
	});&#13;
}&#13;
&#13;
function shift_formula_xlsx(f, range, cell) {&#13;
	var r = decode_range(range), s = r.s, c = decode_cell(cell);&#13;
	var delta = {r:c.r - s.r, c:c.c - s.c};&#13;
	return shift_formula_str(f, delta);&#13;
}&#13;
&#13;
/* TODO: parse formula */&#13;
function fuzzyfmla(f) {&#13;
	if(f.length == 1) return false;&#13;
	return true;&#13;
}&#13;
&#13;
function _xlfn(f) {&#13;
	return f.replace(/_xlfn\./g,"");&#13;
}&#13;
function parseread1(blob) { blob.l+=1; return; }&#13;
&#13;
/* [MS-XLS] 2.5.51 */&#13;
function parse_ColRelU(blob, length) {&#13;
	var c = blob.read_shift(length == 1 ? 1 : 2);&#13;
	return [c &amp; 0x3FFF, (c &gt;&gt; 14) &amp; 1, (c &gt;&gt; 15) &amp; 1];&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.198.105 ; [MS-XLSB] 2.5.97.89 */&#13;
function parse_RgceArea(blob, length, opts) {&#13;
	var w = 2;&#13;
	if(opts) {&#13;
		if(opts.biff &gt;= 2 &amp;&amp; opts.biff &lt;= 5) return parse_RgceArea_BIFF2(blob, length, opts);&#13;
		else if(opts.biff == 12) w = 4;&#13;
	}&#13;
	var r=blob.read_shift(w), R=blob.read_shift(w);&#13;
	var c=parse_ColRelU(blob, 2);&#13;
	var C=parse_ColRelU(blob, 2);&#13;
	return { s:{r:r, c:c[0], cRel:c[1], rRel:c[2]}, e:{r:R, c:C[0], cRel:C[1], rRel:C[2]} };&#13;
}&#13;
/* BIFF 2-5 encodes flags in the row field */&#13;
function parse_RgceArea_BIFF2(blob) {&#13;
	var r=parse_ColRelU(blob, 2), R=parse_ColRelU(blob, 2);&#13;
	var c=blob.read_shift(1);&#13;
	var C=blob.read_shift(1);&#13;
	return { s:{r:r[0], c:c, cRel:r[1], rRel:r[2]}, e:{r:R[0], c:C, cRel:R[1], rRel:R[2]} };&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.198.105 ; [MS-XLSB] 2.5.97.90 */&#13;
function parse_RgceAreaRel(blob, length, opts) {&#13;
	if(opts.biff &lt; 8) return parse_RgceArea_BIFF2(blob, length, opts);&#13;
	var r=blob.read_shift(opts.biff == 12 ? 4 : 2), R=blob.read_shift(opts.biff == 12 ? 4 : 2);&#13;
	var c=parse_ColRelU(blob, 2);&#13;
	var C=parse_ColRelU(blob, 2);&#13;
	return { s:{r:r, c:c[0], cRel:c[1], rRel:c[2]}, e:{r:R, c:C[0], cRel:C[1], rRel:C[2]} };&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.198.109 ; [MS-XLSB] 2.5.97.91 */&#13;
function parse_RgceLoc(blob, length, opts) {&#13;
	if(opts &amp;&amp; opts.biff &gt;= 2 &amp;&amp; opts.biff &lt;= 5) return parse_RgceLoc_BIFF2(blob, length, opts);&#13;
	var r = blob.read_shift(opts &amp;&amp; opts.biff == 12 ? 4 : 2);&#13;
	var c = parse_ColRelU(blob, 2);&#13;
	return {r:r, c:c[0], cRel:c[1], rRel:c[2]};&#13;
}&#13;
function parse_RgceLoc_BIFF2(blob) {&#13;
	var r = parse_ColRelU(blob, 2);&#13;
	var c = blob.read_shift(1);&#13;
	return {r:r[0], c:c, cRel:r[1], rRel:r[2]};&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.198.107, 2.5.47 */&#13;
function parse_RgceElfLoc(blob) {&#13;
	var r = blob.read_shift(2);&#13;
	var c = blob.read_shift(2);&#13;
	return {r:r, c:c &amp; 0xFF, fQuoted:!!(c &amp; 0x4000), cRel:c&gt;&gt;15, rRel:c&gt;&gt;15 };&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.198.111 ; [MS-XLSB] 2.5.97.92 TODO */&#13;
function parse_RgceLocRel(blob, length, opts) {&#13;
	var biff = opts &amp;&amp; opts.biff ? opts.biff : 8;&#13;
	if(biff &gt;= 2 &amp;&amp; biff &lt;= 5) return parse_RgceLocRel_BIFF2(blob, length, opts);&#13;
	var r = blob.read_shift(biff &gt;= 12 ? 4 : 2);&#13;
	var cl = blob.read_shift(2);&#13;
	var cRel = (cl &amp; 0x4000) &gt;&gt; 14, rRel = (cl &amp; 0x8000) &gt;&gt; 15;&#13;
	cl &amp;= 0x3FFF;&#13;
	if(rRel == 1) while(r &gt; 0x7FFFF) r -= 0x100000;&#13;
	if(cRel == 1) while(cl &gt; 0x1FFF) cl = cl - 0x4000;&#13;
	return {r:r,c:cl,cRel:cRel,rRel:rRel};&#13;
}&#13;
function parse_RgceLocRel_BIFF2(blob) {&#13;
	var rl = blob.read_shift(2);&#13;
	var c = blob.read_shift(1);&#13;
	var rRel = (rl &amp; 0x8000) &gt;&gt; 15, cRel = (rl &amp; 0x4000) &gt;&gt; 14;&#13;
	rl &amp;= 0x3FFF;&#13;
	if(rRel == 1 &amp;&amp; rl &gt;= 0x2000) rl = rl - 0x4000;&#13;
	if(cRel == 1 &amp;&amp; c &gt;= 0x80) c = c - 0x100;&#13;
	return {r:rl,c:c,cRel:cRel,rRel:rRel};&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.198.27 ; [MS-XLSB] 2.5.97.18 */&#13;
function parse_PtgArea(blob, length, opts) {&#13;
	var type = (blob[blob.l++] &amp; 0x60) &gt;&gt; 5;&#13;
	var area = parse_RgceArea(blob, opts.biff &gt;= 2 &amp;&amp; opts.biff &lt;= 5 ? 6 : 8, opts);&#13;
	return [type, area];&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.198.28 ; [MS-XLSB] 2.5.97.19 */&#13;
function parse_PtgArea3d(blob, length, opts) {&#13;
	var type = (blob[blob.l++] &amp; 0x60) &gt;&gt; 5;&#13;
	var ixti = blob.read_shift(2, 'i');&#13;
	var w = 8;&#13;
	if(opts) switch(opts.biff) {&#13;
		case 5: blob.l += 12; w = 6; break;&#13;
		case 12: w = 12; break;&#13;
	}&#13;
	var area = parse_RgceArea(blob, w, opts);&#13;
	return [type, ixti, area];&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.198.29 ; [MS-XLSB] 2.5.97.20 */&#13;
function parse_PtgAreaErr(blob, length, opts) {&#13;
	var type = (blob[blob.l++] &amp; 0x60) &gt;&gt; 5;&#13;
	blob.l += opts &amp;&amp; (opts.biff &gt; 8) ? 12 : (opts.biff &lt; 8 ? 6 : 8);&#13;
	return [type];&#13;
}&#13;
/* [MS-XLS] 2.5.198.30 ; [MS-XLSB] 2.5.97.21 */&#13;
function parse_PtgAreaErr3d(blob, length, opts) {&#13;
	var type = (blob[blob.l++] &amp; 0x60) &gt;&gt; 5;&#13;
	var ixti = blob.read_shift(2);&#13;
	var w = 8;&#13;
	if(opts) switch(opts.biff) {&#13;
		case 5: blob.l += 12; w = 6; break;&#13;
		case 12: w = 12; break;&#13;
	}&#13;
	blob.l += w;&#13;
	return [type, ixti];&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.198.31 ; [MS-XLSB] 2.5.97.22 */&#13;
function parse_PtgAreaN(blob, length, opts) {&#13;
	var type = (blob[blob.l++] &amp; 0x60) &gt;&gt; 5;&#13;
	var area = parse_RgceAreaRel(blob, length - 1, opts);&#13;
	return [type, area];&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.198.32 ; [MS-XLSB] 2.5.97.23 */&#13;
function parse_PtgArray(blob, length, opts) {&#13;
	var type = (blob[blob.l++] &amp; 0x60) &gt;&gt; 5;&#13;
	blob.l += opts.biff == 2 ? 6 : opts.biff == 12 ? 14 : 7;&#13;
	return [type];&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.198.33 ; [MS-XLSB] 2.5.97.24 */&#13;
function parse_PtgAttrBaxcel(blob) {&#13;
	var bitSemi = blob[blob.l+1] &amp; 0x01; /* 1 = volatile */&#13;
	var bitBaxcel = 1;&#13;
	blob.l += 4;&#13;
	return [bitSemi, bitBaxcel];&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.198.34 ; [MS-XLSB] 2.5.97.25 */&#13;
function parse_PtgAttrChoose(blob, length, opts) {&#13;
	blob.l +=2;&#13;
	var offset = blob.read_shift(opts &amp;&amp; opts.biff == 2 ? 1 : 2);&#13;
	var o = [];&#13;
	/* offset is 1 less than the number of elements */&#13;
	for(var i = 0; i &lt;= offset; ++i) o.push(blob.read_shift(opts &amp;&amp; opts.biff == 2 ? 1 : 2));&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.198.35 ; [MS-XLSB] 2.5.97.26 */&#13;
function parse_PtgAttrGoto(blob, length, opts) {&#13;
	var bitGoto = (blob[blob.l+1] &amp; 0xFF) ? 1 : 0;&#13;
	blob.l += 2;&#13;
	return [bitGoto, blob.read_shift(opts &amp;&amp; opts.biff == 2 ? 1 : 2)];&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.198.36 ; [MS-XLSB] 2.5.97.27 */&#13;
function parse_PtgAttrIf(blob, length, opts) {&#13;
	var bitIf = (blob[blob.l+1] &amp; 0xFF) ? 1 : 0;&#13;
	blob.l += 2;&#13;
	return [bitIf, blob.read_shift(opts &amp;&amp; opts.biff == 2 ? 1 : 2)];&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.5.97.28 */&#13;
function parse_PtgAttrIfError(blob) {&#13;
	var bitIf = (blob[blob.l+1] &amp; 0xFF) ? 1 : 0;&#13;
	blob.l += 2;&#13;
	return [bitIf, blob.read_shift(2)];&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.198.37 ; [MS-XLSB] 2.5.97.29 */&#13;
function parse_PtgAttrSemi(blob, length, opts) {&#13;
	var bitSemi = (blob[blob.l+1] &amp; 0xFF) ? 1 : 0;&#13;
	blob.l += opts &amp;&amp; opts.biff == 2 ? 3 : 4;&#13;
	return [bitSemi];&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.198.40 ; [MS-XLSB] 2.5.97.32 */&#13;
function parse_PtgAttrSpaceType(blob) {&#13;
	var type = blob.read_shift(1), cch = blob.read_shift(1);&#13;
	return [type, cch];&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.198.38 ; [MS-XLSB] 2.5.97.30 */&#13;
function parse_PtgAttrSpace(blob) {&#13;
	blob.read_shift(2);&#13;
	return parse_PtgAttrSpaceType(blob, 2);&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.198.39 ; [MS-XLSB] 2.5.97.31 */&#13;
function parse_PtgAttrSpaceSemi(blob) {&#13;
	blob.read_shift(2);&#13;
	return parse_PtgAttrSpaceType(blob, 2);&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.198.84 ; [MS-XLSB] 2.5.97.68 TODO */&#13;
function parse_PtgRef(blob, length, opts) {&#13;
	//var ptg = blob[blob.l] &amp; 0x1F;&#13;
	var type = (blob[blob.l] &amp; 0x60)&gt;&gt;5;&#13;
	blob.l += 1;&#13;
	var loc = parse_RgceLoc(blob, 0, opts);&#13;
	return [type, loc];&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.198.88 ; [MS-XLSB] 2.5.97.72 TODO */&#13;
function parse_PtgRefN(blob, length, opts) {&#13;
	var type = (blob[blob.l] &amp; 0x60)&gt;&gt;5;&#13;
	blob.l += 1;&#13;
	var loc = parse_RgceLocRel(blob, 0, opts);&#13;
	return [type, loc];&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.198.85 ; [MS-XLSB] 2.5.97.69 TODO */&#13;
function parse_PtgRef3d(blob, length, opts) {&#13;
	var type = (blob[blob.l] &amp; 0x60)&gt;&gt;5;&#13;
	blob.l += 1;&#13;
	var ixti = blob.read_shift(2); // XtiIndex&#13;
	if(opts &amp;&amp; opts.biff == 5) blob.l += 12;&#13;
	var loc = parse_RgceLoc(blob, 0, opts); // TODO: or RgceLocRel&#13;
	return [type, ixti, loc];&#13;
}&#13;
&#13;
&#13;
/* [MS-XLS] 2.5.198.62 ; [MS-XLSB] 2.5.97.45 TODO */&#13;
function parse_PtgFunc(blob, length, opts) {&#13;
	//var ptg = blob[blob.l] &amp; 0x1F;&#13;
	var type = (blob[blob.l] &amp; 0x60)&gt;&gt;5;&#13;
	blob.l += 1;&#13;
	var iftab = blob.read_shift(opts &amp;&amp; opts.biff &lt;= 3 ? 1 : 2);&#13;
	return [FtabArgc[iftab], Ftab[iftab], type];&#13;
}&#13;
/* [MS-XLS] 2.5.198.63 ; [MS-XLSB] 2.5.97.46 TODO */&#13;
function parse_PtgFuncVar(blob, length, opts) {&#13;
	var type = blob[blob.l++];&#13;
	var cparams = blob.read_shift(1), tab = opts &amp;&amp; opts.biff &lt;= 3 ? [(type == 0x58 ? -1 : 0), blob.read_shift(1)]: parsetab(blob);&#13;
	return [cparams, (tab[0] === 0 ? Ftab : Cetab)[tab[1]]];&#13;
}&#13;
&#13;
function parsetab(blob) {&#13;
	return [blob[blob.l+1]&gt;&gt;7, blob.read_shift(2) &amp; 0x7FFF];&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.198.41 ; [MS-XLSB] 2.5.97.33 */&#13;
function parse_PtgAttrSum(blob, length, opts) {&#13;
	blob.l += opts &amp;&amp; opts.biff == 2 ? 3 : 4; return;&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.198.58 ; [MS-XLSB] 2.5.97.40 */&#13;
function parse_PtgExp(blob, length, opts) {&#13;
	blob.l++;&#13;
	if(opts &amp;&amp; opts.biff == 12) return [blob.read_shift(4, 'i'), 0];&#13;
	var row = blob.read_shift(2);&#13;
	var col = blob.read_shift(opts &amp;&amp; opts.biff == 2 ? 1 : 2);&#13;
	return [row, col];&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.198.57 ; [MS-XLSB] 2.5.97.39 */&#13;
function parse_PtgErr(blob) { blob.l++; return BErr[blob.read_shift(1)]; }&#13;
&#13;
/* [MS-XLS] 2.5.198.66 ; [MS-XLSB] 2.5.97.49 */&#13;
function parse_PtgInt(blob) { blob.l++; return blob.read_shift(2); }&#13;
&#13;
/* [MS-XLS] 2.5.198.42 ; [MS-XLSB] 2.5.97.34 */&#13;
function parse_PtgBool(blob) { blob.l++; return blob.read_shift(1)!==0;}&#13;
&#13;
/* [MS-XLS] 2.5.198.79 ; [MS-XLSB] 2.5.97.63 */&#13;
function parse_PtgNum(blob) { blob.l++; return parse_Xnum(blob, 8); }&#13;
&#13;
/* [MS-XLS] 2.5.198.89 ; [MS-XLSB] 2.5.97.74 */&#13;
function parse_PtgStr(blob, length, opts) { blob.l++; return parse_ShortXLUnicodeString(blob, length-1, opts); }&#13;
&#13;
/* [MS-XLS] 2.5.192.112 + 2.5.192.11{3,4,5,6,7} */&#13;
/* [MS-XLSB] 2.5.97.93 + 2.5.97.9{4,5,6,7} */&#13;
function parse_SerAr(blob, biff) {&#13;
	var val = [blob.read_shift(1)];&#13;
	if(biff == 12) switch(val[0]) {&#13;
		case 0x02: val[0] = 0x04; break; /* SerBool */&#13;
		case 0x04: val[0] = 0x10; break; /* SerErr */&#13;
		case 0x00: val[0] = 0x01; break; /* SerNum */&#13;
		case 0x01: val[0] = 0x02; break; /* SerStr */&#13;
	}&#13;
	switch(val[0]) {&#13;
		case 0x04: /* SerBool -- boolean */&#13;
			val[1] = parsebool(blob, 1) ? 'TRUE' : 'FALSE';&#13;
			if(biff != 12) blob.l += 7; break;&#13;
		case 0x25: /* appears to be an alias */&#13;
		case 0x10: /* SerErr -- error */&#13;
			val[1] = BErr[blob[blob.l]];&#13;
			blob.l += ((biff == 12) ? 4 : 8); break;&#13;
		case 0x00: /* SerNil -- honestly, I'm not sure how to reproduce this */&#13;
			blob.l += 8; break;&#13;
		case 0x01: /* SerNum -- Xnum */&#13;
			val[1] = parse_Xnum(blob, 8); break;&#13;
		case 0x02: /* SerStr -- XLUnicodeString (&lt;256 chars) */&#13;
			val[1] = parse_XLUnicodeString2(blob, 0, {biff:biff &gt; 0 &amp;&amp; biff &lt; 8 ? 2 : biff}); break;&#13;
		default: throw new Error("Bad SerAr: " + val[0]); /* Unreachable */&#13;
	}&#13;
	return val;&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.198.61 ; [MS-XLSB] 2.5.97.44 */&#13;
function parse_PtgExtraMem(blob, cce, opts) {&#13;
	var count = blob.read_shift((opts.biff == 12) ? 4 : 2);&#13;
	var out = [];&#13;
	for(var i = 0; i != count; ++i) out.push(((opts.biff == 12) ? parse_UncheckedRfX : parse_Ref8U)(blob, 8));&#13;
	return out;&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.198.59 ; [MS-XLSB] 2.5.97.41 */&#13;
function parse_PtgExtraArray(blob, length, opts) {&#13;
	var rows = 0, cols = 0;&#13;
	if(opts.biff == 12) {&#13;
		rows = blob.read_shift(4); // DRw&#13;
		cols = blob.read_shift(4); // DCol&#13;
	} else {&#13;
		cols = 1 + blob.read_shift(1); //DColByteU&#13;
		rows = 1 + blob.read_shift(2); //DRw&#13;
	}&#13;
	if(opts.biff &gt;= 2 &amp;&amp; opts.biff &lt; 8) { --rows; if(--cols == 0) cols = 0x100; }&#13;
	// $FlowIgnore&#13;
	for(var i = 0, o = []; i != rows &amp;&amp; (o[i] = []); ++i)&#13;
		for(var j = 0; j != cols; ++j) o[i][j] = parse_SerAr(blob, opts.biff);&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.198.76 ; [MS-XLSB] 2.5.97.60 */&#13;
function parse_PtgName(blob, length, opts) {&#13;
	var type = (blob.read_shift(1) &gt;&gt;&gt; 5) &amp; 0x03;&#13;
	var w = (!opts || (opts.biff &gt;= 8)) ? 4 : 2;&#13;
	var nameindex = blob.read_shift(w);&#13;
	switch(opts.biff) {&#13;
		case 2: blob.l += 5; break;&#13;
		case 3: case 4: blob.l += 8; break;&#13;
		case 5: blob.l += 12; break;&#13;
	}&#13;
	return [type, 0, nameindex];&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.198.77 ; [MS-XLSB] 2.5.97.61 */&#13;
function parse_PtgNameX(blob, length, opts) {&#13;
	if(opts.biff == 5) return parse_PtgNameX_BIFF5(blob, length, opts);&#13;
	var type = (blob.read_shift(1) &gt;&gt;&gt; 5) &amp; 0x03;&#13;
	var ixti = blob.read_shift(2); // XtiIndex&#13;
	var nameindex = blob.read_shift(4);&#13;
	return [type, ixti, nameindex];&#13;
}&#13;
function parse_PtgNameX_BIFF5(blob) {&#13;
	var type = (blob.read_shift(1) &gt;&gt;&gt; 5) &amp; 0x03;&#13;
	var ixti = blob.read_shift(2, 'i'); // XtiIndex&#13;
	blob.l += 8;&#13;
	var nameindex = blob.read_shift(2);&#13;
	blob.l += 12;&#13;
	return [type, ixti, nameindex];&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.198.70 ; [MS-XLSB] 2.5.97.54 */&#13;
function parse_PtgMemArea(blob, length, opts) {&#13;
	var type = (blob.read_shift(1) &gt;&gt;&gt; 5) &amp; 0x03;&#13;
	blob.l += (opts &amp;&amp; opts.biff == 2 ? 3 : 4);&#13;
	var cce = blob.read_shift(opts &amp;&amp; opts.biff == 2 ? 1 : 2);&#13;
	return [type, cce];&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.198.72 ; [MS-XLSB] 2.5.97.56 */&#13;
function parse_PtgMemFunc(blob, length, opts) {&#13;
	var type = (blob.read_shift(1) &gt;&gt;&gt; 5) &amp; 0x03;&#13;
	var cce = blob.read_shift(opts &amp;&amp; opts.biff == 2 ? 1 : 2);&#13;
	return [type, cce];&#13;
}&#13;
&#13;
&#13;
/* [MS-XLS] 2.5.198.86 ; [MS-XLSB] 2.5.97.69 */&#13;
function parse_PtgRefErr(blob, length, opts) {&#13;
	var type = (blob.read_shift(1) &gt;&gt;&gt; 5) &amp; 0x03;&#13;
	blob.l += 4;&#13;
	if(opts.biff &lt; 8) blob.l--;&#13;
	if(opts.biff == 12) blob.l += 2;&#13;
	return [type];&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.198.87 ; [MS-XLSB] 2.5.97.71 */&#13;
function parse_PtgRefErr3d(blob, length, opts) {&#13;
	var type = (blob[blob.l++] &amp; 0x60) &gt;&gt; 5;&#13;
	var ixti = blob.read_shift(2);&#13;
	var w = 4;&#13;
	if(opts) switch(opts.biff) {&#13;
		case 5: w = 15; break;&#13;
		case 12: w = 6; break;&#13;
	}&#13;
	blob.l += w;&#13;
	return [type, ixti];&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.198.71 ; [MS-XLSB] 2.5.97.55 */&#13;
var parse_PtgMemErr = parsenoop;&#13;
/* [MS-XLS] 2.5.198.73  ; [MS-XLSB] 2.5.97.57 */&#13;
var parse_PtgMemNoMem = parsenoop;&#13;
/* [MS-XLS] 2.5.198.92 */&#13;
var parse_PtgTbl = parsenoop;&#13;
&#13;
function parse_PtgElfLoc(blob, length, opts) {&#13;
	blob.l += 2;&#13;
	return [parse_RgceElfLoc(blob, 4, opts)];&#13;
}&#13;
function parse_PtgElfNoop(blob) {&#13;
	blob.l += 6;&#13;
	return [];&#13;
}&#13;
/* [MS-XLS] 2.5.198.46 */&#13;
var parse_PtgElfCol = parse_PtgElfLoc;&#13;
/* [MS-XLS] 2.5.198.47 */&#13;
var parse_PtgElfColS = parse_PtgElfNoop;&#13;
/* [MS-XLS] 2.5.198.48 */&#13;
var parse_PtgElfColSV = parse_PtgElfNoop;&#13;
/* [MS-XLS] 2.5.198.49 */&#13;
var parse_PtgElfColV = parse_PtgElfLoc;&#13;
/* [MS-XLS] 2.5.198.50 */&#13;
function parse_PtgElfLel(blob) {&#13;
	blob.l += 2;&#13;
	return [parseuint16(blob), blob.read_shift(2) &amp; 0x01];&#13;
}&#13;
/* [MS-XLS] 2.5.198.51 */&#13;
var parse_PtgElfRadical = parse_PtgElfLoc;&#13;
/* [MS-XLS] 2.5.198.52 */&#13;
var parse_PtgElfRadicalLel = parse_PtgElfLel;&#13;
/* [MS-XLS] 2.5.198.53 */&#13;
var parse_PtgElfRadicalS = parse_PtgElfNoop;&#13;
/* [MS-XLS] 2.5.198.54 */&#13;
var parse_PtgElfRw = parse_PtgElfLoc;&#13;
/* [MS-XLS] 2.5.198.55 */&#13;
var parse_PtgElfRwV = parse_PtgElfLoc;&#13;
&#13;
/* [MS-XLSB] 2.5.97.52 TODO */&#13;
var PtgListRT = [&#13;
	"Data",&#13;
	"All",&#13;
	"Headers",&#13;
	"??",&#13;
	"?Data2",&#13;
	"??",&#13;
	"?DataHeaders",&#13;
	"??",&#13;
	"Totals",&#13;
	"??",&#13;
	"??",&#13;
	"??",&#13;
	"?DataTotals",&#13;
	"??",&#13;
	"??",&#13;
	"??",&#13;
	"?Current"&#13;
];&#13;
function parse_PtgList(blob) {&#13;
	blob.l += 2;&#13;
	var ixti = blob.read_shift(2);&#13;
	var flags = blob.read_shift(2);&#13;
	var idx = blob.read_shift(4);&#13;
	var c = blob.read_shift(2);&#13;
	var C = blob.read_shift(2);&#13;
	var rt = PtgListRT[(flags &gt;&gt; 2) &amp; 0x1F];&#13;
	return {ixti: ixti, coltype:(flags&amp;0x3), rt:rt, idx:idx, c:c, C:C};&#13;
}&#13;
/* [MS-XLS] 2.5.198.91 ; [MS-XLSB] 2.5.97.76 */&#13;
function parse_PtgSxName(blob) {&#13;
	blob.l += 2;&#13;
	return [blob.read_shift(4)];&#13;
}&#13;
&#13;
/* [XLS] old spec */&#13;
function parse_PtgSheet(blob, length, opts) {&#13;
	blob.l += 5;&#13;
	blob.l += 2;&#13;
	blob.l += (opts.biff == 2 ? 1 : 4);&#13;
	return ["PTGSHEET"];&#13;
}&#13;
function parse_PtgEndSheet(blob, length, opts) {&#13;
	blob.l += (opts.biff == 2 ? 4 : 5);&#13;
	return ["PTGENDSHEET"];&#13;
}&#13;
function parse_PtgMemAreaN(blob) {&#13;
	var type = (blob.read_shift(1) &gt;&gt;&gt; 5) &amp; 0x03;&#13;
	var cce = blob.read_shift(2);&#13;
	return [type, cce];&#13;
}&#13;
function parse_PtgMemNoMemN(blob) {&#13;
	var type = (blob.read_shift(1) &gt;&gt;&gt; 5) &amp; 0x03;&#13;
	var cce = blob.read_shift(2);&#13;
	return [type, cce];&#13;
}&#13;
function parse_PtgAttrNoop(blob) {&#13;
	blob.l += 4;&#13;
	return [0, 0];&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.198.25 ; [MS-XLSB] 2.5.97.16 */&#13;
var PtgTypes = {&#13;
0x01: { n:'PtgExp', f:parse_PtgExp },&#13;
0x02: { n:'PtgTbl', f:parse_PtgTbl },&#13;
0x03: { n:'PtgAdd', f:parseread1 },&#13;
0x04: { n:'PtgSub', f:parseread1 },&#13;
0x05: { n:'PtgMul', f:parseread1 },&#13;
0x06: { n:'PtgDiv', f:parseread1 },&#13;
0x07: { n:'PtgPower', f:parseread1 },&#13;
0x08: { n:'PtgConcat', f:parseread1 },&#13;
0x09: { n:'PtgLt', f:parseread1 },&#13;
0x0A: { n:'PtgLe', f:parseread1 },&#13;
0x0B: { n:'PtgEq', f:parseread1 },&#13;
0x0C: { n:'PtgGe', f:parseread1 },&#13;
0x0D: { n:'PtgGt', f:parseread1 },&#13;
0x0E: { n:'PtgNe', f:parseread1 },&#13;
0x0F: { n:'PtgIsect', f:parseread1 },&#13;
0x10: { n:'PtgUnion', f:parseread1 },&#13;
0x11: { n:'PtgRange', f:parseread1 },&#13;
0x12: { n:'PtgUplus', f:parseread1 },&#13;
0x13: { n:'PtgUminus', f:parseread1 },&#13;
0x14: { n:'PtgPercent', f:parseread1 },&#13;
0x15: { n:'PtgParen', f:parseread1 },&#13;
0x16: { n:'PtgMissArg', f:parseread1 },&#13;
0x17: { n:'PtgStr', f:parse_PtgStr },&#13;
0x1A: { n:'PtgSheet', f:parse_PtgSheet },&#13;
0x1B: { n:'PtgEndSheet', f:parse_PtgEndSheet },&#13;
0x1C: { n:'PtgErr', f:parse_PtgErr },&#13;
0x1D: { n:'PtgBool', f:parse_PtgBool },&#13;
0x1E: { n:'PtgInt', f:parse_PtgInt },&#13;
0x1F: { n:'PtgNum', f:parse_PtgNum },&#13;
0x20: { n:'PtgArray', f:parse_PtgArray },&#13;
0x21: { n:'PtgFunc', f:parse_PtgFunc },&#13;
0x22: { n:'PtgFuncVar', f:parse_PtgFuncVar },&#13;
0x23: { n:'PtgName', f:parse_PtgName },&#13;
0x24: { n:'PtgRef', f:parse_PtgRef },&#13;
0x25: { n:'PtgArea', f:parse_PtgArea },&#13;
0x26: { n:'PtgMemArea', f:parse_PtgMemArea },&#13;
0x27: { n:'PtgMemErr', f:parse_PtgMemErr },&#13;
0x28: { n:'PtgMemNoMem', f:parse_PtgMemNoMem },&#13;
0x29: { n:'PtgMemFunc', f:parse_PtgMemFunc },&#13;
0x2A: { n:'PtgRefErr', f:parse_PtgRefErr },&#13;
0x2B: { n:'PtgAreaErr', f:parse_PtgAreaErr },&#13;
0x2C: { n:'PtgRefN', f:parse_PtgRefN },&#13;
0x2D: { n:'PtgAreaN', f:parse_PtgAreaN },&#13;
0x2E: { n:'PtgMemAreaN', f:parse_PtgMemAreaN },&#13;
0x2F: { n:'PtgMemNoMemN', f:parse_PtgMemNoMemN },&#13;
0x39: { n:'PtgNameX', f:parse_PtgNameX },&#13;
0x3A: { n:'PtgRef3d', f:parse_PtgRef3d },&#13;
0x3B: { n:'PtgArea3d', f:parse_PtgArea3d },&#13;
0x3C: { n:'PtgRefErr3d', f:parse_PtgRefErr3d },&#13;
0x3D: { n:'PtgAreaErr3d', f:parse_PtgAreaErr3d },&#13;
0xFF: {}&#13;
};&#13;
/* These are duplicated in the PtgTypes table */&#13;
var PtgDupes = {&#13;
0x40: 0x20, 0x60: 0x20,&#13;
0x41: 0x21, 0x61: 0x21,&#13;
0x42: 0x22, 0x62: 0x22,&#13;
0x43: 0x23, 0x63: 0x23,&#13;
0x44: 0x24, 0x64: 0x24,&#13;
0x45: 0x25, 0x65: 0x25,&#13;
0x46: 0x26, 0x66: 0x26,&#13;
0x47: 0x27, 0x67: 0x27,&#13;
0x48: 0x28, 0x68: 0x28,&#13;
0x49: 0x29, 0x69: 0x29,&#13;
0x4A: 0x2A, 0x6A: 0x2A,&#13;
0x4B: 0x2B, 0x6B: 0x2B,&#13;
0x4C: 0x2C, 0x6C: 0x2C,&#13;
0x4D: 0x2D, 0x6D: 0x2D,&#13;
0x4E: 0x2E, 0x6E: 0x2E,&#13;
0x4F: 0x2F, 0x6F: 0x2F,&#13;
0x58: 0x22, 0x78: 0x22,&#13;
0x59: 0x39, 0x79: 0x39,&#13;
0x5A: 0x3A, 0x7A: 0x3A,&#13;
0x5B: 0x3B, 0x7B: 0x3B,&#13;
0x5C: 0x3C, 0x7C: 0x3C,&#13;
0x5D: 0x3D, 0x7D: 0x3D&#13;
};&#13;
&#13;
var Ptg18 = {&#13;
0x01: { n:'PtgElfLel', f:parse_PtgElfLel },&#13;
0x02: { n:'PtgElfRw', f:parse_PtgElfRw },&#13;
0x03: { n:'PtgElfCol', f:parse_PtgElfCol },&#13;
0x06: { n:'PtgElfRwV', f:parse_PtgElfRwV },&#13;
0x07: { n:'PtgElfColV', f:parse_PtgElfColV },&#13;
0x0A: { n:'PtgElfRadical', f:parse_PtgElfRadical },&#13;
0x0B: { n:'PtgElfRadicalS', f:parse_PtgElfRadicalS },&#13;
0x0D: { n:'PtgElfColS', f:parse_PtgElfColS },&#13;
0x0F: { n:'PtgElfColSV', f:parse_PtgElfColSV },&#13;
0x10: { n:'PtgElfRadicalLel', f:parse_PtgElfRadicalLel },&#13;
0x19: { n:'PtgList', f:parse_PtgList },&#13;
0x1D: { n:'PtgSxName', f:parse_PtgSxName },&#13;
0xFF: {}&#13;
};&#13;
var Ptg19 = {&#13;
0x00: { n:'PtgAttrNoop', f:parse_PtgAttrNoop },&#13;
0x01: { n:'PtgAttrSemi', f:parse_PtgAttrSemi },&#13;
0x02: { n:'PtgAttrIf', f:parse_PtgAttrIf },&#13;
0x04: { n:'PtgAttrChoose', f:parse_PtgAttrChoose },&#13;
0x08: { n:'PtgAttrGoto', f:parse_PtgAttrGoto },&#13;
0x10: { n:'PtgAttrSum', f:parse_PtgAttrSum },&#13;
0x20: { n:'PtgAttrBaxcel', f:parse_PtgAttrBaxcel },&#13;
0x21: { n:'PtgAttrBaxcel', f:parse_PtgAttrBaxcel },&#13;
0x40: { n:'PtgAttrSpace', f:parse_PtgAttrSpace },&#13;
0x41: { n:'PtgAttrSpaceSemi', f:parse_PtgAttrSpaceSemi },&#13;
0x80: { n:'PtgAttrIfError', f:parse_PtgAttrIfError },&#13;
0xFF: {}&#13;
};&#13;
&#13;
/* [MS-XLS] 2.5.198.103 ; [MS-XLSB] 2.5.97.87 */&#13;
function parse_RgbExtra(blob, length, rgce, opts) {&#13;
	if(opts.biff &lt; 8) return parsenoop(blob, length);&#13;
	var target = blob.l + length;&#13;
	var o = [];&#13;
	for(var i = 0; i !== rgce.length; ++i) {&#13;
		switch(rgce[i][0]) {&#13;
			case 'PtgArray': /* PtgArray -&gt; PtgExtraArray */&#13;
				rgce[i][1] = parse_PtgExtraArray(blob, 0, opts);&#13;
				o.push(rgce[i][1]);&#13;
				break;&#13;
			case 'PtgMemArea': /* PtgMemArea -&gt; PtgExtraMem */&#13;
				rgce[i][2] = parse_PtgExtraMem(blob, rgce[i][1], opts);&#13;
				o.push(rgce[i][2]);&#13;
				break;&#13;
			case 'PtgExp': /* PtgExp -&gt; PtgExtraCol */&#13;
				if(opts &amp;&amp; opts.biff == 12) {&#13;
					rgce[i][1][1] = blob.read_shift(4);&#13;
					o.push(rgce[i][1]);&#13;
				} break;&#13;
			case 'PtgList': /* TODO: PtgList -&gt; PtgExtraList */&#13;
			case 'PtgElfRadicalS': /* TODO: PtgElfRadicalS -&gt; PtgExtraElf */&#13;
			case 'PtgElfColS': /* TODO: PtgElfColS -&gt; PtgExtraElf */&#13;
			case 'PtgElfColSV': /* TODO: PtgElfColSV -&gt; PtgExtraElf */&#13;
				throw "Unsupported " + rgce[i][0];&#13;
			default: break;&#13;
		}&#13;
	}&#13;
	length = target - blob.l;&#13;
	/* note: this is technically an error but Excel disregards */&#13;
	//if(target !== blob.l &amp;&amp; blob.l !== target - length) throw new Error(target + " != " + blob.l);&#13;
	if(length !== 0) o.push(parsenoop(blob, length));&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.198.104 ; [MS-XLSB] 2.5.97.88 */&#13;
function parse_Rgce(blob, length, opts) {&#13;
	var target = blob.l + length;&#13;
	var R, id, ptgs = [];&#13;
	while(target != blob.l) {&#13;
		length = target - blob.l;&#13;
		id = blob[blob.l];&#13;
		R = PtgTypes[id] || PtgTypes[PtgDupes[id]];&#13;
		if(id === 0x18 || id === 0x19) R = (id === 0x18 ? Ptg18 : Ptg19)[blob[blob.l + 1]];&#13;
		if(!R || !R.f) { /*ptgs.push*/(parsenoop(blob, length)); }&#13;
		else { ptgs.push([R.n, R.f(blob, length, opts)]); }&#13;
	}&#13;
	return ptgs;&#13;
}&#13;
&#13;
function stringify_array(f) {&#13;
	var o = [];&#13;
	for(var i = 0; i &lt; f.length; ++i) {&#13;
		var x = f[i], r = [];&#13;
		for(var j = 0; j &lt; x.length; ++j) {&#13;
			var y = x[j];&#13;
			if(y) switch(y[0]) {&#13;
				// TODO: handle embedded quotes&#13;
				case 0x02:&#13;
r.push('"' + y[1].replace(/"/g,'""') + '"'); break;&#13;
				default: r.push(y[1]);&#13;
			} else r.push("");&#13;
		}&#13;
		o.push(r.join(","));&#13;
	}&#13;
	return o.join(";");&#13;
}&#13;
&#13;
/* [MS-XLS] 2.2.2 ; [MS-XLSB] 2.2.2 TODO */&#13;
var PtgBinOp = {&#13;
	PtgAdd: "+",&#13;
	PtgConcat: "&amp;",&#13;
	PtgDiv: "/",&#13;
	PtgEq: "=",&#13;
	PtgGe: "&gt;=",&#13;
	PtgGt: "&gt;",&#13;
	PtgLe: "&lt;=",&#13;
	PtgLt: "&lt;",&#13;
	PtgMul: "*",&#13;
	PtgNe: "&lt;&gt;",&#13;
	PtgPower: "^",&#13;
	PtgSub: "-"&#13;
};&#13;
&#13;
// TODO: explore space&#13;
function make_3d_range(start, end) {&#13;
	var s = start.lastIndexOf("!"), e = end.lastIndexOf("!");&#13;
	if(s == -1 &amp;&amp; e == -1) return start + ":" + end;&#13;
	if(s &gt; 0 &amp;&amp; e &gt; 0 &amp;&amp; start.slice(0, s).toLowerCase() == end.slice(0, e).toLowerCase()) return start + ":" + end.slice(e+1);&#13;
	console.error("Cannot hydrate range", start, end);&#13;
	return start + ":" + end;&#13;
}&#13;
&#13;
function get_ixti_raw(supbooks, ixti, opts) {&#13;
	if(!supbooks) return "SH33TJSERR0";&#13;
	if(opts.biff &gt; 8 &amp;&amp; (!supbooks.XTI || !supbooks.XTI[ixti])) return supbooks.SheetNames[ixti];&#13;
	if(!supbooks.XTI) return "SH33TJSERR6";&#13;
	var XTI = supbooks.XTI[ixti];&#13;
	if(opts.biff &lt; 8) {&#13;
		if(ixti &gt; 10000) ixti-= 65536;&#13;
		if(ixti &lt; 0) ixti = -ixti;&#13;
		return ixti == 0 ? "" : supbooks.XTI[ixti - 1];&#13;
	}&#13;
	if(!XTI) return "SH33TJSERR1";&#13;
	var o = "";&#13;
	if(opts.biff &gt; 8) switch(supbooks[XTI[0]][0]) {&#13;
		case 0x0165: /* 'BrtSupSelf' */&#13;
			o = XTI[1] == -1 ? "#REF" : supbooks.SheetNames[XTI[1]];&#13;
			return XTI[1] == XTI[2] ? o : o + ":" + supbooks.SheetNames[XTI[2]];&#13;
		case 0x0166: /* 'BrtSupSame' */&#13;
			if(opts.SID != null) return supbooks.SheetNames[opts.SID];&#13;
			return "SH33TJSSAME" + supbooks[XTI[0]][0];&#13;
		case 0x0163: /* 'BrtSupBookSrc' */&#13;
			/* falls through */&#13;
		default: return "SH33TJSSRC" + supbooks[XTI[0]][0];&#13;
	}&#13;
	switch(supbooks[XTI[0]][0][0]) {&#13;
		case 0x0401:&#13;
			o = XTI[1] == -1 ? "#REF" : (supbooks.SheetNames[XTI[1]] || "SH33TJSERR3");&#13;
			return XTI[1] == XTI[2] ? o : o + ":" + supbooks.SheetNames[XTI[2]];&#13;
		case 0x3A01: return supbooks[XTI[0]].slice(1).map(function(name) { return name.Name; }).join(";;"); //return "SH33TJSERR8";&#13;
		default:&#13;
			if(!supbooks[XTI[0]][0][3]) return "SH33TJSERR2";&#13;
			o = XTI[1] == -1 ? "#REF" : (supbooks[XTI[0]][0][3][XTI[1]] || "SH33TJSERR4");&#13;
			return XTI[1] == XTI[2] ? o : o + ":" + supbooks[XTI[0]][0][3][XTI[2]];&#13;
	}&#13;
}&#13;
function get_ixti(supbooks, ixti, opts) {&#13;
	var ixtiraw = get_ixti_raw(supbooks, ixti, opts);&#13;
	return ixtiraw == "#REF" ? ixtiraw : formula_quote_sheet_name(ixtiraw, opts);&#13;
}&#13;
function stringify_formula(formula/*Array&lt;any&gt;*/, range, cell, supbooks, opts) {&#13;
	var biff = (opts &amp;&amp; opts.biff) || 8;&#13;
	var _range = /*range != null ? range :*/ {s:{c:0, r:0},e:{c:0, r:0}};&#13;
	var stack = [], e1, e2,  c, ixti=0, nameidx=0, r, sname="";&#13;
	if(!formula[0] || !formula[0][0]) return "";&#13;
	var last_sp = -1, sp = "";&#13;
	for(var ff = 0, fflen = formula[0].length; ff &lt; fflen; ++ff) {&#13;
		var f = formula[0][ff];&#13;
		switch(f[0]) {&#13;
			case 'PtgUminus': /* [MS-XLS] 2.5.198.93 */&#13;
				stack.push("-" + stack.pop()); break;&#13;
			case 'PtgUplus': /* [MS-XLS] 2.5.198.95 */&#13;
				stack.push("+" + stack.pop()); break;&#13;
			case 'PtgPercent': /* [MS-XLS] 2.5.198.81 */&#13;
				stack.push(stack.pop() + "%"); break;&#13;
&#13;
			case 'PtgAdd':    /* [MS-XLS] 2.5.198.26 */&#13;
			case 'PtgConcat': /* [MS-XLS] 2.5.198.43 */&#13;
			case 'PtgDiv':    /* [MS-XLS] 2.5.198.45 */&#13;
			case 'PtgEq':     /* [MS-XLS] 2.5.198.56 */&#13;
			case 'PtgGe':     /* [MS-XLS] 2.5.198.64 */&#13;
			case 'PtgGt':     /* [MS-XLS] 2.5.198.65 */&#13;
			case 'PtgLe':     /* [MS-XLS] 2.5.198.68 */&#13;
			case 'PtgLt':     /* [MS-XLS] 2.5.198.69 */&#13;
			case 'PtgMul':    /* [MS-XLS] 2.5.198.75 */&#13;
			case 'PtgNe':     /* [MS-XLS] 2.5.198.78 */&#13;
			case 'PtgPower':  /* [MS-XLS] 2.5.198.82 */&#13;
			case 'PtgSub':    /* [MS-XLS] 2.5.198.90 */&#13;
				e1 = stack.pop(); e2 = stack.pop();&#13;
				if(last_sp &gt;= 0) {&#13;
					switch(formula[0][last_sp][1][0]) {&#13;
						case 0:&#13;
							// $FlowIgnore&#13;
							sp = fill(" ", formula[0][last_sp][1][1]); break;&#13;
						case 1:&#13;
							// $FlowIgnore&#13;
							sp = fill("\r", formula[0][last_sp][1][1]); break;&#13;
						default:&#13;
							sp = "";&#13;
							// $FlowIgnore&#13;
							if(opts.WTF) throw new Error("Unexpected PtgAttrSpaceType " + formula[0][last_sp][1][0]);&#13;
					}&#13;
					e2 = e2 + sp;&#13;
					last_sp = -1;&#13;
				}&#13;
				stack.push(e2+PtgBinOp[f[0]]+e1);&#13;
				break;&#13;
&#13;
			case 'PtgIsect': /* [MS-XLS] 2.5.198.67 */&#13;
				e1 = stack.pop(); e2 = stack.pop();&#13;
				stack.push(e2+" "+e1);&#13;
				break;&#13;
			case 'PtgUnion': /* [MS-XLS] 2.5.198.94 */&#13;
				e1 = stack.pop(); e2 = stack.pop();&#13;
				stack.push(e2+","+e1);&#13;
				break;&#13;
			case 'PtgRange': /* [MS-XLS] 2.5.198.83 */&#13;
				e1 = stack.pop(); e2 = stack.pop();&#13;
				stack.push(make_3d_range(e2,e1));&#13;
				break;&#13;
&#13;
			case 'PtgAttrChoose': /* [MS-XLS] 2.5.198.34 */&#13;
				break;&#13;
			case 'PtgAttrGoto': /* [MS-XLS] 2.5.198.35 */&#13;
				break;&#13;
			case 'PtgAttrIf': /* [MS-XLS] 2.5.198.36 */&#13;
				break;&#13;
			case 'PtgAttrIfError': /* [MS-XLSB] 2.5.97.28 */&#13;
				break;&#13;
&#13;
&#13;
			case 'PtgRef': /* [MS-XLS] 2.5.198.84 */&#13;
c = shift_cell_xls((f[1][1]), _range, opts);&#13;
				stack.push(encode_cell_xls(c, biff));&#13;
				break;&#13;
			case 'PtgRefN': /* [MS-XLS] 2.5.198.88 */&#13;
c = cell ? shift_cell_xls((f[1][1]), cell, opts) : (f[1][1]);&#13;
				stack.push(encode_cell_xls(c, biff));&#13;
				break;&#13;
			case 'PtgRef3d': /* [MS-XLS] 2.5.198.85 */&#13;
ixti = f[1][1]; c = shift_cell_xls((f[1][2]), _range, opts);&#13;
				sname = get_ixti(supbooks, ixti, opts);&#13;
				var w = sname; /* IE9 fails on defined names */ // eslint-disable-line no-unused-vars&#13;
				stack.push(sname + "!" + encode_cell_xls(c, biff));&#13;
				break;&#13;
&#13;
			case 'PtgFunc': /* [MS-XLS] 2.5.198.62 */&#13;
			case 'PtgFuncVar': /* [MS-XLS] 2.5.198.63 */&#13;
				/* f[1] = [argc, func, type] */&#13;
				var argc = (f[1][0]), func = (f[1][1]);&#13;
				if(!argc) argc = 0;&#13;
				argc &amp;= 0x7F;&#13;
				var args = argc == 0 ? [] : stack.slice(-argc);&#13;
				stack.length -= argc;&#13;
				if(func === 'User') func = args.shift();&#13;
				stack.push(func + "(" + args.join(",") + ")");&#13;
				break;&#13;
&#13;
			case 'PtgBool': /* [MS-XLS] 2.5.198.42 */&#13;
				stack.push(f[1] ? "TRUE" : "FALSE"); break;&#13;
			case 'PtgInt': /* [MS-XLS] 2.5.198.66 */&#13;
				stack.push(f[1]); break;&#13;
			case 'PtgNum': /* [MS-XLS] 2.5.198.79 TODO: precision? */&#13;
				stack.push(String(f[1])); break;&#13;
			case 'PtgStr': /* [MS-XLS] 2.5.198.89 */&#13;
				// $FlowIgnore&#13;
				stack.push('"' + f[1].replace(/"/g, '""') + '"'); break;&#13;
			case 'PtgErr': /* [MS-XLS] 2.5.198.57 */&#13;
				stack.push(f[1]); break;&#13;
			case 'PtgAreaN': /* [MS-XLS] 2.5.198.31 TODO */&#13;
r = shift_range_xls(f[1][1], cell ? {s:cell} : _range, opts);&#13;
				stack.push(encode_range_xls((r), opts));&#13;
				break;&#13;
			case 'PtgArea': /* [MS-XLS] 2.5.198.27 TODO: fixed points */&#13;
r = shift_range_xls(f[1][1], _range, opts);&#13;
				stack.push(encode_range_xls((r), opts));&#13;
				break;&#13;
			case 'PtgArea3d': /* [MS-XLS] 2.5.198.28 TODO */&#13;
ixti = f[1][1]; r = f[1][2];&#13;
				sname = get_ixti(supbooks, ixti, opts);&#13;
				stack.push(sname + "!" + encode_range_xls((r), opts));&#13;
				break;&#13;
			case 'PtgAttrSum': /* [MS-XLS] 2.5.198.41 */&#13;
				stack.push("SUM(" + stack.pop() + ")");&#13;
				break;&#13;
&#13;
			case 'PtgAttrBaxcel': /* [MS-XLS] 2.5.198.33 */&#13;
			case 'PtgAttrSemi': /* [MS-XLS] 2.5.198.37 */&#13;
				break;&#13;
&#13;
			case 'PtgName': /* [MS-XLS] 2.5.198.76 ; [MS-XLSB] 2.5.97.60 TODO: revisions */&#13;
				/* f[1] = type, 0, nameindex */&#13;
				nameidx = (f[1][2]);&#13;
				var lbl = (supbooks.names||[])[nameidx-1] || (supbooks[0]||[])[nameidx];&#13;
				var name = lbl ? lbl.Name : "SH33TJSNAME" + String(nameidx);&#13;
				/* [MS-XLSB] 2.5.97.10 Ftab -- last verified 20220204 */&#13;
				if(name &amp;&amp; name.slice(0,6) == "_xlfn." &amp;&amp; !opts.xlfn) name = name.slice(6);&#13;
				stack.push(name);&#13;
				break;&#13;
&#13;
			case 'PtgNameX': /* [MS-XLS] 2.5.198.77 ; [MS-XLSB] 2.5.97.61 TODO: revisions */&#13;
				/* f[1] = type, ixti, nameindex */&#13;
				var bookidx = (f[1][1]); nameidx = (f[1][2]); var externbook;&#13;
				/* TODO: Properly handle missing values -- this should be using get_ixti_raw primarily */&#13;
				if(opts.biff &lt;= 5) {&#13;
					if(bookidx &lt; 0) bookidx = -bookidx;&#13;
					if(supbooks[bookidx]) externbook = supbooks[bookidx][nameidx];&#13;
				} else {&#13;
					var o = "";&#13;
					if(((supbooks[bookidx]||[])[0]||[])[0] == 0x3A01){/* empty */}&#13;
					else if(((supbooks[bookidx]||[])[0]||[])[0] == 0x0401){&#13;
						if(supbooks[bookidx][nameidx] &amp;&amp; supbooks[bookidx][nameidx].itab &gt; 0) {&#13;
							o = supbooks.SheetNames[supbooks[bookidx][nameidx].itab-1] + "!";&#13;
						}&#13;
					}&#13;
					else o = supbooks.SheetNames[nameidx-1]+ "!";&#13;
					if(supbooks[bookidx] &amp;&amp; supbooks[bookidx][nameidx]) o += supbooks[bookidx][nameidx].Name;&#13;
					else if(supbooks[0] &amp;&amp; supbooks[0][nameidx]) o += supbooks[0][nameidx].Name;&#13;
					else {&#13;
						var ixtidata = (get_ixti_raw(supbooks, bookidx, opts)||"").split(";;");&#13;
						if(ixtidata[nameidx - 1]) o = ixtidata[nameidx - 1]; // TODO: confirm this is correct&#13;
						else o += "SH33TJSERRX";&#13;
					}&#13;
					stack.push(o);&#13;
					break;&#13;
				}&#13;
				if(!externbook) externbook = {Name: "SH33TJSERRY"};&#13;
				stack.push(externbook.Name);&#13;
				break;&#13;
&#13;
			case 'PtgParen': /* [MS-XLS] 2.5.198.80 */&#13;
				var lp = '(', rp = ')';&#13;
				if(last_sp &gt;= 0) {&#13;
					sp = "";&#13;
					switch(formula[0][last_sp][1][0]) {&#13;
						// $FlowIgnore&#13;
						case 2: lp = fill(" ", formula[0][last_sp][1][1]) + lp; break;&#13;
						// $FlowIgnore&#13;
						case 3: lp = fill("\r", formula[0][last_sp][1][1]) + lp; break;&#13;
						// $FlowIgnore&#13;
						case 4: rp = fill(" ", formula[0][last_sp][1][1]) + rp; break;&#13;
						// $FlowIgnore&#13;
						case 5: rp = fill("\r", formula[0][last_sp][1][1]) + rp; break;&#13;
						default:&#13;
							// $FlowIgnore&#13;
							if(opts.WTF) throw new Error("Unexpected PtgAttrSpaceType " + formula[0][last_sp][1][0]);&#13;
					}&#13;
					last_sp = -1;&#13;
				}&#13;
				stack.push(lp + stack.pop() + rp); break;&#13;
&#13;
			case 'PtgRefErr': /* [MS-XLS] 2.5.198.86 */&#13;
				stack.push('#REF!'); break;&#13;
&#13;
			case 'PtgRefErr3d': /* [MS-XLS] 2.5.198.87 */&#13;
				stack.push('#REF!'); break;&#13;
&#13;
			case 'PtgExp': /* [MS-XLS] 2.5.198.58 TODO */&#13;
				c = {c:(f[1][1]),r:(f[1][0])};&#13;
				var q = ({c: cell.c, r:cell.r});&#13;
				if(supbooks.sharedf[encode_cell(c)]) {&#13;
					var parsedf = (supbooks.sharedf[encode_cell(c)]);&#13;
					stack.push(stringify_formula(parsedf, _range, q, supbooks, opts));&#13;
				} else {&#13;
					var fnd = false;&#13;
					for(e1=0;e1!=supbooks.arrayf.length; ++e1) {&#13;
						/* TODO: should be something like range_has */&#13;
						e2 = supbooks.arrayf[e1];&#13;
						if(c.c &lt; e2[0].s.c || c.c &gt; e2[0].e.c) continue;&#13;
						if(c.r &lt; e2[0].s.r || c.r &gt; e2[0].e.r) continue;&#13;
						stack.push(stringify_formula(e2[1], _range, q, supbooks, opts));&#13;
						fnd = true;&#13;
						break;&#13;
					}&#13;
					if(!fnd) stack.push(f[1]);&#13;
				}&#13;
				break;&#13;
&#13;
			case 'PtgArray': /* [MS-XLS] 2.5.198.32 TODO */&#13;
				stack.push("{" + stringify_array(f[1]) + "}");&#13;
				break;&#13;
&#13;
			case 'PtgMemArea': /* [MS-XLS] 2.5.198.70 TODO: confirm this is a non-display */&#13;
				//stack.push("(" + f[2].map(encode_range).join(",") + ")");&#13;
				break;&#13;
&#13;
			case 'PtgAttrSpace': /* [MS-XLS] 2.5.198.38 */&#13;
			case 'PtgAttrSpaceSemi': /* [MS-XLS] 2.5.198.39 */&#13;
				last_sp = ff;&#13;
				break;&#13;
&#13;
			case 'PtgTbl': /* [MS-XLS] 2.5.198.92 TODO */&#13;
				break;&#13;
&#13;
			case 'PtgMemErr': /* [MS-XLS] 2.5.198.71 */&#13;
				break;&#13;
&#13;
			case 'PtgMissArg': /* [MS-XLS] 2.5.198.74 */&#13;
				stack.push("");&#13;
				break;&#13;
&#13;
			case 'PtgAreaErr': /* [MS-XLS] 2.5.198.29 */&#13;
				stack.push("#REF!"); break;&#13;
&#13;
			case 'PtgAreaErr3d': /* [MS-XLS] 2.5.198.30 */&#13;
				stack.push("#REF!"); break;&#13;
&#13;
			case 'PtgList': /* [MS-XLSB] 2.5.97.52 */&#13;
				// $FlowIgnore&#13;
				stack.push("Table" + f[1].idx + "[#" + f[1].rt + "]");&#13;
				break;&#13;
&#13;
			case 'PtgMemAreaN':&#13;
			case 'PtgMemNoMemN':&#13;
			case 'PtgAttrNoop':&#13;
			case 'PtgSheet':&#13;
			case 'PtgEndSheet':&#13;
				break;&#13;
&#13;
			case 'PtgMemFunc': /* [MS-XLS] 2.5.198.72 TODO */&#13;
				break;&#13;
			case 'PtgMemNoMem': /* [MS-XLS] 2.5.198.73 TODO */&#13;
				break;&#13;
&#13;
			case 'PtgElfCol': /* [MS-XLS] 2.5.198.46 */&#13;
			case 'PtgElfColS': /* [MS-XLS] 2.5.198.47 */&#13;
			case 'PtgElfColSV': /* [MS-XLS] 2.5.198.48 */&#13;
			case 'PtgElfColV': /* [MS-XLS] 2.5.198.49 */&#13;
			case 'PtgElfLel': /* [MS-XLS] 2.5.198.50 */&#13;
			case 'PtgElfRadical': /* [MS-XLS] 2.5.198.51 */&#13;
			case 'PtgElfRadicalLel': /* [MS-XLS] 2.5.198.52 */&#13;
			case 'PtgElfRadicalS': /* [MS-XLS] 2.5.198.53 */&#13;
			case 'PtgElfRw': /* [MS-XLS] 2.5.198.54 */&#13;
			case 'PtgElfRwV': /* [MS-XLS] 2.5.198.55 */&#13;
				throw new Error("Unsupported ELFs");&#13;
&#13;
			case 'PtgSxName': /* [MS-XLS] 2.5.198.91 TODO -- find a test case */&#13;
				throw new Error('Unrecognized Formula Token: ' + String(f));&#13;
			default: throw new Error('Unrecognized Formula Token: ' + String(f));&#13;
		}&#13;
		var PtgNonDisp = ['PtgAttrSpace', 'PtgAttrSpaceSemi', 'PtgAttrGoto'];&#13;
		if(opts.biff != 3) if(last_sp &gt;= 0 &amp;&amp; PtgNonDisp.indexOf(formula[0][ff][0]) == -1) {&#13;
			f = formula[0][last_sp];&#13;
			var _left = true;&#13;
			switch(f[1][0]) {&#13;
				/* note: some bad XLSB files omit the PtgParen */&#13;
				case 4: _left = false;&#13;
				/* falls through */&#13;
				case 0:&#13;
					// $FlowIgnore&#13;
					sp = fill(" ", f[1][1]); break;&#13;
				case 5: _left = false;&#13;
				/* falls through */&#13;
				case 1:&#13;
					// $FlowIgnore&#13;
					sp = fill("\r", f[1][1]); break;&#13;
				default:&#13;
					sp = "";&#13;
					// $FlowIgnore&#13;
					if(opts.WTF) throw new Error("Unexpected PtgAttrSpaceType " + f[1][0]);&#13;
			}&#13;
			stack.push((_left ? sp : "") + stack.pop() + (_left ? "" : sp));&#13;
			last_sp = -1;&#13;
		}&#13;
	}&#13;
	if(stack.length &gt; 1 &amp;&amp; opts.WTF) throw new Error("bad formula stack");&#13;
	if(stack[0] == "TRUE") return true; if(stack[0] == "FALSE") return false;&#13;
	return stack[0];&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.198.1 TODO */&#13;
function parse_ArrayParsedFormula(blob, length, opts) {&#13;
	var target = blob.l + length, len = opts.biff == 2 ? 1 : 2;&#13;
	var rgcb, cce = blob.read_shift(len); // length of rgce&#13;
	if(cce == 0xFFFF) return [[],parsenoop(blob, length-2)];&#13;
	var rgce = parse_Rgce(blob, cce, opts);&#13;
	if(length !== cce + len) rgcb = parse_RgbExtra(blob, length - cce - len, rgce, opts);&#13;
	blob.l = target;&#13;
	return [rgce, rgcb];&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.198.3 TODO */&#13;
function parse_XLSCellParsedFormula(blob, length, opts) {&#13;
	var target = blob.l + length, len = opts.biff == 2 ? 1 : 2;&#13;
	var rgcb, cce = blob.read_shift(len); // length of rgce&#13;
	if(cce == 0xFFFF) return [[],parsenoop(blob, length-2)];&#13;
	var rgce = parse_Rgce(blob, cce, opts);&#13;
	if(length !== cce + len) rgcb = parse_RgbExtra(blob, length - cce - len, rgce, opts);&#13;
	blob.l = target;&#13;
	return [rgce, rgcb];&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.198.21 */&#13;
function parse_NameParsedFormula(blob, length, opts, cce) {&#13;
	var target = blob.l + length;&#13;
	var rgce = parse_Rgce(blob, cce, opts);&#13;
	var rgcb;&#13;
	if(target !== blob.l) rgcb = parse_RgbExtra(blob, target - blob.l, rgce, opts);&#13;
	return [rgce, rgcb];&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.198.118 TODO */&#13;
function parse_SharedParsedFormula(blob, length, opts) {&#13;
	var target = blob.l + length;&#13;
	var rgcb, cce = blob.read_shift(2); // length of rgce&#13;
	var rgce = parse_Rgce(blob, cce, opts);&#13;
	if(cce == 0xFFFF) return [[],parsenoop(blob, length-2)];&#13;
	if(length !== cce + 2) rgcb = parse_RgbExtra(blob, target - cce - 2, rgce, opts);&#13;
	return [rgce, rgcb];&#13;
}&#13;
&#13;
/* [MS-XLS] 2.5.133 TODO: how to emit empty strings? */&#13;
function parse_FormulaValue(blob) {&#13;
	var b;&#13;
	if(__readUInt16LE(blob,blob.l + 6) !== 0xFFFF) return [parse_Xnum(blob),'n'];&#13;
	switch(blob[blob.l]) {&#13;
		case 0x00: blob.l += 8; return ["String", 's'];&#13;
		case 0x01: b = blob[blob.l+2] === 0x1; blob.l += 8; return [b,'b'];&#13;
		case 0x02: b = blob[blob.l+2]; blob.l += 8; return [b,'e'];&#13;
		case 0x03: blob.l += 8; return ["",'s'];&#13;
	}&#13;
	return [];&#13;
}&#13;
function write_FormulaValue(value) {&#13;
	if(value == null) {&#13;
		// Blank String Value&#13;
		var o = new_buf(8);&#13;
		o.write_shift(1, 0x03);&#13;
		o.write_shift(1, 0);&#13;
		o.write_shift(2, 0);&#13;
		o.write_shift(2, 0);&#13;
		o.write_shift(2, 0xFFFF);&#13;
		return o;&#13;
	} else if(typeof value == "number") return write_Xnum(value);&#13;
	return write_Xnum(0);&#13;
}&#13;
&#13;
/* [MS-XLS] 2.4.127 TODO */&#13;
function parse_Formula(blob, length, opts) {&#13;
	var end = blob.l + length;&#13;
	var cell = parse_XLSCell(blob, 6);&#13;
	if(opts.biff == 2) ++blob.l;&#13;
	var val = parse_FormulaValue(blob,8);&#13;
	var flags = blob.read_shift(1);&#13;
	if(opts.biff != 2) {&#13;
		blob.read_shift(1);&#13;
		if(opts.biff &gt;= 5) {&#13;
			/*var chn = */blob.read_shift(4);&#13;
		}&#13;
	}&#13;
	var cbf = parse_XLSCellParsedFormula(blob, end - blob.l, opts);&#13;
	return {cell:cell, val:val[0], formula:cbf, shared: (flags &gt;&gt; 3) &amp; 1, tt:val[1]};&#13;
}&#13;
function write_Formula(cell, R, C, opts, os) {&#13;
	// Cell&#13;
	var o1 = write_XLSCell(R, C, os);&#13;
&#13;
	// FormulaValue&#13;
	var o2 = write_FormulaValue(cell.v);&#13;
&#13;
	// flags + cache&#13;
	var o3 = new_buf(6);&#13;
	var flags = 0x01 | 0x20;&#13;
	o3.write_shift(2, flags);&#13;
	o3.write_shift(4, 0);&#13;
&#13;
	// CellParsedFormula&#13;
	var bf = new_buf(cell.bf.length);&#13;
	for(var i = 0; i &lt; cell.bf.length; ++i) bf[i] = cell.bf[i];&#13;
&#13;
	var out = bconcat([o1, o2, o3, bf]);&#13;
	return out;&#13;
}&#13;
&#13;
&#13;
/* XLSB Parsed Formula records have the same shape */&#13;
function parse_XLSBParsedFormula(data, length, opts) {&#13;
	var cce = data.read_shift(4);&#13;
	var rgce = parse_Rgce(data, cce, opts);&#13;
	var cb = data.read_shift(4);&#13;
	var rgcb = cb &gt; 0 ? parse_RgbExtra(data, cb, rgce, opts) : null;&#13;
	return [rgce, rgcb];&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.5.97.1 ArrayParsedFormula */&#13;
var parse_XLSBArrayParsedFormula = parse_XLSBParsedFormula;&#13;
/* [MS-XLSB] 2.5.97.4 CellParsedFormula */&#13;
var parse_XLSBCellParsedFormula = parse_XLSBParsedFormula;&#13;
/* [MS-XLSB] 2.5.97.8 DVParsedFormula */&#13;
//var parse_XLSBDVParsedFormula = parse_XLSBParsedFormula;&#13;
/* [MS-XLSB] 2.5.97.9 FRTParsedFormula */&#13;
//var parse_XLSBFRTParsedFormula = parse_XLSBParsedFormula2;&#13;
/* [MS-XLSB] 2.5.97.12 NameParsedFormula */&#13;
var parse_XLSBNameParsedFormula = parse_XLSBParsedFormula;&#13;
/* [MS-XLSB] 2.5.97.98 SharedParsedFormula */&#13;
var parse_XLSBSharedParsedFormula = parse_XLSBParsedFormula;&#13;
&#13;
/* Writes a PtgNum or PtgInt */&#13;
function write_XLSBFormulaNum(val) {&#13;
	if((val | 0) == val &amp;&amp; val &lt; Math.pow(2,16) &amp;&amp; val &gt;= 0) {&#13;
		var oint = new_buf(11);&#13;
		oint.write_shift(4, 3);&#13;
		oint.write_shift(1, 0x1e);&#13;
		oint.write_shift(2, val);&#13;
		oint.write_shift(4, 0);&#13;
		return oint;&#13;
	}&#13;
&#13;
	var num = new_buf(17);&#13;
	num.write_shift(4, 11);&#13;
	num.write_shift(1, 0x1f);&#13;
	num.write_shift(8, val);&#13;
	num.write_shift(4, 0);&#13;
	return num;&#13;
}&#13;
/* Writes a PtgErr */&#13;
function write_XLSBFormulaErr(val) {&#13;
	var oint = new_buf(10);&#13;
	oint.write_shift(4, 2);&#13;
	oint.write_shift(1, 0x1C);&#13;
	oint.write_shift(1, val);&#13;
	oint.write_shift(4, 0);&#13;
	return oint;&#13;
}&#13;
/* Writes a PtgBool */&#13;
function write_XLSBFormulaBool(val) {&#13;
	var oint = new_buf(10);&#13;
	oint.write_shift(4, 2);&#13;
	oint.write_shift(1, 0x1D);&#13;
	oint.write_shift(1, val?1:0);&#13;
	oint.write_shift(4, 0);&#13;
	return oint;&#13;
}&#13;
&#13;
/* Writes a PtgStr */&#13;
function write_XLSBFormulaStr(val) {&#13;
	var preamble = new_buf(7);&#13;
	preamble.write_shift(4, 3 + 2 * val.length);&#13;
	preamble.write_shift(1, 0x17);&#13;
	preamble.write_shift(2, val.length);&#13;
&#13;
	var body = new_buf(2 * val.length);&#13;
	body.write_shift(2 * val.length, val, "utf16le");&#13;
&#13;
	var postamble = new_buf(4);&#13;
	postamble.write_shift(4, 0);&#13;
&#13;
	return bconcat([preamble, body, postamble]);&#13;
}&#13;
&#13;
/* Writes a PtgRef */&#13;
function write_XLSBFormulaRef(str) {&#13;
	var cell = decode_cell(str);&#13;
	var out = new_buf(15);&#13;
	out.write_shift(4, 7);&#13;
	out.write_shift(1, 0x04 | ((1)&lt;&lt;5));&#13;
	out.write_shift(4, cell.r);&#13;
	out.write_shift(2, cell.c | ((str.charAt(0) == "$" ? 0 : 1)&lt;&lt;14) | ((str.match(/\$\d/) ? 0 : 1)&lt;&lt;15)); // &lt;== ColRelShort&#13;
	out.write_shift(4, 0);&#13;
&#13;
	return out;&#13;
}&#13;
&#13;
/* Writes a PtgRef3d */&#13;
function write_XLSBFormulaRef3D(str, wb) {&#13;
	var lastbang = str.lastIndexOf("!");&#13;
	var sname = str.slice(0, lastbang);&#13;
	str = str.slice(lastbang+1);&#13;
	var cell = decode_cell(str);&#13;
	if(sname.charAt(0) == "'") sname = sname.slice(1, -1).replace(/''/g, "'");&#13;
&#13;
	var out = new_buf(17);&#13;
	out.write_shift(4, 9);&#13;
	out.write_shift(1, 0x1A | ((1)&lt;&lt;5));&#13;
	out.write_shift(2, 2 + wb.SheetNames.map(function(n) { return n.toLowerCase(); }).indexOf(sname.toLowerCase()));&#13;
	out.write_shift(4, cell.r);&#13;
	out.write_shift(2, cell.c | ((str.charAt(0) == "$" ? 0 : 1)&lt;&lt;14) | ((str.match(/\$\d/) ? 0 : 1)&lt;&lt;15)); // &lt;== ColRelShort&#13;
	out.write_shift(4, 0);&#13;
&#13;
	return out;&#13;
}&#13;
&#13;
/* Writes a PtgRefErr3d */&#13;
function write_XLSBFormulaRefErr3D(str, wb) {&#13;
	var lastbang = str.lastIndexOf("!");&#13;
	var sname = str.slice(0, lastbang);&#13;
	str = str.slice(lastbang+1);&#13;
	if(sname.charAt(0) == "'") sname = sname.slice(1, -1).replace(/''/g, "'");&#13;
&#13;
	var out = new_buf(17);&#13;
	out.write_shift(4, 9);&#13;
	out.write_shift(1, 0x1C | ((1)&lt;&lt;5));&#13;
	out.write_shift(2, 2 + wb.SheetNames.map(function(n) { return n.toLowerCase(); }).indexOf(sname.toLowerCase()));&#13;
	out.write_shift(4, 0);&#13;
	out.write_shift(2, 0); // &lt;== ColRelShort&#13;
	out.write_shift(4, 0);&#13;
&#13;
	return out;&#13;
}&#13;
&#13;
/* Writes a single sheet range [PtgRef PtgRef PtgRange] */&#13;
function write_XLSBFormulaRange(_str) {&#13;
	var parts = _str.split(":"), str = parts[0];&#13;
&#13;
	var out = new_buf(23);&#13;
	out.write_shift(4, 15);&#13;
&#13;
	/* start cell */&#13;
	str = parts[0]; var cell = decode_cell(str);&#13;
	out.write_shift(1, 0x04 | ((1)&lt;&lt;5));&#13;
	out.write_shift(4, cell.r);&#13;
	out.write_shift(2, cell.c | ((str.charAt(0) == "$" ? 0 : 1)&lt;&lt;14) | ((str.match(/\$\d/) ? 0 : 1)&lt;&lt;15)); // &lt;== ColRelShort&#13;
	out.write_shift(4, 0);&#13;
&#13;
	/* end cell */&#13;
	str = parts[1]; cell = decode_cell(str);&#13;
	out.write_shift(1, 0x04 | ((1)&lt;&lt;5));&#13;
	out.write_shift(4, cell.r);&#13;
	out.write_shift(2, cell.c | ((str.charAt(0) == "$" ? 0 : 1)&lt;&lt;14) | ((str.match(/\$\d/) ? 0 : 1)&lt;&lt;15)); // &lt;== ColRelShort&#13;
	out.write_shift(4, 0);&#13;
&#13;
	/* PtgRange */&#13;
	out.write_shift(1, 0x11);&#13;
&#13;
	out.write_shift(4, 0);&#13;
&#13;
	return out;&#13;
}&#13;
&#13;
/* Writes a range with explicit sheet name [PtgRef3D PtgRef3D PtgRange] */&#13;
function write_XLSBFormulaRangeWS(_str, wb) {&#13;
	var lastbang = _str.lastIndexOf("!");&#13;
	var sname = _str.slice(0, lastbang);&#13;
	_str = _str.slice(lastbang+1);&#13;
	if(sname.charAt(0) == "'") sname = sname.slice(1, -1).replace(/''/g, "'");&#13;
	var parts = _str.split(":"); str = parts[0];&#13;
&#13;
	var out = new_buf(27);&#13;
	out.write_shift(4, 19);&#13;
&#13;
	/* start cell */&#13;
	var str = parts[0], cell = decode_cell(str);&#13;
	out.write_shift(1, 0x1A | ((1)&lt;&lt;5));&#13;
	out.write_shift(2, 2 + wb.SheetNames.map(function(n) { return n.toLowerCase(); }).indexOf(sname.toLowerCase()));&#13;
	out.write_shift(4, cell.r);&#13;
	out.write_shift(2, cell.c | ((str.charAt(0) == "$" ? 0 : 1)&lt;&lt;14) | ((str.match(/\$\d/) ? 0 : 1)&lt;&lt;15)); // &lt;== ColRelShort&#13;
&#13;
	/* end cell */&#13;
	str = parts[1]; cell = decode_cell(str);&#13;
	out.write_shift(1, 0x1A | ((1)&lt;&lt;5));&#13;
	out.write_shift(2, 2 + wb.SheetNames.map(function(n) { return n.toLowerCase(); }).indexOf(sname.toLowerCase()));&#13;
	out.write_shift(4, cell.r);&#13;
	out.write_shift(2, cell.c | ((str.charAt(0) == "$" ? 0 : 1)&lt;&lt;14) | ((str.match(/\$\d/) ? 0 : 1)&lt;&lt;15)); // &lt;== ColRelShort&#13;
&#13;
	/* PtgRange */&#13;
	out.write_shift(1, 0x11);&#13;
&#13;
	out.write_shift(4, 0);&#13;
&#13;
	return out;&#13;
}&#13;
&#13;
/* Writes a range with explicit sheet name [PtgArea3d] */&#13;
function write_XLSBFormulaArea3D(_str, wb) {&#13;
	var lastbang = _str.lastIndexOf("!");&#13;
	var sname = _str.slice(0, lastbang);&#13;
	_str = _str.slice(lastbang+1);&#13;
	if(sname.charAt(0) == "'") sname = sname.slice(1, -1).replace(/''/g, "'");&#13;
	var range = decode_range(_str);&#13;
&#13;
	var out = new_buf(23);&#13;
	out.write_shift(4, 15);&#13;
&#13;
	out.write_shift(1, 0x1B | ((1)&lt;&lt;5));&#13;
	out.write_shift(2, 2 + wb.SheetNames.map(function(n) { return n.toLowerCase(); }).indexOf(sname.toLowerCase()));&#13;
	out.write_shift(4, range.s.r);&#13;
	out.write_shift(4, range.e.r);&#13;
	out.write_shift(2, range.s.c);&#13;
	out.write_shift(2, range.e.c);&#13;
&#13;
	out.write_shift(4, 0);&#13;
&#13;
	return out;&#13;
}&#13;
&#13;
&#13;
/* General Formula */&#13;
function write_XLSBFormula(val, wb) {&#13;
	if(typeof val == "number") return write_XLSBFormulaNum(val);&#13;
	if(typeof val == "boolean") return write_XLSBFormulaBool(val);&#13;
	if(/^#(DIV\/0!|GETTING_DATA|N\/A|NAME\?|NULL!|NUM!|REF!|VALUE!)$/.test(val)) return write_XLSBFormulaErr(+RBErr[val]);&#13;
	if(val.match(/^\$?(?:[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D]|[A-Z]{1,2})\$?(?:10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5})$/)) return write_XLSBFormulaRef(val);&#13;
	if(val.match(/^\$?(?:[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D]|[A-Z]{1,2})\$?(?:10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5}):\$?(?:[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D]|[A-Z]{1,2})\$?(?:10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5})$/)) return write_XLSBFormulaRange(val);&#13;
	if(val.match(/^#REF!\$?(?:[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D]|[A-Z]{1,2})\$?(?:10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5}):\$?(?:[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D]|[A-Z]{1,2})\$?(?:10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5})$/)) return write_XLSBFormulaArea3D(val, wb);&#13;
	if(val.match(/^(?:'[^\\\/?*\[\]:]*'|[^'][^\\\/?*\[\]:'`~!@#$%^()\-=+{}|;,&lt;.&gt;]*)!\$?(?:[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D]|[A-Z]{1,2})\$?(?:10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5})$/)) return write_XLSBFormulaRef3D(val, wb);&#13;
	if(val.match(/^(?:'[^\\\/?*\[\]:]*'|[^'][^\\\/?*\[\]:'`~!@#$%^()\-=+{}|;,&lt;.&gt;]*)!\$?(?:[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D]|[A-Z]{1,2})\$?(?:10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5}):\$?(?:[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D]|[A-Z]{1,2})\$?(?:10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5})$/)) return write_XLSBFormulaRangeWS(val, wb);&#13;
	if(/^(?:'[^\\\/?*\[\]:]*'|[^'][^\\\/?*\[\]:'`~!@#$%^()\-=+{}|;,&lt;.&gt;]*)!#REF!$/.test(val)) return write_XLSBFormulaRefErr3D(val, wb);&#13;
	if(/^".*"$/.test(val)) return write_XLSBFormulaStr(val);&#13;
	if(/^[+-]\d+$/.test(val)) return write_XLSBFormulaNum(parseInt(val, 10));&#13;
	throw "Formula |" + val + "| not supported for XLSB";&#13;
}&#13;
var write_XLSBNameParsedFormula = write_XLSBFormula;&#13;
var Cetab = {&#13;
  0: "BEEP",&#13;
  1: "OPEN",&#13;
  2: "OPEN.LINKS",&#13;
  3: "CLOSE.ALL",&#13;
  4: "SAVE",&#13;
  5: "SAVE.AS",&#13;
  6: "FILE.DELETE",&#13;
  7: "PAGE.SETUP",&#13;
  8: "PRINT",&#13;
  9: "PRINTER.SETUP",&#13;
  10: "QUIT",&#13;
  11: "NEW.WINDOW",&#13;
  12: "ARRANGE.ALL",&#13;
  13: "WINDOW.SIZE",&#13;
  14: "WINDOW.MOVE",&#13;
  15: "FULL",&#13;
  16: "CLOSE",&#13;
  17: "RUN",&#13;
  22: "SET.PRINT.AREA",&#13;
  23: "SET.PRINT.TITLES",&#13;
  24: "SET.PAGE.BREAK",&#13;
  25: "REMOVE.PAGE.BREAK",&#13;
  26: "FONT",&#13;
  27: "DISPLAY",&#13;
  28: "PROTECT.DOCUMENT",&#13;
  29: "PRECISION",&#13;
  30: "A1.R1C1",&#13;
  31: "CALCULATE.NOW",&#13;
  32: "CALCULATION",&#13;
  34: "DATA.FIND",&#13;
  35: "EXTRACT",&#13;
  36: "DATA.DELETE",&#13;
  37: "SET.DATABASE",&#13;
  38: "SET.CRITERIA",&#13;
  39: "SORT",&#13;
  40: "DATA.SERIES",&#13;
  41: "TABLE",&#13;
  42: "FORMAT.NUMBER",&#13;
  43: "ALIGNMENT",&#13;
  44: "STYLE",&#13;
  45: "BORDER",&#13;
  46: "CELL.PROTECTION",&#13;
  47: "COLUMN.WIDTH",&#13;
  48: "UNDO",&#13;
  49: "CUT",&#13;
  50: "COPY",&#13;
  51: "PASTE",&#13;
  52: "CLEAR",&#13;
  53: "PASTE.SPECIAL",&#13;
  54: "EDIT.DELETE",&#13;
  55: "INSERT",&#13;
  56: "FILL.RIGHT",&#13;
  57: "FILL.DOWN",&#13;
  61: "DEFINE.NAME",&#13;
  62: "CREATE.NAMES",&#13;
  63: "FORMULA.GOTO",&#13;
  64: "FORMULA.FIND",&#13;
  65: "SELECT.LAST.CELL",&#13;
  66: "SHOW.ACTIVE.CELL",&#13;
  67: "GALLERY.AREA",&#13;
  68: "GALLERY.BAR",&#13;
  69: "GALLERY.COLUMN",&#13;
  70: "GALLERY.LINE",&#13;
  71: "GALLERY.PIE",&#13;
  72: "GALLERY.SCATTER",&#13;
  73: "COMBINATION",&#13;
  74: "PREFERRED",&#13;
  75: "ADD.OVERLAY",&#13;
  76: "GRIDLINES",&#13;
  77: "SET.PREFERRED",&#13;
  78: "AXES",&#13;
  79: "LEGEND",&#13;
  80: "ATTACH.TEXT",&#13;
  81: "ADD.ARROW",&#13;
  82: "SELECT.CHART",&#13;
  83: "SELECT.PLOT.AREA",&#13;
  84: "PATTERNS",&#13;
  85: "MAIN.CHART",&#13;
  86: "OVERLAY",&#13;
  87: "SCALE",&#13;
  88: "FORMAT.LEGEND",&#13;
  89: "FORMAT.TEXT",&#13;
  90: "EDIT.REPEAT",&#13;
  91: "PARSE",&#13;
  92: "JUSTIFY",&#13;
  93: "HIDE",&#13;
  94: "UNHIDE",&#13;
  95: "WORKSPACE",&#13;
  96: "FORMULA",&#13;
  97: "FORMULA.FILL",&#13;
  98: "FORMULA.ARRAY",&#13;
  99: "DATA.FIND.NEXT",&#13;
  100: "DATA.FIND.PREV",&#13;
  101: "FORMULA.FIND.NEXT",&#13;
  102: "FORMULA.FIND.PREV",&#13;
  103: "ACTIVATE",&#13;
  104: "ACTIVATE.NEXT",&#13;
  105: "ACTIVATE.PREV",&#13;
  106: "UNLOCKED.NEXT",&#13;
  107: "UNLOCKED.PREV",&#13;
  108: "COPY.PICTURE",&#13;
  109: "SELECT",&#13;
  110: "DELETE.NAME",&#13;
  111: "DELETE.FORMAT",&#13;
  112: "VLINE",&#13;
  113: "HLINE",&#13;
  114: "VPAGE",&#13;
  115: "HPAGE",&#13;
  116: "VSCROLL",&#13;
  117: "HSCROLL",&#13;
  118: "ALERT",&#13;
  119: "NEW",&#13;
  120: "CANCEL.COPY",&#13;
  121: "SHOW.CLIPBOARD",&#13;
  122: "MESSAGE",&#13;
  124: "PASTE.LINK",&#13;
  125: "APP.ACTIVATE",&#13;
  126: "DELETE.ARROW",&#13;
  127: "ROW.HEIGHT",&#13;
  128: "FORMAT.MOVE",&#13;
  129: "FORMAT.SIZE",&#13;
  130: "FORMULA.REPLACE",&#13;
  131: "SEND.KEYS",&#13;
  132: "SELECT.SPECIAL",&#13;
  133: "APPLY.NAMES",&#13;
  134: "REPLACE.FONT",&#13;
  135: "FREEZE.PANES",&#13;
  136: "SHOW.INFO",&#13;
  137: "SPLIT",&#13;
  138: "ON.WINDOW",&#13;
  139: "ON.DATA",&#13;
  140: "DISABLE.INPUT",&#13;
  142: "OUTLINE",&#13;
  143: "LIST.NAMES",&#13;
  144: "FILE.CLOSE",&#13;
  145: "SAVE.WORKBOOK",&#13;
  146: "DATA.FORM",&#13;
  147: "COPY.CHART",&#13;
  148: "ON.TIME",&#13;
  149: "WAIT",&#13;
  150: "FORMAT.FONT",&#13;
  151: "FILL.UP",&#13;
  152: "FILL.LEFT",&#13;
  153: "DELETE.OVERLAY",&#13;
  155: "SHORT.MENUS",&#13;
  159: "SET.UPDATE.STATUS",&#13;
  161: "COLOR.PALETTE",&#13;
  162: "DELETE.STYLE",&#13;
  163: "WINDOW.RESTORE",&#13;
  164: "WINDOW.MAXIMIZE",&#13;
  166: "CHANGE.LINK",&#13;
  167: "CALCULATE.DOCUMENT",&#13;
  168: "ON.KEY",&#13;
  169: "APP.RESTORE",&#13;
  170: "APP.MOVE",&#13;
  171: "APP.SIZE",&#13;
  172: "APP.MINIMIZE",&#13;
  173: "APP.MAXIMIZE",&#13;
  174: "BRING.TO.FRONT",&#13;
  175: "SEND.TO.BACK",&#13;
  185: "MAIN.CHART.TYPE",&#13;
  186: "OVERLAY.CHART.TYPE",&#13;
  187: "SELECT.END",&#13;
  188: "OPEN.MAIL",&#13;
  189: "SEND.MAIL",&#13;
  190: "STANDARD.FONT",&#13;
  191: "CONSOLIDATE",&#13;
  192: "SORT.SPECIAL",&#13;
  193: "GALLERY.3D.AREA",&#13;
  194: "GALLERY.3D.COLUMN",&#13;
  195: "GALLERY.3D.LINE",&#13;
  196: "GALLERY.3D.PIE",&#13;
  197: "VIEW.3D",&#13;
  198: "GOAL.SEEK",&#13;
  199: "WORKGROUP",&#13;
  200: "FILL.GROUP",&#13;
  201: "UPDATE.LINK",&#13;
  202: "PROMOTE",&#13;
  203: "DEMOTE",&#13;
  204: "SHOW.DETAIL",&#13;
  206: "UNGROUP",&#13;
  207: "OBJECT.PROPERTIES",&#13;
  208: "SAVE.NEW.OBJECT",&#13;
  209: "SHARE",&#13;
  210: "SHARE.NAME",&#13;
  211: "DUPLICATE",&#13;
  212: "APPLY.STYLE",&#13;
  213: "ASSIGN.TO.OBJECT",&#13;
  214: "OBJECT.PROTECTION",&#13;
  215: "HIDE.OBJECT",&#13;
  216: "SET.EXTRACT",&#13;
  217: "CREATE.PUBLISHER",&#13;
  218: "SUBSCRIBE.TO",&#13;
  219: "ATTRIBUTES",&#13;
  220: "SHOW.TOOLBAR",&#13;
  222: "PRINT.PREVIEW",&#13;
  223: "EDIT.COLOR",&#13;
  224: "SHOW.LEVELS",&#13;
  225: "FORMAT.MAIN",&#13;
  226: "FORMAT.OVERLAY",&#13;
  227: "ON.RECALC",&#13;
  228: "EDIT.SERIES",&#13;
  229: "DEFINE.STYLE",&#13;
  240: "LINE.PRINT",&#13;
  243: "ENTER.DATA",&#13;
  249: "GALLERY.RADAR",&#13;
  250: "MERGE.STYLES",&#13;
  251: "EDITION.OPTIONS",&#13;
  252: "PASTE.PICTURE",&#13;
  253: "PASTE.PICTURE.LINK",&#13;
  254: "SPELLING",&#13;
  256: "ZOOM",&#13;
  259: "INSERT.OBJECT",&#13;
  260: "WINDOW.MINIMIZE",&#13;
  265: "SOUND.NOTE",&#13;
  266: "SOUND.PLAY",&#13;
  267: "FORMAT.SHAPE",&#13;
  268: "EXTEND.POLYGON",&#13;
  269: "FORMAT.AUTO",&#13;
  272: "GALLERY.3D.BAR",&#13;
  273: "GALLERY.3D.SURFACE",&#13;
  274: "FILL.AUTO",&#13;
  276: "CUSTOMIZE.TOOLBAR",&#13;
  277: "ADD.TOOL",&#13;
  278: "EDIT.OBJECT",&#13;
  279: "ON.DOUBLECLICK",&#13;
  280: "ON.ENTRY",&#13;
  281: "WORKBOOK.ADD",&#13;
  282: "WORKBOOK.MOVE",&#13;
  283: "WORKBOOK.COPY",&#13;
  284: "WORKBOOK.OPTIONS",&#13;
  285: "SAVE.WORKSPACE",&#13;
  288: "CHART.WIZARD",&#13;
  289: "DELETE.TOOL",&#13;
  290: "MOVE.TOOL",&#13;
  291: "WORKBOOK.SELECT",&#13;
  292: "WORKBOOK.ACTIVATE",&#13;
  293: "ASSIGN.TO.TOOL",&#13;
  295: "COPY.TOOL",&#13;
  296: "RESET.TOOL",&#13;
  297: "CONSTRAIN.NUMERIC",&#13;
  298: "PASTE.TOOL",&#13;
  302: "WORKBOOK.NEW",&#13;
  305: "SCENARIO.CELLS",&#13;
  306: "SCENARIO.DELETE",&#13;
  307: "SCENARIO.ADD",&#13;
  308: "SCENARIO.EDIT",&#13;
  309: "SCENARIO.SHOW",&#13;
  310: "SCENARIO.SHOW.NEXT",&#13;
  311: "SCENARIO.SUMMARY",&#13;
  312: "PIVOT.TABLE.WIZARD",&#13;
  313: "PIVOT.FIELD.PROPERTIES",&#13;
  314: "PIVOT.FIELD",&#13;
  315: "PIVOT.ITEM",&#13;
  316: "PIVOT.ADD.FIELDS",&#13;
  318: "OPTIONS.CALCULATION",&#13;
  319: "OPTIONS.EDIT",&#13;
  320: "OPTIONS.VIEW",&#13;
  321: "ADDIN.MANAGER",&#13;
  322: "MENU.EDITOR",&#13;
  323: "ATTACH.TOOLBARS",&#13;
  324: "VBAActivate",&#13;
  325: "OPTIONS.CHART",&#13;
  328: "VBA.INSERT.FILE",&#13;
  330: "VBA.PROCEDURE.DEFINITION",&#13;
  336: "ROUTING.SLIP",&#13;
  338: "ROUTE.DOCUMENT",&#13;
  339: "MAIL.LOGON",&#13;
  342: "INSERT.PICTURE",&#13;
  343: "EDIT.TOOL",&#13;
  344: "GALLERY.DOUGHNUT",&#13;
  350: "CHART.TREND",&#13;
  352: "PIVOT.ITEM.PROPERTIES",&#13;
  354: "WORKBOOK.INSERT",&#13;
  355: "OPTIONS.TRANSITION",&#13;
  356: "OPTIONS.GENERAL",&#13;
  370: "FILTER.ADVANCED",&#13;
  373: "MAIL.ADD.MAILER",&#13;
  374: "MAIL.DELETE.MAILER",&#13;
  375: "MAIL.REPLY",&#13;
  376: "MAIL.REPLY.ALL",&#13;
  377: "MAIL.FORWARD",&#13;
  378: "MAIL.NEXT.LETTER",&#13;
  379: "DATA.LABEL",&#13;
  380: "INSERT.TITLE",&#13;
  381: "FONT.PROPERTIES",&#13;
  382: "MACRO.OPTIONS",&#13;
  383: "WORKBOOK.HIDE",&#13;
  384: "WORKBOOK.UNHIDE",&#13;
  385: "WORKBOOK.DELETE",&#13;
  386: "WORKBOOK.NAME",&#13;
  388: "GALLERY.CUSTOM",&#13;
  390: "ADD.CHART.AUTOFORMAT",&#13;
  391: "DELETE.CHART.AUTOFORMAT",&#13;
  392: "CHART.ADD.DATA",&#13;
  393: "AUTO.OUTLINE",&#13;
  394: "TAB.ORDER",&#13;
  395: "SHOW.DIALOG",&#13;
  396: "SELECT.ALL",&#13;
  397: "UNGROUP.SHEETS",&#13;
  398: "SUBTOTAL.CREATE",&#13;
  399: "SUBTOTAL.REMOVE",&#13;
  400: "RENAME.OBJECT",&#13;
  412: "WORKBOOK.SCROLL",&#13;
  413: "WORKBOOK.NEXT",&#13;
  414: "WORKBOOK.PREV",&#13;
  415: "WORKBOOK.TAB.SPLIT",&#13;
  416: "FULL.SCREEN",&#13;
  417: "WORKBOOK.PROTECT",&#13;
  420: "SCROLLBAR.PROPERTIES",&#13;
  421: "PIVOT.SHOW.PAGES",&#13;
  422: "TEXT.TO.COLUMNS",&#13;
  423: "FORMAT.CHARTTYPE",&#13;
  424: "LINK.FORMAT",&#13;
  425: "TRACER.DISPLAY",&#13;
  430: "TRACER.NAVIGATE",&#13;
  431: "TRACER.CLEAR",&#13;
  432: "TRACER.ERROR",&#13;
  433: "PIVOT.FIELD.GROUP",&#13;
  434: "PIVOT.FIELD.UNGROUP",&#13;
  435: "CHECKBOX.PROPERTIES",&#13;
  436: "LABEL.PROPERTIES",&#13;
  437: "LISTBOX.PROPERTIES",&#13;
  438: "EDITBOX.PROPERTIES",&#13;
  439: "PIVOT.REFRESH",&#13;
  440: "LINK.COMBO",&#13;
  441: "OPEN.TEXT",&#13;
  442: "HIDE.DIALOG",&#13;
  443: "SET.DIALOG.FOCUS",&#13;
  444: "ENABLE.OBJECT",&#13;
  445: "PUSHBUTTON.PROPERTIES",&#13;
  446: "SET.DIALOG.DEFAULT",&#13;
  447: "FILTER",&#13;
  448: "FILTER.SHOW.ALL",&#13;
  449: "CLEAR.OUTLINE",&#13;
  450: "FUNCTION.WIZARD",&#13;
  451: "ADD.LIST.ITEM",&#13;
  452: "SET.LIST.ITEM",&#13;
  453: "REMOVE.LIST.ITEM",&#13;
  454: "SELECT.LIST.ITEM",&#13;
  455: "SET.CONTROL.VALUE",&#13;
  456: "SAVE.COPY.AS",&#13;
  458: "OPTIONS.LISTS.ADD",&#13;
  459: "OPTIONS.LISTS.DELETE",&#13;
  460: "SERIES.AXES",&#13;
  461: "SERIES.X",&#13;
  462: "SERIES.Y",&#13;
  463: "ERRORBAR.X",&#13;
  464: "ERRORBAR.Y",&#13;
  465: "FORMAT.CHART",&#13;
  466: "SERIES.ORDER",&#13;
  467: "MAIL.LOGOFF",&#13;
  468: "CLEAR.ROUTING.SLIP",&#13;
  469: "APP.ACTIVATE.MICROSOFT",&#13;
  470: "MAIL.EDIT.MAILER",&#13;
  471: "ON.SHEET",&#13;
  472: "STANDARD.WIDTH",&#13;
  473: "SCENARIO.MERGE",&#13;
  474: "SUMMARY.INFO",&#13;
  475: "FIND.FILE",&#13;
  476: "ACTIVE.CELL.FONT",&#13;
  477: "ENABLE.TIPWIZARD",&#13;
  478: "VBA.MAKE.ADDIN",&#13;
  480: "INSERTDATATABLE",&#13;
  481: "WORKGROUP.OPTIONS",&#13;
  482: "MAIL.SEND.MAILER",&#13;
  485: "AUTOCORRECT",&#13;
  489: "POST.DOCUMENT",&#13;
  491: "PICKLIST",&#13;
  493: "VIEW.SHOW",&#13;
  494: "VIEW.DEFINE",&#13;
  495: "VIEW.DELETE",&#13;
  509: "SHEET.BACKGROUND",&#13;
  510: "INSERT.MAP.OBJECT",&#13;
  511: "OPTIONS.MENONO",&#13;
  517: "MSOCHECKS",&#13;
  518: "NORMAL",&#13;
  519: "LAYOUT",&#13;
  520: "RM.PRINT.AREA",&#13;
  521: "CLEAR.PRINT.AREA",&#13;
  522: "ADD.PRINT.AREA",&#13;
  523: "MOVE.BRK",&#13;
  545: "HIDECURR.NOTE",&#13;
  546: "HIDEALL.NOTES",&#13;
  547: "DELETE.NOTE",&#13;
  548: "TRAVERSE.NOTES",&#13;
  549: "ACTIVATE.NOTES",&#13;
  620: "PROTECT.REVISIONS",&#13;
  621: "UNPROTECT.REVISIONS",&#13;
  647: "OPTIONS.ME",&#13;
  653: "WEB.PUBLISH",&#13;
  667: "NEWWEBQUERY",&#13;
  673: "PIVOT.TABLE.CHART",&#13;
  753: "OPTIONS.SAVE",&#13;
  755: "OPTIONS.SPELL",&#13;
  808: "HIDEALL.INKANNOTS"&#13;
};&#13;
var Ftab = {&#13;
  0: "COUNT",&#13;
  1: "IF",&#13;
  2: "ISNA",&#13;
  3: "ISERROR",&#13;
  4: "SUM",&#13;
  5: "AVERAGE",&#13;
  6: "MIN",&#13;
  7: "MAX",&#13;
  8: "ROW",&#13;
  9: "COLUMN",&#13;
  10: "NA",&#13;
  11: "NPV",&#13;
  12: "STDEV",&#13;
  13: "DOLLAR",&#13;
  14: "FIXED",&#13;
  15: "SIN",&#13;
  16: "COS",&#13;
  17: "TAN",&#13;
  18: "ATAN",&#13;
  19: "PI",&#13;
  20: "SQRT",&#13;
  21: "EXP",&#13;
  22: "LN",&#13;
  23: "LOG10",&#13;
  24: "ABS",&#13;
  25: "INT",&#13;
  26: "SIGN",&#13;
  27: "ROUND",&#13;
  28: "LOOKUP",&#13;
  29: "INDEX",&#13;
  30: "REPT",&#13;
  31: "MID",&#13;
  32: "LEN",&#13;
  33: "VALUE",&#13;
  34: "TRUE",&#13;
  35: "FALSE",&#13;
  36: "AND",&#13;
  37: "OR",&#13;
  38: "NOT",&#13;
  39: "MOD",&#13;
  40: "DCOUNT",&#13;
  41: "DSUM",&#13;
  42: "DAVERAGE",&#13;
  43: "DMIN",&#13;
  44: "DMAX",&#13;
  45: "DSTDEV",&#13;
  46: "VAR",&#13;
  47: "DVAR",&#13;
  48: "TEXT",&#13;
  49: "LINEST",&#13;
  50: "TREND",&#13;
  51: "LOGEST",&#13;
  52: "GROWTH",&#13;
  53: "GOTO",&#13;
  54: "HALT",&#13;
  55: "RETURN",&#13;
  56: "PV",&#13;
  57: "FV",&#13;
  58: "NPER",&#13;
  59: "PMT",&#13;
  60: "RATE",&#13;
  61: "MIRR",&#13;
  62: "IRR",&#13;
  63: "RAND",&#13;
  64: "MATCH",&#13;
  65: "DATE",&#13;
  66: "TIME",&#13;
  67: "DAY",&#13;
  68: "MONTH",&#13;
  69: "YEAR",&#13;
  70: "WEEKDAY",&#13;
  71: "HOUR",&#13;
  72: "MINUTE",&#13;
  73: "SECOND",&#13;
  74: "NOW",&#13;
  75: "AREAS",&#13;
  76: "ROWS",&#13;
  77: "COLUMNS",&#13;
  78: "OFFSET",&#13;
  79: "ABSREF",&#13;
  80: "RELREF",&#13;
  81: "ARGUMENT",&#13;
  82: "SEARCH",&#13;
  83: "TRANSPOSE",&#13;
  84: "ERROR",&#13;
  85: "STEP",&#13;
  86: "TYPE",&#13;
  87: "ECHO",&#13;
  88: "SET.NAME",&#13;
  89: "CALLER",&#13;
  90: "DEREF",&#13;
  91: "WINDOWS",&#13;
  92: "SERIES",&#13;
  93: "DOCUMENTS",&#13;
  94: "ACTIVE.CELL",&#13;
  95: "SELECTION",&#13;
  96: "RESULT",&#13;
  97: "ATAN2",&#13;
  98: "ASIN",&#13;
  99: "ACOS",&#13;
  100: "CHOOSE",&#13;
  101: "HLOOKUP",&#13;
  102: "VLOOKUP",&#13;
  103: "LINKS",&#13;
  104: "INPUT",&#13;
  105: "ISREF",&#13;
  106: "GET.FORMULA",&#13;
  107: "GET.NAME",&#13;
  108: "SET.VALUE",&#13;
  109: "LOG",&#13;
  110: "EXEC",&#13;
  111: "CHAR",&#13;
  112: "LOWER",&#13;
  113: "UPPER",&#13;
  114: "PROPER",&#13;
  115: "LEFT",&#13;
  116: "RIGHT",&#13;
  117: "EXACT",&#13;
  118: "TRIM",&#13;
  119: "REPLACE",&#13;
  120: "SUBSTITUTE",&#13;
  121: "CODE",&#13;
  122: "NAMES",&#13;
  123: "DIRECTORY",&#13;
  124: "FIND",&#13;
  125: "CELL",&#13;
  126: "ISERR",&#13;
  127: "ISTEXT",&#13;
  128: "ISNUMBER",&#13;
  129: "ISBLANK",&#13;
  130: "T",&#13;
  131: "N",&#13;
  132: "FOPEN",&#13;
  133: "FCLOSE",&#13;
  134: "FSIZE",&#13;
  135: "FREADLN",&#13;
  136: "FREAD",&#13;
  137: "FWRITELN",&#13;
  138: "FWRITE",&#13;
  139: "FPOS",&#13;
  140: "DATEVALUE",&#13;
  141: "TIMEVALUE",&#13;
  142: "SLN",&#13;
  143: "SYD",&#13;
  144: "DDB",&#13;
  145: "GET.DEF",&#13;
  146: "REFTEXT",&#13;
  147: "TEXTREF",&#13;
  148: "INDIRECT",&#13;
  149: "REGISTER",&#13;
  150: "CALL",&#13;
  151: "ADD.BAR",&#13;
  152: "ADD.MENU",&#13;
  153: "ADD.COMMAND",&#13;
  154: "ENABLE.COMMAND",&#13;
  155: "CHECK.COMMAND",&#13;
  156: "RENAME.COMMAND",&#13;
  157: "SHOW.BAR",&#13;
  158: "DELETE.MENU",&#13;
  159: "DELETE.COMMAND",&#13;
  160: "GET.CHART.ITEM",&#13;
  161: "DIALOG.BOX",&#13;
  162: "CLEAN",&#13;
  163: "MDETERM",&#13;
  164: "MINVERSE",&#13;
  165: "MMULT",&#13;
  166: "FILES",&#13;
  167: "IPMT",&#13;
  168: "PPMT",&#13;
  169: "COUNTA",&#13;
  170: "CANCEL.KEY",&#13;
  171: "FOR",&#13;
  172: "WHILE",&#13;
  173: "BREAK",&#13;
  174: "NEXT",&#13;
  175: "INITIATE",&#13;
  176: "REQUEST",&#13;
  177: "POKE",&#13;
  178: "EXECUTE",&#13;
  179: "TERMINATE",&#13;
  180: "RESTART",&#13;
  181: "HELP",&#13;
  182: "GET.BAR",&#13;
  183: "PRODUCT",&#13;
  184: "FACT",&#13;
  185: "GET.CELL",&#13;
  186: "GET.WORKSPACE",&#13;
  187: "GET.WINDOW",&#13;
  188: "GET.DOCUMENT",&#13;
  189: "DPRODUCT",&#13;
  190: "ISNONTEXT",&#13;
  191: "GET.NOTE",&#13;
  192: "NOTE",&#13;
  193: "STDEVP",&#13;
  194: "VARP",&#13;
  195: "DSTDEVP",&#13;
  196: "DVARP",&#13;
  197: "TRUNC",&#13;
  198: "ISLOGICAL",&#13;
  199: "DCOUNTA",&#13;
  200: "DELETE.BAR",&#13;
  201: "UNREGISTER",&#13;
  204: "USDOLLAR",&#13;
  205: "FINDB",&#13;
  206: "SEARCHB",&#13;
  207: "REPLACEB",&#13;
  208: "LEFTB",&#13;
  209: "RIGHTB",&#13;
  210: "MIDB",&#13;
  211: "LENB",&#13;
  212: "ROUNDUP",&#13;
  213: "ROUNDDOWN",&#13;
  214: "ASC",&#13;
  215: "DBCS",&#13;
  216: "RANK",&#13;
  219: "ADDRESS",&#13;
  220: "DAYS360",&#13;
  221: "TODAY",&#13;
  222: "VDB",&#13;
  223: "ELSE",&#13;
  224: "ELSE.IF",&#13;
  225: "END.IF",&#13;
  226: "FOR.CELL",&#13;
  227: "MEDIAN",&#13;
  228: "SUMPRODUCT",&#13;
  229: "SINH",&#13;
  230: "COSH",&#13;
  231: "TANH",&#13;
  232: "ASINH",&#13;
  233: "ACOSH",&#13;
  234: "ATANH",&#13;
  235: "DGET",&#13;
  236: "CREATE.OBJECT",&#13;
  237: "VOLATILE",&#13;
  238: "LAST.ERROR",&#13;
  239: "CUSTOM.UNDO",&#13;
  240: "CUSTOM.REPEAT",&#13;
  241: "FORMULA.CONVERT",&#13;
  242: "GET.LINK.INFO",&#13;
  243: "TEXT.BOX",&#13;
  244: "INFO",&#13;
  245: "GROUP",&#13;
  246: "GET.OBJECT",&#13;
  247: "DB",&#13;
  248: "PAUSE",&#13;
  251: "RESUME",&#13;
  252: "FREQUENCY",&#13;
  253: "ADD.TOOLBAR",&#13;
  254: "DELETE.TOOLBAR",&#13;
  255: "User",&#13;
  256: "RESET.TOOLBAR",&#13;
  257: "EVALUATE",&#13;
  258: "GET.TOOLBAR",&#13;
  259: "GET.TOOL",&#13;
  260: "SPELLING.CHECK",&#13;
  261: "ERROR.TYPE",&#13;
  262: "APP.TITLE",&#13;
  263: "WINDOW.TITLE",&#13;
  264: "SAVE.TOOLBAR",&#13;
  265: "ENABLE.TOOL",&#13;
  266: "PRESS.TOOL",&#13;
  267: "REGISTER.ID",&#13;
  268: "GET.WORKBOOK",&#13;
  269: "AVEDEV",&#13;
  270: "BETADIST",&#13;
  271: "GAMMALN",&#13;
  272: "BETAINV",&#13;
  273: "BINOMDIST",&#13;
  274: "CHIDIST",&#13;
  275: "CHIINV",&#13;
  276: "COMBIN",&#13;
  277: "CONFIDENCE",&#13;
  278: "CRITBINOM",&#13;
  279: "EVEN",&#13;
  280: "EXPONDIST",&#13;
  281: "FDIST",&#13;
  282: "FINV",&#13;
  283: "FISHER",&#13;
  284: "FISHERINV",&#13;
  285: "FLOOR",&#13;
  286: "GAMMADIST",&#13;
  287: "GAMMAINV",&#13;
  288: "CEILING",&#13;
  289: "HYPGEOMDIST",&#13;
  290: "LOGNORMDIST",&#13;
  291: "LOGINV",&#13;
  292: "NEGBINOMDIST",&#13;
  293: "NORMDIST",&#13;
  294: "NORMSDIST",&#13;
  295: "NORMINV",&#13;
  296: "NORMSINV",&#13;
  297: "STANDARDIZE",&#13;
  298: "ODD",&#13;
  299: "PERMUT",&#13;
  300: "POISSON",&#13;
  301: "TDIST",&#13;
  302: "WEIBULL",&#13;
  303: "SUMXMY2",&#13;
  304: "SUMX2MY2",&#13;
  305: "SUMX2PY2",&#13;
  306: "CHITEST",&#13;
  307: "CORREL",&#13;
  308: "COVAR",&#13;
  309: "FORECAST",&#13;
  310: "FTEST",&#13;
  311: "INTERCEPT",&#13;
  312: "PEARSON",&#13;
  313: "RSQ",&#13;
  314: "STEYX",&#13;
  315: "SLOPE",&#13;
  316: "TTEST",&#13;
  317: "PROB",&#13;
  318: "DEVSQ",&#13;
  319: "GEOMEAN",&#13;
  320: "HARMEAN",&#13;
  321: "SUMSQ",&#13;
  322: "KURT",&#13;
  323: "SKEW",&#13;
  324: "ZTEST",&#13;
  325: "LARGE",&#13;
  326: "SMALL",&#13;
  327: "QUARTILE",&#13;
  328: "PERCENTILE",&#13;
  329: "PERCENTRANK",&#13;
  330: "MODE",&#13;
  331: "TRIMMEAN",&#13;
  332: "TINV",&#13;
  334: "MOVIE.COMMAND",&#13;
  335: "GET.MOVIE",&#13;
  336: "CONCATENATE",&#13;
  337: "POWER",&#13;
  338: "PIVOT.ADD.DATA",&#13;
  339: "GET.PIVOT.TABLE",&#13;
  340: "GET.PIVOT.FIELD",&#13;
  341: "GET.PIVOT.ITEM",&#13;
  342: "RADIANS",&#13;
  343: "DEGREES",&#13;
  344: "SUBTOTAL",&#13;
  345: "SUMIF",&#13;
  346: "COUNTIF",&#13;
  347: "COUNTBLANK",&#13;
  348: "SCENARIO.GET",&#13;
  349: "OPTIONS.LISTS.GET",&#13;
  350: "ISPMT",&#13;
  351: "DATEDIF",&#13;
  352: "DATESTRING",&#13;
  353: "NUMBERSTRING",&#13;
  354: "ROMAN",&#13;
  355: "OPEN.DIALOG",&#13;
  356: "SAVE.DIALOG",&#13;
  357: "VIEW.GET",&#13;
  358: "GETPIVOTDATA",&#13;
  359: "HYPERLINK",&#13;
  360: "PHONETIC",&#13;
  361: "AVERAGEA",&#13;
  362: "MAXA",&#13;
  363: "MINA",&#13;
  364: "STDEVPA",&#13;
  365: "VARPA",&#13;
  366: "STDEVA",&#13;
  367: "VARA",&#13;
  368: "BAHTTEXT",&#13;
  369: "THAIDAYOFWEEK",&#13;
  370: "THAIDIGIT",&#13;
  371: "THAIMONTHOFYEAR",&#13;
  372: "THAINUMSOUND",&#13;
  373: "THAINUMSTRING",&#13;
  374: "THAISTRINGLENGTH",&#13;
  375: "ISTHAIDIGIT",&#13;
  376: "ROUNDBAHTDOWN",&#13;
  377: "ROUNDBAHTUP",&#13;
  378: "THAIYEAR",&#13;
  379: "RTD",&#13;
  380: "CUBEVALUE",&#13;
  381: "CUBEMEMBER",&#13;
  382: "CUBEMEMBERPROPERTY",&#13;
  383: "CUBERANKEDMEMBER",&#13;
  384: "HEX2BIN",&#13;
  385: "HEX2DEC",&#13;
  386: "HEX2OCT",&#13;
  387: "DEC2BIN",&#13;
  388: "DEC2HEX",&#13;
  389: "DEC2OCT",&#13;
  390: "OCT2BIN",&#13;
  391: "OCT2HEX",&#13;
  392: "OCT2DEC",&#13;
  393: "BIN2DEC",&#13;
  394: "BIN2OCT",&#13;
  395: "BIN2HEX",&#13;
  396: "IMSUB",&#13;
  397: "IMDIV",&#13;
  398: "IMPOWER",&#13;
  399: "IMABS",&#13;
  400: "IMSQRT",&#13;
  401: "IMLN",&#13;
  402: "IMLOG2",&#13;
  403: "IMLOG10",&#13;
  404: "IMSIN",&#13;
  405: "IMCOS",&#13;
  406: "IMEXP",&#13;
  407: "IMARGUMENT",&#13;
  408: "IMCONJUGATE",&#13;
  409: "IMAGINARY",&#13;
  410: "IMREAL",&#13;
  411: "COMPLEX",&#13;
  412: "IMSUM",&#13;
  413: "IMPRODUCT",&#13;
  414: "SERIESSUM",&#13;
  415: "FACTDOUBLE",&#13;
  416: "SQRTPI",&#13;
  417: "QUOTIENT",&#13;
  418: "DELTA",&#13;
  419: "GESTEP",&#13;
  420: "ISEVEN",&#13;
  421: "ISODD",&#13;
  422: "MROUND",&#13;
  423: "ERF",&#13;
  424: "ERFC",&#13;
  425: "BESSELJ",&#13;
  426: "BESSELK",&#13;
  427: "BESSELY",&#13;
  428: "BESSELI",&#13;
  429: "XIRR",&#13;
  430: "XNPV",&#13;
  431: "PRICEMAT",&#13;
  432: "YIELDMAT",&#13;
  433: "INTRATE",&#13;
  434: "RECEIVED",&#13;
  435: "DISC",&#13;
  436: "PRICEDISC",&#13;
  437: "YIELDDISC",&#13;
  438: "TBILLEQ",&#13;
  439: "TBILLPRICE",&#13;
  440: "TBILLYIELD",&#13;
  441: "PRICE",&#13;
  442: "YIELD",&#13;
  443: "DOLLARDE",&#13;
  444: "DOLLARFR",&#13;
  445: "NOMINAL",&#13;
  446: "EFFECT",&#13;
  447: "CUMPRINC",&#13;
  448: "CUMIPMT",&#13;
  449: "EDATE",&#13;
  450: "EOMONTH",&#13;
  451: "YEARFRAC",&#13;
  452: "COUPDAYBS",&#13;
  453: "COUPDAYS",&#13;
  454: "COUPDAYSNC",&#13;
  455: "COUPNCD",&#13;
  456: "COUPNUM",&#13;
  457: "COUPPCD",&#13;
  458: "DURATION",&#13;
  459: "MDURATION",&#13;
  460: "ODDLPRICE",&#13;
  461: "ODDLYIELD",&#13;
  462: "ODDFPRICE",&#13;
  463: "ODDFYIELD",&#13;
  464: "RANDBETWEEN",&#13;
  465: "WEEKNUM",&#13;
  466: "AMORDEGRC",&#13;
  467: "AMORLINC",&#13;
  468: "CONVERT",&#13;
  724: "SHEETJS",&#13;
  469: "ACCRINT",&#13;
  470: "ACCRINTM",&#13;
  471: "WORKDAY",&#13;
  472: "NETWORKDAYS",&#13;
  473: "GCD",&#13;
  474: "MULTINOMIAL",&#13;
  475: "LCM",&#13;
  476: "FVSCHEDULE",&#13;
  477: "CUBEKPIMEMBER",&#13;
  478: "CUBESET",&#13;
  479: "CUBESETCOUNT",&#13;
  480: "IFERROR",&#13;
  481: "COUNTIFS",&#13;
  482: "SUMIFS",&#13;
  483: "AVERAGEIF",&#13;
  484: "AVERAGEIFS"&#13;
};&#13;
var FtabArgc = {&#13;
  2: 1,&#13;
  3: 1,&#13;
  10: 0,&#13;
  15: 1,&#13;
  16: 1,&#13;
  17: 1,&#13;
  18: 1,&#13;
  19: 0,&#13;
  20: 1,&#13;
  21: 1,&#13;
  22: 1,&#13;
  23: 1,&#13;
  24: 1,&#13;
  25: 1,&#13;
  26: 1,&#13;
  27: 2,&#13;
  30: 2,&#13;
  31: 3,&#13;
  32: 1,&#13;
  33: 1,&#13;
  34: 0,&#13;
  35: 0,&#13;
  38: 1,&#13;
  39: 2,&#13;
  40: 3,&#13;
  41: 3,&#13;
  42: 3,&#13;
  43: 3,&#13;
  44: 3,&#13;
  45: 3,&#13;
  47: 3,&#13;
  48: 2,&#13;
  53: 1,&#13;
  61: 3,&#13;
  63: 0,&#13;
  65: 3,&#13;
  66: 3,&#13;
  67: 1,&#13;
  68: 1,&#13;
  69: 1,&#13;
  70: 1,&#13;
  71: 1,&#13;
  72: 1,&#13;
  73: 1,&#13;
  74: 0,&#13;
  75: 1,&#13;
  76: 1,&#13;
  77: 1,&#13;
  79: 2,&#13;
  80: 2,&#13;
  83: 1,&#13;
  85: 0,&#13;
  86: 1,&#13;
  89: 0,&#13;
  90: 1,&#13;
  94: 0,&#13;
  95: 0,&#13;
  97: 2,&#13;
  98: 1,&#13;
  99: 1,&#13;
  101: 3,&#13;
  102: 3,&#13;
  105: 1,&#13;
  106: 1,&#13;
  108: 2,&#13;
  111: 1,&#13;
  112: 1,&#13;
  113: 1,&#13;
  114: 1,&#13;
  117: 2,&#13;
  118: 1,&#13;
  119: 4,&#13;
  121: 1,&#13;
  126: 1,&#13;
  127: 1,&#13;
  128: 1,&#13;
  129: 1,&#13;
  130: 1,&#13;
  131: 1,&#13;
  133: 1,&#13;
  134: 1,&#13;
  135: 1,&#13;
  136: 2,&#13;
  137: 2,&#13;
  138: 2,&#13;
  140: 1,&#13;
  141: 1,&#13;
  142: 3,&#13;
  143: 4,&#13;
  144: 4,&#13;
  161: 1,&#13;
  162: 1,&#13;
  163: 1,&#13;
  164: 1,&#13;
  165: 2,&#13;
  172: 1,&#13;
  175: 2,&#13;
  176: 2,&#13;
  177: 3,&#13;
  178: 2,&#13;
  179: 1,&#13;
  184: 1,&#13;
  186: 1,&#13;
  189: 3,&#13;
  190: 1,&#13;
  195: 3,&#13;
  196: 3,&#13;
  197: 1,&#13;
  198: 1,&#13;
  199: 3,&#13;
  201: 1,&#13;
  207: 4,&#13;
  210: 3,&#13;
  211: 1,&#13;
  212: 2,&#13;
  213: 2,&#13;
  214: 1,&#13;
  215: 1,&#13;
  225: 0,&#13;
  229: 1,&#13;
  230: 1,&#13;
  231: 1,&#13;
  232: 1,&#13;
  233: 1,&#13;
  234: 1,&#13;
  235: 3,&#13;
  244: 1,&#13;
  247: 4,&#13;
  252: 2,&#13;
  257: 1,&#13;
  261: 1,&#13;
  271: 1,&#13;
  273: 4,&#13;
  274: 2,&#13;
  275: 2,&#13;
  276: 2,&#13;
  277: 3,&#13;
  278: 3,&#13;
  279: 1,&#13;
  280: 3,&#13;
  281: 3,&#13;
  282: 3,&#13;
  283: 1,&#13;
  284: 1,&#13;
  285: 2,&#13;
  286: 4,&#13;
  287: 3,&#13;
  288: 2,&#13;
  289: 4,&#13;
  290: 3,&#13;
  291: 3,&#13;
  292: 3,&#13;
  293: 4,&#13;
  294: 1,&#13;
  295: 3,&#13;
  296: 1,&#13;
  297: 3,&#13;
  298: 1,&#13;
  299: 2,&#13;
  300: 3,&#13;
  301: 3,&#13;
  302: 4,&#13;
  303: 2,&#13;
  304: 2,&#13;
  305: 2,&#13;
  306: 2,&#13;
  307: 2,&#13;
  308: 2,&#13;
  309: 3,&#13;
  310: 2,&#13;
  311: 2,&#13;
  312: 2,&#13;
  313: 2,&#13;
  314: 2,&#13;
  315: 2,&#13;
  316: 4,&#13;
  325: 2,&#13;
  326: 2,&#13;
  327: 2,&#13;
  328: 2,&#13;
  331: 2,&#13;
  332: 2,&#13;
  337: 2,&#13;
  342: 1,&#13;
  343: 1,&#13;
  346: 2,&#13;
  347: 1,&#13;
  350: 4,&#13;
  351: 3,&#13;
  352: 1,&#13;
  353: 2,&#13;
  360: 1,&#13;
  368: 1,&#13;
  369: 1,&#13;
  370: 1,&#13;
  371: 1,&#13;
  372: 1,&#13;
  373: 1,&#13;
  374: 1,&#13;
  375: 1,&#13;
  376: 1,&#13;
  377: 1,&#13;
  378: 1,&#13;
  382: 3,&#13;
  385: 1,&#13;
  392: 1,&#13;
  393: 1,&#13;
  396: 2,&#13;
  397: 2,&#13;
  398: 2,&#13;
  399: 1,&#13;
  400: 1,&#13;
  401: 1,&#13;
  402: 1,&#13;
  403: 1,&#13;
  404: 1,&#13;
  405: 1,&#13;
  406: 1,&#13;
  407: 1,&#13;
  408: 1,&#13;
  409: 1,&#13;
  410: 1,&#13;
  414: 4,&#13;
  415: 1,&#13;
  416: 1,&#13;
  417: 2,&#13;
  420: 1,&#13;
  421: 1,&#13;
  422: 2,&#13;
  424: 1,&#13;
  425: 2,&#13;
  426: 2,&#13;
  427: 2,&#13;
  428: 2,&#13;
  430: 3,&#13;
  438: 3,&#13;
  439: 3,&#13;
  440: 3,&#13;
  443: 2,&#13;
  444: 2,&#13;
  445: 2,&#13;
  446: 2,&#13;
  447: 6,&#13;
  448: 6,&#13;
  449: 2,&#13;
  450: 2,&#13;
  464: 2,&#13;
  468: 3,&#13;
  476: 2,&#13;
  479: 1,&#13;
  480: 2,&#13;
  65535: 0&#13;
};&#13;
/* Part 3 TODO: actually parse formulae */&#13;
function ods_to_csf_formula(f) {&#13;
	if(f.slice(0,3) == "of:") f = f.slice(3);&#13;
	/* 5.2 Basic Expressions */&#13;
	if(f.charCodeAt(0) == 61) {&#13;
		f = f.slice(1);&#13;
		if(f.charCodeAt(0) == 61) f = f.slice(1);&#13;
	}&#13;
	f = f.replace(/COM\.MICROSOFT\./g, "");&#13;
	/* Part 3 Section 5.8 References */&#13;
	f = f.replace(/\[((?:\.[A-Z]+[0-9]+)(?::\.[A-Z]+[0-9]+)?)\]/g, function($$, $1) { return $1.replace(/\./g,""); });&#13;
	f = f.replace(/\$'([^']|'')+'/g, function($$) { return $$.slice(1); });&#13;
	f = f.replace(/\$([^\]\. #$]+)/g, function($$, $1) { return ($1).match(/^([A-Z]{1,2}|[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D])?(10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5})?$/) ? $$ : $1; });&#13;
	/* TODO: something other than this */&#13;
	f = f.replace(/\[.(#[A-Z]*[?!])\]/g, "$1");&#13;
	return f.replace(/[;~]/g,",").replace(/\|/g,";");&#13;
}&#13;
&#13;
function csf_to_ods_formula(f) {&#13;
	var o = "of:=" + f.replace(crefregex, "$1[.$2$3$4$5]").replace(/\]:\[/g,":");&#13;
	/* TODO: something other than this */&#13;
	return o.replace(/;/g, "|").replace(/,/g,";");&#13;
}&#13;
&#13;
function ods_to_csf_3D(r) {&#13;
	r = r.replace(/\$'([^']|'')+'/g, function($$) { return $$.slice(1); });&#13;
	r = r.replace(/\$([^\]\. #$]+)/g, function($$, $1) { return ($1).match(/^([A-Z]{1,2}|[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D])?(10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5})?$/) ? $$ : $1; });&#13;
	var a = r.split(":");&#13;
	var s = a[0].split(".")[0];&#13;
	return [s, a[0].split(".")[1] + (a.length &gt; 1 ? (":" + (a[1].split(".")[1] || a[1].split(".")[0])) : "")];&#13;
}&#13;
&#13;
function csf_to_ods_3D(r) {&#13;
	return r.replace(/!/,".");&#13;
}&#13;
&#13;
var strs = {}; // shared strings&#13;
var _ssfopts = {}; // spreadsheet formatting options&#13;
&#13;
&#13;
/*global Map */&#13;
var browser_has_Map = typeof Map !== 'undefined';&#13;
&#13;
function get_sst_id(sst, str, rev) {&#13;
	var i = 0, len = sst.length;&#13;
	if(rev) {&#13;
		if(browser_has_Map ? rev.has(str) : Object.prototype.hasOwnProperty.call(rev, str)) {&#13;
			var revarr = browser_has_Map ? rev.get(str) : rev[str];&#13;
			for(; i &lt; revarr.length; ++i) {&#13;
				if(sst[revarr[i]].t === str) { sst.Count ++; return revarr[i]; }&#13;
			}&#13;
		}&#13;
	} else for(; i &lt; len; ++i) {&#13;
		if(sst[i].t === str) { sst.Count ++; return i; }&#13;
	}&#13;
	sst[len] = ({t:str}); sst.Count ++; sst.Unique ++;&#13;
	if(rev) {&#13;
		if(browser_has_Map) {&#13;
			if(!rev.has(str)) rev.set(str, []);&#13;
			rev.get(str).push(len);&#13;
		} else {&#13;
			if(!Object.prototype.hasOwnProperty.call(rev, str)) rev[str] = [];&#13;
			rev[str].push(len);&#13;
		}&#13;
	}&#13;
	return len;&#13;
}&#13;
&#13;
function col_obj_w(C, col) {&#13;
	var p = ({min:C+1,max:C+1});&#13;
	/* wch (chars), wpx (pixels) */&#13;
	var wch = -1;&#13;
	if(col.MDW) MDW = col.MDW;&#13;
	if(col.width != null) p.customWidth = 1;&#13;
	else if(col.wpx != null) wch = px2char(col.wpx);&#13;
	else if(col.wch != null) wch = col.wch;&#13;
	if(wch &gt; -1) { p.width = char2width(wch); p.customWidth = 1; }&#13;
	else if(col.width != null) p.width = col.width;&#13;
	if(col.hidden) p.hidden = true;&#13;
	if(col.level != null) { p.outlineLevel = p.level = col.level; }&#13;
	return p;&#13;
}&#13;
&#13;
function default_margins(margins, mode) {&#13;
	if(!margins) return;&#13;
	var defs = [0.7, 0.7, 0.75, 0.75, 0.3, 0.3];&#13;
	if(mode == 'xlml') defs = [1, 1, 1, 1, 0.5, 0.5];&#13;
	if(margins.left   == null) margins.left   = defs[0];&#13;
	if(margins.right  == null) margins.right  = defs[1];&#13;
	if(margins.top    == null) margins.top    = defs[2];&#13;
	if(margins.bottom == null) margins.bottom = defs[3];&#13;
	if(margins.header == null) margins.header = defs[4];&#13;
	if(margins.footer == null) margins.footer = defs[5];&#13;
}&#13;
&#13;
function get_cell_style(styles, cell, opts) {&#13;
	var z = opts.revssf[cell.z != null ? cell.z : "General"];&#13;
	var i = 0x3c, len = styles.length;&#13;
	if(z == null &amp;&amp; opts.ssf) {&#13;
		for(; i &lt; 0x188; ++i) if(opts.ssf[i] == null) {&#13;
			SSF__load(cell.z, i);&#13;
			// $FlowIgnore&#13;
			opts.ssf[i] = cell.z;&#13;
			opts.revssf[cell.z] = z = i;&#13;
			break;&#13;
		}&#13;
	}&#13;
	for(i = 0; i != len; ++i) if(styles[i].numFmtId === z) return i;&#13;
	styles[len] = {&#13;
		numFmtId:z,&#13;
		fontId:0,&#13;
		fillId:0,&#13;
		borderId:0,&#13;
		xfId:0,&#13;
		applyNumberFormat:1&#13;
	};&#13;
	return len;&#13;
}&#13;
&#13;
function safe_format(p, fmtid, fillid, opts, themes, styles) {&#13;
	try {&#13;
		if(opts.cellNF) p.z = table_fmt[fmtid];&#13;
	} catch(e) { if(opts.WTF) throw e; }&#13;
	if(p.t === 'z' &amp;&amp; !opts.cellStyles) return;&#13;
	if(p.t === 'd' &amp;&amp; typeof p.v === 'string') p.v = parseDate(p.v);&#13;
	if((!opts || opts.cellText !== false) &amp;&amp; p.t !== 'z') try {&#13;
		if(table_fmt[fmtid] == null) SSF__load(SSFImplicit[fmtid] || "General", fmtid);&#13;
		if(p.t === 'e') p.w = p.w || BErr[p.v];&#13;
		else if(fmtid === 0) {&#13;
			if(p.t === 'n') {&#13;
				if((p.v|0) === p.v) p.w = p.v.toString(10);&#13;
				else p.w = SSF_general_num(p.v);&#13;
			}&#13;
			else if(p.t === 'd') {&#13;
				var dd = datenum(p.v);&#13;
				if((dd|0) === dd) p.w = dd.toString(10);&#13;
				else p.w = SSF_general_num(dd);&#13;
			}&#13;
			else if(p.v === undefined) return "";&#13;
			else p.w = SSF_general(p.v,_ssfopts);&#13;
		}&#13;
		else if(p.t === 'd') p.w = SSF_format(fmtid,datenum(p.v),_ssfopts);&#13;
		else p.w = SSF_format(fmtid,p.v,_ssfopts);&#13;
	} catch(e) { if(opts.WTF) throw e; }&#13;
	if(!opts.cellStyles) return;&#13;
	if(fillid != null) try {&#13;
		p.s = styles.Fills[fillid];&#13;
		if (p.s.fgColor &amp;&amp; p.s.fgColor.theme &amp;&amp; !p.s.fgColor.rgb) {&#13;
			p.s.fgColor.rgb = rgb_tint(themes.themeElements.clrScheme[p.s.fgColor.theme].rgb, p.s.fgColor.tint || 0);&#13;
			if(opts.WTF) p.s.fgColor.raw_rgb = themes.themeElements.clrScheme[p.s.fgColor.theme].rgb;&#13;
		}&#13;
		if (p.s.bgColor &amp;&amp; p.s.bgColor.theme) {&#13;
			p.s.bgColor.rgb = rgb_tint(themes.themeElements.clrScheme[p.s.bgColor.theme].rgb, p.s.bgColor.tint || 0);&#13;
			if(opts.WTF) p.s.bgColor.raw_rgb = themes.themeElements.clrScheme[p.s.bgColor.theme].rgb;&#13;
		}&#13;
	} catch(e) { if(opts.WTF &amp;&amp; styles.Fills) throw e; }&#13;
}&#13;
&#13;
function check_ws(ws, sname, i) {&#13;
	if(ws &amp;&amp; ws['!ref']) {&#13;
		var range = safe_decode_range(ws['!ref']);&#13;
		if(range.e.c &lt; range.s.c || range.e.r &lt; range.s.r) throw new Error("Bad range (" + i + "): " + ws['!ref']);&#13;
	}&#13;
}&#13;
function parse_ws_xml_dim(ws, s) {&#13;
	var d = safe_decode_range(s);&#13;
	if(d.s.r&lt;=d.e.r &amp;&amp; d.s.c&lt;=d.e.c &amp;&amp; d.s.r&gt;=0 &amp;&amp; d.s.c&gt;=0) ws["!ref"] = encode_range(d);&#13;
}&#13;
var mergecregex = /&lt;(?:\w:)?mergeCell ref="[A-Z0-9:]+"\s*[\/]?&gt;/g;&#13;
var sheetdataregex = /&lt;(?:\w+:)?sheetData[^&gt;]*&gt;([\s\S]*)&lt;\/(?:\w+:)?sheetData&gt;/;&#13;
var hlinkregex = /&lt;(?:\w:)?hyperlink [^&gt;]*&gt;/mg;&#13;
var dimregex = /"(\w*:\w*)"/;&#13;
var colregex = /&lt;(?:\w:)?col\b[^&gt;]*[\/]?&gt;/g;&#13;
var afregex = /&lt;(?:\w:)?autoFilter[^&gt;]*([\/]|&gt;([\s\S]*)&lt;\/(?:\w:)?autoFilter)&gt;/g;&#13;
var marginregex= /&lt;(?:\w:)?pageMargins[^&gt;]*\/&gt;/g;&#13;
var sheetprregex = /&lt;(?:\w:)?sheetPr\b(?:[^&gt;a-z][^&gt;]*)?\/&gt;/;&#13;
var sheetprregex2= /&lt;(?:\w:)?sheetPr[^&gt;]*(?:[\/]|&gt;([\s\S]*)&lt;\/(?:\w:)?sheetPr)&gt;/;&#13;
var svsregex = /&lt;(?:\w:)?sheetViews[^&gt;]*(?:[\/]|&gt;([\s\S]*)&lt;\/(?:\w:)?sheetViews)&gt;/;&#13;
&#13;
/* 18.3 Worksheets */&#13;
function parse_ws_xml(data, opts, idx, rels, wb, themes, styles) {&#13;
	if(!data) return data;&#13;
	if(!rels) rels = {'!id':{}};&#13;
	if(DENSE != null &amp;&amp; opts.dense == null) opts.dense = DENSE;&#13;
&#13;
	/* 18.3.1.99 worksheet CT_Worksheet */&#13;
	var s = opts.dense ? ([]) : ({});&#13;
	var refguess = ({s: {r:2000000, c:2000000}, e: {r:0, c:0} });&#13;
&#13;
	var data1 = "", data2 = "";&#13;
	var mtch = data.match(sheetdataregex);&#13;
	if(mtch) {&#13;
		data1 = data.slice(0, mtch.index);&#13;
		data2 = data.slice(mtch.index + mtch[0].length);&#13;
	} else data1 = data2 = data;&#13;
&#13;
	/* 18.3.1.82 sheetPr CT_SheetPr */&#13;
	var sheetPr = data1.match(sheetprregex);&#13;
	if(sheetPr) parse_ws_xml_sheetpr(sheetPr[0], s, wb, idx);&#13;
	else if((sheetPr = data1.match(sheetprregex2))) parse_ws_xml_sheetpr2(sheetPr[0], sheetPr[1]||"", s, wb, idx, styles, themes);&#13;
&#13;
	/* 18.3.1.35 dimension CT_SheetDimension */&#13;
	var ridx = (data1.match(/&lt;(?:\w*:)?dimension/)||{index:-1}).index;&#13;
	if(ridx &gt; 0) {&#13;
		var ref = data1.slice(ridx,ridx+50).match(dimregex);&#13;
		if(ref) parse_ws_xml_dim(s, ref[1]);&#13;
	}&#13;
&#13;
	/* 18.3.1.88 sheetViews CT_SheetViews */&#13;
	var svs = data1.match(svsregex);&#13;
	if(svs &amp;&amp; svs[1]) parse_ws_xml_sheetviews(svs[1], wb);&#13;
&#13;
	/* 18.3.1.17 cols CT_Cols */&#13;
	var columns = [];&#13;
	if(opts.cellStyles) {&#13;
		/* 18.3.1.13 col CT_Col */&#13;
		var cols = data1.match(colregex);&#13;
		if(cols) parse_ws_xml_cols(columns, cols);&#13;
	}&#13;
&#13;
	/* 18.3.1.80 sheetData CT_SheetData ? */&#13;
	if(mtch) parse_ws_xml_data(mtch[1], s, opts, refguess, themes, styles);&#13;
&#13;
	/* 18.3.1.2  autoFilter CT_AutoFilter */&#13;
	var afilter = data2.match(afregex);&#13;
	if(afilter) s['!autofilter'] = parse_ws_xml_autofilter(afilter[0]);&#13;
&#13;
	/* 18.3.1.55 mergeCells CT_MergeCells */&#13;
	var merges = [];&#13;
	var _merge = data2.match(mergecregex);&#13;
	if(_merge) for(ridx = 0; ridx != _merge.length; ++ridx)&#13;
		merges[ridx] = safe_decode_range(_merge[ridx].slice(_merge[ridx].indexOf("\"")+1));&#13;
&#13;
	/* 18.3.1.48 hyperlinks CT_Hyperlinks */&#13;
	var hlink = data2.match(hlinkregex);&#13;
	if(hlink) parse_ws_xml_hlinks(s, hlink, rels);&#13;
&#13;
	/* 18.3.1.62 pageMargins CT_PageMargins */&#13;
	var margins = data2.match(marginregex);&#13;
	if(margins) s['!margins'] = parse_ws_xml_margins(parsexmltag(margins[0]));&#13;
&#13;
	if(!s["!ref"] &amp;&amp; refguess.e.c &gt;= refguess.s.c &amp;&amp; refguess.e.r &gt;= refguess.s.r) s["!ref"] = encode_range(refguess);&#13;
	if(opts.sheetRows &gt; 0 &amp;&amp; s["!ref"]) {&#13;
		var tmpref = safe_decode_range(s["!ref"]);&#13;
		if(opts.sheetRows &lt;= +tmpref.e.r) {&#13;
			tmpref.e.r = opts.sheetRows - 1;&#13;
			if(tmpref.e.r &gt; refguess.e.r) tmpref.e.r = refguess.e.r;&#13;
			if(tmpref.e.r &lt; tmpref.s.r) tmpref.s.r = tmpref.e.r;&#13;
			if(tmpref.e.c &gt; refguess.e.c) tmpref.e.c = refguess.e.c;&#13;
			if(tmpref.e.c &lt; tmpref.s.c) tmpref.s.c = tmpref.e.c;&#13;
			s["!fullref"] = s["!ref"];&#13;
			s["!ref"] = encode_range(tmpref);&#13;
		}&#13;
	}&#13;
	if(columns.length &gt; 0) s["!cols"] = columns;&#13;
	if(merges.length &gt; 0) s["!merges"] = merges;&#13;
	return s;&#13;
}&#13;
&#13;
function write_ws_xml_merges(merges) {&#13;
	if(merges.length === 0) return "";&#13;
	var o = '&lt;mergeCells count="' + merges.length + '"&gt;';&#13;
	for(var i = 0; i != merges.length; ++i) o += '&lt;mergeCell ref="' + encode_range(merges[i]) + '"/&gt;';&#13;
	return o + '&lt;/mergeCells&gt;';&#13;
}&#13;
&#13;
/* 18.3.1.82-3 sheetPr CT_ChartsheetPr / CT_SheetPr */&#13;
function parse_ws_xml_sheetpr(sheetPr, s, wb, idx) {&#13;
	var data = parsexmltag(sheetPr);&#13;
	if(!wb.Sheets[idx]) wb.Sheets[idx] = {};&#13;
	if(data.codeName) wb.Sheets[idx].CodeName = unescapexml(utf8read(data.codeName));&#13;
}&#13;
function parse_ws_xml_sheetpr2(sheetPr, body, s, wb, idx) {&#13;
	parse_ws_xml_sheetpr(sheetPr.slice(0, sheetPr.indexOf("&gt;")), s, wb, idx);&#13;
}&#13;
function write_ws_xml_sheetpr(ws, wb, idx, opts, o) {&#13;
	var needed = false;&#13;
	var props = {}, payload = null;&#13;
	if(opts.bookType !== 'xlsx' &amp;&amp; wb.vbaraw) {&#13;
		var cname = wb.SheetNames[idx];&#13;
		try { if(wb.Workbook) cname = wb.Workbook.Sheets[idx].CodeName || cname; } catch(e) {}&#13;
		needed = true;&#13;
		props.codeName = utf8write(escapexml(cname));&#13;
	}&#13;
&#13;
	if(ws &amp;&amp; ws["!outline"]) {&#13;
		var outlineprops = {summaryBelow:1, summaryRight:1};&#13;
		if(ws["!outline"].above) outlineprops.summaryBelow = 0;&#13;
		if(ws["!outline"].left) outlineprops.summaryRight = 0;&#13;
		payload = (payload||"") + writextag('outlinePr', null, outlineprops);&#13;
	}&#13;
&#13;
	if(!needed &amp;&amp; !payload) return;&#13;
	o[o.length] = (writextag('sheetPr', payload, props));&#13;
}&#13;
&#13;
/* 18.3.1.85 sheetProtection CT_SheetProtection */&#13;
var sheetprot_deffalse = ["objects", "scenarios", "selectLockedCells", "selectUnlockedCells"];&#13;
var sheetprot_deftrue = [&#13;
	"formatColumns", "formatRows", "formatCells",&#13;
	"insertColumns", "insertRows", "insertHyperlinks",&#13;
	"deleteColumns", "deleteRows",&#13;
	"sort", "autoFilter", "pivotTables"&#13;
];&#13;
function write_ws_xml_protection(sp) {&#13;
	// algorithmName, hashValue, saltValue, spinCount&#13;
	var o = ({sheet:1});&#13;
	sheetprot_deffalse.forEach(function(n) { if(sp[n] != null &amp;&amp; sp[n]) o[n] = "1"; });&#13;
	sheetprot_deftrue.forEach(function(n) { if(sp[n] != null &amp;&amp; !sp[n]) o[n] = "0"; });&#13;
	/* TODO: algorithm */&#13;
	if(sp.password) o.password = crypto_CreatePasswordVerifier_Method1(sp.password).toString(16).toUpperCase();&#13;
	return writextag('sheetProtection', null, o);&#13;
}&#13;
&#13;
function parse_ws_xml_hlinks(s, data, rels) {&#13;
	var dense = Array.isArray(s);&#13;
	for(var i = 0; i != data.length; ++i) {&#13;
		var val = parsexmltag(utf8read(data[i]), true);&#13;
		if(!val.ref) return;&#13;
		var rel = ((rels || {})['!id']||[])[val.id];&#13;
		if(rel) {&#13;
			val.Target = rel.Target;&#13;
			if(val.location) val.Target += "#"+unescapexml(val.location);&#13;
		} else {&#13;
			val.Target = "#" + unescapexml(val.location);&#13;
			rel = {Target: val.Target, TargetMode: 'Internal'};&#13;
		}&#13;
		val.Rel = rel;&#13;
		if(val.tooltip) { val.Tooltip = val.tooltip; delete val.tooltip; }&#13;
		var rng = safe_decode_range(val.ref);&#13;
		for(var R=rng.s.r;R&lt;=rng.e.r;++R) for(var C=rng.s.c;C&lt;=rng.e.c;++C) {&#13;
			var addr = encode_cell({c:C,r:R});&#13;
			if(dense) {&#13;
				if(!s[R]) s[R] = [];&#13;
				if(!s[R][C]) s[R][C] = {t:"z",v:undefined};&#13;
				s[R][C].l = val;&#13;
			} else {&#13;
				if(!s[addr]) s[addr] = {t:"z",v:undefined};&#13;
				s[addr].l = val;&#13;
			}&#13;
		}&#13;
	}&#13;
}&#13;
&#13;
function parse_ws_xml_margins(margin) {&#13;
	var o = {};&#13;
	["left", "right", "top", "bottom", "header", "footer"].forEach(function(k) {&#13;
		if(margin[k]) o[k] = parseFloat(margin[k]);&#13;
	});&#13;
	return o;&#13;
}&#13;
function write_ws_xml_margins(margin) {&#13;
	default_margins(margin);&#13;
	return writextag('pageMargins', null, margin);&#13;
}&#13;
&#13;
function parse_ws_xml_cols(columns, cols) {&#13;
	var seencol = false;&#13;
	for(var coli = 0; coli != cols.length; ++coli) {&#13;
		var coll = parsexmltag(cols[coli], true);&#13;
		if(coll.hidden) coll.hidden = parsexmlbool(coll.hidden);&#13;
		var colm=parseInt(coll.min, 10)-1, colM=parseInt(coll.max,10)-1;&#13;
		if(coll.outlineLevel) coll.level = (+coll.outlineLevel || 0);&#13;
		delete coll.min; delete coll.max; coll.width = +coll.width;&#13;
		if(!seencol &amp;&amp; coll.width) { seencol = true; find_mdw_colw(coll.width); }&#13;
		process_col(coll);&#13;
		while(colm &lt;= colM) columns[colm++] = dup(coll);&#13;
	}&#13;
}&#13;
function write_ws_xml_cols(ws, cols) {&#13;
	var o = ["&lt;cols&gt;"], col;&#13;
	for(var i = 0; i != cols.length; ++i) {&#13;
		if(!(col = cols[i])) continue;&#13;
		o[o.length] = (writextag('col', null, col_obj_w(i, col)));&#13;
	}&#13;
	o[o.length] = "&lt;/cols&gt;";&#13;
	return o.join("");&#13;
}&#13;
&#13;
function parse_ws_xml_autofilter(data) {&#13;
	var o = { ref: (data.match(/ref="([^"]*)"/)||[])[1]};&#13;
	return o;&#13;
}&#13;
function write_ws_xml_autofilter(data, ws, wb, idx) {&#13;
	var ref = typeof data.ref == "string" ? data.ref : encode_range(data.ref);&#13;
	if(!wb.Workbook) wb.Workbook = ({Sheets:[]});&#13;
	if(!wb.Workbook.Names) wb.Workbook.Names = [];&#13;
	var names = wb.Workbook.Names;&#13;
	var range = decode_range(ref);&#13;
	if(range.s.r == range.e.r) { range.e.r = decode_range(ws["!ref"]).e.r; ref = encode_range(range); }&#13;
	for(var i = 0; i &lt; names.length; ++i) {&#13;
		var name = names[i];&#13;
		if(name.Name != '_xlnm._FilterDatabase') continue;&#13;
		if(name.Sheet != idx) continue;&#13;
		name.Ref = formula_quote_sheet_name(wb.SheetNames[idx]) + "!" + fix_range(ref); break;&#13;
	}&#13;
	if(i == names.length) names.push({ Name: '_xlnm._FilterDatabase', Sheet: idx, Ref: "'" + wb.SheetNames[idx] + "'!" + ref  });&#13;
	return writextag("autoFilter", null, {ref:ref});&#13;
}&#13;
&#13;
/* 18.3.1.88 sheetViews CT_SheetViews */&#13;
/* 18.3.1.87 sheetView CT_SheetView */&#13;
var sviewregex = /&lt;(?:\w:)?sheetView(?:[^&gt;a-z][^&gt;]*)?\/?&gt;/g;&#13;
function parse_ws_xml_sheetviews(data, wb) {&#13;
	if(!wb.Views) wb.Views = [{}];&#13;
	(data.match(sviewregex)||[]).forEach(function(r, i) {&#13;
		var tag = parsexmltag(r);&#13;
		// $FlowIgnore&#13;
		if(!wb.Views[i]) wb.Views[i] = {};&#13;
		// $FlowIgnore&#13;
		if(+tag.zoomScale) wb.Views[i].zoom = +tag.zoomScale;&#13;
		// $FlowIgnore&#13;
		if(tag.rightToLeft &amp;&amp; parsexmlbool(tag.rightToLeft)) wb.Views[i].RTL = true;&#13;
	});&#13;
}&#13;
function write_ws_xml_sheetviews(ws, opts, idx, wb) {&#13;
	var sview = ({workbookViewId:"0"});&#13;
	// $FlowIgnore&#13;
	if((((wb||{}).Workbook||{}).Views||[])[0]) sview.rightToLeft = wb.Workbook.Views[0].RTL ? "1" : "0";&#13;
	return writextag("sheetViews", writextag("sheetView", null, sview), {});&#13;
}&#13;
&#13;
function write_ws_xml_cell(cell, ref, ws, opts) {&#13;
	if(cell.c) ws['!comments'].push([ref, cell.c]);&#13;
	if((cell.v === undefined || cell.t === "z" &amp;&amp; !(opts||{}).sheetStubs) &amp;&amp; typeof cell.f !== "string" &amp;&amp; typeof cell.z == "undefined") return "";&#13;
	var vv = "";&#13;
	var oldt = cell.t, oldv = cell.v;&#13;
	if(cell.t !== "z") switch(cell.t) {&#13;
		case 'b': vv = cell.v ? "1" : "0"; break;&#13;
		case 'n': vv = ''+cell.v; break;&#13;
		case 'e': vv = BErr[cell.v]; break;&#13;
		case 'd':&#13;
			if(opts &amp;&amp; opts.cellDates) vv = parseDate(cell.v, -1).toISOString();&#13;
			else {&#13;
				cell = dup(cell);&#13;
				cell.t = 'n';&#13;
				vv = ''+(cell.v = datenum(parseDate(cell.v)));&#13;
			}&#13;
			if(typeof cell.z === 'undefined') cell.z = table_fmt[14];&#13;
			break;&#13;
		default: vv = cell.v; break;&#13;
	}&#13;
	var v = (cell.t == "z" || cell.v == null)? "" : writetag('v', escapexml(vv)), o = ({r:ref});&#13;
	/* TODO: cell style */&#13;
	var os = get_cell_style(opts.cellXfs, cell, opts);&#13;
	if(os !== 0) o.s = os;&#13;
	switch(cell.t) {&#13;
		case 'n': break;&#13;
		case 'd': o.t = "d"; break;&#13;
		case 'b': o.t = "b"; break;&#13;
		case 'e': o.t = "e"; break;&#13;
		case 'z': break;&#13;
		default: if(cell.v == null) { delete cell.t; break; }&#13;
			if(cell.v.length &gt; 32767) throw new Error("Text length must not exceed 32767 characters");&#13;
			if(opts &amp;&amp; opts.bookSST) {&#13;
				v = writetag('v', ''+get_sst_id(opts.Strings, cell.v, opts.revStrings));&#13;
				o.t = "s"; break;&#13;
			}&#13;
			else o.t = "str"; break;&#13;
	}&#13;
	if(cell.t != oldt) { cell.t = oldt; cell.v = oldv; }&#13;
	if(typeof cell.f == "string" &amp;&amp; cell.f) {&#13;
		var ff = cell.F &amp;&amp; cell.F.slice(0, ref.length) == ref ? {t:"array", ref:cell.F} : null;&#13;
		v = writextag('f', escapexml(cell.f), ff) + (cell.v != null ? v : "");&#13;
	}&#13;
	if(cell.l) {&#13;
		cell.l.display = escapexml(vv);&#13;
		ws['!links'].push([ref, cell.l]);&#13;
	}&#13;
	if(cell.D) o.cm = 1;&#13;
	return writextag('c', v, o);&#13;
}&#13;
&#13;
var parse_ws_xml_data = (function() {&#13;
	var cellregex = /&lt;(?:\w+:)?c[ \/&gt;]/, rowregex = /&lt;\/(?:\w+:)?row&gt;/;&#13;
	var rregex = /r=["']([^"']*)["']/, isregex = /&lt;(?:\w+:)?is&gt;([\S\s]*?)&lt;\/(?:\w+:)?is&gt;/;&#13;
	var refregex = /ref=["']([^"']*)["']/;&#13;
	var match_v = matchtag("v"), match_f = matchtag("f");&#13;
&#13;
return function parse_ws_xml_data(sdata, s, opts, guess, themes, styles) {&#13;
	var ri = 0, x = "", cells = [], cref = [], idx=0, i=0, cc=0, d="", p;&#13;
	var tag, tagr = 0, tagc = 0;&#13;
	var sstr, ftag;&#13;
	var fmtid = 0, fillid = 0;&#13;
	var do_format = Array.isArray(styles.CellXf), cf;&#13;
	var arrayf = [];&#13;
	var sharedf = [];&#13;
	var dense = Array.isArray(s);&#13;
	var rows = [], rowobj = {}, rowrite = false;&#13;
	var sheetStubs = !!opts.sheetStubs;&#13;
	for(var marr = sdata.split(rowregex), mt = 0, marrlen = marr.length; mt != marrlen; ++mt) {&#13;
		x = marr[mt].trim();&#13;
		var xlen = x.length;&#13;
		if(xlen === 0) continue;&#13;
&#13;
		/* 18.3.1.73 row CT_Row */&#13;
		var rstarti = 0;&#13;
		outa: for(ri = 0; ri &lt; xlen; ++ri) switch(/*x.charCodeAt(ri)*/x[ri]) {&#13;
			case "&gt;" /*62*/:&#13;
				if(/*x.charCodeAt(ri-1) != 47*/x[ri-1] != "/") { ++ri; break outa; }&#13;
				if(opts &amp;&amp; opts.cellStyles) {&#13;
					// TODO: avoid duplication&#13;
					tag = parsexmltag(x.slice(rstarti,ri), true);&#13;
					tagr = tag.r != null ? parseInt(tag.r, 10) : tagr+1; tagc = -1;&#13;
					if(opts.sheetRows &amp;&amp; opts.sheetRows &lt; tagr) continue;&#13;
					rowobj = {}; rowrite = false;&#13;
					if(tag.ht) { rowrite = true; rowobj.hpt = parseFloat(tag.ht); rowobj.hpx = pt2px(rowobj.hpt); }&#13;
					if(tag.hidden &amp;&amp; parsexmlbool(tag.hidden)) { rowrite = true; rowobj.hidden = true; }&#13;
					if(tag.outlineLevel != null) { rowrite = true; rowobj.level = +tag.outlineLevel; }&#13;
					if(rowrite) rows[tagr-1] = rowobj;&#13;
				}&#13;
				break;&#13;
			case "&lt;" /*60*/: rstarti = ri; break;&#13;
		}&#13;
		if(rstarti &gt;= ri) break;&#13;
		tag = parsexmltag(x.slice(rstarti,ri), true);&#13;
		tagr = tag.r != null ? parseInt(tag.r, 10) : tagr+1; tagc = -1;&#13;
		if(opts.sheetRows &amp;&amp; opts.sheetRows &lt; tagr) continue;&#13;
		if(guess.s.r &gt; tagr - 1) guess.s.r = tagr - 1;&#13;
		if(guess.e.r &lt; tagr - 1) guess.e.r = tagr - 1;&#13;
&#13;
		if(opts &amp;&amp; opts.cellStyles) {&#13;
			rowobj = {}; rowrite = false;&#13;
			if(tag.ht) { rowrite = true; rowobj.hpt = parseFloat(tag.ht); rowobj.hpx = pt2px(rowobj.hpt); }&#13;
			if(tag.hidden &amp;&amp; parsexmlbool(tag.hidden)) { rowrite = true; rowobj.hidden = true; }&#13;
			if(tag.outlineLevel != null) { rowrite = true; rowobj.level = +tag.outlineLevel; }&#13;
			if(rowrite) rows[tagr-1] = rowobj;&#13;
		}&#13;
&#13;
		/* 18.3.1.4 c CT_Cell */&#13;
		cells = x.slice(ri).split(cellregex);&#13;
		for(var rslice = 0; rslice != cells.length; ++rslice) if(cells[rslice].trim().charAt(0) != "&lt;") break;&#13;
		cells = cells.slice(rslice);&#13;
		for(ri = 0; ri != cells.length; ++ri) {&#13;
			x = cells[ri].trim();&#13;
			if(x.length === 0) continue;&#13;
			cref = x.match(rregex); idx = ri; i=0; cc=0;&#13;
			x = "&lt;c " + (x.slice(0,1)=="&lt;"?"&gt;":"") + x;&#13;
			if(cref != null &amp;&amp; cref.length === 2) {&#13;
				idx = 0; d=cref[1];&#13;
				for(i=0; i != d.length; ++i) {&#13;
					if((cc=d.charCodeAt(i)-64) &lt; 1 || cc &gt; 26) break;&#13;
					idx = 26*idx + cc;&#13;
				}&#13;
				--idx;&#13;
				tagc = idx;&#13;
			} else ++tagc;&#13;
			for(i = 0; i != x.length; ++i) if(x.charCodeAt(i) === 62) break; ++i;&#13;
			tag = parsexmltag(x.slice(0,i), true);&#13;
			if(!tag.r) tag.r = encode_cell({r:tagr-1, c:tagc});&#13;
			d = x.slice(i);&#13;
			p = ({t:""});&#13;
&#13;
			if((cref=d.match(match_v))!= null &amp;&amp; cref[1] !== '') p.v=unescapexml(cref[1]);&#13;
			if(opts.cellFormula) {&#13;
				if((cref=d.match(match_f))!= null &amp;&amp; cref[1] !== '') {&#13;
					/* TODO: match against XLSXFutureFunctions */&#13;
					p.f=unescapexml(utf8read(cref[1]), true);&#13;
					if(!opts.xlfn) p.f = _xlfn(p.f);&#13;
					if(cref[0].indexOf('t="array"') &gt; -1) {&#13;
						p.F = (d.match(refregex)||[])[1];&#13;
						if(p.F.indexOf(":") &gt; -1) arrayf.push([safe_decode_range(p.F), p.F]);&#13;
					} else if(cref[0].indexOf('t="shared"') &gt; -1) {&#13;
						// TODO: parse formula&#13;
						ftag = parsexmltag(cref[0]);&#13;
						var ___f = unescapexml(utf8read(cref[1]));&#13;
						if(!opts.xlfn) ___f = _xlfn(___f);&#13;
						sharedf[parseInt(ftag.si, 10)] = [ftag, ___f, tag.r];&#13;
					}&#13;
				} else if((cref=d.match(/&lt;f[^&gt;]*\/&gt;/))) {&#13;
					ftag = parsexmltag(cref[0]);&#13;
					if(sharedf[ftag.si]) p.f = shift_formula_xlsx(sharedf[ftag.si][1], sharedf[ftag.si][2]/*[0].ref*/, tag.r);&#13;
				}&#13;
				/* TODO: factor out contains logic */&#13;
				var _tag = decode_cell(tag.r);&#13;
				for(i = 0; i &lt; arrayf.length; ++i)&#13;
					if(_tag.r &gt;= arrayf[i][0].s.r &amp;&amp; _tag.r &lt;= arrayf[i][0].e.r)&#13;
						if(_tag.c &gt;= arrayf[i][0].s.c &amp;&amp; _tag.c &lt;= arrayf[i][0].e.c)&#13;
							p.F = arrayf[i][1];&#13;
			}&#13;
&#13;
			if(tag.t == null &amp;&amp; p.v === undefined) {&#13;
				if(p.f || p.F) {&#13;
					p.v = 0; p.t = "n";&#13;
				} else if(!sheetStubs) continue;&#13;
				else p.t = "z";&#13;
			}&#13;
			else p.t = tag.t || "n";&#13;
			if(guess.s.c &gt; tagc) guess.s.c = tagc;&#13;
			if(guess.e.c &lt; tagc) guess.e.c = tagc;&#13;
			/* 18.18.11 t ST_CellType */&#13;
			switch(p.t) {&#13;
				case 'n':&#13;
					if(p.v == "" || p.v == null) {&#13;
						if(!sheetStubs) continue;&#13;
						p.t = 'z';&#13;
					} else p.v = parseFloat(p.v);&#13;
					break;&#13;
				case 's':&#13;
					if(typeof p.v == 'undefined') {&#13;
						if(!sheetStubs) continue;&#13;
						p.t = 'z';&#13;
					} else {&#13;
						sstr = strs[parseInt(p.v, 10)];&#13;
						p.v = sstr.t;&#13;
						p.r = sstr.r;&#13;
						if(opts.cellHTML) p.h = sstr.h;&#13;
					}&#13;
					break;&#13;
				case 'str':&#13;
					p.t = "s";&#13;
					p.v = (p.v!=null) ? unescapexml(utf8read(p.v), true) : '';&#13;
					if(opts.cellHTML) p.h = escapehtml(p.v);&#13;
					break;&#13;
				case 'inlineStr':&#13;
					cref = d.match(isregex);&#13;
					p.t = 's';&#13;
					if(cref != null &amp;&amp; (sstr = parse_si(cref[1]))) {&#13;
						p.v = sstr.t;&#13;
						if(opts.cellHTML) p.h = sstr.h;&#13;
					} else p.v = "";&#13;
					break;&#13;
				case 'b': p.v = parsexmlbool(p.v); break;&#13;
				case 'd':&#13;
					if(opts.cellDates) p.v = parseDate(p.v, 1);&#13;
					else { p.v = datenum(parseDate(p.v, 1)); p.t = 'n'; }&#13;
					break;&#13;
				/* error string in .w, number in .v */&#13;
				case 'e':&#13;
					if(!opts || opts.cellText !== false) p.w = p.v;&#13;
					p.v = RBErr[p.v]; break;&#13;
			}&#13;
			/* formatting */&#13;
			fmtid = fillid = 0;&#13;
			cf = null;&#13;
			if(do_format &amp;&amp; tag.s !== undefined) {&#13;
				cf = styles.CellXf[tag.s];&#13;
				if(cf != null) {&#13;
					if(cf.numFmtId != null) fmtid = cf.numFmtId;&#13;
					if(opts.cellStyles) {&#13;
						if(cf.fillId != null) fillid = cf.fillId;&#13;
					}&#13;
				}&#13;
			}&#13;
			safe_format(p, fmtid, fillid, opts, themes, styles);&#13;
			if(opts.cellDates &amp;&amp; do_format &amp;&amp; p.t == 'n' &amp;&amp; fmt_is_date(table_fmt[fmtid])) { p.t = 'd'; p.v = numdate(p.v); }&#13;
			if(tag.cm &amp;&amp; opts.xlmeta) {&#13;
				var cm = (opts.xlmeta.Cell||[])[+tag.cm-1];&#13;
				if(cm &amp;&amp; cm.type == 'XLDAPR') p.D = true;&#13;
			}&#13;
			if(dense) {&#13;
				var _r = decode_cell(tag.r);&#13;
				if(!s[_r.r]) s[_r.r] = [];&#13;
				s[_r.r][_r.c] = p;&#13;
			} else s[tag.r] = p;&#13;
		}&#13;
	}&#13;
	if(rows.length &gt; 0) s['!rows'] = rows;&#13;
}; })();&#13;
&#13;
function write_ws_xml_data(ws, opts, idx, wb) {&#13;
	var o = [], r = [], range = safe_decode_range(ws['!ref']), cell="", ref, rr = "", cols = [], R=0, C=0, rows = ws['!rows'];&#13;
	var dense = Array.isArray(ws);&#13;
	var params = ({r:rr}), row, height = -1;&#13;
	for(C = range.s.c; C &lt;= range.e.c; ++C) cols[C] = encode_col(C);&#13;
	for(R = range.s.r; R &lt;= range.e.r; ++R) {&#13;
		r = [];&#13;
		rr = encode_row(R);&#13;
		for(C = range.s.c; C &lt;= range.e.c; ++C) {&#13;
			ref = cols[C] + rr;&#13;
			var _cell = dense ? (ws[R]||[])[C]: ws[ref];&#13;
			if(_cell === undefined) continue;&#13;
			if((cell = write_ws_xml_cell(_cell, ref, ws, opts, idx, wb)) != null) r.push(cell);&#13;
		}&#13;
		if(r.length &gt; 0 || (rows &amp;&amp; rows[R])) {&#13;
			params = ({r:rr});&#13;
			if(rows &amp;&amp; rows[R]) {&#13;
				row = rows[R];&#13;
				if(row.hidden) params.hidden = 1;&#13;
				height = -1;&#13;
				if(row.hpx) height = px2pt(row.hpx);&#13;
				else if(row.hpt) height = row.hpt;&#13;
				if(height &gt; -1) { params.ht = height; params.customHeight = 1; }&#13;
				if(row.level) { params.outlineLevel = row.level; }&#13;
			}&#13;
			o[o.length] = (writextag('row', r.join(""), params));&#13;
		}&#13;
	}&#13;
	if(rows) for(; R &lt; rows.length; ++R) {&#13;
		if(rows &amp;&amp; rows[R]) {&#13;
			params = ({r:R+1});&#13;
			row = rows[R];&#13;
			if(row.hidden) params.hidden = 1;&#13;
			height = -1;&#13;
			if (row.hpx) height = px2pt(row.hpx);&#13;
			else if (row.hpt) height = row.hpt;&#13;
			if (height &gt; -1) { params.ht = height; params.customHeight = 1; }&#13;
			if (row.level) { params.outlineLevel = row.level; }&#13;
			o[o.length] = (writextag('row', "", params));&#13;
		}&#13;
	}&#13;
	return o.join("");&#13;
}&#13;
&#13;
function write_ws_xml(idx, opts, wb, rels) {&#13;
	var o = [XML_HEADER, writextag('worksheet', null, {&#13;
		'xmlns': XMLNS_main[0],&#13;
		'xmlns:r': XMLNS.r&#13;
	})];&#13;
	var s = wb.SheetNames[idx], sidx = 0, rdata = "";&#13;
	var ws = wb.Sheets[s];&#13;
	if(ws == null) ws = {};&#13;
	var ref = ws['!ref'] || 'A1';&#13;
	var range = safe_decode_range(ref);&#13;
	if(range.e.c &gt; 0x3FFF || range.e.r &gt; 0xFFFFF) {&#13;
		if(opts.WTF) throw new Error("Range " + ref + " exceeds format limit A1:XFD1048576");&#13;
		range.e.c = Math.min(range.e.c, 0x3FFF);&#13;
		range.e.r = Math.min(range.e.c, 0xFFFFF);&#13;
		ref = encode_range(range);&#13;
	}&#13;
	if(!rels) rels = {};&#13;
	ws['!comments'] = [];&#13;
	var _drawing = [];&#13;
&#13;
	write_ws_xml_sheetpr(ws, wb, idx, opts, o);&#13;
&#13;
	o[o.length] = (writextag('dimension', null, {'ref': ref}));&#13;
&#13;
	o[o.length] = write_ws_xml_sheetviews(ws, opts, idx, wb);&#13;
&#13;
	/* TODO: store in WB, process styles */&#13;
	if(opts.sheetFormat) o[o.length] = (writextag('sheetFormatPr', null, {&#13;
		defaultRowHeight:opts.sheetFormat.defaultRowHeight||'16',&#13;
		baseColWidth:opts.sheetFormat.baseColWidth||'10',&#13;
		outlineLevelRow:opts.sheetFormat.outlineLevelRow||'7'&#13;
	}));&#13;
&#13;
	if(ws['!cols'] != null &amp;&amp; ws['!cols'].length &gt; 0) o[o.length] = (write_ws_xml_cols(ws, ws['!cols']));&#13;
&#13;
	o[sidx = o.length] = '&lt;sheetData/&gt;';&#13;
	ws['!links'] = [];&#13;
	if(ws['!ref'] != null) {&#13;
		rdata = write_ws_xml_data(ws, opts, idx, wb, rels);&#13;
		if(rdata.length &gt; 0) o[o.length] = (rdata);&#13;
	}&#13;
	if(o.length&gt;sidx+1) { o[o.length] = ('&lt;/sheetData&gt;'); o[sidx]=o[sidx].replace("/&gt;","&gt;"); }&#13;
&#13;
	/* sheetCalcPr */&#13;
&#13;
	if(ws['!protect']) o[o.length] = write_ws_xml_protection(ws['!protect']);&#13;
&#13;
	/* protectedRanges */&#13;
	/* scenarios */&#13;
&#13;
	if(ws['!autofilter'] != null) o[o.length] = write_ws_xml_autofilter(ws['!autofilter'], ws, wb, idx);&#13;
&#13;
	/* sortState */&#13;
	/* dataConsolidate */&#13;
	/* customSheetViews */&#13;
&#13;
	if(ws['!merges'] != null &amp;&amp; ws['!merges'].length &gt; 0) o[o.length] = (write_ws_xml_merges(ws['!merges']));&#13;
&#13;
	/* phoneticPr */&#13;
	/* conditionalFormatting */&#13;
	/* dataValidations */&#13;
&#13;
	var relc = -1, rel, rId = -1;&#13;
	if(ws['!links'].length &gt; 0) {&#13;
		o[o.length] = "&lt;hyperlinks&gt;";&#13;
ws['!links'].forEach(function(l) {&#13;
			if(!l[1].Target) return;&#13;
			rel = ({"ref":l[0]});&#13;
			if(l[1].Target.charAt(0) != "#") {&#13;
				rId = add_rels(rels, -1, escapexml(l[1].Target).replace(/#.*$/, ""), RELS.HLINK);&#13;
				rel["r:id"] = "rId"+rId;&#13;
			}&#13;
			if((relc = l[1].Target.indexOf("#")) &gt; -1) rel.location = escapexml(l[1].Target.slice(relc+1));&#13;
			if(l[1].Tooltip) rel.tooltip = escapexml(l[1].Tooltip);&#13;
			rel.display = l[1].display;&#13;
			o[o.length] = writextag("hyperlink",null,rel);&#13;
		});&#13;
		o[o.length] = "&lt;/hyperlinks&gt;";&#13;
	}&#13;
	delete ws['!links'];&#13;
&#13;
	/* printOptions */&#13;
&#13;
	if(ws['!margins'] != null) o[o.length] =  write_ws_xml_margins(ws['!margins']);&#13;
&#13;
	/* pageSetup */&#13;
	/* headerFooter */&#13;
	/* rowBreaks */&#13;
	/* colBreaks */&#13;
	/* customProperties */&#13;
	/* cellWatches */&#13;
&#13;
	if(!opts || opts.ignoreEC || (opts.ignoreEC == (void 0))) o[o.length] = writetag("ignoredErrors", writextag("ignoredError", null, {numberStoredAsText:1, sqref:ref}));&#13;
&#13;
	/* smartTags */&#13;
&#13;
	if(_drawing.length &gt; 0) {&#13;
		rId = add_rels(rels, -1, "../drawings/drawing" + (idx+1) + ".xml", RELS.DRAW);&#13;
		o[o.length] = writextag("drawing", null, {"r:id":"rId" + rId});&#13;
		ws['!drawing'] = _drawing;&#13;
	}&#13;
&#13;
	if(ws['!comments'].length &gt; 0) {&#13;
		rId = add_rels(rels, -1, "../drawings/vmlDrawing" + (idx+1) + ".vml", RELS.VML);&#13;
		o[o.length] = writextag("legacyDrawing", null, {"r:id":"rId" + rId});&#13;
		ws['!legacy'] = rId;&#13;
	}&#13;
&#13;
	/* legacyDrawingHF */&#13;
	/* picture */&#13;
	/* oleObjects */&#13;
	/* controls */&#13;
	/* webPublishItems */&#13;
	/* tableParts */&#13;
	/* extLst */&#13;
&#13;
	if(o.length&gt;1) { o[o.length] = ('&lt;/worksheet&gt;'); o[1]=o[1].replace("/&gt;","&gt;"); }&#13;
	return o.join("");&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.4.726 BrtRowHdr */&#13;
function parse_BrtRowHdr(data, length) {&#13;
	var z = ({});&#13;
	var tgt = data.l + length;&#13;
	z.r = data.read_shift(4);&#13;
	data.l += 4; // TODO: ixfe&#13;
	var miyRw = data.read_shift(2);&#13;
	data.l += 1; // TODO: top/bot padding&#13;
	var flags = data.read_shift(1);&#13;
	data.l = tgt;&#13;
	if(flags &amp; 0x07) z.level = flags &amp; 0x07;&#13;
	if(flags &amp; 0x10) z.hidden = true;&#13;
	if(flags &amp; 0x20) z.hpt = miyRw / 20;&#13;
	return z;&#13;
}&#13;
function write_BrtRowHdr(R, range, ws) {&#13;
	var o = new_buf(17+8*16);&#13;
	var row = (ws['!rows']||[])[R]||{};&#13;
	o.write_shift(4, R);&#13;
&#13;
	o.write_shift(4, 0); /* TODO: ixfe */&#13;
&#13;
	var miyRw = 0x0140;&#13;
	if(row.hpx) miyRw = px2pt(row.hpx) * 20;&#13;
	else if(row.hpt) miyRw = row.hpt * 20;&#13;
	o.write_shift(2, miyRw);&#13;
&#13;
	o.write_shift(1, 0); /* top/bot padding */&#13;
&#13;
	var flags = 0x0;&#13;
	if(row.level) flags |= row.level;&#13;
	if(row.hidden) flags |= 0x10;&#13;
	if(row.hpx || row.hpt) flags |= 0x20;&#13;
	o.write_shift(1, flags);&#13;
&#13;
	o.write_shift(1, 0); /* phonetic guide */&#13;
&#13;
	/* [MS-XLSB] 2.5.8 BrtColSpan explains the mechanism */&#13;
	var ncolspan = 0, lcs = o.l;&#13;
	o.l += 4;&#13;
&#13;
	var caddr = {r:R, c:0};&#13;
	for(var i = 0; i &lt; 16; ++i) {&#13;
		if((range.s.c &gt; ((i+1) &lt;&lt; 10)) || (range.e.c &lt; (i &lt;&lt; 10))) continue;&#13;
		var first = -1, last = -1;&#13;
		for(var j = (i&lt;&lt;10); j &lt; ((i+1)&lt;&lt;10); ++j) {&#13;
			caddr.c = j;&#13;
			var cell = Array.isArray(ws) ? (ws[caddr.r]||[])[caddr.c] : ws[encode_cell(caddr)];&#13;
			if(cell) { if(first &lt; 0) first = j; last = j; }&#13;
		}&#13;
		if(first &lt; 0) continue;&#13;
		++ncolspan;&#13;
		o.write_shift(4, first);&#13;
		o.write_shift(4, last);&#13;
	}&#13;
&#13;
	var l = o.l;&#13;
	o.l = lcs;&#13;
	o.write_shift(4, ncolspan);&#13;
	o.l = l;&#13;
&#13;
	return o.length &gt; o.l ? o.slice(0, o.l) : o;&#13;
}&#13;
function write_row_header(ba, ws, range, R) {&#13;
	var o = write_BrtRowHdr(R, range, ws);&#13;
	if((o.length &gt; 17) || (ws['!rows']||[])[R]) write_record(ba, 0x0000 /* BrtRowHdr */, o);&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.4.820 BrtWsDim */&#13;
var parse_BrtWsDim = parse_UncheckedRfX;&#13;
var write_BrtWsDim = write_UncheckedRfX;&#13;
&#13;
/* [MS-XLSB] 2.4.821 BrtWsFmtInfo */&#13;
function parse_BrtWsFmtInfo() {&#13;
}&#13;
//function write_BrtWsFmtInfo(ws, o) { }&#13;
&#13;
/* [MS-XLSB] 2.4.823 BrtWsProp */&#13;
function parse_BrtWsProp(data, length) {&#13;
	var z = {};&#13;
	var f = data[data.l]; ++data.l;&#13;
	z.above = !(f &amp; 0x40);&#13;
	z.left  = !(f &amp; 0x80);&#13;
	/* TODO: pull flags */&#13;
	data.l += 18;&#13;
	z.name = parse_XLSBCodeName(data, length - 19);&#13;
	return z;&#13;
}&#13;
function write_BrtWsProp(str, outl, o) {&#13;
	if(o == null) o = new_buf(84+4*str.length);&#13;
	var f = 0xC0;&#13;
	if(outl) {&#13;
		if(outl.above) f &amp;= ~0x40;&#13;
		if(outl.left)  f &amp;= ~0x80;&#13;
	}&#13;
	o.write_shift(1, f);&#13;
	for(var i = 1; i &lt; 3; ++i) o.write_shift(1,0);&#13;
	write_BrtColor({auto:1}, o);&#13;
	o.write_shift(-4,-1);&#13;
	o.write_shift(-4,-1);&#13;
	write_XLSBCodeName(str, o);&#13;
	return o.slice(0, o.l);&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.4.306 BrtCellBlank */&#13;
function parse_BrtCellBlank(data) {&#13;
	var cell = parse_XLSBCell(data);&#13;
	return [cell];&#13;
}&#13;
function write_BrtCellBlank(cell, ncell, o) {&#13;
	if(o == null) o = new_buf(8);&#13;
	return write_XLSBCell(ncell, o);&#13;
}&#13;
function parse_BrtShortBlank(data) {&#13;
	var cell = parse_XLSBShortCell(data);&#13;
	return [cell];&#13;
}&#13;
function write_BrtShortBlank(cell, ncell, o) {&#13;
	if(o == null) o = new_buf(4);&#13;
	return write_XLSBShortCell(ncell, o);&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.4.307 BrtCellBool */&#13;
function parse_BrtCellBool(data) {&#13;
	var cell = parse_XLSBCell(data);&#13;
	var fBool = data.read_shift(1);&#13;
	return [cell, fBool, 'b'];&#13;
}&#13;
function write_BrtCellBool(cell, ncell, o) {&#13;
	if(o == null) o = new_buf(9);&#13;
	write_XLSBCell(ncell, o);&#13;
	o.write_shift(1, cell.v ? 1 : 0);&#13;
	return o;&#13;
}&#13;
function parse_BrtShortBool(data) {&#13;
	var cell = parse_XLSBShortCell(data);&#13;
	var fBool = data.read_shift(1);&#13;
	return [cell, fBool, 'b'];&#13;
}&#13;
function write_BrtShortBool(cell, ncell, o) {&#13;
	if(o == null) o = new_buf(5);&#13;
	write_XLSBShortCell(ncell, o);&#13;
	o.write_shift(1, cell.v ? 1 : 0);&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.4.308 BrtCellError */&#13;
function parse_BrtCellError(data) {&#13;
	var cell = parse_XLSBCell(data);&#13;
	var bError = data.read_shift(1);&#13;
	return [cell, bError, 'e'];&#13;
}&#13;
function write_BrtCellError(cell, ncell, o) {&#13;
	if(o == null) o = new_buf(9);&#13;
	write_XLSBCell(ncell, o);&#13;
	o.write_shift(1, cell.v);&#13;
	return o;&#13;
}&#13;
function parse_BrtShortError(data) {&#13;
	var cell = parse_XLSBShortCell(data);&#13;
	var bError = data.read_shift(1);&#13;
	return [cell, bError, 'e'];&#13;
}&#13;
function write_BrtShortError(cell, ncell, o) {&#13;
	if(o == null) o = new_buf(8);&#13;
	write_XLSBShortCell(ncell, o);&#13;
	o.write_shift(1, cell.v);&#13;
	o.write_shift(2, 0);&#13;
	o.write_shift(1, 0);&#13;
	return o;&#13;
}&#13;
&#13;
&#13;
/* [MS-XLSB] 2.4.311 BrtCellIsst */&#13;
function parse_BrtCellIsst(data) {&#13;
	var cell = parse_XLSBCell(data);&#13;
	var isst = data.read_shift(4);&#13;
	return [cell, isst, 's'];&#13;
}&#13;
function write_BrtCellIsst(cell, ncell, o) {&#13;
	if(o == null) o = new_buf(12);&#13;
	write_XLSBCell(ncell, o);&#13;
	o.write_shift(4, ncell.v);&#13;
	return o;&#13;
}&#13;
function parse_BrtShortIsst(data) {&#13;
	var cell = parse_XLSBShortCell(data);&#13;
	var isst = data.read_shift(4);&#13;
	return [cell, isst, 's'];&#13;
}&#13;
function write_BrtShortIsst(cell, ncell, o) {&#13;
	if(o == null) o = new_buf(8);&#13;
	write_XLSBShortCell(ncell, o);&#13;
	o.write_shift(4, ncell.v);&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.4.313 BrtCellReal */&#13;
function parse_BrtCellReal(data) {&#13;
	var cell = parse_XLSBCell(data);&#13;
	var value = parse_Xnum(data);&#13;
	return [cell, value, 'n'];&#13;
}&#13;
function write_BrtCellReal(cell, ncell, o) {&#13;
	if(o == null) o = new_buf(16);&#13;
	write_XLSBCell(ncell, o);&#13;
	write_Xnum(cell.v, o);&#13;
	return o;&#13;
}&#13;
function parse_BrtShortReal(data) {&#13;
	var cell = parse_XLSBShortCell(data);&#13;
	var value = parse_Xnum(data);&#13;
	return [cell, value, 'n'];&#13;
}&#13;
function write_BrtShortReal(cell, ncell, o) {&#13;
	if(o == null) o = new_buf(12);&#13;
	write_XLSBShortCell(ncell, o);&#13;
	write_Xnum(cell.v, o);&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.4.314 BrtCellRk */&#13;
function parse_BrtCellRk(data) {&#13;
	var cell = parse_XLSBCell(data);&#13;
	var value = parse_RkNumber(data);&#13;
	return [cell, value, 'n'];&#13;
}&#13;
function write_BrtCellRk(cell, ncell, o) {&#13;
	if(o == null) o = new_buf(12);&#13;
	write_XLSBCell(ncell, o);&#13;
	write_RkNumber(cell.v, o);&#13;
	return o;&#13;
}&#13;
function parse_BrtShortRk(data) {&#13;
	var cell = parse_XLSBShortCell(data);&#13;
	var value = parse_RkNumber(data);&#13;
	return [cell, value, 'n'];&#13;
}&#13;
function write_BrtShortRk(cell, ncell, o) {&#13;
	if(o == null) o = new_buf(8);&#13;
	write_XLSBShortCell(ncell, o);&#13;
	write_RkNumber(cell.v, o);&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.4.323 BrtCellRString */&#13;
function parse_BrtCellRString(data) {&#13;
	var cell = parse_XLSBCell(data);&#13;
	var value = parse_RichStr(data);&#13;
	return [cell, value, 'is'];&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.4.317 BrtCellSt */&#13;
function parse_BrtCellSt(data) {&#13;
	var cell = parse_XLSBCell(data);&#13;
	var value = parse_XLWideString(data);&#13;
	return [cell, value, 'str'];&#13;
}&#13;
function write_BrtCellSt(cell, ncell, o) {&#13;
	var data = cell.v == null ? "" : String(cell.v);&#13;
	if(o == null) o = new_buf(12 + 4 * cell.v.length);&#13;
	write_XLSBCell(ncell, o);&#13;
	write_XLWideString(data, o);&#13;
	return o.length &gt; o.l ? o.slice(0, o.l) : o;&#13;
}&#13;
function parse_BrtShortSt(data) {&#13;
	var cell = parse_XLSBShortCell(data);&#13;
	var value = parse_XLWideString(data);&#13;
	return [cell, value, 'str'];&#13;
}&#13;
function write_BrtShortSt(cell, ncell, o) {&#13;
	var data = cell.v == null ? "" : String(cell.v);&#13;
	if(o == null) o = new_buf(8 + 4 * data.length);&#13;
	write_XLSBShortCell(ncell, o);&#13;
	write_XLWideString(data, o);&#13;
	return o.length &gt; o.l ? o.slice(0, o.l) : o;&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.4.653 BrtFmlaBool */&#13;
function parse_BrtFmlaBool(data, length, opts) {&#13;
	var end = data.l + length;&#13;
	var cell = parse_XLSBCell(data);&#13;
	cell.r = opts['!row'];&#13;
	var value = data.read_shift(1);&#13;
	var o = [cell, value, 'b'];&#13;
	if(opts.cellFormula) {&#13;
		data.l += 2;&#13;
		var formula = parse_XLSBCellParsedFormula(data, end - data.l, opts);&#13;
		o[3] = stringify_formula(formula, null/*range*/, cell, opts.supbooks, opts);/* TODO */&#13;
	}&#13;
	else data.l = end;&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.4.654 BrtFmlaError */&#13;
function parse_BrtFmlaError(data, length, opts) {&#13;
	var end = data.l + length;&#13;
	var cell = parse_XLSBCell(data);&#13;
	cell.r = opts['!row'];&#13;
	var value = data.read_shift(1);&#13;
	var o = [cell, value, 'e'];&#13;
	if(opts.cellFormula) {&#13;
		data.l += 2;&#13;
		var formula = parse_XLSBCellParsedFormula(data, end - data.l, opts);&#13;
		o[3] = stringify_formula(formula, null/*range*/, cell, opts.supbooks, opts);/* TODO */&#13;
	}&#13;
	else data.l = end;&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.4.655 BrtFmlaNum */&#13;
function parse_BrtFmlaNum(data, length, opts) {&#13;
	var end = data.l + length;&#13;
	var cell = parse_XLSBCell(data);&#13;
	cell.r = opts['!row'];&#13;
	var value = parse_Xnum(data);&#13;
	var o = [cell, value, 'n'];&#13;
	if(opts.cellFormula) {&#13;
		data.l += 2;&#13;
		var formula = parse_XLSBCellParsedFormula(data, end - data.l, opts);&#13;
		o[3] = stringify_formula(formula, null/*range*/, cell, opts.supbooks, opts);/* TODO */&#13;
	}&#13;
	else data.l = end;&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.4.656 BrtFmlaString */&#13;
function parse_BrtFmlaString(data, length, opts) {&#13;
	var end = data.l + length;&#13;
	var cell = parse_XLSBCell(data);&#13;
	cell.r = opts['!row'];&#13;
	var value = parse_XLWideString(data);&#13;
	var o = [cell, value, 'str'];&#13;
	if(opts.cellFormula) {&#13;
		data.l += 2;&#13;
		var formula = parse_XLSBCellParsedFormula(data, end - data.l, opts);&#13;
		o[3] = stringify_formula(formula, null/*range*/, cell, opts.supbooks, opts);/* TODO */&#13;
	}&#13;
	else data.l = end;&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.4.682 BrtMergeCell */&#13;
var parse_BrtMergeCell = parse_UncheckedRfX;&#13;
var write_BrtMergeCell = write_UncheckedRfX;&#13;
/* [MS-XLSB] 2.4.107 BrtBeginMergeCells */&#13;
function write_BrtBeginMergeCells(cnt, o) {&#13;
	if(o == null) o = new_buf(4);&#13;
	o.write_shift(4, cnt);&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.4.662 BrtHLink */&#13;
function parse_BrtHLink(data, length) {&#13;
	var end = data.l + length;&#13;
	var rfx = parse_UncheckedRfX(data, 16);&#13;
	var relId = parse_XLNullableWideString(data);&#13;
	var loc = parse_XLWideString(data);&#13;
	var tooltip = parse_XLWideString(data);&#13;
	var display = parse_XLWideString(data);&#13;
	data.l = end;&#13;
	var o = ({rfx:rfx, relId:relId, loc:loc, display:display});&#13;
	if(tooltip) o.Tooltip = tooltip;&#13;
	return o;&#13;
}&#13;
function write_BrtHLink(l, rId) {&#13;
	var o = new_buf(50+4*(l[1].Target.length + (l[1].Tooltip || "").length));&#13;
	write_UncheckedRfX({s:decode_cell(l[0]), e:decode_cell(l[0])}, o);&#13;
	write_RelID("rId" + rId, o);&#13;
	var locidx = l[1].Target.indexOf("#");&#13;
	var loc = locidx == -1 ? "" : l[1].Target.slice(locidx+1);&#13;
	write_XLWideString(loc || "", o);&#13;
	write_XLWideString(l[1].Tooltip || "", o);&#13;
	write_XLWideString("", o);&#13;
	return o.slice(0, o.l);&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.4.692 BrtPane */&#13;
function parse_BrtPane(/*data, length, opts*/) {&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.4.6 BrtArrFmla */&#13;
function parse_BrtArrFmla(data, length, opts) {&#13;
	var end = data.l + length;&#13;
	var rfx = parse_RfX(data, 16);&#13;
	var fAlwaysCalc = data.read_shift(1);&#13;
	var o = [rfx]; o[2] = fAlwaysCalc;&#13;
	if(opts.cellFormula) {&#13;
		var formula = parse_XLSBArrayParsedFormula(data, end - data.l, opts);&#13;
		o[1] = formula;&#13;
	} else data.l = end;&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.4.750 BrtShrFmla */&#13;
function parse_BrtShrFmla(data, length, opts) {&#13;
	var end = data.l + length;&#13;
	var rfx = parse_UncheckedRfX(data, 16);&#13;
	var o = [rfx];&#13;
	if(opts.cellFormula) {&#13;
		var formula = parse_XLSBSharedParsedFormula(data, end - data.l, opts);&#13;
		o[1] = formula;&#13;
		data.l = end;&#13;
	} else data.l = end;&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.4.323 BrtColInfo */&#13;
/* TODO: once XLS ColInfo is set, combine the functions */&#13;
function write_BrtColInfo(C, col, o) {&#13;
	if(o == null) o = new_buf(18);&#13;
	var p = col_obj_w(C, col);&#13;
	o.write_shift(-4, C);&#13;
	o.write_shift(-4, C);&#13;
	o.write_shift(4, (p.width || 10) * 256);&#13;
	o.write_shift(4, 0/*ixfe*/); // style&#13;
	var flags = 0;&#13;
	if(col.hidden) flags |= 0x01;&#13;
	if(typeof p.width == 'number') flags |= 0x02;&#13;
	if(col.level) flags |= (col.level &lt;&lt; 8);&#13;
	o.write_shift(2, flags); // bit flag&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.4.678 BrtMargins */&#13;
var BrtMarginKeys = ["left","right","top","bottom","header","footer"];&#13;
function parse_BrtMargins(data) {&#13;
	var margins = ({});&#13;
	BrtMarginKeys.forEach(function(k) { margins[k] = parse_Xnum(data, 8); });&#13;
	return margins;&#13;
}&#13;
function write_BrtMargins(margins, o) {&#13;
	if(o == null) o = new_buf(6*8);&#13;
	default_margins(margins);&#13;
	BrtMarginKeys.forEach(function(k) { write_Xnum((margins)[k], o); });&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.4.299 BrtBeginWsView */&#13;
function parse_BrtBeginWsView(data) {&#13;
	var f = data.read_shift(2);&#13;
	data.l += 28;&#13;
	return { RTL: f &amp; 0x20 };&#13;
}&#13;
function write_BrtBeginWsView(ws, Workbook, o) {&#13;
	if(o == null) o = new_buf(30);&#13;
	var f = 0x39c;&#13;
	if((((Workbook||{}).Views||[])[0]||{}).RTL) f |= 0x20;&#13;
	o.write_shift(2, f); // bit flag&#13;
	o.write_shift(4, 0);&#13;
	o.write_shift(4, 0); // view first row&#13;
	o.write_shift(4, 0); // view first col&#13;
	o.write_shift(1, 0); // gridline color ICV&#13;
	o.write_shift(1, 0);&#13;
	o.write_shift(2, 0);&#13;
	o.write_shift(2, 100); // zoom scale&#13;
	o.write_shift(2, 0);&#13;
	o.write_shift(2, 0);&#13;
	o.write_shift(2, 0);&#13;
	o.write_shift(4, 0); // workbook view id&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.4.309 BrtCellIgnoreEC */&#13;
function write_BrtCellIgnoreEC(ref) {&#13;
	var o = new_buf(24);&#13;
	o.write_shift(4, 4);&#13;
	o.write_shift(4, 1);&#13;
	write_UncheckedRfX(ref, o);&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.4.748 BrtSheetProtection */&#13;
function write_BrtSheetProtection(sp, o) {&#13;
	if(o == null) o = new_buf(16*4+2);&#13;
	o.write_shift(2, sp.password ? crypto_CreatePasswordVerifier_Method1(sp.password) : 0);&#13;
	o.write_shift(4, 1); // this record should not be written if no protection&#13;
	[&#13;
		["objects",             false], // fObjects&#13;
		["scenarios",           false], // fScenarios&#13;
		["formatCells",          true], // fFormatCells&#13;
		["formatColumns",        true], // fFormatColumns&#13;
		["formatRows",           true], // fFormatRows&#13;
		["insertColumns",        true], // fInsertColumns&#13;
		["insertRows",           true], // fInsertRows&#13;
		["insertHyperlinks",     true], // fInsertHyperlinks&#13;
		["deleteColumns",        true], // fDeleteColumns&#13;
		["deleteRows",           true], // fDeleteRows&#13;
		["selectLockedCells",   false], // fSelLockedCells&#13;
		["sort",                 true], // fSort&#13;
		["autoFilter",           true], // fAutoFilter&#13;
		["pivotTables",          true], // fPivotTables&#13;
		["selectUnlockedCells", false]  // fSelUnlockedCells&#13;
	].forEach(function(n) {&#13;
if(n[1]) o.write_shift(4, sp[n[0]] != null &amp;&amp; !sp[n[0]] ? 1 : 0);&#13;
		else      o.write_shift(4, sp[n[0]] != null &amp;&amp; sp[n[0]] ? 0 : 1);&#13;
	});&#13;
	return o;&#13;
}&#13;
&#13;
function parse_BrtDVal(/*data, length, opts*/) {&#13;
}&#13;
function parse_BrtDVal14(/*data, length, opts*/) {&#13;
}&#13;
/* [MS-XLSB] 2.1.7.61 Worksheet */&#13;
function parse_ws_bin(data, _opts, idx, rels, wb, themes, styles) {&#13;
	if(!data) return data;&#13;
	var opts = _opts || {};&#13;
	if(!rels) rels = {'!id':{}};&#13;
	if(DENSE != null &amp;&amp; opts.dense == null) opts.dense = DENSE;&#13;
	var s = (opts.dense ? [] : {});&#13;
&#13;
	var ref;&#13;
	var refguess = {s: {r:2000000, c:2000000}, e: {r:0, c:0} };&#13;
&#13;
	var state = [];&#13;
	var pass = false, end = false;&#13;
	var row, p, cf, R, C, addr, sstr, rr, cell;&#13;
	var merges = [];&#13;
	opts.biff = 12;&#13;
	opts['!row'] = 0;&#13;
&#13;
	var ai = 0, af = false;&#13;
&#13;
	var arrayf = [];&#13;
	var sharedf = {};&#13;
	var supbooks = opts.supbooks || wb.supbooks || ([[]]);&#13;
	supbooks.sharedf = sharedf;&#13;
	supbooks.arrayf = arrayf;&#13;
	supbooks.SheetNames = wb.SheetNames || wb.Sheets.map(function(x) { return x.name; });&#13;
	if(!opts.supbooks) {&#13;
		opts.supbooks = supbooks;&#13;
		if(wb.Names) for(var i = 0; i &lt; wb.Names.length; ++i) supbooks[0][i+1] = wb.Names[i];&#13;
	}&#13;
&#13;
	var colinfo = [], rowinfo = [];&#13;
	var seencol = false;&#13;
&#13;
	XLSBRecordEnum[0x0010] = { n:"BrtShortReal", f:parse_BrtShortReal };&#13;
&#13;
	var cm, vm;&#13;
&#13;
	recordhopper(data, function ws_parse(val, RR, RT) {&#13;
		if(end) return;&#13;
		switch(RT) {&#13;
			case 0x0094: /* 'BrtWsDim' */&#13;
				ref = val; break;&#13;
			case 0x0000: /* 'BrtRowHdr' */&#13;
				row = val;&#13;
				if(opts.sheetRows &amp;&amp; opts.sheetRows &lt;= row.r) end=true;&#13;
				rr = encode_row(R = row.r);&#13;
				opts['!row'] = row.r;&#13;
				if(val.hidden || val.hpt || val.level != null) {&#13;
					if(val.hpt) val.hpx = pt2px(val.hpt);&#13;
					rowinfo[val.r] = val;&#13;
				}&#13;
				break;&#13;
&#13;
			case 0x0002: /* 'BrtCellRk' */&#13;
			case 0x0003: /* 'BrtCellError' */&#13;
			case 0x0004: /* 'BrtCellBool' */&#13;
			case 0x0005: /* 'BrtCellReal' */&#13;
			case 0x0006: /* 'BrtCellSt' */&#13;
			case 0x0007: /* 'BrtCellIsst' */&#13;
			case 0x0008: /* 'BrtFmlaString' */&#13;
			case 0x0009: /* 'BrtFmlaNum' */&#13;
			case 0x000A: /* 'BrtFmlaBool' */&#13;
			case 0x000B: /* 'BrtFmlaError' */&#13;
			case 0x000D: /* 'BrtShortRk' */&#13;
			case 0x000E: /* 'BrtShortError' */&#13;
			case 0x000F: /* 'BrtShortBool' */&#13;
			case 0x0010: /* 'BrtShortReal' */&#13;
			case 0x0011: /* 'BrtShortSt' */&#13;
			case 0x0012: /* 'BrtShortIsst' */&#13;
			case 0x003E: /* 'BrtCellRString' */&#13;
				p = ({t:val[2]});&#13;
				switch(val[2]) {&#13;
					case 'n': p.v = val[1]; break;&#13;
					case 's': sstr = strs[val[1]]; p.v = sstr.t; p.r = sstr.r; break;&#13;
					case 'b': p.v = val[1] ? true : false; break;&#13;
					case 'e': p.v = val[1]; if(opts.cellText !== false) p.w = BErr[p.v]; break;&#13;
					case 'str': p.t = 's'; p.v = val[1]; break;&#13;
					case 'is': p.t = 's'; p.v = val[1].t; break;&#13;
				}&#13;
				if((cf = styles.CellXf[val[0].iStyleRef])) safe_format(p,cf.numFmtId,null,opts, themes, styles);&#13;
				C = val[0].c == -1 ? C + 1 : val[0].c;&#13;
				if(opts.dense) { if(!s[R]) s[R] = []; s[R][C] = p; }&#13;
				else s[encode_col(C) + rr] = p;&#13;
				if(opts.cellFormula) {&#13;
					af = false;&#13;
					for(ai = 0; ai &lt; arrayf.length; ++ai) {&#13;
						var aii = arrayf[ai];&#13;
						if(row.r &gt;= aii[0].s.r &amp;&amp; row.r &lt;= aii[0].e.r)&#13;
							if(C &gt;= aii[0].s.c &amp;&amp; C &lt;= aii[0].e.c) {&#13;
								p.F = encode_range(aii[0]); af = true;&#13;
							}&#13;
					}&#13;
					if(!af &amp;&amp; val.length &gt; 3) p.f = val[3];&#13;
				}&#13;
&#13;
				if(refguess.s.r &gt; row.r) refguess.s.r = row.r;&#13;
				if(refguess.s.c &gt; C) refguess.s.c = C;&#13;
				if(refguess.e.r &lt; row.r) refguess.e.r = row.r;&#13;
				if(refguess.e.c &lt; C) refguess.e.c = C;&#13;
				if(opts.cellDates &amp;&amp; cf &amp;&amp; p.t == 'n' &amp;&amp; fmt_is_date(table_fmt[cf.numFmtId])) {&#13;
					var _d = SSF_parse_date_code(p.v); if(_d) { p.t = 'd'; p.v = new Date(_d.y, _d.m-1,_d.d,_d.H,_d.M,_d.S,_d.u); }&#13;
				}&#13;
				if(cm) {&#13;
					if(cm.type == 'XLDAPR') p.D = true;&#13;
					cm = void 0;&#13;
				}&#13;
				if(vm) vm = void 0;&#13;
				break;&#13;
&#13;
			case 0x0001: /* 'BrtCellBlank' */&#13;
			case 0x000C: /* 'BrtShortBlank' */&#13;
				if(!opts.sheetStubs || pass) break;&#13;
				p = ({t:'z',v:void 0});&#13;
				C = val[0].c == -1 ? C + 1 : val[0].c;&#13;
				if(opts.dense) { if(!s[R]) s[R] = []; s[R][C] = p; }&#13;
				else s[encode_col(C) + rr] = p;&#13;
				if(refguess.s.r &gt; row.r) refguess.s.r = row.r;&#13;
				if(refguess.s.c &gt; C) refguess.s.c = C;&#13;
				if(refguess.e.r &lt; row.r) refguess.e.r = row.r;&#13;
				if(refguess.e.c &lt; C) refguess.e.c = C;&#13;
				if(cm) {&#13;
					if(cm.type == 'XLDAPR') p.D = true;&#13;
					cm = void 0;&#13;
				}&#13;
				if(vm) vm = void 0;&#13;
				break;&#13;
&#13;
			case 0x00B0: /* 'BrtMergeCell' */&#13;
				merges.push(val); break;&#13;
&#13;
			case 0x0031: { /* 'BrtCellMeta' */&#13;
				cm = ((opts.xlmeta||{}).Cell||[])[val-1];&#13;
			} break;&#13;
&#13;
			case 0x01EE: /* 'BrtHLink' */&#13;
				var rel = rels['!id'][val.relId];&#13;
				if(rel) {&#13;
					val.Target = rel.Target;&#13;
					if(val.loc) val.Target += "#"+val.loc;&#13;
					val.Rel = rel;&#13;
				} else if(val.relId == '') {&#13;
					val.Target = "#" + val.loc;&#13;
				}&#13;
				for(R=val.rfx.s.r;R&lt;=val.rfx.e.r;++R) for(C=val.rfx.s.c;C&lt;=val.rfx.e.c;++C) {&#13;
					if(opts.dense) {&#13;
						if(!s[R]) s[R] = [];&#13;
						if(!s[R][C]) s[R][C] = {t:'z',v:undefined};&#13;
						s[R][C].l = val;&#13;
					} else {&#13;
						addr = encode_cell({c:C,r:R});&#13;
						if(!s[addr]) s[addr] = {t:'z',v:undefined};&#13;
						s[addr].l = val;&#13;
					}&#13;
				}&#13;
				break;&#13;
&#13;
			case 0x01AA: /* 'BrtArrFmla' */&#13;
				if(!opts.cellFormula) break;&#13;
				arrayf.push(val);&#13;
				cell = ((opts.dense ? s[R][C] : s[encode_col(C) + rr]));&#13;
				cell.f = stringify_formula(val[1], refguess, {r:row.r, c:C}, supbooks, opts);&#13;
				cell.F = encode_range(val[0]);&#13;
				break;&#13;
			case 0x01AB: /* 'BrtShrFmla' */&#13;
				if(!opts.cellFormula) break;&#13;
				sharedf[encode_cell(val[0].s)] = val[1];&#13;
				cell = (opts.dense ? s[R][C] : s[encode_col(C) + rr]);&#13;
				cell.f = stringify_formula(val[1], refguess, {r:row.r, c:C}, supbooks, opts);&#13;
				break;&#13;
&#13;
			/* identical to 'ColInfo' in XLS */&#13;
			case 0x003C: /* 'BrtColInfo' */&#13;
				if(!opts.cellStyles) break;&#13;
				while(val.e &gt;= val.s) {&#13;
					colinfo[val.e--] = { width: val.w/256, hidden: !!(val.flags &amp; 0x01), level: val.level };&#13;
					if(!seencol) { seencol = true; find_mdw_colw(val.w/256); }&#13;
					process_col(colinfo[val.e+1]);&#13;
				}&#13;
				break;&#13;
&#13;
			case 0x00A1: /* 'BrtBeginAFilter' */&#13;
				s['!autofilter'] = { ref:encode_range(val) };&#13;
				break;&#13;
&#13;
			case 0x01DC: /* 'BrtMargins' */&#13;
				s['!margins'] = val;&#13;
				break;&#13;
&#13;
			case 0x0093: /* 'BrtWsProp' */&#13;
				if(!wb.Sheets[idx]) wb.Sheets[idx] = {};&#13;
				if(val.name) wb.Sheets[idx].CodeName = val.name;&#13;
				if(val.above || val.left) s['!outline'] = { above: val.above, left: val.left };&#13;
				break;&#13;
&#13;
			case 0x0089: /* 'BrtBeginWsView' */&#13;
				if(!wb.Views) wb.Views = [{}];&#13;
				if(!wb.Views[0]) wb.Views[0] = {};&#13;
				if(val.RTL) wb.Views[0].RTL = true;&#13;
				break;&#13;
&#13;
			case 0x01E5: /* 'BrtWsFmtInfo' */&#13;
				break;&#13;
&#13;
			case 0x0040: /* 'BrtDVal' */&#13;
			case 0x041D: /* 'BrtDVal14' */&#13;
				break;&#13;
&#13;
			case 0x0097: /* 'BrtPane' */&#13;
				break;&#13;
			case 0x0098: /* 'BrtSel' */&#13;
			case 0x00AF: /* 'BrtAFilterDateGroupItem' */&#13;
			case 0x0284: /* 'BrtActiveX' */&#13;
			case 0x0271: /* 'BrtBigName' */&#13;
			case 0x0232: /* 'BrtBkHim' */&#13;
			case 0x018C: /* 'BrtBrk' */&#13;
			case 0x0458: /* 'BrtCFIcon' */&#13;
			case 0x047A: /* 'BrtCFRuleExt' */&#13;
			case 0x01D7: /* 'BrtCFVO' */&#13;
			case 0x041A: /* 'BrtCFVO14' */&#13;
			case 0x0289: /* 'BrtCellIgnoreEC' */&#13;
			case 0x0451: /* 'BrtCellIgnoreEC14' */&#13;
			case 0x024D: /* 'BrtCellSmartTagProperty' */&#13;
			case 0x025F: /* 'BrtCellWatch' */&#13;
			case 0x0234: /* 'BrtColor' */&#13;
			case 0x041F: /* 'BrtColor14' */&#13;
			case 0x00A8: /* 'BrtColorFilter' */&#13;
			case 0x00AE: /* 'BrtCustomFilter' */&#13;
			case 0x049C: /* 'BrtCustomFilter14' */&#13;
			case 0x01F3: /* 'BrtDRef' */&#13;
			case 0x01FB: /* 'BrtDXF' */&#13;
			case 0x0226: /* 'BrtDrawing' */&#13;
			case 0x00AB: /* 'BrtDynamicFilter' */&#13;
			case 0x00A7: /* 'BrtFilter' */&#13;
			case 0x0499: /* 'BrtFilter14' */&#13;
			case 0x00A9: /* 'BrtIconFilter' */&#13;
			case 0x049D: /* 'BrtIconFilter14' */&#13;
			case 0x0227: /* 'BrtLegacyDrawing' */&#13;
			case 0x0228: /* 'BrtLegacyDrawingHF' */&#13;
			case 0x0295: /* 'BrtListPart' */&#13;
			case 0x027F: /* 'BrtOleObject' */&#13;
			case 0x01DE: /* 'BrtPageSetup' */&#13;
			case 0x0219: /* 'BrtPhoneticInfo' */&#13;
			case 0x01DD: /* 'BrtPrintOptions' */&#13;
			case 0x0218: /* 'BrtRangeProtection' */&#13;
			case 0x044F: /* 'BrtRangeProtection14' */&#13;
			case 0x02A8: /* 'BrtRangeProtectionIso' */&#13;
			case 0x0450: /* 'BrtRangeProtectionIso14' */&#13;
			case 0x0400: /* 'BrtRwDescent' */&#13;
			case 0x0297: /* 'BrtSheetCalcProp' */&#13;
			case 0x0217: /* 'BrtSheetProtection' */&#13;
			case 0x02A6: /* 'BrtSheetProtectionIso' */&#13;
			case 0x01F8: /* 'BrtSlc' */&#13;
			case 0x0413: /* 'BrtSparkline' */&#13;
			case 0x01AC: /* 'BrtTable' */&#13;
			case 0x00AA: /* 'BrtTop10Filter' */&#13;
			case 0x0C00: /* 'BrtUid' */&#13;
			case 0x0032: /* 'BrtValueMeta' */&#13;
			case 0x0816: /* 'BrtWebExtension' */&#13;
			case 0x0415: /* 'BrtWsFmtInfoEx14' */&#13;
				break;&#13;
&#13;
			case 0x0023: /* 'BrtFRTBegin' */&#13;
				pass = true; break;&#13;
			case 0x0024: /* 'BrtFRTEnd' */&#13;
				pass = false; break;&#13;
			case 0x0025: /* 'BrtACBegin' */&#13;
				state.push(RT); pass = true; break;&#13;
			case 0x0026: /* 'BrtACEnd' */&#13;
				state.pop(); pass = false; break;&#13;
&#13;
			default:&#13;
				if(RR.T){/* empty */}&#13;
				else if(!pass || opts.WTF) throw new Error("Unexpected record 0x" + RT.toString(16));&#13;
		}&#13;
	}, opts);&#13;
&#13;
	delete opts.supbooks;&#13;
	delete opts['!row'];&#13;
&#13;
	if(!s["!ref"] &amp;&amp; (refguess.s.r &lt; 2000000 || ref &amp;&amp; (ref.e.r &gt; 0 || ref.e.c &gt; 0 || ref.s.r &gt; 0 || ref.s.c &gt; 0))) s["!ref"] = encode_range(ref || refguess);&#13;
	if(opts.sheetRows &amp;&amp; s["!ref"]) {&#13;
		var tmpref = safe_decode_range(s["!ref"]);&#13;
		if(opts.sheetRows &lt;= +tmpref.e.r) {&#13;
			tmpref.e.r = opts.sheetRows - 1;&#13;
			if(tmpref.e.r &gt; refguess.e.r) tmpref.e.r = refguess.e.r;&#13;
			if(tmpref.e.r &lt; tmpref.s.r) tmpref.s.r = tmpref.e.r;&#13;
			if(tmpref.e.c &gt; refguess.e.c) tmpref.e.c = refguess.e.c;&#13;
			if(tmpref.e.c &lt; tmpref.s.c) tmpref.s.c = tmpref.e.c;&#13;
			s["!fullref"] = s["!ref"];&#13;
			s["!ref"] = encode_range(tmpref);&#13;
		}&#13;
	}&#13;
	if(merges.length &gt; 0) s["!merges"] = merges;&#13;
	if(colinfo.length &gt; 0) s["!cols"] = colinfo;&#13;
	if(rowinfo.length &gt; 0) s["!rows"] = rowinfo;&#13;
	return s;&#13;
}&#13;
&#13;
/* TODO: something useful -- this is a stub */&#13;
function write_ws_bin_cell(ba, cell, R, C, opts, ws, last_seen) {&#13;
	var o = ({r:R, c:C});&#13;
	if(cell.c) ws['!comments'].push([encode_cell(o), cell.c]);&#13;
	if(cell.v === undefined) return false;&#13;
	var vv = "";&#13;
	switch(cell.t) {&#13;
		case 'b': vv = cell.v ? "1" : "0"; break;&#13;
		case 'd': // no BrtCellDate :(&#13;
			cell = dup(cell);&#13;
			cell.z = cell.z || table_fmt[14];&#13;
			cell.v = datenum(parseDate(cell.v)); cell.t = 'n';&#13;
			break;&#13;
		/* falls through */&#13;
		case 'n': case 'e': vv = ''+cell.v; break;&#13;
		default: vv = cell.v; break;&#13;
	}&#13;
	/* TODO: cell style */&#13;
	o.s = get_cell_style(opts.cellXfs, cell, opts);&#13;
	if(cell.l) ws['!links'].push([encode_cell(o), cell.l]);&#13;
	switch(cell.t) {&#13;
		case 's': case 'str':&#13;
			if(opts.bookSST) {&#13;
				vv = get_sst_id(opts.Strings, (cell.v == null ? "" : String(cell.v)), opts.revStrings);&#13;
				o.t = "s"; o.v = vv;&#13;
				if(last_seen) write_record(ba, 0x0012 /* BrtShortIsst */, write_BrtShortIsst(cell, o));&#13;
				else write_record(ba, 0x0007 /* BrtCellIsst */, write_BrtCellIsst(cell, o));&#13;
			} else {&#13;
				o.t = "str";&#13;
				if(last_seen) write_record(ba, 0x0011 /* BrtShortSt */, write_BrtShortSt(cell, o));&#13;
				else write_record(ba, 0x0006 /* BrtCellSt */, write_BrtCellSt(cell, o));&#13;
			}&#13;
			return true;&#13;
		case 'n':&#13;
			/* TODO: determine threshold for Real vs RK */&#13;
			if(cell.v == (cell.v | 0) &amp;&amp; cell.v &gt; -1000 &amp;&amp; cell.v &lt; 1000) {&#13;
				if(last_seen) write_record(ba, 0x000D /* BrtShortRk */, write_BrtShortRk(cell, o));&#13;
				else write_record(ba, 0x0002 /* BrtCellRk */, write_BrtCellRk(cell, o));&#13;
			} else {&#13;
				if(last_seen) write_record(ba, 0x0010 /* BrtShortReal */, write_BrtShortReal(cell, o));&#13;
				else write_record(ba, 0x0005 /* BrtCellReal */, write_BrtCellReal(cell, o));&#13;
			} return true;&#13;
		case 'b':&#13;
			o.t = "b";&#13;
			if(last_seen) write_record(ba, 0x000F /* BrtShortBool */, write_BrtShortBool(cell, o));&#13;
			else write_record(ba, 0x0004 /* BrtCellBool */, write_BrtCellBool(cell, o));&#13;
			return true;&#13;
		case 'e':&#13;
			o.t = "e";&#13;
			if(last_seen) write_record(ba, 0x000E /* BrtShortError */, write_BrtShortError(cell, o));&#13;
			else write_record(ba, 0x0003 /* BrtCellError */, write_BrtCellError(cell, o));&#13;
			return true;&#13;
	}&#13;
	if(last_seen) write_record(ba, 0x000C /* BrtShortBlank */, write_BrtShortBlank(cell, o));&#13;
	else write_record(ba, 0x0001 /* BrtCellBlank */, write_BrtCellBlank(cell, o));&#13;
	return true;&#13;
}&#13;
&#13;
function write_CELLTABLE(ba, ws, idx, opts) {&#13;
	var range = safe_decode_range(ws['!ref'] || "A1"), ref, rr = "", cols = [];&#13;
	write_record(ba, 0x0091 /* BrtBeginSheetData */);&#13;
	var dense = Array.isArray(ws);&#13;
	var cap = range.e.r;&#13;
	if(ws['!rows']) cap = Math.max(range.e.r, ws['!rows'].length - 1);&#13;
	for(var R = range.s.r; R &lt;= cap; ++R) {&#13;
		rr = encode_row(R);&#13;
		/* [ACCELLTABLE] */&#13;
		/* BrtRowHdr */&#13;
		write_row_header(ba, ws, range, R);&#13;
		var last_seen = false;&#13;
		if(R &lt;= range.e.r) for(var C = range.s.c; C &lt;= range.e.c; ++C) {&#13;
			/* *16384CELL */&#13;
			if(R === range.s.r) cols[C] = encode_col(C);&#13;
			ref = cols[C] + rr;&#13;
			var cell = dense ? (ws[R]||[])[C] : ws[ref];&#13;
			if(!cell) { last_seen = false; continue; }&#13;
			/* write cell */&#13;
			last_seen = write_ws_bin_cell(ba, cell, R, C, opts, ws, last_seen);&#13;
		}&#13;
	}&#13;
	write_record(ba, 0x0092 /* BrtEndSheetData */);&#13;
}&#13;
&#13;
function write_MERGECELLS(ba, ws) {&#13;
	if(!ws || !ws['!merges']) return;&#13;
	write_record(ba, 0x00B1 /* BrtBeginMergeCells */, write_BrtBeginMergeCells(ws['!merges'].length));&#13;
	ws['!merges'].forEach(function(m) { write_record(ba, 0x00B0 /* BrtMergeCell */, write_BrtMergeCell(m)); });&#13;
	write_record(ba, 0x00B2 /* BrtEndMergeCells */);&#13;
}&#13;
&#13;
function write_COLINFOS(ba, ws) {&#13;
	if(!ws || !ws['!cols']) return;&#13;
	write_record(ba, 0x0186 /* BrtBeginColInfos */);&#13;
	ws['!cols'].forEach(function(m, i) { if(m) write_record(ba, 0x003C /* 'BrtColInfo' */, write_BrtColInfo(i, m)); });&#13;
	write_record(ba, 0x0187 /* BrtEndColInfos */);&#13;
}&#13;
&#13;
function write_IGNOREECS(ba, ws) {&#13;
	if(!ws || !ws['!ref']) return;&#13;
	write_record(ba, 0x0288 /* BrtBeginCellIgnoreECs */);&#13;
	write_record(ba, 0x0289 /* BrtCellIgnoreEC */, write_BrtCellIgnoreEC(safe_decode_range(ws['!ref'])));&#13;
	write_record(ba, 0x028A /* BrtEndCellIgnoreECs */);&#13;
}&#13;
&#13;
function write_HLINKS(ba, ws, rels) {&#13;
	/* *BrtHLink */&#13;
	ws['!links'].forEach(function(l) {&#13;
		if(!l[1].Target) return;&#13;
		var rId = add_rels(rels, -1, l[1].Target.replace(/#.*$/, ""), RELS.HLINK);&#13;
		write_record(ba, 0x01EE /* BrtHLink */, write_BrtHLink(l, rId));&#13;
	});&#13;
	delete ws['!links'];&#13;
}&#13;
function write_LEGACYDRAWING(ba, ws, idx, rels) {&#13;
	/* [BrtLegacyDrawing] */&#13;
	if(ws['!comments'].length &gt; 0) {&#13;
		var rId = add_rels(rels, -1, "../drawings/vmlDrawing" + (idx+1) + ".vml", RELS.VML);&#13;
		write_record(ba, 0x0227 /* BrtLegacyDrawing */, write_RelID("rId" + rId));&#13;
		ws['!legacy'] = rId;&#13;
	}&#13;
}&#13;
&#13;
function write_AUTOFILTER(ba, ws, wb, idx) {&#13;
	if(!ws['!autofilter']) return;&#13;
	var data = ws['!autofilter'];&#13;
	var ref = typeof data.ref === "string" ? data.ref : encode_range(data.ref);&#13;
&#13;
	/* Update FilterDatabase defined name for the worksheet */&#13;
	if(!wb.Workbook) wb.Workbook = ({Sheets:[]});&#13;
	if(!wb.Workbook.Names) wb.Workbook.Names = [];&#13;
	var names = wb.Workbook.Names;&#13;
	var range = decode_range(ref);&#13;
	if(range.s.r == range.e.r) { range.e.r = decode_range(ws["!ref"]).e.r; ref = encode_range(range); }&#13;
	for(var i = 0; i &lt; names.length; ++i) {&#13;
		var name = names[i];&#13;
		if(name.Name != '_xlnm._FilterDatabase') continue;&#13;
		if(name.Sheet != idx) continue;&#13;
		name.Ref = formula_quote_sheet_name(wb.SheetNames[idx]) + "!" + fix_range(ref); break;&#13;
	}&#13;
	if(i == names.length) names.push({ Name: '_xlnm._FilterDatabase', Sheet: idx, Ref: formula_quote_sheet_name(wb.SheetNames[idx]) + "!" + fix_range(ref)  });&#13;
&#13;
	write_record(ba, 0x00A1 /* BrtBeginAFilter */, write_UncheckedRfX(safe_decode_range(ref)));&#13;
	/* *FILTERCOLUMN */&#13;
	/* [SORTSTATE] */&#13;
	/* BrtEndAFilter */&#13;
	write_record(ba, 0x00A2 /* BrtEndAFilter */);&#13;
}&#13;
&#13;
function write_WSVIEWS2(ba, ws, Workbook) {&#13;
	write_record(ba, 0x0085 /* BrtBeginWsViews */);&#13;
	{ /* 1*WSVIEW2 */&#13;
		/* [ACUID] */&#13;
		write_record(ba, 0x0089 /* BrtBeginWsView */, write_BrtBeginWsView(ws, Workbook));&#13;
		/* [BrtPane] */&#13;
		/* *4BrtSel */&#13;
		/* *4SXSELECT */&#13;
		/* *FRT */&#13;
		write_record(ba, 0x008A /* BrtEndWsView */);&#13;
	}&#13;
	/* *FRT */&#13;
	write_record(ba, 0x0086 /* BrtEndWsViews */);&#13;
}&#13;
&#13;
function write_WSFMTINFO() {&#13;
	/* [ACWSFMTINFO] */&#13;
	// write_record(ba, 0x01E5 /* BrtWsFmtInfo */, write_BrtWsFmtInfo(ws));&#13;
}&#13;
&#13;
function write_SHEETPROTECT(ba, ws) {&#13;
	if(!ws['!protect']) return;&#13;
	/* [BrtSheetProtectionIso] */&#13;
	write_record(ba, 0x0217 /* BrtSheetProtection */, write_BrtSheetProtection(ws['!protect']));&#13;
}&#13;
&#13;
function write_ws_bin(idx, opts, wb, rels) {&#13;
	var ba = buf_array();&#13;
	var s = wb.SheetNames[idx], ws = wb.Sheets[s] || {};&#13;
	var c = s; try { if(wb &amp;&amp; wb.Workbook) c = wb.Workbook.Sheets[idx].CodeName || c; } catch(e) {}&#13;
	var r = safe_decode_range(ws['!ref'] || "A1");&#13;
	if(r.e.c &gt; 0x3FFF || r.e.r &gt; 0xFFFFF) {&#13;
		if(opts.WTF) throw new Error("Range " + (ws['!ref'] || "A1") + " exceeds format limit A1:XFD1048576");&#13;
		r.e.c = Math.min(r.e.c, 0x3FFF);&#13;
		r.e.r = Math.min(r.e.c, 0xFFFFF);&#13;
	}&#13;
	ws['!links'] = [];&#13;
	/* passed back to write_zip and removed there */&#13;
	ws['!comments'] = [];&#13;
	write_record(ba, 0x0081 /* BrtBeginSheet */);&#13;
	if(wb.vbaraw || ws['!outline']) write_record(ba, 0x0093 /* BrtWsProp */, write_BrtWsProp(c, ws['!outline']));&#13;
	write_record(ba, 0x0094 /* BrtWsDim */, write_BrtWsDim(r));&#13;
	write_WSVIEWS2(ba, ws, wb.Workbook);&#13;
	write_WSFMTINFO(ba, ws);&#13;
	write_COLINFOS(ba, ws, idx, opts, wb);&#13;
	write_CELLTABLE(ba, ws, idx, opts, wb);&#13;
	/* [BrtSheetCalcProp] */&#13;
	write_SHEETPROTECT(ba, ws);&#13;
	/* *([BrtRangeProtectionIso] BrtRangeProtection) */&#13;
	/* [SCENMAN] */&#13;
	write_AUTOFILTER(ba, ws, wb, idx);&#13;
	/* [SORTSTATE] */&#13;
	/* [DCON] */&#13;
	/* [USERSHVIEWS] */&#13;
	write_MERGECELLS(ba, ws);&#13;
	/* [BrtPhoneticInfo] */&#13;
	/* *CONDITIONALFORMATTING */&#13;
	/* [DVALS] */&#13;
	write_HLINKS(ba, ws, rels);&#13;
	/* [BrtPrintOptions] */&#13;
	if(ws['!margins']) write_record(ba, 0x01DC /* BrtMargins */, write_BrtMargins(ws['!margins']));&#13;
	/* [BrtPageSetup] */&#13;
	/* [HEADERFOOTER] */&#13;
	/* [RWBRK] */&#13;
	/* [COLBRK] */&#13;
	/* *BrtBigName */&#13;
	/* [CELLWATCHES] */&#13;
	if(!opts || opts.ignoreEC || (opts.ignoreEC == (void 0))) write_IGNOREECS(ba, ws);&#13;
	/* [SMARTTAGS] */&#13;
	/* [BrtDrawing] */&#13;
	write_LEGACYDRAWING(ba, ws, idx, rels);&#13;
	/* [BrtLegacyDrawingHF] */&#13;
	/* [BrtBkHim] */&#13;
	/* [OLEOBJECTS] */&#13;
	/* [ACTIVEXCONTROLS] */&#13;
	/* [WEBPUBITEMS] */&#13;
	/* [LISTPARTS] */&#13;
	/* FRTWORKSHEET */&#13;
	write_record(ba, 0x0082 /* BrtEndSheet */);&#13;
	return ba.end();&#13;
}&#13;
function parse_Cache(data) {&#13;
	var col = [];&#13;
	var num = data.match(/^&lt;c:numCache&gt;/);&#13;
	var f;&#13;
&#13;
	/* 21.2.2.150 pt CT_NumVal */&#13;
	(data.match(/&lt;c:pt idx="(\d*)"&gt;(.*?)&lt;\/c:pt&gt;/mg)||[]).forEach(function(pt) {&#13;
		var q = pt.match(/&lt;c:pt idx="(\d*?)"&gt;&lt;c:v&gt;(.*)&lt;\/c:v&gt;&lt;\/c:pt&gt;/);&#13;
		if(!q) return;&#13;
		col[+q[1]] = num ? +q[2] : q[2];&#13;
	});&#13;
&#13;
	/* 21.2.2.71 formatCode CT_Xstring */&#13;
	var nf = unescapexml((data.match(/&lt;c:formatCode&gt;([\s\S]*?)&lt;\/c:formatCode&gt;/) || ["","General"])[1]);&#13;
&#13;
	(data.match(/&lt;c:f&gt;(.*?)&lt;\/c:f&gt;/mg)||[]).forEach(function(F) { f = F.replace(/&lt;.*?&gt;/g,""); });&#13;
&#13;
	return [col, nf, f];&#13;
}&#13;
&#13;
/* 21.2 DrawingML - Charts */&#13;
function parse_chart(data, name, opts, rels, wb, csheet) {&#13;
	var cs = ((csheet || {"!type":"chart"}));&#13;
	if(!data) return csheet;&#13;
	/* 21.2.2.27 chart CT_Chart */&#13;
&#13;
	var C = 0, R = 0, col = "A";&#13;
	var refguess = {s: {r:2000000, c:2000000}, e: {r:0, c:0} };&#13;
&#13;
	/* 21.2.2.120 numCache CT_NumData */&#13;
	(data.match(/&lt;c:numCache&gt;[\s\S]*?&lt;\/c:numCache&gt;/gm)||[]).forEach(function(nc) {&#13;
		var cache = parse_Cache(nc);&#13;
		refguess.s.r = refguess.s.c = 0;&#13;
		refguess.e.c = C;&#13;
		col = encode_col(C);&#13;
		cache[0].forEach(function(n,i) {&#13;
			cs[col + encode_row(i)] = {t:'n', v:n, z:cache[1] };&#13;
			R = i;&#13;
		});&#13;
		if(refguess.e.r &lt; R) refguess.e.r = R;&#13;
		++C;&#13;
	});&#13;
	if(C &gt; 0) cs["!ref"] = encode_range(refguess);&#13;
	return cs;&#13;
}&#13;
/* 18.3 Worksheets also covers Chartsheets */&#13;
function parse_cs_xml(data, opts, idx, rels, wb) {&#13;
	if(!data) return data;&#13;
	/* 18.3.1.12 chartsheet CT_ChartSheet */&#13;
	if(!rels) rels = {'!id':{}};&#13;
	var s = ({'!type':"chart", '!drawel':null, '!rel':""});&#13;
	var m;&#13;
&#13;
	/* 18.3.1.83 sheetPr CT_ChartsheetPr */&#13;
	var sheetPr = data.match(sheetprregex);&#13;
	if(sheetPr) parse_ws_xml_sheetpr(sheetPr[0], s, wb, idx);&#13;
&#13;
	/* 18.3.1.36 drawing CT_Drawing */&#13;
	if((m = data.match(/drawing r:id="(.*?)"/))) s['!rel'] = m[1];&#13;
&#13;
	if(rels['!id'][s['!rel']]) s['!drawel'] = rels['!id'][s['!rel']];&#13;
	return s;&#13;
}&#13;
//function write_cs_xml(idx, opts, wb, rels) {&#13;
//	var o = [XML_HEADER, writextag('chartsheet', null, {&#13;
//		'xmlns': XMLNS_main[0],&#13;
//		'xmlns:r': XMLNS.r&#13;
//	})];&#13;
//	o[o.length] = writextag("drawing", null, {"r:id": "rId1"});&#13;
//	add_rels(rels, -1, "../drawings/drawing" + (idx+1) + ".xml", RELS.DRAW);&#13;
//	if(o.length&gt;2) { o[o.length] = ('&lt;/chartsheet&gt;'); o[1]=o[1].replace("/&gt;","&gt;"); }&#13;
//	return o.join("");&#13;
//}&#13;
&#13;
/* [MS-XLSB] 2.4.331 BrtCsProp */&#13;
function parse_BrtCsProp(data, length) {&#13;
	data.l += 10;&#13;
	var name = parse_XLWideString(data, length - 10);&#13;
	return { name: name };&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.1.7.7 Chart Sheet */&#13;
function parse_cs_bin(data, opts, idx, rels, wb) {&#13;
	if(!data) return data;&#13;
	if(!rels) rels = {'!id':{}};&#13;
	var s = {'!type':"chart", '!drawel':null, '!rel':""};&#13;
	var state = [];&#13;
	var pass = false;&#13;
	recordhopper(data, function cs_parse(val, R, RT) {&#13;
		switch(RT) {&#13;
&#13;
			case 0x0226: /* 'BrtDrawing' */&#13;
				s['!rel'] = val; break;&#13;
&#13;
			case 0x028B: /* 'BrtCsProp' */&#13;
				if(!wb.Sheets[idx]) wb.Sheets[idx] = {};&#13;
				if(val.name) wb.Sheets[idx].CodeName = val.name;&#13;
				break;&#13;
&#13;
			case 0x0232: /* 'BrtBkHim' */&#13;
			case 0x028C: /* 'BrtCsPageSetup' */&#13;
			case 0x029D: /* 'BrtCsProtection' */&#13;
			case 0x02A7: /* 'BrtCsProtectionIso' */&#13;
			case 0x0227: /* 'BrtLegacyDrawing' */&#13;
			case 0x0228: /* 'BrtLegacyDrawingHF' */&#13;
			case 0x01DC: /* 'BrtMargins' */&#13;
			case 0x0C00: /* 'BrtUid' */&#13;
				break;&#13;
&#13;
			case 0x0023: /* 'BrtFRTBegin' */&#13;
				pass = true; break;&#13;
			case 0x0024: /* 'BrtFRTEnd' */&#13;
				pass = false; break;&#13;
			case 0x0025: /* 'BrtACBegin' */&#13;
				state.push(RT); break;&#13;
			case 0x0026: /* 'BrtACEnd' */&#13;
				state.pop(); break;&#13;
&#13;
			default:&#13;
				if(R.T &gt; 0) state.push(RT);&#13;
				else if(R.T &lt; 0) state.pop();&#13;
				else if(!pass || opts.WTF) throw new Error("Unexpected record 0x" + RT.toString(16));&#13;
		}&#13;
	}, opts);&#13;
&#13;
	if(rels['!id'][s['!rel']]) s['!drawel'] = rels['!id'][s['!rel']];&#13;
	return s;&#13;
}&#13;
//function write_cs_bin() {&#13;
//	var ba = buf_array();&#13;
//	write_record(ba, 0x0081 /* BrtBeginSheet */);&#13;
//	/* [BrtCsProp] */&#13;
//	/* CSVIEWS */&#13;
//	/* [[BrtCsProtectionIso] BrtCsProtection] */&#13;
//	/* [USERCSVIEWS] */&#13;
//	/* [BrtMargins] */&#13;
//	/* [BrtCsPageSetup] */&#13;
//	/* [HEADERFOOTER] */&#13;
//	/* BrtDrawing */&#13;
//	/* [BrtLegacyDrawing] */&#13;
//	/* [BrtLegacyDrawingHF] */&#13;
//	/* [BrtBkHim] */&#13;
//	/* [WEBPUBITEMS] */&#13;
//	/* FRTCHARTSHEET */&#13;
//	write_record(ba, 0x0082 /* BrtEndSheet */);&#13;
//	return ba.end();&#13;
//}&#13;
/* 18.2.28 (CT_WorkbookProtection) Defaults */&#13;
var WBPropsDef = [&#13;
	['allowRefreshQuery',           false, "bool"],&#13;
	['autoCompressPictures',        true,  "bool"],&#13;
	['backupFile',                  false, "bool"],&#13;
	['checkCompatibility',          false, "bool"],&#13;
	['CodeName',                    ''],&#13;
	['date1904',                    false, "bool"],&#13;
	['defaultThemeVersion',         0,      "int"],&#13;
	['filterPrivacy',               false, "bool"],&#13;
	['hidePivotFieldList',          false, "bool"],&#13;
	['promptedSolutions',           false, "bool"],&#13;
	['publishItems',                false, "bool"],&#13;
	['refreshAllConnections',       false, "bool"],&#13;
	['saveExternalLinkValues',      true,  "bool"],&#13;
	['showBorderUnselectedTables',  true,  "bool"],&#13;
	['showInkAnnotation',           true,  "bool"],&#13;
	['showObjects',                 'all'],&#13;
	['showPivotChartFilter',        false, "bool"],&#13;
	['updateLinks', 'userSet']&#13;
];&#13;
&#13;
/* 18.2.30 (CT_BookView) Defaults */&#13;
var WBViewDef = [&#13;
	['activeTab',                   0,      "int"],&#13;
	['autoFilterDateGrouping',      true,  "bool"],&#13;
	['firstSheet',                  0,      "int"],&#13;
	['minimized',                   false, "bool"],&#13;
	['showHorizontalScroll',        true,  "bool"],&#13;
	['showSheetTabs',               true,  "bool"],&#13;
	['showVerticalScroll',          true,  "bool"],&#13;
	['tabRatio',                    600,    "int"],&#13;
	['visibility',                  'visible']&#13;
	//window{Height,Width}, {x,y}Window&#13;
];&#13;
&#13;
/* 18.2.19 (CT_Sheet) Defaults */&#13;
var SheetDef = [&#13;
	//['state', 'visible']&#13;
];&#13;
&#13;
/* 18.2.2  (CT_CalcPr) Defaults */&#13;
var CalcPrDef = [&#13;
	['calcCompleted', 'true'],&#13;
	['calcMode', 'auto'],&#13;
	['calcOnSave', 'true'],&#13;
	['concurrentCalc', 'true'],&#13;
	['fullCalcOnLoad', 'false'],&#13;
	['fullPrecision', 'true'],&#13;
	['iterate', 'false'],&#13;
	['iterateCount', '100'],&#13;
	['iterateDelta', '0.001'],&#13;
	['refMode', 'A1']&#13;
];&#13;
&#13;
/* 18.2.3 (CT_CustomWorkbookView) Defaults */&#13;
/*var CustomWBViewDef = [&#13;
	['autoUpdate', 'false'],&#13;
	['changesSavedWin', 'false'],&#13;
	['includeHiddenRowCol', 'true'],&#13;
	['includePrintSettings', 'true'],&#13;
	['maximized', 'false'],&#13;
	['minimized', 'false'],&#13;
	['onlySync', 'false'],&#13;
	['personalView', 'false'],&#13;
	['showComments', 'commIndicator'],&#13;
	['showFormulaBar', 'true'],&#13;
	['showHorizontalScroll', 'true'],&#13;
	['showObjects', 'all'],&#13;
	['showSheetTabs', 'true'],&#13;
	['showStatusbar', 'true'],&#13;
	['showVerticalScroll', 'true'],&#13;
	['tabRatio', '600'],&#13;
	['xWindow', '0'],&#13;
	['yWindow', '0']&#13;
];*/&#13;
&#13;
function push_defaults_array(target, defaults) {&#13;
	for(var j = 0; j != target.length; ++j) { var w = target[j];&#13;
		for(var i=0; i != defaults.length; ++i) { var z = defaults[i];&#13;
			if(w[z[0]] == null) w[z[0]] = z[1];&#13;
			else switch(z[2]) {&#13;
			case "bool": if(typeof w[z[0]] == "string") w[z[0]] = parsexmlbool(w[z[0]]); break;&#13;
			case "int": if(typeof w[z[0]] == "string") w[z[0]] = parseInt(w[z[0]], 10); break;&#13;
			}&#13;
		}&#13;
	}&#13;
}&#13;
function push_defaults(target, defaults) {&#13;
	for(var i = 0; i != defaults.length; ++i) { var z = defaults[i];&#13;
		if(target[z[0]] == null) target[z[0]] = z[1];&#13;
		else switch(z[2]) {&#13;
			case "bool": if(typeof target[z[0]] == "string") target[z[0]] = parsexmlbool(target[z[0]]); break;&#13;
			case "int": if(typeof target[z[0]] == "string") target[z[0]] = parseInt(target[z[0]], 10); break;&#13;
		}&#13;
	}&#13;
}&#13;
&#13;
function parse_wb_defaults(wb) {&#13;
	push_defaults(wb.WBProps, WBPropsDef);&#13;
	push_defaults(wb.CalcPr, CalcPrDef);&#13;
&#13;
	push_defaults_array(wb.WBView, WBViewDef);&#13;
	push_defaults_array(wb.Sheets, SheetDef);&#13;
&#13;
	_ssfopts.date1904 = parsexmlbool(wb.WBProps.date1904);&#13;
}&#13;
&#13;
function safe1904(wb) {&#13;
	/* TODO: store date1904 somewhere else */&#13;
	if(!wb.Workbook) return "false";&#13;
	if(!wb.Workbook.WBProps) return "false";&#13;
	return parsexmlbool(wb.Workbook.WBProps.date1904) ? "true" : "false";&#13;
}&#13;
&#13;
var badchars = ":][*?\/\\".split("");&#13;
function check_ws_name(n, safe) {&#13;
	if(n.length &gt; 31) { if(safe) return false; throw new Error("Sheet names cannot exceed 31 chars"); }&#13;
	var _good = true;&#13;
	badchars.forEach(function(c) {&#13;
		if(n.indexOf(c) == -1) return;&#13;
		if(!safe) throw new Error("Sheet name cannot contain : \\ / ? * [ ]");&#13;
		_good = false;&#13;
	});&#13;
	return _good;&#13;
}&#13;
function check_wb_names(N, S, codes) {&#13;
	N.forEach(function(n,i) {&#13;
		check_ws_name(n);&#13;
		for(var j = 0; j &lt; i; ++j) if(n == N[j]) throw new Error("Duplicate Sheet Name: " + n);&#13;
		if(codes) {&#13;
			var cn = (S &amp;&amp; S[i] &amp;&amp; S[i].CodeName) || n;&#13;
			if(cn.charCodeAt(0) == 95 &amp;&amp; cn.length &gt; 22) throw new Error("Bad Code Name: Worksheet" + cn);&#13;
		}&#13;
	});&#13;
}&#13;
function check_wb(wb) {&#13;
	if(!wb || !wb.SheetNames || !wb.Sheets) throw new Error("Invalid Workbook");&#13;
	if(!wb.SheetNames.length) throw new Error("Workbook is empty");&#13;
	var Sheets = (wb.Workbook &amp;&amp; wb.Workbook.Sheets) || [];&#13;
	check_wb_names(wb.SheetNames, Sheets, !!wb.vbaraw);&#13;
	for(var i = 0; i &lt; wb.SheetNames.length; ++i) check_ws(wb.Sheets[wb.SheetNames[i]], wb.SheetNames[i], i);&#13;
	wb.SheetNames.forEach(function(n, i) {&#13;
		var ws = wb.Sheets[n];&#13;
		if(!ws || !ws["!autofilter"]) return;&#13;
		var DN;&#13;
		if(!wb.Workbook) wb.Workbook = {};&#13;
		if(!wb.Workbook.Names) wb.Workbook.Names = [];&#13;
		wb.Workbook.Names.forEach(function(dn) { if(dn.Name == "_xlnm._FilterDatabase" &amp;&amp; dn.Sheet == i) DN = dn; });&#13;
		var nn = formula_quote_sheet_name(n) + "!" + fix_range(ws["!autofilter"].ref);&#13;
		if(DN) DN.Ref = nn;&#13;
		else wb.Workbook.Names.push({Name: "_xlnm._FilterDatabase", Sheet: i, Ref: nn});&#13;
	});&#13;
	/* TODO: validate workbook */&#13;
}&#13;
/* 18.2 Workbook */&#13;
var wbnsregex = /&lt;\w+:workbook/;&#13;
function parse_wb_xml(data, opts) {&#13;
	if(!data) throw new Error("Could not find file");&#13;
	var wb = { AppVersion:{}, WBProps:{}, WBView:[], Sheets:[], CalcPr:{}, Names:[], xmlns: "" };&#13;
	var pass = false, xmlns = "xmlns";&#13;
	var dname = {}, dnstart = 0;&#13;
	data.replace(tagregex, function xml_wb(x, idx) {&#13;
		var y = parsexmltag(x);&#13;
		switch(strip_ns(y[0])) {&#13;
			case '&lt;?xml': break;&#13;
&#13;
			/* 18.2.27 workbook CT_Workbook 1 */&#13;
			case '&lt;workbook':&#13;
				if(x.match(wbnsregex)) xmlns = "xmlns" + x.match(/&lt;(\w+):/)[1];&#13;
				wb.xmlns = y[xmlns];&#13;
				break;&#13;
			case '&lt;/workbook&gt;': break;&#13;
&#13;
			/* 18.2.13 fileVersion CT_FileVersion ? */&#13;
			case '&lt;fileVersion': delete y[0]; wb.AppVersion = y; break;&#13;
			case '&lt;fileVersion/&gt;': case '&lt;/fileVersion&gt;': break;&#13;
&#13;
			/* 18.2.12 fileSharing CT_FileSharing ? */&#13;
			case '&lt;fileSharing':&#13;
				break;&#13;
			case '&lt;fileSharing/&gt;': break;&#13;
&#13;
			/* 18.2.28 workbookPr CT_WorkbookPr ? */&#13;
			case '&lt;workbookPr':&#13;
			case '&lt;workbookPr/&gt;':&#13;
				WBPropsDef.forEach(function(w) {&#13;
					if(y[w[0]] == null) return;&#13;
					switch(w[2]) {&#13;
						case "bool": wb.WBProps[w[0]] = parsexmlbool(y[w[0]]); break;&#13;
						case "int": wb.WBProps[w[0]] = parseInt(y[w[0]], 10); break;&#13;
						default: wb.WBProps[w[0]] = y[w[0]];&#13;
					}&#13;
				});&#13;
				if(y.codeName) wb.WBProps.CodeName = utf8read(y.codeName);&#13;
				break;&#13;
			case '&lt;/workbookPr&gt;': break;&#13;
&#13;
			/* 18.2.29 workbookProtection CT_WorkbookProtection ? */&#13;
			case '&lt;workbookProtection':&#13;
				break;&#13;
			case '&lt;workbookProtection/&gt;': break;&#13;
&#13;
			/* 18.2.1  bookViews CT_BookViews ? */&#13;
			case '&lt;bookViews': case '&lt;bookViews&gt;': case '&lt;/bookViews&gt;': break;&#13;
			/* 18.2.30   workbookView CT_BookView + */&#13;
			case '&lt;workbookView': case '&lt;workbookView/&gt;': delete y[0]; wb.WBView.push(y); break;&#13;
			case '&lt;/workbookView&gt;': break;&#13;
&#13;
			/* 18.2.20 sheets CT_Sheets 1 */&#13;
			case '&lt;sheets': case '&lt;sheets&gt;': case '&lt;/sheets&gt;': break; // aggregate sheet&#13;
			/* 18.2.19   sheet CT_Sheet + */&#13;
			case '&lt;sheet':&#13;
				switch(y.state) {&#13;
					case "hidden": y.Hidden = 1; break;&#13;
					case "veryHidden": y.Hidden = 2; break;&#13;
					default: y.Hidden = 0;&#13;
				}&#13;
				delete y.state;&#13;
				y.name = unescapexml(utf8read(y.name));&#13;
				delete y[0]; wb.Sheets.push(y); break;&#13;
			case '&lt;/sheet&gt;': break;&#13;
&#13;
			/* 18.2.15 functionGroups CT_FunctionGroups ? */&#13;
			case '&lt;functionGroups': case '&lt;functionGroups/&gt;': break;&#13;
			/* 18.2.14   functionGroup CT_FunctionGroup + */&#13;
			case '&lt;functionGroup': break;&#13;
&#13;
			/* 18.2.9  externalReferences CT_ExternalReferences ? */&#13;
			case '&lt;externalReferences': case '&lt;/externalReferences&gt;': case '&lt;externalReferences&gt;': break;&#13;
			/* 18.2.8    externalReference CT_ExternalReference + */&#13;
			case '&lt;externalReference': break;&#13;
&#13;
			/* 18.2.6  definedNames CT_DefinedNames ? */&#13;
			case '&lt;definedNames/&gt;': break;&#13;
			case '&lt;definedNames&gt;': case '&lt;definedNames': pass=true; break;&#13;
			case '&lt;/definedNames&gt;': pass=false; break;&#13;
			/* 18.2.5    definedName CT_DefinedName + */&#13;
			case '&lt;definedName': {&#13;
				dname = {};&#13;
				dname.Name = utf8read(y.name);&#13;
				if(y.comment) dname.Comment = y.comment;&#13;
				if(y.localSheetId) dname.Sheet = +y.localSheetId;&#13;
				if(parsexmlbool(y.hidden||"0")) dname.Hidden = true;&#13;
				dnstart = idx + x.length;&#13;
			}	break;&#13;
			case '&lt;/definedName&gt;': {&#13;
				dname.Ref = unescapexml(utf8read(data.slice(dnstart, idx)));&#13;
				wb.Names.push(dname);&#13;
			} break;&#13;
			case '&lt;definedName/&gt;': break;&#13;
&#13;
			/* 18.2.2  calcPr CT_CalcPr ? */&#13;
			case '&lt;calcPr': delete y[0]; wb.CalcPr = y; break;&#13;
			case '&lt;calcPr/&gt;': delete y[0]; wb.CalcPr = y; break;&#13;
			case '&lt;/calcPr&gt;': break;&#13;
&#13;
			/* 18.2.16 oleSize CT_OleSize ? (ref required) */&#13;
			case '&lt;oleSize': break;&#13;
&#13;
			/* 18.2.4  customWorkbookViews CT_CustomWorkbookViews ? */&#13;
			case '&lt;customWorkbookViews&gt;': case '&lt;/customWorkbookViews&gt;': case '&lt;customWorkbookViews': break;&#13;
			/* 18.2.3  customWorkbookView CT_CustomWorkbookView + */&#13;
			case '&lt;customWorkbookView': case '&lt;/customWorkbookView&gt;': break;&#13;
&#13;
			/* 18.2.18 pivotCaches CT_PivotCaches ? */&#13;
			case '&lt;pivotCaches&gt;': case '&lt;/pivotCaches&gt;': case '&lt;pivotCaches': break;&#13;
			/* 18.2.17 pivotCache CT_PivotCache ? */&#13;
			case '&lt;pivotCache': break;&#13;
&#13;
			/* 18.2.21 smartTagPr CT_SmartTagPr ? */&#13;
			case '&lt;smartTagPr': case '&lt;smartTagPr/&gt;': break;&#13;
&#13;
			/* 18.2.23 smartTagTypes CT_SmartTagTypes ? */&#13;
			case '&lt;smartTagTypes': case '&lt;smartTagTypes&gt;': case '&lt;/smartTagTypes&gt;': break;&#13;
			/* 18.2.22 smartTagType CT_SmartTagType ? */&#13;
			case '&lt;smartTagType': break;&#13;
&#13;
			/* 18.2.24 webPublishing CT_WebPublishing ? */&#13;
			case '&lt;webPublishing': case '&lt;webPublishing/&gt;': break;&#13;
&#13;
			/* 18.2.11 fileRecoveryPr CT_FileRecoveryPr ? */&#13;
			case '&lt;fileRecoveryPr': case '&lt;fileRecoveryPr/&gt;': break;&#13;
&#13;
			/* 18.2.26 webPublishObjects CT_WebPublishObjects ? */&#13;
			case '&lt;webPublishObjects&gt;': case '&lt;webPublishObjects': case '&lt;/webPublishObjects&gt;': break;&#13;
			/* 18.2.25 webPublishObject CT_WebPublishObject ? */&#13;
			case '&lt;webPublishObject': break;&#13;
&#13;
			/* 18.2.10 extLst CT_ExtensionList ? */&#13;
			case '&lt;extLst': case '&lt;extLst&gt;': case '&lt;/extLst&gt;': case '&lt;extLst/&gt;': break;&#13;
			/* 18.2.7  ext CT_Extension + */&#13;
			case '&lt;ext': pass=true; break; //TODO: check with versions of excel&#13;
			case '&lt;/ext&gt;': pass=false; break;&#13;
&#13;
			/* Others */&#13;
			case '&lt;ArchID': break;&#13;
			case '&lt;AlternateContent':&#13;
			case '&lt;AlternateContent&gt;': pass=true; break;&#13;
			case '&lt;/AlternateContent&gt;': pass=false; break;&#13;
&#13;
			/* TODO */&#13;
			case '&lt;revisionPtr': break;&#13;
&#13;
			default: if(!pass &amp;&amp; opts.WTF) throw new Error('unrecognized ' + y[0] + ' in workbook');&#13;
		}&#13;
		return x;&#13;
	});&#13;
	if(XMLNS_main.indexOf(wb.xmlns) === -1) throw new Error("Unknown Namespace: " + wb.xmlns);&#13;
&#13;
	parse_wb_defaults(wb);&#13;
&#13;
	return wb;&#13;
}&#13;
&#13;
function write_wb_xml(wb) {&#13;
	var o = [XML_HEADER];&#13;
	o[o.length] = writextag('workbook', null, {&#13;
		'xmlns': XMLNS_main[0],&#13;
		//'xmlns:mx': XMLNS.mx,&#13;
		//'xmlns:s': XMLNS_main[0],&#13;
		'xmlns:r': XMLNS.r&#13;
	});&#13;
&#13;
	var write_names = (wb.Workbook &amp;&amp; (wb.Workbook.Names||[]).length &gt; 0);&#13;
&#13;
	/* fileVersion */&#13;
	/* fileSharing */&#13;
&#13;
	var workbookPr = ({codeName:"ThisWorkbook"});&#13;
	if(wb.Workbook &amp;&amp; wb.Workbook.WBProps) {&#13;
		WBPropsDef.forEach(function(x) {&#13;
if((wb.Workbook.WBProps[x[0]]) == null) return;&#13;
			if((wb.Workbook.WBProps[x[0]]) == x[1]) return;&#13;
			workbookPr[x[0]] = (wb.Workbook.WBProps[x[0]]);&#13;
		});&#13;
if(wb.Workbook.WBProps.CodeName) { workbookPr.codeName = wb.Workbook.WBProps.CodeName; delete workbookPr.CodeName; }&#13;
	}&#13;
	o[o.length] = (writextag('workbookPr', null, workbookPr));&#13;
&#13;
	/* workbookProtection */&#13;
&#13;
	var sheets = wb.Workbook &amp;&amp; wb.Workbook.Sheets || [];&#13;
	var i = 0;&#13;
&#13;
	/* bookViews only written if first worksheet is hidden */&#13;
	if(sheets &amp;&amp; sheets[0] &amp;&amp; !!sheets[0].Hidden) {&#13;
		o[o.length] = "&lt;bookViews&gt;";&#13;
		for(i = 0; i != wb.SheetNames.length; ++i) {&#13;
			if(!sheets[i]) break;&#13;
			if(!sheets[i].Hidden) break;&#13;
		}&#13;
		if(i == wb.SheetNames.length) i = 0;&#13;
		o[o.length] = '&lt;workbookView firstSheet="' + i + '" activeTab="' + i + '"/&gt;';&#13;
		o[o.length] = "&lt;/bookViews&gt;";&#13;
	}&#13;
&#13;
	o[o.length] = "&lt;sheets&gt;";&#13;
	for(i = 0; i != wb.SheetNames.length; ++i) {&#13;
		var sht = ({name:escapexml(wb.SheetNames[i].slice(0,31))});&#13;
		sht.sheetId = ""+(i+1);&#13;
		sht["r:id"] = "rId"+(i+1);&#13;
		if(sheets[i]) switch(sheets[i].Hidden) {&#13;
			case 1: sht.state = "hidden"; break;&#13;
			case 2: sht.state = "veryHidden"; break;&#13;
		}&#13;
		o[o.length] = (writextag('sheet',null,sht));&#13;
	}&#13;
	o[o.length] = "&lt;/sheets&gt;";&#13;
&#13;
	/* functionGroups */&#13;
	/* externalReferences */&#13;
&#13;
	if(write_names) {&#13;
		o[o.length] = "&lt;definedNames&gt;";&#13;
		if(wb.Workbook &amp;&amp; wb.Workbook.Names) wb.Workbook.Names.forEach(function(n) {&#13;
			var d = {name:n.Name};&#13;
			if(n.Comment) d.comment = n.Comment;&#13;
			if(n.Sheet != null) d.localSheetId = ""+n.Sheet;&#13;
			if(n.Hidden) d.hidden = "1";&#13;
			if(!n.Ref) return;&#13;
			o[o.length] = writextag('definedName', escapexml(n.Ref), d);&#13;
		});&#13;
		o[o.length] = "&lt;/definedNames&gt;";&#13;
	}&#13;
&#13;
	/* calcPr */&#13;
	/* oleSize */&#13;
	/* customWorkbookViews */&#13;
	/* pivotCaches */&#13;
	/* smartTagPr */&#13;
	/* smartTagTypes */&#13;
	/* webPublishing */&#13;
	/* fileRecoveryPr */&#13;
	/* webPublishObjects */&#13;
	/* extLst */&#13;
&#13;
	if(o.length&gt;2){ o[o.length] = '&lt;/workbook&gt;'; o[1]=o[1].replace("/&gt;","&gt;"); }&#13;
	return o.join("");&#13;
}&#13;
/* [MS-XLSB] 2.4.304 BrtBundleSh */&#13;
function parse_BrtBundleSh(data, length) {&#13;
	var z = {};&#13;
	z.Hidden = data.read_shift(4); //hsState ST_SheetState&#13;
	z.iTabID = data.read_shift(4);&#13;
	z.strRelID = parse_RelID(data,length-8);&#13;
	z.name = parse_XLWideString(data);&#13;
	return z;&#13;
}&#13;
function write_BrtBundleSh(data, o) {&#13;
	if(!o) o = new_buf(127);&#13;
	o.write_shift(4, data.Hidden);&#13;
	o.write_shift(4, data.iTabID);&#13;
	write_RelID(data.strRelID, o);&#13;
	write_XLWideString(data.name.slice(0,31), o);&#13;
	return o.length &gt; o.l ? o.slice(0, o.l) : o;&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.4.815 BrtWbProp */&#13;
function parse_BrtWbProp(data, length) {&#13;
	var o = ({});&#13;
	var flags = data.read_shift(4);&#13;
	o.defaultThemeVersion = data.read_shift(4);&#13;
	var strName = (length &gt; 8) ? parse_XLWideString(data) : "";&#13;
	if(strName.length &gt; 0) o.CodeName = strName;&#13;
	o.autoCompressPictures = !!(flags &amp; 0x10000);&#13;
	o.backupFile = !!(flags &amp; 0x40);&#13;
	o.checkCompatibility = !!(flags &amp; 0x1000);&#13;
	o.date1904 = !!(flags &amp; 0x01);&#13;
	o.filterPrivacy = !!(flags &amp; 0x08);&#13;
	o.hidePivotFieldList = !!(flags &amp; 0x400);&#13;
	o.promptedSolutions = !!(flags &amp; 0x10);&#13;
	o.publishItems = !!(flags &amp; 0x800);&#13;
	o.refreshAllConnections = !!(flags &amp; 0x40000);&#13;
	o.saveExternalLinkValues = !!(flags &amp; 0x80);&#13;
	o.showBorderUnselectedTables = !!(flags &amp; 0x04);&#13;
	o.showInkAnnotation = !!(flags &amp; 0x20);&#13;
	o.showObjects = ["all", "placeholders", "none"][(flags &gt;&gt; 13) &amp; 0x03];&#13;
	o.showPivotChartFilter = !!(flags &amp; 0x8000);&#13;
	o.updateLinks = ["userSet", "never", "always"][(flags &gt;&gt; 8) &amp; 0x03];&#13;
	return o;&#13;
}&#13;
function write_BrtWbProp(data, o) {&#13;
	if(!o) o = new_buf(72);&#13;
	var flags = 0;&#13;
	if(data) {&#13;
		/* TODO: mirror parse_BrtWbProp fields */&#13;
		if(data.date1904) flags |= 0x01;&#13;
		if(data.filterPrivacy) flags |= 0x08;&#13;
	}&#13;
	o.write_shift(4, flags);&#13;
	o.write_shift(4, 0);&#13;
	write_XLSBCodeName(data &amp;&amp; data.CodeName || "ThisWorkbook", o);&#13;
	return o.slice(0, o.l);&#13;
}&#13;
&#13;
function parse_BrtFRTArchID$(data, length) {&#13;
	var o = {};&#13;
	data.read_shift(4);&#13;
	o.ArchID = data.read_shift(4);&#13;
	data.l += length - 8;&#13;
	return o;&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.4.687 BrtName */&#13;
function parse_BrtName(data, length, opts) {&#13;
	var end = data.l + length;&#13;
	var flags = data.read_shift(4);&#13;
	data.l += 1; //var chKey = data.read_shift(1);&#13;
	var itab = data.read_shift(4);&#13;
	var name = parse_XLNameWideString(data);&#13;
	var formula = parse_XLSBNameParsedFormula(data, 0, opts);&#13;
	var comment = parse_XLNullableWideString(data);&#13;
	if(flags &amp; 0x20) name = "_xlnm." + name;&#13;
	//if(0 /* fProc */) {&#13;
		// unusedstring1: XLNullableWideString&#13;
		// description: XLNullableWideString&#13;
		// helpTopic: XLNullableWideString&#13;
		// unusedstring2: XLNullableWideString&#13;
	//}&#13;
	data.l = end;&#13;
	var out = ({Name:name, Ptg:formula, Flags: flags});&#13;
	if(itab &lt; 0xFFFFFFF) out.Sheet = itab;&#13;
	if(comment) out.Comment = comment;&#13;
	return out;&#13;
}&#13;
function write_BrtName(name, wb) {&#13;
	var o = new_buf(9);&#13;
	var flags = 0;&#13;
	var dname = name.Name;&#13;
	if(XLSLblBuiltIn.indexOf(dname) &gt; -1) { flags |= 0x20; dname = dname.slice(6); }&#13;
	o.write_shift(4, flags); // flags&#13;
	o.write_shift(1, 0); // chKey&#13;
	o.write_shift(4, name.Sheet == null ? 0xFFFFFFFF : name.Sheet);&#13;
&#13;
	var arr = [&#13;
		o,&#13;
		write_XLWideString(dname),&#13;
		write_XLSBNameParsedFormula(name.Ref, wb)&#13;
	];&#13;
	if(name.Comment) arr.push(write_XLNullableWideString(name.Comment));&#13;
	else {&#13;
		var x = new_buf(4);&#13;
		x.write_shift(4, 0xFFFFFFFF);&#13;
		arr.push(x);&#13;
	}&#13;
&#13;
	// if macro (flags &amp; 0x0F):&#13;
	// write_shift(4, 0xFFFFFFFF);&#13;
	// write_XLNullableWideString(description)&#13;
	// write_XLNullableWideString(helpTopic)&#13;
	// write_shift(4, 0xFFFFFFFF);&#13;
&#13;
	return bconcat(arr);&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.1.7.61 Workbook */&#13;
function parse_wb_bin(data, opts) {&#13;
	var wb = { AppVersion:{}, WBProps:{}, WBView:[], Sheets:[], CalcPr:{}, xmlns: "" };&#13;
	var state = [];&#13;
	var pass = false;&#13;
&#13;
	if(!opts) opts = {};&#13;
	opts.biff = 12;&#13;
&#13;
	var Names = [];&#13;
	var supbooks = ([[]]);&#13;
	supbooks.SheetNames = [];&#13;
	supbooks.XTI = [];&#13;
&#13;
	XLSBRecordEnum[0x0010] = { n:"BrtFRTArchID$", f:parse_BrtFRTArchID$ };&#13;
&#13;
	recordhopper(data, function hopper_wb(val, R, RT) {&#13;
		switch(RT) {&#13;
			case 0x009C: /* 'BrtBundleSh' */&#13;
				supbooks.SheetNames.push(val.name);&#13;
				wb.Sheets.push(val); break;&#13;
&#13;
			case 0x0099: /* 'BrtWbProp' */&#13;
				wb.WBProps = val; break;&#13;
&#13;
			case 0x0027: /* 'BrtName' */&#13;
				if(val.Sheet != null) opts.SID = val.Sheet;&#13;
				val.Ref = stringify_formula(val.Ptg, null, null, supbooks, opts);&#13;
				delete opts.SID;&#13;
				delete val.Ptg;&#13;
				Names.push(val);&#13;
				break;&#13;
			case 0x040C: /* 'BrtNameExt' */ break;&#13;
&#13;
			case 0x0165: /* 'BrtSupSelf' */&#13;
			case 0x0166: /* 'BrtSupSame' */&#13;
			case 0x0163: /* 'BrtSupBookSrc' */&#13;
			case 0x029B: /* 'BrtSupAddin' */&#13;
				if(!supbooks[0].length) supbooks[0] = [RT, val];&#13;
				else supbooks.push([RT, val]);&#13;
				supbooks[supbooks.length - 1].XTI = [];&#13;
				break;&#13;
			case 0x016A: /* 'BrtExternSheet' */&#13;
				if(supbooks.length === 0) { supbooks[0] = []; supbooks[0].XTI = []; }&#13;
				supbooks[supbooks.length - 1].XTI = supbooks[supbooks.length - 1].XTI.concat(val);&#13;
				supbooks.XTI = supbooks.XTI.concat(val);&#13;
				break;&#13;
			case 0x0169: /* 'BrtPlaceholderName' */&#13;
				break;&#13;
&#13;
			case 0x0817: /* 'BrtAbsPath15' */&#13;
			case 0x009E: /* 'BrtBookView' */&#13;
			case 0x008F: /* 'BrtBeginBundleShs' */&#13;
			case 0x0298: /* 'BrtBeginFnGroup' */&#13;
			case 0x0161: /* 'BrtBeginExternals' */&#13;
				break;&#13;
&#13;
			/* case 'BrtModelTimeGroupingCalcCol' */&#13;
			case 0x0C00: /* 'BrtUid' */&#13;
			case 0x0C01: /* 'BrtRevisionPtr' */&#13;
			case 0x0216: /* 'BrtBookProtection' */&#13;
			case 0x02A5: /* 'BrtBookProtectionIso' */&#13;
			case 0x009D: /* 'BrtCalcProp' */&#13;
			case 0x0262: /* 'BrtCrashRecErr' */&#13;
			case 0x0802: /* 'BrtDecoupledPivotCacheID' */&#13;
			case 0x009B: /* 'BrtFileRecover' */&#13;
			case 0x0224: /* 'BrtFileSharing' */&#13;
			case 0x02A4: /* 'BrtFileSharingIso' */&#13;
			case 0x0080: /* 'BrtFileVersion' */&#13;
			case 0x0299: /* 'BrtFnGroup' */&#13;
			case 0x0850: /* 'BrtModelRelationship' */&#13;
			case 0x084D: /* 'BrtModelTable' */&#13;
			case 0x0225: /* 'BrtOleSize' */&#13;
			case 0x0805: /* 'BrtPivotTableRef' */&#13;
			case 0x0254: /* 'BrtSmartTagType' */&#13;
			case 0x081C: /* 'BrtTableSlicerCacheID' */&#13;
			case 0x081B: /* 'BrtTableSlicerCacheIDs' */&#13;
			case 0x0822: /* 'BrtTimelineCachePivotCacheID' */&#13;
			case 0x018D: /* 'BrtUserBookView' */&#13;
			case 0x009A: /* 'BrtWbFactoid' */&#13;
			case 0x045D: /* 'BrtWbProp14' */&#13;
			case 0x0229: /* 'BrtWebOpt' */&#13;
			case 0x082B: /* 'BrtWorkBookPr15' */&#13;
				break;&#13;
&#13;
			case 0x0023: /* 'BrtFRTBegin' */&#13;
				state.push(RT); pass = true; break;&#13;
			case 0x0024: /* 'BrtFRTEnd' */&#13;
				state.pop(); pass = false; break;&#13;
			case 0x0025: /* 'BrtACBegin' */&#13;
				state.push(RT); pass = true; break;&#13;
			case 0x0026: /* 'BrtACEnd' */&#13;
				state.pop(); pass = false; break;&#13;
&#13;
			case 0x0010: /* 'BrtFRTArchID$' */ break;&#13;
&#13;
			default:&#13;
				if(R.T){/* empty */}&#13;
				else if(!pass || (opts.WTF &amp;&amp; state[state.length-1] != 0x0025 /* BrtACBegin */ &amp;&amp; state[state.length-1] != 0x0023 /* BrtFRTBegin */)) throw new Error("Unexpected record 0x" + RT.toString(16));&#13;
		}&#13;
	}, opts);&#13;
&#13;
	parse_wb_defaults(wb);&#13;
&#13;
	// $FlowIgnore&#13;
	wb.Names = Names;&#13;
&#13;
	(wb).supbooks = supbooks;&#13;
	return wb;&#13;
}&#13;
&#13;
function write_BUNDLESHS(ba, wb) {&#13;
	write_record(ba, 0x008F /* BrtBeginBundleShs */);&#13;
	for(var idx = 0; idx != wb.SheetNames.length; ++idx) {&#13;
		var viz = wb.Workbook &amp;&amp; wb.Workbook.Sheets &amp;&amp; wb.Workbook.Sheets[idx] &amp;&amp; wb.Workbook.Sheets[idx].Hidden || 0;&#13;
		var d = { Hidden: viz, iTabID: idx+1, strRelID: 'rId' + (idx+1), name: wb.SheetNames[idx] };&#13;
		write_record(ba, 0x009C /* BrtBundleSh */, write_BrtBundleSh(d));&#13;
	}&#13;
	write_record(ba, 0x0090 /* BrtEndBundleShs */);&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.4.649 BrtFileVersion */&#13;
function write_BrtFileVersion(data, o) {&#13;
	if(!o) o = new_buf(127);&#13;
	for(var i = 0; i != 4; ++i) o.write_shift(4, 0);&#13;
	write_XLWideString("xlsx", o);&#13;
	write_XLWideString(XLSX.version, o);&#13;
	write_XLWideString(XLSX.version, o);&#13;
	write_XLWideString("7262", o);&#13;
	return o.length &gt; o.l ? o.slice(0, o.l) : o;&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.4.301 BrtBookView */&#13;
function write_BrtBookView(idx, o) {&#13;
	if(!o) o = new_buf(29);&#13;
	o.write_shift(-4, 0);&#13;
	o.write_shift(-4, 460);&#13;
	o.write_shift(4,  28800);&#13;
	o.write_shift(4,  17600);&#13;
	o.write_shift(4,  500);&#13;
	o.write_shift(4,  idx);&#13;
	o.write_shift(4,  idx);&#13;
	var flags = 0x78;&#13;
	o.write_shift(1,  flags);&#13;
	return o.length &gt; o.l ? o.slice(0, o.l) : o;&#13;
}&#13;
&#13;
function write_BOOKVIEWS(ba, wb) {&#13;
	/* required if hidden tab appears before visible tab */&#13;
	if(!wb.Workbook || !wb.Workbook.Sheets) return;&#13;
	var sheets = wb.Workbook.Sheets;&#13;
	var i = 0, vistab = -1, hidden = -1;&#13;
	for(; i &lt; sheets.length; ++i) {&#13;
		if(!sheets[i] || !sheets[i].Hidden &amp;&amp; vistab == -1) vistab = i;&#13;
		else if(sheets[i].Hidden == 1 &amp;&amp; hidden == -1) hidden = i;&#13;
	}&#13;
	if(hidden &gt; vistab) return;&#13;
	write_record(ba, 0x0087 /* BrtBeginBookViews */);&#13;
	write_record(ba, 0x009E /* BrtBookView */, write_BrtBookView(vistab));&#13;
	/* 1*(BrtBookView *FRT) */&#13;
	write_record(ba, 0x0088 /* BrtEndBookViews */);&#13;
}&#13;
&#13;
function write_BRTNAMES(ba, wb) {&#13;
	if(!wb.Workbook || !wb.Workbook.Names) return;&#13;
	wb.Workbook.Names.forEach(function(name) { try {&#13;
		if(name.Flags &amp; 0x0e) return; // TODO: macro name write&#13;
		write_record(ba, 0x0027 /* BrtName */, write_BrtName(name, wb));&#13;
	} catch(e) {&#13;
		console.error("Could not serialize defined name " + JSON.stringify(name));&#13;
	} });&#13;
}&#13;
&#13;
function write_SELF_EXTERNS_xlsb(wb) {&#13;
	var L = wb.SheetNames.length;&#13;
	var o = new_buf(12 * L + 28);&#13;
	o.write_shift(4, L + 2);&#13;
	o.write_shift(4, 0); o.write_shift(4, -2); o.write_shift(4, -2); // workbook-level reference&#13;
	o.write_shift(4, 0); o.write_shift(4, -1); o.write_shift(4, -1); // #REF!...&#13;
	for(var i = 0; i &lt; L; ++i) {&#13;
		o.write_shift(4, 0); o.write_shift(4, i); o.write_shift(4, i);&#13;
	}&#13;
	return o;&#13;
}&#13;
function write_EXTERNALS_xlsb(ba, wb) {&#13;
	write_record(ba, 0x0161 /* BrtBeginExternals */);&#13;
	write_record(ba, 0x0165 /* BrtSupSelf */);&#13;
	write_record(ba, 0x016A /* BrtExternSheet */, write_SELF_EXTERNS_xlsb(wb, 0));&#13;
	write_record(ba, 0x0162 /* BrtEndExternals */);&#13;
}&#13;
&#13;
/* [MS-XLSB] 2.4.305 BrtCalcProp */&#13;
/*function write_BrtCalcProp(data, o) {&#13;
	if(!o) o = new_buf(26);&#13;
	o.write_shift(4,0); // force recalc&#13;
	o.write_shift(4,1);&#13;
	o.write_shift(4,0);&#13;
	write_Xnum(0, o);&#13;
	o.write_shift(-4, 1023);&#13;
	o.write_shift(1, 0x33);&#13;
	o.write_shift(1, 0x00);&#13;
	return o;&#13;
}*/&#13;
&#13;
/* [MS-XLSB] 2.4.646 BrtFileRecover */&#13;
/*function write_BrtFileRecover(data, o) {&#13;
	if(!o) o = new_buf(1);&#13;
	o.write_shift(1,0);&#13;
	return o;&#13;
}*/&#13;
&#13;
/* [MS-XLSB] 2.1.7.61 Workbook */&#13;
function write_wb_bin(wb, opts) {&#13;
	var ba = buf_array();&#13;
	write_record(ba, 0x0083 /* BrtBeginBook */);&#13;
	write_record(ba, 0x0080 /* BrtFileVersion */, write_BrtFileVersion());&#13;
	/* [[BrtFileSharingIso] BrtFileSharing] */&#13;
	write_record(ba, 0x0099 /* BrtWbProp */, write_BrtWbProp(wb.Workbook &amp;&amp; wb.Workbook.WBProps || null));&#13;
	/* [ACABSPATH] */&#13;
	/* [[BrtBookProtectionIso] BrtBookProtection] */&#13;
	write_BOOKVIEWS(ba, wb, opts);&#13;
	write_BUNDLESHS(ba, wb, opts);&#13;
	/* [FNGROUP] */&#13;
	write_EXTERNALS_xlsb(ba, wb);&#13;
	if((wb.Workbook||{}).Names) write_BRTNAMES(ba, wb);&#13;
	/* write_record(ba, 0x009D BrtCalcProp, write_BrtCalcProp()); */&#13;
	/* [BrtOleSize] */&#13;
	/* *(BrtUserBookView *FRT) */&#13;
	/* [PIVOTCACHEIDS] */&#13;
	/* [BrtWbFactoid] */&#13;
	/* [SMARTTAGTYPES] */&#13;
	/* [BrtWebOpt] */&#13;
	/* write_record(ba, 0x009B BrtFileRecover, write_BrtFileRecover()); */&#13;
	/* [WEBPUBITEMS] */&#13;
	/* [CRERRS] */&#13;
	/* FRTWORKBOOK */&#13;
	write_record(ba, 0x0084 /* BrtEndBook */);&#13;
&#13;
	return ba.end();&#13;
}&#13;
function parse_wb(data, name, opts) {&#13;
	if(name.slice(-4)===".bin") return parse_wb_bin((data), opts);&#13;
	return parse_wb_xml((data), opts);&#13;
}&#13;
&#13;
function parse_ws(data, name, idx, opts, rels, wb, themes, styles) {&#13;
	if(name.slice(-4)===".bin") return parse_ws_bin((data), opts, idx, rels, wb, themes, styles);&#13;
	return parse_ws_xml((data), opts, idx, rels, wb, themes, styles);&#13;
}&#13;
&#13;
function parse_cs(data, name, idx, opts, rels, wb, themes, styles) {&#13;
	if(name.slice(-4)===".bin") return parse_cs_bin((data), opts, idx, rels, wb, themes, styles);&#13;
	return parse_cs_xml((data), opts, idx, rels, wb, themes, styles);&#13;
}&#13;
&#13;
function parse_ms(data, name, idx, opts, rels, wb, themes, styles) {&#13;
	if(name.slice(-4)===".bin") return parse_ms_bin((data), opts, idx, rels, wb, themes, styles);&#13;
	return parse_ms_xml((data), opts, idx, rels, wb, themes, styles);&#13;
}&#13;
&#13;
function parse_ds(data, name, idx, opts, rels, wb, themes, styles) {&#13;
	if(name.slice(-4)===".bin") return parse_ds_bin((data), opts, idx, rels, wb, themes, styles);&#13;
	return parse_ds_xml((data), opts, idx, rels, wb, themes, styles);&#13;
}&#13;
&#13;
function parse_sty(data, name, themes, opts) {&#13;
	if(name.slice(-4)===".bin") return parse_sty_bin((data), themes, opts);&#13;
	return parse_sty_xml((data), themes, opts);&#13;
}&#13;
&#13;
function parse_sst(data, name, opts) {&#13;
	if(name.slice(-4)===".bin") return parse_sst_bin((data), opts);&#13;
	return parse_sst_xml((data), opts);&#13;
}&#13;
&#13;
function parse_cmnt(data, name, opts) {&#13;
	if(name.slice(-4)===".bin") return parse_comments_bin((data), opts);&#13;
	return parse_comments_xml((data), opts);&#13;
}&#13;
&#13;
function parse_cc(data, name, opts) {&#13;
	if(name.slice(-4)===".bin") return parse_cc_bin((data), name, opts);&#13;
	return parse_cc_xml((data), name, opts);&#13;
}&#13;
&#13;
function parse_xlink(data, rel, name, opts) {&#13;
	if(name.slice(-4)===".bin") return parse_xlink_bin((data), rel, name, opts);&#13;
	return parse_xlink_xml((data), rel, name, opts);&#13;
}&#13;
&#13;
function parse_xlmeta(data, name, opts) {&#13;
	if(name.slice(-4)===".bin") return parse_xlmeta_bin((data), name, opts);&#13;
	return parse_xlmeta_xml((data), name, opts);&#13;
}&#13;
var attregexg2=/([\w:]+)=((?:")([^"]*)(?:")|(?:')([^']*)(?:'))/g;&#13;
var attregex2=/([\w:]+)=((?:")(?:[^"]*)(?:")|(?:')(?:[^']*)(?:'))/;&#13;
function xlml_parsexmltag(tag, skip_root) {&#13;
	var words = tag.split(/\s+/);&#13;
	var z = ([]); if(!skip_root) z[0] = words[0];&#13;
	if(words.length === 1) return z;&#13;
	var m = tag.match(attregexg2), y, j, w, i;&#13;
	if(m) for(i = 0; i != m.length; ++i) {&#13;
		y = m[i].match(attregex2);&#13;
if((j=y[1].indexOf(":")) === -1) z[y[1]] = y[2].slice(1,y[2].length-1);&#13;
		else {&#13;
			if(y[1].slice(0,6) === "xmlns:") w = "xmlns"+y[1].slice(6);&#13;
			else w = y[1].slice(j+1);&#13;
			z[w] = y[2].slice(1,y[2].length-1);&#13;
		}&#13;
	}&#13;
	return z;&#13;
}&#13;
function xlml_parsexmltagobj(tag) {&#13;
	var words = tag.split(/\s+/);&#13;
	var z = {};&#13;
	if(words.length === 1) return z;&#13;
	var m = tag.match(attregexg2), y, j, w, i;&#13;
	if(m) for(i = 0; i != m.length; ++i) {&#13;
		y = m[i].match(attregex2);&#13;
if((j=y[1].indexOf(":")) === -1) z[y[1]] = y[2].slice(1,y[2].length-1);&#13;
		else {&#13;
			if(y[1].slice(0,6) === "xmlns:") w = "xmlns"+y[1].slice(6);&#13;
			else w = y[1].slice(j+1);&#13;
			z[w] = y[2].slice(1,y[2].length-1);&#13;
		}&#13;
	}&#13;
	return z;&#13;
}&#13;
&#13;
// ----&#13;
&#13;
/* map from xlml named formats to SSF TODO: localize */&#13;
var XLMLFormatMap;&#13;
&#13;
function xlml_format(format, value) {&#13;
	var fmt = XLMLFormatMap[format] || unescapexml(format);&#13;
	if(fmt === "General") return SSF_general(value);&#13;
	return SSF_format(fmt, value);&#13;
}&#13;
&#13;
function xlml_set_custprop(Custprops, key, cp, val) {&#13;
	var oval = val;&#13;
	switch((cp[0].match(/dt:dt="([\w.]+)"/)||["",""])[1]) {&#13;
		case "boolean": oval = parsexmlbool(val); break;&#13;
		case "i2": case "int": oval = parseInt(val, 10); break;&#13;
		case "r4": case "float": oval = parseFloat(val); break;&#13;
		case "date": case "dateTime.tz": oval = parseDate(val); break;&#13;
		case "i8": case "string": case "fixed": case "uuid": case "bin.base64": break;&#13;
		default: throw new Error("bad custprop:" + cp[0]);&#13;
	}&#13;
	Custprops[unescapexml(key)] = oval;&#13;
}&#13;
&#13;
function safe_format_xlml(cell, nf, o) {&#13;
	if(cell.t === 'z') return;&#13;
	if(!o || o.cellText !== false) try {&#13;
		if(cell.t === 'e') { cell.w = cell.w || BErr[cell.v]; }&#13;
		else if(nf === "General") {&#13;
			if(cell.t === 'n') {&#13;
				if((cell.v|0) === cell.v) cell.w = cell.v.toString(10);&#13;
				else cell.w = SSF_general_num(cell.v);&#13;
			}&#13;
			else cell.w = SSF_general(cell.v);&#13;
		}&#13;
		else cell.w = xlml_format(nf||"General", cell.v);&#13;
	} catch(e) { if(o.WTF) throw e; }&#13;
	try {&#13;
		var z = XLMLFormatMap[nf]||nf||"General";&#13;
		if(o.cellNF) cell.z = z;&#13;
		if(o.cellDates &amp;&amp; cell.t == 'n' &amp;&amp; fmt_is_date(z)) {&#13;
			var _d = SSF_parse_date_code(cell.v); if(_d) { cell.t = 'd'; cell.v = new Date(_d.y, _d.m-1,_d.d,_d.H,_d.M,_d.S,_d.u); }&#13;
		}&#13;
	} catch(e) { if(o.WTF) throw e; }&#13;
}&#13;
&#13;
function process_style_xlml(styles, stag, opts) {&#13;
	if(opts.cellStyles) {&#13;
		if(stag.Interior) {&#13;
			var I = stag.Interior;&#13;
			if(I.Pattern) I.patternType = XLMLPatternTypeMap[I.Pattern] || I.Pattern;&#13;
		}&#13;
	}&#13;
	styles[stag.ID] = stag;&#13;
}&#13;
&#13;
/* TODO: there must exist some form of OSP-blessed spec */&#13;
function parse_xlml_data(xml, ss, data, cell, base, styles, csty, row, arrayf, o) {&#13;
	var nf = "General", sid = cell.StyleID, S = {}; o = o || {};&#13;
	var interiors = [];&#13;
	var i = 0;&#13;
	if(sid === undefined &amp;&amp; row) sid = row.StyleID;&#13;
	if(sid === undefined &amp;&amp; csty) sid = csty.StyleID;&#13;
	while(styles[sid] !== undefined) {&#13;
		if(styles[sid].nf) nf = styles[sid].nf;&#13;
		if(styles[sid].Interior) interiors.push(styles[sid].Interior);&#13;
		if(!styles[sid].Parent) break;&#13;
		sid = styles[sid].Parent;&#13;
	}&#13;
	switch(data.Type) {&#13;
		case 'Boolean':&#13;
			cell.t = 'b';&#13;
			cell.v = parsexmlbool(xml);&#13;
			break;&#13;
		case 'String':&#13;
			cell.t = 's'; cell.r = xlml_fixstr(unescapexml(xml));&#13;
			cell.v = (xml.indexOf("&lt;") &gt; -1 ? unescapexml(ss||xml).replace(/&lt;.*?&gt;/g, "") : cell.r); // todo: BR etc&#13;
			break;&#13;
		case 'DateTime':&#13;
			if(xml.slice(-1) != "Z") xml += "Z";&#13;
			cell.v = (parseDate(xml) - new Date(Date.UTC(1899, 11, 30))) / (24 * 60 * 60 * 1000);&#13;
			if(cell.v !== cell.v) cell.v = unescapexml(xml);&#13;
			else if(cell.v&lt;60) cell.v = cell.v -1;&#13;
			if(!nf || nf == "General") nf = "yyyy-mm-dd";&#13;
			/* falls through */&#13;
		case 'Number':&#13;
			if(cell.v === undefined) cell.v=+xml;&#13;
			if(!cell.t) cell.t = 'n';&#13;
			break;&#13;
		case 'Error': cell.t = 'e'; cell.v = RBErr[xml]; if(o.cellText !== false) cell.w = xml; break;&#13;
		default:&#13;
			if(xml == "" &amp;&amp; ss == "") { cell.t = 'z'; }&#13;
			else { cell.t = 's'; cell.v = xlml_fixstr(ss||xml); }&#13;
			break;&#13;
	}&#13;
	safe_format_xlml(cell, nf, o);&#13;
	if(o.cellFormula !== false) {&#13;
		if(cell.Formula) {&#13;
			var fstr = unescapexml(cell.Formula);&#13;
			/* strictly speaking, the leading = is required but some writers omit */&#13;
			if(fstr.charCodeAt(0) == 61 /* = */) fstr = fstr.slice(1);&#13;
			cell.f = rc_to_a1(fstr, base);&#13;
			delete cell.Formula;&#13;
			if(cell.ArrayRange == "RC") cell.F = rc_to_a1("RC:RC", base);&#13;
			else if(cell.ArrayRange) {&#13;
				cell.F = rc_to_a1(cell.ArrayRange, base);&#13;
				arrayf.push([safe_decode_range(cell.F), cell.F]);&#13;
			}&#13;
		} else {&#13;
			for(i = 0; i &lt; arrayf.length; ++i)&#13;
				if(base.r &gt;= arrayf[i][0].s.r &amp;&amp; base.r &lt;= arrayf[i][0].e.r)&#13;
					if(base.c &gt;= arrayf[i][0].s.c &amp;&amp; base.c &lt;= arrayf[i][0].e.c)&#13;
						cell.F = arrayf[i][1];&#13;
		}&#13;
	}&#13;
	if(o.cellStyles) {&#13;
		interiors.forEach(function(x) {&#13;
			if(!S.patternType &amp;&amp; x.patternType) S.patternType = x.patternType;&#13;
		});&#13;
		cell.s = S;&#13;
	}&#13;
	if(cell.StyleID !== undefined) cell.ixfe = cell.StyleID;&#13;
}&#13;
&#13;
function xlml_prefix_dname(dname) {&#13;
	return XLSLblBuiltIn.indexOf("_xlnm." + dname) &gt; -1 ? "_xlnm." + dname : dname;&#13;
}&#13;
&#13;
function xlml_clean_comment(comment) {&#13;
	comment.t = comment.v || "";&#13;
	comment.t = comment.t.replace(/\r\n/g,"\n").replace(/\r/g,"\n");&#13;
	comment.v = comment.w = comment.ixfe = undefined;&#13;
}&#13;
&#13;
/* TODO: Everything */&#13;
function parse_xlml_xml(d, _opts) {&#13;
	var opts = _opts || {};&#13;
	make_ssf();&#13;
	var str = debom(xlml_normalize(d));&#13;
	if(opts.type == 'binary' || opts.type == 'array' || opts.type == 'base64') {&#13;
		if(typeof $cptable !== 'undefined') str = $cptable.utils.decode(65001, char_codes(str));&#13;
		else str = utf8read(str);&#13;
	}&#13;
	var opening = str.slice(0, 1024).toLowerCase(), ishtml = false;&#13;
	opening = opening.replace(/".*?"/g, "");&#13;
	if((opening.indexOf("&gt;") &amp; 1023) &gt; Math.min((opening.indexOf(",") &amp; 1023), (opening.indexOf(";")&amp;1023))) { var _o = dup(opts); _o.type = "string"; return PRN.to_workbook(str, _o); }&#13;
	if(opening.indexOf("&lt;?xml") == -1) ["html", "table", "head", "meta", "script", "style", "div"].forEach(function(tag) { if(opening.indexOf("&lt;" + tag) &gt;= 0) ishtml = true; });&#13;
	if(ishtml) return html_to_workbook(str, opts);&#13;
&#13;
	XLMLFormatMap = ({&#13;
		"General Number": "General",&#13;
		"General Date": table_fmt[22],&#13;
		"Long Date": "dddd, mmmm dd, yyyy",&#13;
		"Medium Date": table_fmt[15],&#13;
		"Short Date": table_fmt[14],&#13;
		"Long Time": table_fmt[19],&#13;
		"Medium Time": table_fmt[18],&#13;
		"Short Time": table_fmt[20],&#13;
		"Currency": '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',&#13;
		"Fixed": table_fmt[2],&#13;
		"Standard": table_fmt[4],&#13;
		"Percent": table_fmt[10],&#13;
		"Scientific": table_fmt[11],&#13;
		"Yes/No": '"Yes";"Yes";"No";@',&#13;
		"True/False": '"True";"True";"False";@',&#13;
		"On/Off": '"Yes";"Yes";"No";@'&#13;
	});&#13;
&#13;
&#13;
	var Rn;&#13;
	var state = [], tmp;&#13;
	if(DENSE != null &amp;&amp; opts.dense == null) opts.dense = DENSE;&#13;
	var sheets = {}, sheetnames = [], cursheet = (opts.dense ? [] : {}), sheetname = "";&#13;
	var cell = ({}), row = {};// eslint-disable-line no-unused-vars&#13;
	var dtag = xlml_parsexmltag('&lt;Data ss:Type="String"&gt;'), didx = 0;&#13;
	var c = 0, r = 0;&#13;
	var refguess = {s: {r:2000000, c:2000000}, e: {r:0, c:0} };&#13;
	var styles = {}, stag = {};&#13;
	var ss = "", fidx = 0;&#13;
	var merges = [];&#13;
	var Props = {}, Custprops = {}, pidx = 0, cp = [];&#13;
	var comments = [], comment = ({});&#13;
	var cstys = [], csty, seencol = false;&#13;
	var arrayf = [];&#13;
	var rowinfo = [], rowobj = {}, cc = 0, rr = 0;&#13;
	var Workbook = ({ Sheets:[], WBProps:{date1904:false} }), wsprops = {};&#13;
	xlmlregex.lastIndex = 0;&#13;
	str = str.replace(/&lt;!--([\s\S]*?)--&gt;/mg,"");&#13;
	var raw_Rn3 = "";&#13;
	while((Rn = xlmlregex.exec(str))) switch((Rn[3] = (raw_Rn3 = Rn[3]).toLowerCase())) {&#13;
		case 'data' /*case 'Data'*/:&#13;
			if(raw_Rn3 == "data") {&#13;
				if(Rn[1]==='/'){if((tmp=state.pop())[0]!==Rn[3]) throw new Error("Bad state: "+tmp.join("|"));}&#13;
				else if(Rn[0].charAt(Rn[0].length-2) !== '/') state.push([Rn[3], true]);&#13;
				break;&#13;
			}&#13;
			if(state[state.length-1][1]) break;&#13;
			if(Rn[1]==='/') parse_xlml_data(str.slice(didx, Rn.index), ss, dtag, state[state.length-1][0]==/*"Comment"*/"comment"?comment:cell, {c:c,r:r}, styles, cstys[c], row, arrayf, opts);&#13;
			else { ss = ""; dtag = xlml_parsexmltag(Rn[0]); didx = Rn.index + Rn[0].length; }&#13;
			break;&#13;
		case 'cell' /*case 'Cell'*/:&#13;
			if(Rn[1]==='/'){&#13;
				if(comments.length &gt; 0) cell.c = comments;&#13;
				if((!opts.sheetRows || opts.sheetRows &gt; r) &amp;&amp; cell.v !== void 0) {&#13;
					if(opts.dense) {&#13;
						if(!cursheet[r]) cursheet[r] = [];&#13;
						cursheet[r][c] = cell;&#13;
					} else cursheet[encode_col(c) + encode_row(r)] = cell;&#13;
				}&#13;
				if(cell.HRef) {&#13;
					cell.l = ({Target:unescapexml(cell.HRef)});&#13;
					if(cell.HRefScreenTip) cell.l.Tooltip = cell.HRefScreenTip;&#13;
					delete cell.HRef; delete cell.HRefScreenTip;&#13;
				}&#13;
				if(cell.MergeAcross || cell.MergeDown) {&#13;
					cc = c + (parseInt(cell.MergeAcross,10)|0);&#13;
					rr = r + (parseInt(cell.MergeDown,10)|0);&#13;
					if(cc &gt; c || rr &gt; r) merges.push({s:{c:c,r:r},e:{c:cc,r:rr}});&#13;
				}&#13;
				if(!opts.sheetStubs) { if(cell.MergeAcross) c = cc + 1; else ++c; }&#13;
				else if(cell.MergeAcross || cell.MergeDown) {&#13;
for(var cma = c; cma &lt;= cc; ++cma) {&#13;
						for(var cmd = r; cmd &lt;= rr; ++cmd) {&#13;
							if(cma &gt; c || cmd &gt; r) {&#13;
								if(opts.dense) {&#13;
									if(!cursheet[cmd]) cursheet[cmd] = [];&#13;
									cursheet[cmd][cma] = {t:'z'};&#13;
								} else cursheet[encode_col(cma) + encode_row(cmd)] = {t:'z'};&#13;
							}&#13;
						}&#13;
					}&#13;
					c = cc + 1;&#13;
				}&#13;
				else ++c;&#13;
			} else {&#13;
				cell = xlml_parsexmltagobj(Rn[0]);&#13;
				if(cell.Index) c = +cell.Index - 1;&#13;
				if(c &lt; refguess.s.c) refguess.s.c = c;&#13;
				if(c &gt; refguess.e.c) refguess.e.c = c;&#13;
				if(Rn[0].slice(-2) === "/&gt;") ++c;&#13;
				comments = [];&#13;
			}&#13;
			break;&#13;
		case 'row' /*case 'Row'*/:&#13;
			if(Rn[1]==='/' || Rn[0].slice(-2) === "/&gt;") {&#13;
				if(r &lt; refguess.s.r) refguess.s.r = r;&#13;
				if(r &gt; refguess.e.r) refguess.e.r = r;&#13;
				if(Rn[0].slice(-2) === "/&gt;") {&#13;
					row = xlml_parsexmltag(Rn[0]);&#13;
					if(row.Index) r = +row.Index - 1;&#13;
				}&#13;
				c = 0; ++r;&#13;
			} else {&#13;
				row = xlml_parsexmltag(Rn[0]);&#13;
				if(row.Index) r = +row.Index - 1;&#13;
				rowobj = {};&#13;
				if(row.AutoFitHeight == "0" || row.Height) {&#13;
					rowobj.hpx = parseInt(row.Height, 10); rowobj.hpt = px2pt(rowobj.hpx);&#13;
					rowinfo[r] = rowobj;&#13;
				}&#13;
				if(row.Hidden == "1") { rowobj.hidden = true; rowinfo[r] = rowobj; }&#13;
			}&#13;
			break;&#13;
		case 'worksheet' /*case 'Worksheet'*/: /* TODO: read range from FullRows/FullColumns */&#13;
			if(Rn[1]==='/'){&#13;
				if((tmp=state.pop())[0]!==Rn[3]) throw new Error("Bad state: "+tmp.join("|"));&#13;
				sheetnames.push(sheetname);&#13;
				if(refguess.s.r &lt;= refguess.e.r &amp;&amp; refguess.s.c &lt;= refguess.e.c) {&#13;
					cursheet["!ref"] = encode_range(refguess);&#13;
					if(opts.sheetRows &amp;&amp; opts.sheetRows &lt;= refguess.e.r) {&#13;
						cursheet["!fullref"] = cursheet["!ref"];&#13;
						refguess.e.r = opts.sheetRows - 1;&#13;
						cursheet["!ref"] = encode_range(refguess);&#13;
					}&#13;
				}&#13;
				if(merges.length) cursheet["!merges"] = merges;&#13;
				if(cstys.length &gt; 0) cursheet["!cols"] = cstys;&#13;
				if(rowinfo.length &gt; 0) cursheet["!rows"] = rowinfo;&#13;
				sheets[sheetname] = cursheet;&#13;
			} else {&#13;
				refguess = {s: {r:2000000, c:2000000}, e: {r:0, c:0} };&#13;
				r = c = 0;&#13;
				state.push([Rn[3], false]);&#13;
				tmp = xlml_parsexmltag(Rn[0]);&#13;
				sheetname = unescapexml(tmp.Name);&#13;
				cursheet = (opts.dense ? [] : {});&#13;
				merges = [];&#13;
				arrayf = [];&#13;
				rowinfo = [];&#13;
				wsprops = {name:sheetname, Hidden:0};&#13;
				Workbook.Sheets.push(wsprops);&#13;
			}&#13;
			break;&#13;
		case 'table' /*case 'Table'*/:&#13;
			if(Rn[1]==='/'){if((tmp=state.pop())[0]!==Rn[3]) throw new Error("Bad state: "+tmp.join("|"));}&#13;
			else if(Rn[0].slice(-2) == "/&gt;") break;&#13;
			else {&#13;
				state.push([Rn[3], false]);&#13;
				cstys = []; seencol = false;&#13;
			}&#13;
			break;&#13;
&#13;
		case 'style' /*case 'Style'*/:&#13;
			if(Rn[1]==='/') process_style_xlml(styles, stag, opts);&#13;
			else stag = xlml_parsexmltag(Rn[0]);&#13;
			break;&#13;
&#13;
		case 'numberformat' /*case 'NumberFormat'*/:&#13;
			stag.nf = unescapexml(xlml_parsexmltag(Rn[0]).Format || "General");&#13;
			if(XLMLFormatMap[stag.nf]) stag.nf = XLMLFormatMap[stag.nf];&#13;
			for(var ssfidx = 0; ssfidx != 0x188; ++ssfidx) if(table_fmt[ssfidx] == stag.nf) break;&#13;
			if(ssfidx == 0x188) for(ssfidx = 0x39; ssfidx != 0x188; ++ssfidx) if(table_fmt[ssfidx] == null) { SSF__load(stag.nf, ssfidx); break; }&#13;
			break;&#13;
&#13;
		case 'column' /*case 'Column'*/:&#13;
			if(state[state.length-1][0] !== /*'Table'*/'table') break;&#13;
			if(Rn[1]==='/') break;&#13;
			csty = xlml_parsexmltag(Rn[0]);&#13;
			if(csty.Hidden) { csty.hidden = true; delete csty.Hidden; }&#13;
			if(csty.Width) csty.wpx = parseInt(csty.Width, 10);&#13;
			if(!seencol &amp;&amp; csty.wpx &gt; 10) {&#13;
				seencol = true; MDW = DEF_MDW; //find_mdw_wpx(csty.wpx);&#13;
				for(var _col = 0; _col &lt; cstys.length; ++_col) if(cstys[_col]) process_col(cstys[_col]);&#13;
			}&#13;
			if(seencol) process_col(csty);&#13;
			cstys[(csty.Index-1||cstys.length)] = csty;&#13;
			for(var i = 0; i &lt; +csty.Span; ++i) cstys[cstys.length] = dup(csty);&#13;
			break;&#13;
&#13;
		case 'namedrange' /*case 'NamedRange'*/:&#13;
			if(Rn[1]==='/') break;&#13;
			if(!Workbook.Names) Workbook.Names = [];&#13;
			var _NamedRange = parsexmltag(Rn[0]);&#13;
			var _DefinedName = ({&#13;
				Name: xlml_prefix_dname(_NamedRange.Name),&#13;
				Ref: rc_to_a1(_NamedRange.RefersTo.slice(1), {r:0, c:0})&#13;
			});&#13;
			if(Workbook.Sheets.length&gt;0) _DefinedName.Sheet=Workbook.Sheets.length-1;&#13;
Workbook.Names.push(_DefinedName);&#13;
			break;&#13;
&#13;
		case 'namedcell' /*case 'NamedCell'*/: break;&#13;
		case 'b' /*case 'B'*/: break;&#13;
		case 'i' /*case 'I'*/: break;&#13;
		case 'u' /*case 'U'*/: break;&#13;
		case 's' /*case 'S'*/: break;&#13;
		case 'em' /*case 'EM'*/: break;&#13;
		case 'h2' /*case 'H2'*/: break;&#13;
		case 'h3' /*case 'H3'*/: break;&#13;
		case 'sub' /*case 'Sub'*/: break;&#13;
		case 'sup' /*case 'Sup'*/: break;&#13;
		case 'span' /*case 'Span'*/: break;&#13;
		case 'alignment' /*case 'Alignment'*/:&#13;
			break;&#13;
		case 'borders' /*case 'Borders'*/: break;&#13;
		case 'border' /*case 'Border'*/: break;&#13;
		case 'font' /*case 'Font'*/:&#13;
			if(Rn[0].slice(-2) === "/&gt;") break;&#13;
			else if(Rn[1]==="/") ss += str.slice(fidx, Rn.index);&#13;
			else fidx = Rn.index + Rn[0].length;&#13;
			break;&#13;
		case 'interior' /*case 'Interior'*/:&#13;
			if(!opts.cellStyles) break;&#13;
			stag.Interior = xlml_parsexmltag(Rn[0]);&#13;
			break;&#13;
		case 'protection' /*case 'Protection'*/: break;&#13;
&#13;
		case 'author' /*case 'Author'*/:&#13;
		case 'title' /*case 'Title'*/:&#13;
		case 'description' /*case 'Description'*/:&#13;
		case 'created' /*case 'Created'*/:&#13;
		case 'keywords' /*case 'Keywords'*/:&#13;
		case 'subject' /*case 'Subject'*/:&#13;
		case 'category' /*case 'Category'*/:&#13;
		case 'company' /*case 'Company'*/:&#13;
		case 'lastauthor' /*case 'LastAuthor'*/:&#13;
		case 'lastsaved' /*case 'LastSaved'*/:&#13;
		case 'lastprinted' /*case 'LastPrinted'*/:&#13;
		case 'version' /*case 'Version'*/:&#13;
		case 'revision' /*case 'Revision'*/:&#13;
		case 'totaltime' /*case 'TotalTime'*/:&#13;
		case 'hyperlinkbase' /*case 'HyperlinkBase'*/:&#13;
		case 'manager' /*case 'Manager'*/:&#13;
		case 'contentstatus' /*case 'ContentStatus'*/:&#13;
		case 'identifier' /*case 'Identifier'*/:&#13;
		case 'language' /*case 'Language'*/:&#13;
		case 'appname' /*case 'AppName'*/:&#13;
			if(Rn[0].slice(-2) === "/&gt;") break;&#13;
			else if(Rn[1]==="/") xlml_set_prop(Props, raw_Rn3, str.slice(pidx, Rn.index));&#13;
			else pidx = Rn.index + Rn[0].length;&#13;
			break;&#13;
		case 'paragraphs' /*case 'Paragraphs'*/: break;&#13;
&#13;
		case 'styles' /*case 'Styles'*/:&#13;
		case 'workbook' /*case 'Workbook'*/:&#13;
			if(Rn[1]==='/'){if((tmp=state.pop())[0]!==Rn[3]) throw new Error("Bad state: "+tmp.join("|"));}&#13;
			else state.push([Rn[3], false]);&#13;
			break;&#13;
&#13;
		case 'comment' /*case 'Comment'*/:&#13;
			if(Rn[1]==='/'){&#13;
				if((tmp=state.pop())[0]!==Rn[3]) throw new Error("Bad state: "+tmp.join("|"));&#13;
				xlml_clean_comment(comment);&#13;
				comments.push(comment);&#13;
			} else {&#13;
				state.push([Rn[3], false]);&#13;
				tmp = xlml_parsexmltag(Rn[0]);&#13;
				comment = ({a:tmp.Author});&#13;
			}&#13;
			break;&#13;
&#13;
		case 'autofilter' /*case 'AutoFilter'*/:&#13;
			if(Rn[1]==='/'){if((tmp=state.pop())[0]!==Rn[3]) throw new Error("Bad state: "+tmp.join("|"));}&#13;
			else if(Rn[0].charAt(Rn[0].length-2) !== '/') {&#13;
				var AutoFilter = xlml_parsexmltag(Rn[0]);&#13;
				cursheet['!autofilter'] = { ref:rc_to_a1(AutoFilter.Range).replace(/\$/g,"") };&#13;
				state.push([Rn[3], true]);&#13;
			}&#13;
			break;&#13;
&#13;
		case 'name' /*case 'Name'*/: break;&#13;
&#13;
		case 'datavalidation' /*case 'DataValidation'*/:&#13;
			if(Rn[1]==='/'){&#13;
				if((tmp=state.pop())[0]!==Rn[3]) throw new Error("Bad state: "+tmp.join("|"));&#13;
			} else {&#13;
				if(Rn[0].charAt(Rn[0].length-2) !== '/') state.push([Rn[3], true]);&#13;
			}&#13;
			break;&#13;
&#13;
		case 'pixelsperinch' /*case 'PixelsPerInch'*/:&#13;
			break;&#13;
		case 'componentoptions' /*case 'ComponentOptions'*/:&#13;
		case 'documentproperties' /*case 'DocumentProperties'*/:&#13;
		case 'customdocumentproperties' /*case 'CustomDocumentProperties'*/:&#13;
		case 'officedocumentsettings' /*case 'OfficeDocumentSettings'*/:&#13;
		case 'pivottable' /*case 'PivotTable'*/:&#13;
		case 'pivotcache' /*case 'PivotCache'*/:&#13;
		case 'names' /*case 'Names'*/:&#13;
		case 'mapinfo' /*case 'MapInfo'*/:&#13;
		case 'pagebreaks' /*case 'PageBreaks'*/:&#13;
		case 'querytable' /*case 'QueryTable'*/:&#13;
		case 'sorting' /*case 'Sorting'*/:&#13;
		case 'schema' /*case 'Schema'*/: //case 'data' /*case 'data'*/:&#13;
		case 'conditionalformatting' /*case 'ConditionalFormatting'*/:&#13;
		case 'smarttagtype' /*case 'SmartTagType'*/:&#13;
		case 'smarttags' /*case 'SmartTags'*/:&#13;
		case 'excelworkbook' /*case 'ExcelWorkbook'*/:&#13;
		case 'workbookoptions' /*case 'WorkbookOptions'*/:&#13;
		case 'worksheetoptions' /*case 'WorksheetOptions'*/:&#13;
			if(Rn[1]==='/'){if((tmp=state.pop())[0]!==Rn[3]) throw new Error("Bad state: "+tmp.join("|"));}&#13;
			else if(Rn[0].charAt(Rn[0].length-2) !== '/') state.push([Rn[3], true]);&#13;
			break;&#13;
&#13;
		case 'null' /*case 'Null'*/: break;&#13;
&#13;
		default:&#13;
			/* FODS file root is &lt;office:document&gt; */&#13;
			if(state.length == 0 &amp;&amp; Rn[3] == "document") return parse_fods(str, opts);&#13;
			/* UOS file root is &lt;uof:UOF&gt; */&#13;
			if(state.length == 0 &amp;&amp; Rn[3] == "uof"/*"UOF"*/) return parse_fods(str, opts);&#13;
&#13;
			var seen = true;&#13;
			switch(state[state.length-1][0]) {&#13;
				/* OfficeDocumentSettings */&#13;
				case 'officedocumentsettings' /*case 'OfficeDocumentSettings'*/: switch(Rn[3]) {&#13;
					case 'allowpng' /*case 'AllowPNG'*/: break;&#13;
					case 'removepersonalinformation' /*case 'RemovePersonalInformation'*/: break;&#13;
					case 'downloadcomponents' /*case 'DownloadComponents'*/: break;&#13;
					case 'locationofcomponents' /*case 'LocationOfComponents'*/: break;&#13;
					case 'colors' /*case 'Colors'*/: break;&#13;
					case 'color' /*case 'Color'*/: break;&#13;
					case 'index' /*case 'Index'*/: break;&#13;
					case 'rgb' /*case 'RGB'*/: break;&#13;
					case 'targetscreensize' /*case 'TargetScreenSize'*/: break;&#13;
					case 'readonlyrecommended' /*case 'ReadOnlyRecommended'*/: break;&#13;
					default: seen = false;&#13;
				} break;&#13;
&#13;
				/* ComponentOptions */&#13;
				case 'componentoptions' /*case 'ComponentOptions'*/: switch(Rn[3]) {&#13;
					case 'toolbar' /*case 'Toolbar'*/: break;&#13;
					case 'hideofficelogo' /*case 'HideOfficeLogo'*/: break;&#13;
					case 'spreadsheetautofit' /*case 'SpreadsheetAutoFit'*/: break;&#13;
					case 'label' /*case 'Label'*/: break;&#13;
					case 'caption' /*case 'Caption'*/: break;&#13;
					case 'maxheight' /*case 'MaxHeight'*/: break;&#13;
					case 'maxwidth' /*case 'MaxWidth'*/: break;&#13;
					case 'nextsheetnumber' /*case 'NextSheetNumber'*/: break;&#13;
					default: seen = false;&#13;
				} break;&#13;
&#13;
				/* ExcelWorkbook */&#13;
				case 'excelworkbook' /*case 'ExcelWorkbook'*/: switch(Rn[3]) {&#13;
					case 'date1904' /*case 'Date1904'*/:&#13;
Workbook.WBProps.date1904 = true;&#13;
						break;&#13;
					case 'windowheight' /*case 'WindowHeight'*/: break;&#13;
					case 'windowwidth' /*case 'WindowWidth'*/: break;&#13;
					case 'windowtopx' /*case 'WindowTopX'*/: break;&#13;
					case 'windowtopy' /*case 'WindowTopY'*/: break;&#13;
					case 'tabratio' /*case 'TabRatio'*/: break;&#13;
					case 'protectstructure' /*case 'ProtectStructure'*/: break;&#13;
					case 'protectwindow' /*case 'ProtectWindow'*/: break;&#13;
					case 'protectwindows' /*case 'ProtectWindows'*/: break;&#13;
					case 'activesheet' /*case 'ActiveSheet'*/: break;&#13;
					case 'displayinknotes' /*case 'DisplayInkNotes'*/: break;&#13;
					case 'firstvisiblesheet' /*case 'FirstVisibleSheet'*/: break;&#13;
					case 'supbook' /*case 'SupBook'*/: break;&#13;
					case 'sheetname' /*case 'SheetName'*/: break;&#13;
					case 'sheetindex' /*case 'SheetIndex'*/: break;&#13;
					case 'sheetindexfirst' /*case 'SheetIndexFirst'*/: break;&#13;
					case 'sheetindexlast' /*case 'SheetIndexLast'*/: break;&#13;
					case 'dll' /*case 'Dll'*/: break;&#13;
					case 'acceptlabelsinformulas' /*case 'AcceptLabelsInFormulas'*/: break;&#13;
					case 'donotsavelinkvalues' /*case 'DoNotSaveLinkValues'*/: break;&#13;
					case 'iteration' /*case 'Iteration'*/: break;&#13;
					case 'maxiterations' /*case 'MaxIterations'*/: break;&#13;
					case 'maxchange' /*case 'MaxChange'*/: break;&#13;
					case 'path' /*case 'Path'*/: break;&#13;
					case 'xct' /*case 'Xct'*/: break;&#13;
					case 'count' /*case 'Count'*/: break;&#13;
					case 'selectedsheets' /*case 'SelectedSheets'*/: break;&#13;
					case 'calculation' /*case 'Calculation'*/: break;&#13;
					case 'uncalced' /*case 'Uncalced'*/: break;&#13;
					case 'startupprompt' /*case 'StartupPrompt'*/: break;&#13;
					case 'crn' /*case 'Crn'*/: break;&#13;
					case 'externname' /*case 'ExternName'*/: break;&#13;
					case 'formula' /*case 'Formula'*/: break;&#13;
					case 'colfirst' /*case 'ColFirst'*/: break;&#13;
					case 'collast' /*case 'ColLast'*/: break;&#13;
					case 'wantadvise' /*case 'WantAdvise'*/: break;&#13;
					case 'boolean' /*case 'Boolean'*/: break;&#13;
					case 'error' /*case 'Error'*/: break;&#13;
					case 'text' /*case 'Text'*/: break;&#13;
					case 'ole' /*case 'OLE'*/: break;&#13;
					case 'noautorecover' /*case 'NoAutoRecover'*/: break;&#13;
					case 'publishobjects' /*case 'PublishObjects'*/: break;&#13;
					case 'donotcalculatebeforesave' /*case 'DoNotCalculateBeforeSave'*/: break;&#13;
					case 'number' /*case 'Number'*/: break;&#13;
					case 'refmoder1c1' /*case 'RefModeR1C1'*/: break;&#13;
					case 'embedsavesmarttags' /*case 'EmbedSaveSmartTags'*/: break;&#13;
					default: seen = false;&#13;
				} break;&#13;
&#13;
				/* WorkbookOptions */&#13;
				case 'workbookoptions' /*case 'WorkbookOptions'*/: switch(Rn[3]) {&#13;
					case 'owcversion' /*case 'OWCVersion'*/: break;&#13;
					case 'height' /*case 'Height'*/: break;&#13;
					case 'width' /*case 'Width'*/: break;&#13;
					default: seen = false;&#13;
				} break;&#13;
&#13;
				/* WorksheetOptions */&#13;
				case 'worksheetoptions' /*case 'WorksheetOptions'*/: switch(Rn[3]) {&#13;
					case 'visible' /*case 'Visible'*/:&#13;
						if(Rn[0].slice(-2) === "/&gt;"){/* empty */}&#13;
						else if(Rn[1]==="/") switch(str.slice(pidx, Rn.index)) {&#13;
							case "SheetHidden": wsprops.Hidden = 1; break;&#13;
							case "SheetVeryHidden": wsprops.Hidden = 2; break;&#13;
						}&#13;
						else pidx = Rn.index + Rn[0].length;&#13;
						break;&#13;
					case 'header' /*case 'Header'*/:&#13;
						if(!cursheet['!margins']) default_margins(cursheet['!margins']={}, 'xlml');&#13;
						if(!isNaN(+parsexmltag(Rn[0]).Margin)) cursheet['!margins'].header = +parsexmltag(Rn[0]).Margin;&#13;
						break;&#13;
					case 'footer' /*case 'Footer'*/:&#13;
						if(!cursheet['!margins']) default_margins(cursheet['!margins']={}, 'xlml');&#13;
						if(!isNaN(+parsexmltag(Rn[0]).Margin)) cursheet['!margins'].footer = +parsexmltag(Rn[0]).Margin;&#13;
						break;&#13;
					case 'pagemargins' /*case 'PageMargins'*/:&#13;
						var pagemargins = parsexmltag(Rn[0]);&#13;
						if(!cursheet['!margins']) default_margins(cursheet['!margins']={},'xlml');&#13;
						if(!isNaN(+pagemargins.Top)) cursheet['!margins'].top = +pagemargins.Top;&#13;
						if(!isNaN(+pagemargins.Left)) cursheet['!margins'].left = +pagemargins.Left;&#13;
						if(!isNaN(+pagemargins.Right)) cursheet['!margins'].right = +pagemargins.Right;&#13;
						if(!isNaN(+pagemargins.Bottom)) cursheet['!margins'].bottom = +pagemargins.Bottom;&#13;
						break;&#13;
					case 'displayrighttoleft' /*case 'DisplayRightToLeft'*/:&#13;
						if(!Workbook.Views) Workbook.Views = [];&#13;
						if(!Workbook.Views[0]) Workbook.Views[0] = {};&#13;
						Workbook.Views[0].RTL = true;&#13;
						break;&#13;
&#13;
					case 'freezepanes' /*case 'FreezePanes'*/: break;&#13;
					case 'frozennosplit' /*case 'FrozenNoSplit'*/: break;&#13;
&#13;
					case 'splithorizontal' /*case 'SplitHorizontal'*/:&#13;
					case 'splitvertical' /*case 'SplitVertical'*/:&#13;
						break;&#13;
&#13;
					case 'donotdisplaygridlines' /*case 'DoNotDisplayGridlines'*/:&#13;
						break;&#13;
&#13;
					case 'activerow' /*case 'ActiveRow'*/: break;&#13;
					case 'activecol' /*case 'ActiveCol'*/: break;&#13;
					case 'toprowbottompane' /*case 'TopRowBottomPane'*/: break;&#13;
					case 'leftcolumnrightpane' /*case 'LeftColumnRightPane'*/: break;&#13;
&#13;
					case 'unsynced' /*case 'Unsynced'*/: break;&#13;
					case 'print' /*case 'Print'*/: break;&#13;
					case 'printerrors' /*case 'PrintErrors'*/: break;&#13;
					case 'panes' /*case 'Panes'*/: break;&#13;
					case 'scale' /*case 'Scale'*/: break;&#13;
					case 'pane' /*case 'Pane'*/: break;&#13;
					case 'number' /*case 'Number'*/: break;&#13;
					case 'layout' /*case 'Layout'*/: break;&#13;
					case 'pagesetup' /*case 'PageSetup'*/: break;&#13;
					case 'selected' /*case 'Selected'*/: break;&#13;
					case 'protectobjects' /*case 'ProtectObjects'*/: break;&#13;
					case 'enableselection' /*case 'EnableSelection'*/: break;&#13;
					case 'protectscenarios' /*case 'ProtectScenarios'*/: break;&#13;
					case 'validprinterinfo' /*case 'ValidPrinterInfo'*/: break;&#13;
					case 'horizontalresolution' /*case 'HorizontalResolution'*/: break;&#13;
					case 'verticalresolution' /*case 'VerticalResolution'*/: break;&#13;
					case 'numberofcopies' /*case 'NumberofCopies'*/: break;&#13;
					case 'activepane' /*case 'ActivePane'*/: break;&#13;
					case 'toprowvisible' /*case 'TopRowVisible'*/: break;&#13;
					case 'leftcolumnvisible' /*case 'LeftColumnVisible'*/: break;&#13;
					case 'fittopage' /*case 'FitToPage'*/: break;&#13;
					case 'rangeselection' /*case 'RangeSelection'*/: break;&#13;
					case 'papersizeindex' /*case 'PaperSizeIndex'*/: break;&#13;
					case 'pagelayoutzoom' /*case 'PageLayoutZoom'*/: break;&#13;
					case 'pagebreakzoom' /*case 'PageBreakZoom'*/: break;&#13;
					case 'filteron' /*case 'FilterOn'*/: break;&#13;
					case 'fitwidth' /*case 'FitWidth'*/: break;&#13;
					case 'fitheight' /*case 'FitHeight'*/: break;&#13;
					case 'commentslayout' /*case 'CommentsLayout'*/: break;&#13;
					case 'zoom' /*case 'Zoom'*/: break;&#13;
					case 'lefttoright' /*case 'LeftToRight'*/: break;&#13;
					case 'gridlines' /*case 'Gridlines'*/: break;&#13;
					case 'allowsort' /*case 'AllowSort'*/: break;&#13;
					case 'allowfilter' /*case 'AllowFilter'*/: break;&#13;
					case 'allowinsertrows' /*case 'AllowInsertRows'*/: break;&#13;
					case 'allowdeleterows' /*case 'AllowDeleteRows'*/: break;&#13;
					case 'allowinsertcols' /*case 'AllowInsertCols'*/: break;&#13;
					case 'allowdeletecols' /*case 'AllowDeleteCols'*/: break;&#13;
					case 'allowinserthyperlinks' /*case 'AllowInsertHyperlinks'*/: break;&#13;
					case 'allowformatcells' /*case 'AllowFormatCells'*/: break;&#13;
					case 'allowsizecols' /*case 'AllowSizeCols'*/: break;&#13;
					case 'allowsizerows' /*case 'AllowSizeRows'*/: break;&#13;
					case 'nosummaryrowsbelowdetail' /*case 'NoSummaryRowsBelowDetail'*/:&#13;
						if(!cursheet["!outline"]) cursheet["!outline"] = {};&#13;
						cursheet["!outline"].above = true;&#13;
						break;&#13;
					case 'tabcolorindex' /*case 'TabColorIndex'*/: break;&#13;
					case 'donotdisplayheadings' /*case 'DoNotDisplayHeadings'*/: break;&#13;
					case 'showpagelayoutzoom' /*case 'ShowPageLayoutZoom'*/: break;&#13;
					case 'nosummarycolumnsrightdetail' /*case 'NoSummaryColumnsRightDetail'*/:&#13;
						if(!cursheet["!outline"]) cursheet["!outline"] = {};&#13;
						cursheet["!outline"].left = true;&#13;
						break;&#13;
					case 'blackandwhite' /*case 'BlackAndWhite'*/: break;&#13;
					case 'donotdisplayzeros' /*case 'DoNotDisplayZeros'*/: break;&#13;
					case 'displaypagebreak' /*case 'DisplayPageBreak'*/: break;&#13;
					case 'rowcolheadings' /*case 'RowColHeadings'*/: break;&#13;
					case 'donotdisplayoutline' /*case 'DoNotDisplayOutline'*/: break;&#13;
					case 'noorientation' /*case 'NoOrientation'*/: break;&#13;
					case 'allowusepivottables' /*case 'AllowUsePivotTables'*/: break;&#13;
					case 'zeroheight' /*case 'ZeroHeight'*/: break;&#13;
					case 'viewablerange' /*case 'ViewableRange'*/: break;&#13;
					case 'selection' /*case 'Selection'*/: break;&#13;
					case 'protectcontents' /*case 'ProtectContents'*/: break;&#13;
					default: seen = false;&#13;
				} break;&#13;
&#13;
				/* PivotTable */&#13;
				case 'pivottable' /*case 'PivotTable'*/: case 'pivotcache' /*case 'PivotCache'*/: switch(Rn[3]) {&#13;
					case 'immediateitemsondrop' /*case 'ImmediateItemsOnDrop'*/: break;&#13;
					case 'showpagemultipleitemlabel' /*case 'ShowPageMultipleItemLabel'*/: break;&#13;
					case 'compactrowindent' /*case 'CompactRowIndent'*/: break;&#13;
					case 'location' /*case 'Location'*/: break;&#13;
					case 'pivotfield' /*case 'PivotField'*/: break;&#13;
					case 'orientation' /*case 'Orientation'*/: break;&#13;
					case 'layoutform' /*case 'LayoutForm'*/: break;&#13;
					case 'layoutsubtotallocation' /*case 'LayoutSubtotalLocation'*/: break;&#13;
					case 'layoutcompactrow' /*case 'LayoutCompactRow'*/: break;&#13;
					case 'position' /*case 'Position'*/: break;&#13;
					case 'pivotitem' /*case 'PivotItem'*/: break;&#13;
					case 'datatype' /*case 'DataType'*/: break;&#13;
					case 'datafield' /*case 'DataField'*/: break;&#13;
					case 'sourcename' /*case 'SourceName'*/: break;&#13;
					case 'parentfield' /*case 'ParentField'*/: break;&#13;
					case 'ptlineitems' /*case 'PTLineItems'*/: break;&#13;
					case 'ptlineitem' /*case 'PTLineItem'*/: break;&#13;
					case 'countofsameitems' /*case 'CountOfSameItems'*/: break;&#13;
					case 'item' /*case 'Item'*/: break;&#13;
					case 'itemtype' /*case 'ItemType'*/: break;&#13;
					case 'ptsource' /*case 'PTSource'*/: break;&#13;
					case 'cacheindex' /*case 'CacheIndex'*/: break;&#13;
					case 'consolidationreference' /*case 'ConsolidationReference'*/: break;&#13;
					case 'filename' /*case 'FileName'*/: break;&#13;
					case 'reference' /*case 'Reference'*/: break;&#13;
					case 'nocolumngrand' /*case 'NoColumnGrand'*/: break;&#13;
					case 'norowgrand' /*case 'NoRowGrand'*/: break;&#13;
					case 'blanklineafteritems' /*case 'BlankLineAfterItems'*/: break;&#13;
					case 'hidden' /*case 'Hidden'*/: break;&#13;
					case 'subtotal' /*case 'Subtotal'*/: break;&#13;
					case 'basefield' /*case 'BaseField'*/: break;&#13;
					case 'mapchilditems' /*case 'MapChildItems'*/: break;&#13;
					case 'function' /*case 'Function'*/: break;&#13;
					case 'refreshonfileopen' /*case 'RefreshOnFileOpen'*/: break;&#13;
					case 'printsettitles' /*case 'PrintSetTitles'*/: break;&#13;
					case 'mergelabels' /*case 'MergeLabels'*/: break;&#13;
					case 'defaultversion' /*case 'DefaultVersion'*/: break;&#13;
					case 'refreshname' /*case 'RefreshName'*/: break;&#13;
					case 'refreshdate' /*case 'RefreshDate'*/: break;&#13;
					case 'refreshdatecopy' /*case 'RefreshDateCopy'*/: break;&#13;
					case 'versionlastrefresh' /*case 'VersionLastRefresh'*/: break;&#13;
					case 'versionlastupdate' /*case 'VersionLastUpdate'*/: break;&#13;
					case 'versionupdateablemin' /*case 'VersionUpdateableMin'*/: break;&#13;
					case 'versionrefreshablemin' /*case 'VersionRefreshableMin'*/: break;&#13;
					case 'calculation' /*case 'Calculation'*/: break;&#13;
					default: seen = false;&#13;
				} break;&#13;
&#13;
				/* PageBreaks */&#13;
				case 'pagebreaks' /*case 'PageBreaks'*/: switch(Rn[3]) {&#13;
					case 'colbreaks' /*case 'ColBreaks'*/: break;&#13;
					case 'colbreak' /*case 'ColBreak'*/: break;&#13;
					case 'rowbreaks' /*case 'RowBreaks'*/: break;&#13;
					case 'rowbreak' /*case 'RowBreak'*/: break;&#13;
					case 'colstart' /*case 'ColStart'*/: break;&#13;
					case 'colend' /*case 'ColEnd'*/: break;&#13;
					case 'rowend' /*case 'RowEnd'*/: break;&#13;
					default: seen = false;&#13;
				} break;&#13;
&#13;
				/* AutoFilter */&#13;
				case 'autofilter' /*case 'AutoFilter'*/: switch(Rn[3]) {&#13;
					case 'autofiltercolumn' /*case 'AutoFilterColumn'*/: break;&#13;
					case 'autofiltercondition' /*case 'AutoFilterCondition'*/: break;&#13;
					case 'autofilterand' /*case 'AutoFilterAnd'*/: break;&#13;
					case 'autofilteror' /*case 'AutoFilterOr'*/: break;&#13;
					default: seen = false;&#13;
				} break;&#13;
&#13;
				/* QueryTable */&#13;
				case 'querytable' /*case 'QueryTable'*/: switch(Rn[3]) {&#13;
					case 'id' /*case 'Id'*/: break;&#13;
					case 'autoformatfont' /*case 'AutoFormatFont'*/: break;&#13;
					case 'autoformatpattern' /*case 'AutoFormatPattern'*/: break;&#13;
					case 'querysource' /*case 'QuerySource'*/: break;&#13;
					case 'querytype' /*case 'QueryType'*/: break;&#13;
					case 'enableredirections' /*case 'EnableRedirections'*/: break;&#13;
					case 'refreshedinxl9' /*case 'RefreshedInXl9'*/: break;&#13;
					case 'urlstring' /*case 'URLString'*/: break;&#13;
					case 'htmltables' /*case 'HTMLTables'*/: break;&#13;
					case 'connection' /*case 'Connection'*/: break;&#13;
					case 'commandtext' /*case 'CommandText'*/: break;&#13;
					case 'refreshinfo' /*case 'RefreshInfo'*/: break;&#13;
					case 'notitles' /*case 'NoTitles'*/: break;&#13;
					case 'nextid' /*case 'NextId'*/: break;&#13;
					case 'columninfo' /*case 'ColumnInfo'*/: break;&#13;
					case 'overwritecells' /*case 'OverwriteCells'*/: break;&#13;
					case 'donotpromptforfile' /*case 'DoNotPromptForFile'*/: break;&#13;
					case 'textwizardsettings' /*case 'TextWizardSettings'*/: break;&#13;
					case 'source' /*case 'Source'*/: break;&#13;
					case 'number' /*case 'Number'*/: break;&#13;
					case 'decimal' /*case 'Decimal'*/: break;&#13;
					case 'thousandseparator' /*case 'ThousandSeparator'*/: break;&#13;
					case 'trailingminusnumbers' /*case 'TrailingMinusNumbers'*/: break;&#13;
					case 'formatsettings' /*case 'FormatSettings'*/: break;&#13;
					case 'fieldtype' /*case 'FieldType'*/: break;&#13;
					case 'delimiters' /*case 'Delimiters'*/: break;&#13;
					case 'tab' /*case 'Tab'*/: break;&#13;
					case 'comma' /*case 'Comma'*/: break;&#13;
					case 'autoformatname' /*case 'AutoFormatName'*/: break;&#13;
					case 'versionlastedit' /*case 'VersionLastEdit'*/: break;&#13;
					case 'versionlastrefresh' /*case 'VersionLastRefresh'*/: break;&#13;
					default: seen = false;&#13;
				} break;&#13;
&#13;
				case 'datavalidation' /*case 'DataValidation'*/:&#13;
				switch(Rn[3]) {&#13;
					case 'range' /*case 'Range'*/: break;&#13;
&#13;
					case 'type' /*case 'Type'*/: break;&#13;
					case 'min' /*case 'Min'*/: break;&#13;
					case 'max' /*case 'Max'*/: break;&#13;
					case 'sort' /*case 'Sort'*/: break;&#13;
					case 'descending' /*case 'Descending'*/: break;&#13;
					case 'order' /*case 'Order'*/: break;&#13;
					case 'casesensitive' /*case 'CaseSensitive'*/: break;&#13;
					case 'value' /*case 'Value'*/: break;&#13;
					case 'errorstyle' /*case 'ErrorStyle'*/: break;&#13;
					case 'errormessage' /*case 'ErrorMessage'*/: break;&#13;
					case 'errortitle' /*case 'ErrorTitle'*/: break;&#13;
					case 'inputmessage' /*case 'InputMessage'*/: break;&#13;
					case 'inputtitle' /*case 'InputTitle'*/: break;&#13;
					case 'combohide' /*case 'ComboHide'*/: break;&#13;
					case 'inputhide' /*case 'InputHide'*/: break;&#13;
					case 'condition' /*case 'Condition'*/: break;&#13;
					case 'qualifier' /*case 'Qualifier'*/: break;&#13;
					case 'useblank' /*case 'UseBlank'*/: break;&#13;
					case 'value1' /*case 'Value1'*/: break;&#13;
					case 'value2' /*case 'Value2'*/: break;&#13;
					case 'format' /*case 'Format'*/: break;&#13;
&#13;
					case 'cellrangelist' /*case 'CellRangeList'*/: break;&#13;
					default: seen = false;&#13;
				} break;&#13;
&#13;
				case 'sorting' /*case 'Sorting'*/:&#13;
				case 'conditionalformatting' /*case 'ConditionalFormatting'*/:&#13;
				switch(Rn[3]) {&#13;
					case 'range' /*case 'Range'*/: break;&#13;
					case 'type' /*case 'Type'*/: break;&#13;
					case 'min' /*case 'Min'*/: break;&#13;
					case 'max' /*case 'Max'*/: break;&#13;
					case 'sort' /*case 'Sort'*/: break;&#13;
					case 'descending' /*case 'Descending'*/: break;&#13;
					case 'order' /*case 'Order'*/: break;&#13;
					case 'casesensitive' /*case 'CaseSensitive'*/: break;&#13;
					case 'value' /*case 'Value'*/: break;&#13;
					case 'errorstyle' /*case 'ErrorStyle'*/: break;&#13;
					case 'errormessage' /*case 'ErrorMessage'*/: break;&#13;
					case 'errortitle' /*case 'ErrorTitle'*/: break;&#13;
					case 'cellrangelist' /*case 'CellRangeList'*/: break;&#13;
					case 'inputmessage' /*case 'InputMessage'*/: break;&#13;
					case 'inputtitle' /*case 'InputTitle'*/: break;&#13;
					case 'combohide' /*case 'ComboHide'*/: break;&#13;
					case 'inputhide' /*case 'InputHide'*/: break;&#13;
					case 'condition' /*case 'Condition'*/: break;&#13;
					case 'qualifier' /*case 'Qualifier'*/: break;&#13;
					case 'useblank' /*case 'UseBlank'*/: break;&#13;
					case 'value1' /*case 'Value1'*/: break;&#13;
					case 'value2' /*case 'Value2'*/: break;&#13;
					case 'format' /*case 'Format'*/: break;&#13;
					default: seen = false;&#13;
				} break;&#13;
&#13;
				/* MapInfo (schema) */&#13;
				case 'mapinfo' /*case 'MapInfo'*/: case 'schema' /*case 'Schema'*/: case 'data' /*case 'data'*/: switch(Rn[3]) {&#13;
					case 'map' /*case 'Map'*/: break;&#13;
					case 'entry' /*case 'Entry'*/: break;&#13;
					case 'range' /*case 'Range'*/: break;&#13;
					case 'xpath' /*case 'XPath'*/: break;&#13;
					case 'field' /*case 'Field'*/: break;&#13;
					case 'xsdtype' /*case 'XSDType'*/: break;&#13;
					case 'filteron' /*case 'FilterOn'*/: break;&#13;
					case 'aggregate' /*case 'Aggregate'*/: break;&#13;
					case 'elementtype' /*case 'ElementType'*/: break;&#13;
					case 'attributetype' /*case 'AttributeType'*/: break;&#13;
				/* These are from xsd (XML Schema Definition) */&#13;
					case 'schema' /*case 'schema'*/:&#13;
					case 'element' /*case 'element'*/:&#13;
					case 'complextype' /*case 'complexType'*/:&#13;
					case 'datatype' /*case 'datatype'*/:&#13;
					case 'all' /*case 'all'*/:&#13;
					case 'attribute' /*case 'attribute'*/:&#13;
					case 'extends' /*case 'extends'*/: break;&#13;
&#13;
					case 'row' /*case 'row'*/: break;&#13;
					default: seen = false;&#13;
				} break;&#13;
&#13;
				/* SmartTags (can be anything) */&#13;
				case 'smarttags' /*case 'SmartTags'*/: break;&#13;
&#13;
				default: seen = false; break;&#13;
			}&#13;
			if(seen) break;&#13;
			/* CustomDocumentProperties */&#13;
			if(Rn[3].match(/!\[CDATA/)) break;&#13;
			if(!state[state.length-1][1]) throw 'Unrecognized tag: ' + Rn[3] + "|" + state.join("|");&#13;
			if(state[state.length-1][0]===/*'CustomDocumentProperties'*/'customdocumentproperties') {&#13;
				if(Rn[0].slice(-2) === "/&gt;") break;&#13;
				else if(Rn[1]==="/") xlml_set_custprop(Custprops, raw_Rn3, cp, str.slice(pidx, Rn.index));&#13;
				else { cp = Rn; pidx = Rn.index + Rn[0].length; }&#13;
				break;&#13;
			}&#13;
			if(opts.WTF) throw 'Unrecognized tag: ' + Rn[3] + "|" + state.join("|");&#13;
	}&#13;
	var out = ({});&#13;
	if(!opts.bookSheets &amp;&amp; !opts.bookProps) out.Sheets = sheets;&#13;
	out.SheetNames = sheetnames;&#13;
	out.Workbook = Workbook;&#13;
	out.SSF = dup(table_fmt);&#13;
	out.Props = Props;&#13;
	out.Custprops = Custprops;&#13;
	out.bookType = "xlml";&#13;
	return out;&#13;
}&#13;
&#13;
function parse_xlml(data, opts) {&#13;
	fix_read_opts(opts=opts||{});&#13;
	switch(opts.type||"base64") {&#13;
		case "base64": return parse_xlml_xml(Base64_decode(data), opts);&#13;
		case "binary": case "buffer": case "file": return parse_xlml_xml(data, opts);&#13;
		case "array": return parse_xlml_xml(a2s(data), opts);&#13;
	}&#13;
}&#13;
&#13;
/* TODO */&#13;
function write_props_xlml(wb, opts) {&#13;
	var o = [];&#13;
	/* DocumentProperties */&#13;
	if(wb.Props) o.push(xlml_write_docprops(wb.Props, opts));&#13;
	/* CustomDocumentProperties */&#13;
	if(wb.Custprops) o.push(xlml_write_custprops(wb.Props, wb.Custprops, opts));&#13;
	return o.join("");&#13;
}&#13;
/* TODO */&#13;
function write_wb_xlml(wb) {&#13;
	/* OfficeDocumentSettings */&#13;
	/* ExcelWorkbook */&#13;
	if((((wb||{}).Workbook||{}).WBProps||{}).date1904) return '&lt;ExcelWorkbook xmlns="urn:schemas-microsoft-com:office:excel"&gt;&lt;Date1904/&gt;&lt;/ExcelWorkbook&gt;';&#13;
	return "";&#13;
}&#13;
/* TODO */&#13;
function write_sty_xlml(wb, opts) {&#13;
	/* Styles */&#13;
	var styles = ['&lt;Style ss:ID="Default" ss:Name="Normal"&gt;&lt;NumberFormat/&gt;&lt;/Style&gt;'];&#13;
	opts.cellXfs.forEach(function(xf, id) {&#13;
		var payload = [];&#13;
		payload.push(writextag('NumberFormat', null, {"ss:Format": escapexml(table_fmt[xf.numFmtId])}));&#13;
&#13;
		var o = {"ss:ID": "s" + (21+id)};&#13;
		styles.push(writextag('Style', payload.join(""), o));&#13;
	});&#13;
	return writextag("Styles", styles.join(""));&#13;
}&#13;
function write_name_xlml(n) { return writextag("NamedRange", null, {"ss:Name": n.Name.slice(0,6) == "_xlnm." ? n.Name.slice(6) : n.Name, "ss:RefersTo":"=" + a1_to_rc(n.Ref, {r:0,c:0})}); }&#13;
function write_names_xlml(wb) {&#13;
	if(!((wb||{}).Workbook||{}).Names) return "";&#13;
var names = wb.Workbook.Names;&#13;
	var out = [];&#13;
	for(var i = 0; i &lt; names.length; ++i) {&#13;
		var n = names[i];&#13;
		if(n.Sheet != null) continue;&#13;
		if(n.Name.match(/^_xlfn\./)) continue;&#13;
		out.push(write_name_xlml(n));&#13;
	}&#13;
	return writextag("Names", out.join(""));&#13;
}&#13;
function write_ws_xlml_names(ws, opts, idx, wb) {&#13;
	if(!ws) return "";&#13;
	if(!((wb||{}).Workbook||{}).Names) return "";&#13;
var names = wb.Workbook.Names;&#13;
	var out = [];&#13;
	for(var i = 0; i &lt; names.length; ++i) {&#13;
		var n = names[i];&#13;
		if(n.Sheet != idx) continue;&#13;
		/*switch(n.Name) {&#13;
			case "_": continue;&#13;
		}*/&#13;
		if(n.Name.match(/^_xlfn\./)) continue;&#13;
		out.push(write_name_xlml(n));&#13;
	}&#13;
	return out.join("");&#13;
}&#13;
/* WorksheetOptions */&#13;
function write_ws_xlml_wsopts(ws, opts, idx, wb) {&#13;
	if(!ws) return "";&#13;
	var o = [];&#13;
	/* NOTE: spec technically allows any order, but stick with implied order */&#13;
&#13;
	/* FitToPage */&#13;
	/* DoNotDisplayColHeaders */&#13;
	/* DoNotDisplayRowHeaders */&#13;
	/* ViewableRange */&#13;
	/* Selection */&#13;
	/* GridlineColor */&#13;
	/* Name */&#13;
	/* ExcelWorksheetType */&#13;
	/* IntlMacro */&#13;
	/* Unsynced */&#13;
	/* Selected */&#13;
	/* CodeName */&#13;
&#13;
	if(ws['!margins']) {&#13;
		o.push("&lt;PageSetup&gt;");&#13;
		if(ws['!margins'].header) o.push(writextag("Header", null, {'x:Margin':ws['!margins'].header}));&#13;
		if(ws['!margins'].footer) o.push(writextag("Footer", null, {'x:Margin':ws['!margins'].footer}));&#13;
		o.push(writextag("PageMargins", null, {&#13;
			'x:Bottom': ws['!margins'].bottom || "0.75",&#13;
			'x:Left': ws['!margins'].left || "0.7",&#13;
			'x:Right': ws['!margins'].right || "0.7",&#13;
			'x:Top': ws['!margins'].top || "0.75"&#13;
		}));&#13;
		o.push("&lt;/PageSetup&gt;");&#13;
	}&#13;
&#13;
	/* PageSetup */&#13;
	/* DisplayPageBreak */&#13;
	/* TransitionExpressionEvaluation */&#13;
	/* TransitionFormulaEntry */&#13;
	/* Print */&#13;
	/* Zoom */&#13;
	/* PageLayoutZoom */&#13;
	/* PageBreakZoom */&#13;
	/* ShowPageBreakZoom */&#13;
	/* DefaultRowHeight */&#13;
	/* DefaultColumnWidth */&#13;
	/* StandardWidth */&#13;
&#13;
	if(wb &amp;&amp; wb.Workbook &amp;&amp; wb.Workbook.Sheets &amp;&amp; wb.Workbook.Sheets[idx]) {&#13;
		/* Visible */&#13;
		if(wb.Workbook.Sheets[idx].Hidden) o.push(writextag("Visible", (wb.Workbook.Sheets[idx].Hidden == 1 ? "SheetHidden" : "SheetVeryHidden"), {}));&#13;
		else {&#13;
			/* Selected */&#13;
			for(var i = 0; i &lt; idx; ++i) if(wb.Workbook.Sheets[i] &amp;&amp; !wb.Workbook.Sheets[i].Hidden) break;&#13;
			if(i == idx) o.push("&lt;Selected/&gt;");&#13;
		}&#13;
	}&#13;
&#13;
	/* LeftColumnVisible */&#13;
&#13;
	if(((((wb||{}).Workbook||{}).Views||[])[0]||{}).RTL) o.push("&lt;DisplayRightToLeft/&gt;");&#13;
&#13;
	/* GridlineColorIndex */&#13;
	/* DisplayFormulas */&#13;
	/* DoNotDisplayGridlines */&#13;
	/* DoNotDisplayHeadings */&#13;
	/* DoNotDisplayOutline */&#13;
	/* ApplyAutomaticOutlineStyles */&#13;
	/* NoSummaryRowsBelowDetail */&#13;
	/* NoSummaryColumnsRightDetail */&#13;
	/* DoNotDisplayZeros */&#13;
	/* ActiveRow */&#13;
	/* ActiveColumn */&#13;
	/* FilterOn */&#13;
	/* RangeSelection */&#13;
	/* TopRowVisible */&#13;
	/* TopRowBottomPane */&#13;
	/* LeftColumnRightPane */&#13;
	/* ActivePane */&#13;
	/* SplitHorizontal */&#13;
	/* SplitVertical */&#13;
	/* FreezePanes */&#13;
	/* FrozenNoSplit */&#13;
	/* TabColorIndex */&#13;
	/* Panes */&#13;
&#13;
	/* NOTE: Password not supported in XLML Format */&#13;
	if(ws['!protect']) {&#13;
		o.push(writetag("ProtectContents", "True"));&#13;
		if(ws['!protect'].objects) o.push(writetag("ProtectObjects", "True"));&#13;
		if(ws['!protect'].scenarios) o.push(writetag("ProtectScenarios", "True"));&#13;
		if(ws['!protect'].selectLockedCells != null &amp;&amp; !ws['!protect'].selectLockedCells) o.push(writetag("EnableSelection", "NoSelection"));&#13;
		else if(ws['!protect'].selectUnlockedCells != null &amp;&amp; !ws['!protect'].selectUnlockedCells) o.push(writetag("EnableSelection", "UnlockedCells"));&#13;
	[&#13;
		[ "formatCells", "AllowFormatCells" ],&#13;
		[ "formatColumns", "AllowSizeCols" ],&#13;
		[ "formatRows", "AllowSizeRows" ],&#13;
		[ "insertColumns", "AllowInsertCols" ],&#13;
		[ "insertRows", "AllowInsertRows" ],&#13;
		[ "insertHyperlinks", "AllowInsertHyperlinks" ],&#13;
		[ "deleteColumns", "AllowDeleteCols" ],&#13;
		[ "deleteRows", "AllowDeleteRows" ],&#13;
		[ "sort", "AllowSort" ],&#13;
		[ "autoFilter", "AllowFilter" ],&#13;
		[ "pivotTables", "AllowUsePivotTables" ]&#13;
	].forEach(function(x) { if(ws['!protect'][x[0]]) o.push("&lt;"+x[1]+"/&gt;"); });&#13;
	}&#13;
&#13;
	if(o.length == 0) return "";&#13;
	return writextag("WorksheetOptions", o.join(""), {xmlns:XLMLNS.x});&#13;
}&#13;
function write_ws_xlml_comment(comments) {&#13;
	return comments.map(function(c) {&#13;
		// TODO: formatted text&#13;
		var t = xlml_unfixstr(c.t||"");&#13;
		var d =writextag("ss:Data", t, {"xmlns":"http://www.w3.org/TR/REC-html40"});&#13;
		return writextag("Comment", d, {"ss:Author":c.a});&#13;
	}).join("");&#13;
}&#13;
function write_ws_xlml_cell(cell, ref, ws, opts, idx, wb, addr){&#13;
	if(!cell || (cell.v == undefined &amp;&amp; cell.f == undefined)) return "";&#13;
&#13;
	var attr = {};&#13;
	if(cell.f) attr["ss:Formula"] = "=" + escapexml(a1_to_rc(cell.f, addr));&#13;
	if(cell.F &amp;&amp; cell.F.slice(0, ref.length) == ref) {&#13;
		var end = decode_cell(cell.F.slice(ref.length + 1));&#13;
		attr["ss:ArrayRange"] = "RC:R" + (end.r == addr.r ? "" : "[" + (end.r - addr.r) + "]") + "C" + (end.c == addr.c ? "" : "[" + (end.c - addr.c) + "]");&#13;
	}&#13;
&#13;
	if(cell.l &amp;&amp; cell.l.Target) {&#13;
		attr["ss:HRef"] = escapexml(cell.l.Target);&#13;
		if(cell.l.Tooltip) attr["x:HRefScreenTip"] = escapexml(cell.l.Tooltip);&#13;
	}&#13;
&#13;
	if(ws['!merges']) {&#13;
		var marr = ws['!merges'];&#13;
		for(var mi = 0; mi != marr.length; ++mi) {&#13;
			if(marr[mi].s.c != addr.c || marr[mi].s.r != addr.r) continue;&#13;
			if(marr[mi].e.c &gt; marr[mi].s.c) attr['ss:MergeAcross'] = marr[mi].e.c - marr[mi].s.c;&#13;
			if(marr[mi].e.r &gt; marr[mi].s.r) attr['ss:MergeDown'] = marr[mi].e.r - marr[mi].s.r;&#13;
		}&#13;
	}&#13;
&#13;
	var t = "", p = "";&#13;
	switch(cell.t) {&#13;
		case 'z': if(!opts.sheetStubs) return ""; break;&#13;
		case 'n': t = 'Number'; p = String(cell.v); break;&#13;
		case 'b': t = 'Boolean'; p = (cell.v ? "1" : "0"); break;&#13;
		case 'e': t = 'Error'; p = BErr[cell.v]; break;&#13;
		case 'd': t = 'DateTime'; p = new Date(cell.v).toISOString(); if(cell.z == null) cell.z = cell.z || table_fmt[14]; break;&#13;
		case 's': t = 'String'; p = escapexlml(cell.v||""); break;&#13;
	}&#13;
	/* TODO: cell style */&#13;
	var os = get_cell_style(opts.cellXfs, cell, opts);&#13;
	attr["ss:StyleID"] = "s" + (21+os);&#13;
	attr["ss:Index"] = addr.c + 1;&#13;
	var _v = (cell.v != null ? p : "");&#13;
	var m = cell.t == 'z' ? "" : ('&lt;Data ss:Type="' + t + '"&gt;' + _v + '&lt;/Data&gt;');&#13;
&#13;
	if((cell.c||[]).length &gt; 0) m += write_ws_xlml_comment(cell.c);&#13;
&#13;
	return writextag("Cell", m, attr);&#13;
}&#13;
function write_ws_xlml_row(R, row) {&#13;
	var o = '&lt;Row ss:Index="' + (R+1) + '"';&#13;
	if(row) {&#13;
		if(row.hpt &amp;&amp; !row.hpx) row.hpx = pt2px(row.hpt);&#13;
		if(row.hpx) o += ' ss:AutoFitHeight="0" ss:Height="' + row.hpx + '"';&#13;
		if(row.hidden) o += ' ss:Hidden="1"';&#13;
	}&#13;
	return o + '&gt;';&#13;
}&#13;
/* TODO */&#13;
function write_ws_xlml_table(ws, opts, idx, wb) {&#13;
	if(!ws['!ref']) return "";&#13;
	var range = safe_decode_range(ws['!ref']);&#13;
	var marr = ws['!merges'] || [], mi = 0;&#13;
	var o = [];&#13;
	if(ws['!cols']) ws['!cols'].forEach(function(n, i) {&#13;
		process_col(n);&#13;
		var w = !!n.width;&#13;
		var p = col_obj_w(i, n);&#13;
		var k = {"ss:Index":i+1};&#13;
		if(w) k['ss:Width'] = width2px(p.width);&#13;
		if(n.hidden) k['ss:Hidden']="1";&#13;
		o.push(writextag("Column",null,k));&#13;
	});&#13;
	var dense = Array.isArray(ws);&#13;
	for(var R = range.s.r; R &lt;= range.e.r; ++R) {&#13;
		var row = [write_ws_xlml_row(R, (ws['!rows']||[])[R])];&#13;
		for(var C = range.s.c; C &lt;= range.e.c; ++C) {&#13;
			var skip = false;&#13;
			for(mi = 0; mi != marr.length; ++mi) {&#13;
				if(marr[mi].s.c &gt; C) continue;&#13;
				if(marr[mi].s.r &gt; R) continue;&#13;
				if(marr[mi].e.c &lt; C) continue;&#13;
				if(marr[mi].e.r &lt; R) continue;&#13;
				if(marr[mi].s.c != C || marr[mi].s.r != R) skip = true;&#13;
				break;&#13;
			}&#13;
			if(skip) continue;&#13;
			var addr = {r:R,c:C};&#13;
			var ref = encode_cell(addr), cell = dense ? (ws[R]||[])[C] : ws[ref];&#13;
			row.push(write_ws_xlml_cell(cell, ref, ws, opts, idx, wb, addr));&#13;
		}&#13;
		row.push("&lt;/Row&gt;");&#13;
		if(row.length &gt; 2) o.push(row.join(""));&#13;
	}&#13;
	return o.join("");&#13;
}&#13;
function write_ws_xlml(idx, opts, wb) {&#13;
	var o = [];&#13;
	var s = wb.SheetNames[idx];&#13;
	var ws = wb.Sheets[s];&#13;
&#13;
	var t = ws ? write_ws_xlml_names(ws, opts, idx, wb) : "";&#13;
	if(t.length &gt; 0) o.push("&lt;Names&gt;" + t + "&lt;/Names&gt;");&#13;
&#13;
	/* Table */&#13;
	t = ws ? write_ws_xlml_table(ws, opts, idx, wb) : "";&#13;
	if(t.length &gt; 0) o.push("&lt;Table&gt;" + t + "&lt;/Table&gt;");&#13;
&#13;
	/* WorksheetOptions */&#13;
	o.push(write_ws_xlml_wsopts(ws, opts, idx, wb));&#13;
&#13;
	if(ws["!autofilter"]) o.push('&lt;AutoFilter x:Range="' + a1_to_rc(fix_range(ws["!autofilter"].ref), {r:0,c:0}) + '" xmlns="urn:schemas-microsoft-com:office:excel"&gt;&lt;/AutoFilter&gt;');&#13;
&#13;
	return o.join("");&#13;
}&#13;
function write_xlml(wb, opts) {&#13;
	if(!opts) opts = {};&#13;
	if(!wb.SSF) wb.SSF = dup(table_fmt);&#13;
	if(wb.SSF) {&#13;
		make_ssf(); SSF_load_table(wb.SSF);&#13;
		// $FlowIgnore&#13;
		opts.revssf = evert_num(wb.SSF); opts.revssf[wb.SSF[65535]] = 0;&#13;
		opts.ssf = wb.SSF;&#13;
		opts.cellXfs = [];&#13;
		get_cell_style(opts.cellXfs, {}, {revssf:{"General":0}});&#13;
	}&#13;
	var d = [];&#13;
	d.push(write_props_xlml(wb, opts));&#13;
	d.push(write_wb_xlml(wb, opts));&#13;
	d.push("");&#13;
	d.push("");&#13;
	for(var i = 0; i &lt; wb.SheetNames.length; ++i)&#13;
		d.push(writextag("Worksheet", write_ws_xlml(i, opts, wb), {"ss:Name":escapexml(wb.SheetNames[i])}));&#13;
	d[2] = write_sty_xlml(wb, opts);&#13;
	d[3] = write_names_xlml(wb, opts);&#13;
	return XML_HEADER + writextag("Workbook", d.join(""), {&#13;
		'xmlns':      XLMLNS.ss,&#13;
		'xmlns:o':    XLMLNS.o,&#13;
		'xmlns:x':    XLMLNS.x,&#13;
		'xmlns:ss':   XLMLNS.ss,&#13;
		'xmlns:dt':   XLMLNS.dt,&#13;
		'xmlns:html': XLMLNS.html&#13;
	});&#13;
}&#13;
/* [MS-OLEDS] 2.3.8 CompObjStream */&#13;
function parse_compobj(obj) {&#13;
	var v = {};&#13;
	var o = obj.content;&#13;
/* [MS-OLEDS] 2.3.7 CompObjHeader -- All fields MUST be ignored */&#13;
	o.l = 28;&#13;
&#13;
	v.AnsiUserType = o.read_shift(0, "lpstr-ansi");&#13;
	v.AnsiClipboardFormat = parse_ClipboardFormatOrAnsiString(o);&#13;
&#13;
	if(o.length - o.l &lt;= 4) return v;&#13;
&#13;
	var m = o.read_shift(4);&#13;
	if(m == 0 || m &gt; 40) return v;&#13;
	o.l-=4; v.Reserved1 = o.read_shift(0, "lpstr-ansi");&#13;
&#13;
	if(o.length - o.l &lt;= 4) return v;&#13;
	m = o.read_shift(4);&#13;
	if(m !== 0x71b239f4) return v;&#13;
	v.UnicodeClipboardFormat = parse_ClipboardFormatOrUnicodeString(o);&#13;
&#13;
	m = o.read_shift(4);&#13;
	if(m == 0 || m &gt; 40) return v;&#13;
	o.l-=4; v.Reserved2 = o.read_shift(0, "lpwstr");&#13;
}&#13;
&#13;
/*&#13;
	Continue logic for:&#13;
	- 2.4.58 Continue          0x003c&#13;
	- 2.4.59 ContinueBigName   0x043c&#13;
	- 2.4.60 ContinueFrt       0x0812&#13;
	- 2.4.61 ContinueFrt11     0x0875&#13;
	- 2.4.62 ContinueFrt12     0x087f&#13;
*/&#13;
var CONTINUE_RT = [ 0x003c, 0x043c, 0x0812, 0x0875, 0x087f ];&#13;
function slurp(RecordType, R, blob, length, opts) {&#13;
	var l = length;&#13;
	var bufs = [];&#13;
	var d = blob.slice(blob.l,blob.l+l);&#13;
	if(opts &amp;&amp; opts.enc &amp;&amp; opts.enc.insitu &amp;&amp; d.length &gt; 0) switch(RecordType) {&#13;
	case 0x0009: case 0x0209: case 0x0409: case 0x0809/* BOF */: case 0x002F /* FilePass */: case 0x0195 /* FileLock */: case 0x00E1 /* InterfaceHdr */: case 0x0196 /* RRDInfo */: case 0x0138 /* RRDHead */: case 0x0194 /* UsrExcl */: case 0x000a /* EOF */:&#13;
		break;&#13;
	case 0x0085 /* BoundSheet8 */:&#13;
		break;&#13;
	default:&#13;
		opts.enc.insitu(d);&#13;
	}&#13;
	bufs.push(d);&#13;
	blob.l += l;&#13;
	var nextrt = __readUInt16LE(blob,blob.l), next = XLSRecordEnum[nextrt];&#13;
	var start = 0;&#13;
	while(next != null &amp;&amp; CONTINUE_RT.indexOf(nextrt) &gt; -1) {&#13;
		l = __readUInt16LE(blob,blob.l+2);&#13;
		start = blob.l + 4;&#13;
		if(nextrt == 0x0812 /* ContinueFrt */) start += 4;&#13;
		else if(nextrt == 0x0875 || nextrt == 0x087f) {&#13;
			start += 12;&#13;
		}&#13;
		d = blob.slice(start,blob.l+4+l);&#13;
		bufs.push(d);&#13;
		blob.l += 4+l;&#13;
		next = (XLSRecordEnum[nextrt = __readUInt16LE(blob, blob.l)]);&#13;
	}&#13;
	var b = (bconcat(bufs));&#13;
	prep_blob(b, 0);&#13;
	var ll = 0; b.lens = [];&#13;
	for(var j = 0; j &lt; bufs.length; ++j) { b.lens.push(ll); ll += bufs[j].length; }&#13;
	if(b.length &lt; length) throw "XLS Record 0x" + RecordType.toString(16) + " Truncated: " + b.length + " &lt; " + length;&#13;
	return R.f(b, b.length, opts);&#13;
}&#13;
&#13;
function safe_format_xf(p, opts, date1904) {&#13;
	if(p.t === 'z') return;&#13;
	if(!p.XF) return;&#13;
	var fmtid = 0;&#13;
	try {&#13;
		fmtid = p.z || p.XF.numFmtId || 0;&#13;
		if(opts.cellNF) p.z = table_fmt[fmtid];&#13;
	} catch(e) { if(opts.WTF) throw e; }&#13;
	if(!opts || opts.cellText !== false) try {&#13;
		if(p.t === 'e') { p.w = p.w || BErr[p.v]; }&#13;
		else if(fmtid === 0 || fmtid == "General") {&#13;
			if(p.t === 'n') {&#13;
				if((p.v|0) === p.v) p.w = p.v.toString(10);&#13;
				else p.w = SSF_general_num(p.v);&#13;
			}&#13;
			else p.w = SSF_general(p.v);&#13;
		}&#13;
		else p.w = SSF_format(fmtid,p.v, {date1904:!!date1904, dateNF: opts &amp;&amp; opts.dateNF});&#13;
	} catch(e) { if(opts.WTF) throw e; }&#13;
	if(opts.cellDates &amp;&amp; fmtid &amp;&amp; p.t == 'n' &amp;&amp; fmt_is_date(table_fmt[fmtid] || String(fmtid))) {&#13;
		var _d = SSF_parse_date_code(p.v); if(_d) { p.t = 'd'; p.v = new Date(_d.y, _d.m-1,_d.d,_d.H,_d.M,_d.S,_d.u); }&#13;
	}&#13;
}&#13;
&#13;
function make_cell(val, ixfe, t) {&#13;
	return ({v:val, ixfe:ixfe, t:t});&#13;
}&#13;
&#13;
// 2.3.2&#13;
function parse_workbook(blob, options) {&#13;
	var wb = ({opts:{}});&#13;
	var Sheets = {};&#13;
	if(DENSE != null &amp;&amp; options.dense == null) options.dense = DENSE;&#13;
	var out = ((options.dense ? [] : {}));&#13;
	var Directory = {};&#13;
	var range = ({});&#13;
	var last_formula = null;&#13;
	var sst = ([]);&#13;
	var cur_sheet = "";&#13;
	var Preamble = {};&#13;
	var lastcell, last_cell = "", cc, cmnt, rngC, rngR;&#13;
	var sharedf = {};&#13;
	var arrayf = [];&#13;
	var temp_val;&#13;
	var country;&#13;
	var XFs = []; /* XF records */&#13;
	var palette = [];&#13;
	var Workbook = ({ Sheets:[], WBProps:{date1904:false}, Views:[{}] }), wsprops = {};&#13;
	var get_rgb = function getrgb(icv) {&#13;
		if(icv &lt; 8) return XLSIcv[icv];&#13;
		if(icv &lt; 64) return palette[icv-8] || XLSIcv[icv];&#13;
		return XLSIcv[icv];&#13;
	};&#13;
	var process_cell_style = function pcs(cell, line, options) {&#13;
		var xfd = line.XF.data;&#13;
		if(!xfd || !xfd.patternType || !options || !options.cellStyles) return;&#13;
		line.s = ({});&#13;
		line.s.patternType = xfd.patternType;&#13;
		var t;&#13;
		if((t = rgb2Hex(get_rgb(xfd.icvFore)))) { line.s.fgColor = {rgb:t}; }&#13;
		if((t = rgb2Hex(get_rgb(xfd.icvBack)))) { line.s.bgColor = {rgb:t}; }&#13;
	};&#13;
	var addcell = function addcell(cell, line, options) {&#13;
		if(file_depth &gt; 1) return;&#13;
		if(options.sheetRows &amp;&amp; cell.r &gt;= options.sheetRows) return;&#13;
		if(options.cellStyles &amp;&amp; line.XF &amp;&amp; line.XF.data) process_cell_style(cell, line, options);&#13;
		delete line.ixfe; delete line.XF;&#13;
		lastcell = cell;&#13;
		last_cell = encode_cell(cell);&#13;
		if(!range || !range.s || !range.e) range = {s:{r:0,c:0},e:{r:0,c:0}};&#13;
		if(cell.r &lt; range.s.r) range.s.r = cell.r;&#13;
		if(cell.c &lt; range.s.c) range.s.c = cell.c;&#13;
		if(cell.r + 1 &gt; range.e.r) range.e.r = cell.r + 1;&#13;
		if(cell.c + 1 &gt; range.e.c) range.e.c = cell.c + 1;&#13;
		if(options.cellFormula &amp;&amp; line.f) {&#13;
			for(var afi = 0; afi &lt; arrayf.length; ++afi) {&#13;
				if(arrayf[afi][0].s.c &gt; cell.c || arrayf[afi][0].s.r &gt; cell.r) continue;&#13;
				if(arrayf[afi][0].e.c &lt; cell.c || arrayf[afi][0].e.r &lt; cell.r) continue;&#13;
				line.F = encode_range(arrayf[afi][0]);&#13;
				if(arrayf[afi][0].s.c != cell.c || arrayf[afi][0].s.r != cell.r) delete line.f;&#13;
				if(line.f) line.f = "" + stringify_formula(arrayf[afi][1], range, cell, supbooks, opts);&#13;
				break;&#13;
			}&#13;
		}&#13;
		{&#13;
			if(options.dense) {&#13;
				if(!out[cell.r]) out[cell.r] = [];&#13;
				out[cell.r][cell.c] = line;&#13;
			} else out[last_cell] = line;&#13;
		}&#13;
	};&#13;
	var opts = ({&#13;
		enc: false, // encrypted&#13;
		sbcch: 0, // cch in the preceding SupBook&#13;
		snames: [], // sheetnames&#13;
		sharedf: sharedf, // shared formulae by address&#13;
		arrayf: arrayf, // array formulae array&#13;
		rrtabid: [], // RRTabId&#13;
		lastuser: "", // Last User from WriteAccess&#13;
		biff: 8, // BIFF version&#13;
		codepage: 0, // CP from CodePage record&#13;
		winlocked: 0, // fLockWn from WinProtect&#13;
		cellStyles: !!options &amp;&amp; !!options.cellStyles,&#13;
		WTF: !!options &amp;&amp; !!options.wtf&#13;
	});&#13;
	if(options.password) opts.password = options.password;&#13;
	var themes;&#13;
	var merges = [];&#13;
	var objects = [];&#13;
	var colinfo = [], rowinfo = [];&#13;
	var seencol = false;&#13;
	var supbooks = ([]); // 1-indexed, will hold extern names&#13;
	supbooks.SheetNames = opts.snames;&#13;
	supbooks.sharedf = opts.sharedf;&#13;
	supbooks.arrayf = opts.arrayf;&#13;
	supbooks.names = [];&#13;
	supbooks.XTI = [];&#13;
	var last_RT = 0;&#13;
	var file_depth = 0; /* TODO: make a real stack */&#13;
	var BIFF2Fmt = 0, BIFF2FmtTable = [];&#13;
	var FilterDatabases = []; /* TODO: sort out supbooks and process elsewhere */&#13;
	var last_lbl;&#13;
&#13;
	/* explicit override for some broken writers */&#13;
	opts.codepage = 1200;&#13;
	set_cp(1200);&#13;
	var seen_codepage = false;&#13;
	while(blob.l &lt; blob.length - 1) {&#13;
		var s = blob.l;&#13;
		var RecordType = blob.read_shift(2);&#13;
		if(RecordType === 0 &amp;&amp; last_RT === 0x000a /* EOF */) break;&#13;
		var length = (blob.l === blob.length ? 0 : blob.read_shift(2));&#13;
		var R = XLSRecordEnum[RecordType];&#13;
		if(file_depth == 0 &amp;&amp; [0x0009, 0x0209, 0x0409, 0x0809].indexOf(RecordType) == -1 /* BOF */) break;&#13;
		//console.log(RecordType.toString(16), RecordType, R, blob.l, length, blob.length);&#13;
		//if(!R) console.log(blob.slice(blob.l, blob.l + length));&#13;
		if(R &amp;&amp; R.f) {&#13;
			if(options.bookSheets) {&#13;
				if(last_RT === 0x0085 /* BoundSheet8 */ &amp;&amp; RecordType !== 0x0085 /* R.n !== 'BoundSheet8' */) break;&#13;
			}&#13;
			last_RT = RecordType;&#13;
			if(R.r === 2 || R.r == 12) {&#13;
				var rt = blob.read_shift(2); length -= 2;&#13;
				if(!opts.enc &amp;&amp; rt !== RecordType &amp;&amp; (((rt&amp;0xFF)&lt;&lt;8)|(rt&gt;&gt;8)) !== RecordType) throw new Error("rt mismatch: " + rt + "!=" + RecordType);&#13;
				if(R.r == 12){&#13;
					blob.l += 10; length -= 10;&#13;
				} // skip FRT&#13;
			}&#13;
			//console.error(R,blob.l,length,blob.length);&#13;
			var val = ({});&#13;
			if(RecordType === 0x000a /* EOF */) val = R.f(blob, length, opts);&#13;
			else val = slurp(RecordType, R, blob, length, opts);&#13;
if(file_depth == 0 &amp;&amp; [0x0009, 0x0209, 0x0409, 0x0809].indexOf(last_RT) === -1 /* BOF */) continue;&#13;
			switch(RecordType) {&#13;
				case 0x0022 /* Date1904 */:&#13;
wb.opts.Date1904 = Workbook.WBProps.date1904 = val; break;&#13;
				case 0x0086 /* WriteProtect */: wb.opts.WriteProtect = true; break;&#13;
				case 0x002f /* FilePass */:&#13;
					if(!opts.enc) blob.l = 0;&#13;
					opts.enc = val;&#13;
					if(!options.password) throw new Error("File is password-protected");&#13;
					if(val.valid == null) throw new Error("Encryption scheme unsupported");&#13;
					if(!val.valid) throw new Error("Password is incorrect");&#13;
					break;&#13;
				case 0x005c /* WriteAccess */: opts.lastuser = val; break;&#13;
				case 0x0042 /* CodePage */:&#13;
					var cpval = Number(val);&#13;
					/* overrides based on test cases */&#13;
					switch(cpval) {&#13;
						case 0x5212: cpval =  1200; break;&#13;
						case 0x8000: cpval = 10000; break;&#13;
						case 0x8001: cpval =  1252; break;&#13;
					}&#13;
					set_cp(opts.codepage = cpval);&#13;
					seen_codepage = true;&#13;
					break;&#13;
				case 0x013d /* RRTabId */: opts.rrtabid = val; break;&#13;
				case 0x0019 /* WinProtect */: opts.winlocked = val; break;&#13;
				case 0x01b7 /* RefreshAll */: wb.opts["RefreshAll"] = val; break;&#13;
				case 0x000c /* CalcCount */: wb.opts["CalcCount"] = val; break;&#13;
				case 0x0010 /* CalcDelta */: wb.opts["CalcDelta"] = val; break;&#13;
				case 0x0011 /* CalcIter */: wb.opts["CalcIter"] = val; break;&#13;
				case 0x000d /* CalcMode */: wb.opts["CalcMode"] = val; break;&#13;
				case 0x000e /* CalcPrecision */: wb.opts["CalcPrecision"] = val; break;&#13;
				case 0x005f /* CalcSaveRecalc */: wb.opts["CalcSaveRecalc"] = val; break;&#13;
				case 0x000f /* CalcRefMode */: opts.CalcRefMode = val; break; // TODO: implement R1C1&#13;
				case 0x08a3 /* ForceFullCalculation */: wb.opts.FullCalc = val; break;&#13;
				case 0x0081 /* WsBool */:&#13;
					if(val.fDialog) out["!type"] = "dialog";&#13;
					if(!val.fBelow) (out["!outline"] || (out["!outline"] = {})).above = true;&#13;
					if(!val.fRight) (out["!outline"] || (out["!outline"] = {})).left = true;&#13;
					break; // TODO&#13;
				case 0x00e0 /* XF */:&#13;
					XFs.push(val); break;&#13;
				case 0x01ae /* SupBook */:&#13;
					supbooks.push([val]);&#13;
					supbooks[supbooks.length-1].XTI = [];&#13;
					break;&#13;
				case 0x0023: case 0x0223 /* ExternName */:&#13;
					supbooks[supbooks.length-1].push(val);&#13;
					break;&#13;
				case 0x0018: case 0x0218 /* Lbl */:&#13;
					last_lbl = ({&#13;
						Name: val.Name,&#13;
						Ref: stringify_formula(val.rgce,range,null,supbooks,opts)&#13;
					});&#13;
					if(val.itab &gt; 0) last_lbl.Sheet = val.itab - 1;&#13;
					supbooks.names.push(last_lbl);&#13;
					if(!supbooks[0]) { supbooks[0] = []; supbooks[0].XTI = []; }&#13;
					supbooks[supbooks.length-1].push(val);&#13;
					if(val.Name == "_xlnm._FilterDatabase" &amp;&amp; val.itab &gt; 0)&#13;
						if(val.rgce &amp;&amp; val.rgce[0] &amp;&amp; val.rgce[0][0] &amp;&amp; val.rgce[0][0][0] == 'PtgArea3d')&#13;
							FilterDatabases[val.itab - 1] = { ref: encode_range(val.rgce[0][0][1][2]) };&#13;
					break;&#13;
				case 0x0016 /* ExternCount */: opts.ExternCount = val; break;&#13;
				case 0x0017 /* ExternSheet */:&#13;
					if(supbooks.length == 0) { supbooks[0] = []; supbooks[0].XTI = []; }&#13;
					supbooks[supbooks.length - 1].XTI = supbooks[supbooks.length - 1].XTI.concat(val); supbooks.XTI = supbooks.XTI.concat(val); break;&#13;
				case 0x0894 /* NameCmt */:&#13;
					/* TODO: search for correct name */&#13;
					if(opts.biff &lt; 8) break;&#13;
					if(last_lbl != null) last_lbl.Comment = val[1];&#13;
					break;&#13;
				case 0x0012 /* Protect */: out["!protect"] = val; break; /* for sheet or book */&#13;
				case 0x0013 /* Password */: if(val !== 0 &amp;&amp; opts.WTF) console.error("Password verifier: " + val); break;&#13;
				case 0x0085 /* BoundSheet8 */: {&#13;
					Directory[val.pos] = val;&#13;
					opts.snames.push(val.name);&#13;
				} break;&#13;
				case 0x000a /* EOF */: {&#13;
					if(--file_depth) break;&#13;
					if(range.e) {&#13;
						if(range.e.r &gt; 0 &amp;&amp; range.e.c &gt; 0) {&#13;
							range.e.r--; range.e.c--;&#13;
							out["!ref"] = encode_range(range);&#13;
							if(options.sheetRows &amp;&amp; options.sheetRows &lt;= range.e.r) {&#13;
								var tmpri = range.e.r;&#13;
								range.e.r = options.sheetRows - 1;&#13;
								out["!fullref"] = out["!ref"];&#13;
								out["!ref"] = encode_range(range);&#13;
								range.e.r = tmpri;&#13;
							}&#13;
							range.e.r++; range.e.c++;&#13;
						}&#13;
						if(merges.length &gt; 0) out["!merges"] = merges;&#13;
						if(objects.length &gt; 0) out["!objects"] = objects;&#13;
						if(colinfo.length &gt; 0) out["!cols"] = colinfo;&#13;
						if(rowinfo.length &gt; 0) out["!rows"] = rowinfo;&#13;
						Workbook.Sheets.push(wsprops);&#13;
					}&#13;
					if(cur_sheet === "") Preamble = out; else Sheets[cur_sheet] = out;&#13;
					out = ((options.dense ? [] : {}));&#13;
				} break;&#13;
				case 0x0009: case 0x0209: case 0x0409: case 0x0809 /* BOF */: {&#13;
					if(opts.biff === 8) opts.biff = {&#13;
0x0009:2,&#13;
0x0209:3,&#13;
0x0409:4&#13;
					}[RecordType] || {&#13;
0x0200:2,&#13;
0x0300:3,&#13;
0x0400:4,&#13;
0x0500:5,&#13;
0x0600:8,&#13;
0x0002:2,&#13;
0x0007:2&#13;
					}[val.BIFFVer] || 8;&#13;
					opts.biffguess = val.BIFFVer == 0;&#13;
					if(val.BIFFVer == 0 &amp;&amp; val.dt == 0x1000) { opts.biff = 5; seen_codepage = true; set_cp(opts.codepage = 28591); }&#13;
					if(opts.biff == 8 &amp;&amp; val.BIFFVer == 0 &amp;&amp; val.dt == 16) opts.biff = 2;&#13;
					if(file_depth++) break;&#13;
					out = ((options.dense ? [] : {}));&#13;
&#13;
					if(opts.biff &lt; 8 &amp;&amp; !seen_codepage) { seen_codepage = true; set_cp(opts.codepage = options.codepage || 1252); }&#13;
&#13;
					if(opts.biff &lt; 5 || val.BIFFVer == 0 &amp;&amp; val.dt == 0x1000) {&#13;
						if(cur_sheet === "") cur_sheet = "Sheet1";&#13;
						range = {s:{r:0,c:0},e:{r:0,c:0}};&#13;
						/* fake BoundSheet8 */&#13;
						var fakebs8 = {pos: blob.l - length, name:cur_sheet};&#13;
						Directory[fakebs8.pos] = fakebs8;&#13;
						opts.snames.push(cur_sheet);&#13;
					}&#13;
					else cur_sheet = (Directory[s] || {name:""}).name;&#13;
					if(val.dt == 0x20) out["!type"] = "chart";&#13;
					if(val.dt == 0x40) out["!type"] = "macro";&#13;
					merges = [];&#13;
					objects = [];&#13;
					opts.arrayf = arrayf = [];&#13;
					colinfo = []; rowinfo = [];&#13;
					seencol = false;&#13;
					wsprops = {Hidden:(Directory[s]||{hs:0}).hs, name:cur_sheet };&#13;
				} break;&#13;
				case 0x0203 /* Number */: case 0x0003 /* BIFF2NUM */: case 0x0002 /* BIFF2INT */: {&#13;
					if(out["!type"] == "chart") if(options.dense ? (out[val.r]||[])[val.c]: out[encode_cell({c:val.c, r:val.r})]) ++val.c;&#13;
					temp_val = ({ixfe: val.ixfe, XF: XFs[val.ixfe]||{}, v:val.val, t:'n'});&#13;
					if(BIFF2Fmt &gt; 0) temp_val.z = BIFF2FmtTable[(temp_val.ixfe&gt;&gt;8) &amp; 0x3F];&#13;
					safe_format_xf(temp_val, options, wb.opts.Date1904);&#13;
					addcell({c:val.c, r:val.r}, temp_val, options);&#13;
				} break;&#13;
				case 0x0005: case 0x0205 /* BoolErr */: {&#13;
					temp_val = ({ixfe: val.ixfe, XF: XFs[val.ixfe], v:val.val, t:val.t});&#13;
					if(BIFF2Fmt &gt; 0) temp_val.z = BIFF2FmtTable[(temp_val.ixfe&gt;&gt;8) &amp; 0x3F];&#13;
					safe_format_xf(temp_val, options, wb.opts.Date1904);&#13;
					addcell({c:val.c, r:val.r}, temp_val, options);&#13;
				} break;&#13;
				case 0x027e /* RK */: {&#13;
					temp_val = ({ixfe: val.ixfe, XF: XFs[val.ixfe], v:val.rknum, t:'n'});&#13;
					if(BIFF2Fmt &gt; 0) temp_val.z = BIFF2FmtTable[(temp_val.ixfe&gt;&gt;8) &amp; 0x3F];&#13;
					safe_format_xf(temp_val, options, wb.opts.Date1904);&#13;
					addcell({c:val.c, r:val.r}, temp_val, options);&#13;
				} break;&#13;
				case 0x00bd /* MulRk */: {&#13;
					for(var j = val.c; j &lt;= val.C; ++j) {&#13;
						var ixfe = val.rkrec[j-val.c][0];&#13;
						temp_val= ({ixfe:ixfe, XF:XFs[ixfe], v:val.rkrec[j-val.c][1], t:'n'});&#13;
						if(BIFF2Fmt &gt; 0) temp_val.z = BIFF2FmtTable[(temp_val.ixfe&gt;&gt;8) &amp; 0x3F];&#13;
						safe_format_xf(temp_val, options, wb.opts.Date1904);&#13;
						addcell({c:j, r:val.r}, temp_val, options);&#13;
					}&#13;
				} break;&#13;
				case 0x0006: case 0x0206: case 0x0406 /* Formula */: {&#13;
					if(val.val == 'String') { last_formula = val; break; }&#13;
					temp_val = make_cell(val.val, val.cell.ixfe, val.tt);&#13;
					temp_val.XF = XFs[temp_val.ixfe];&#13;
					if(options.cellFormula) {&#13;
						var _f = val.formula;&#13;
						if(_f &amp;&amp; _f[0] &amp;&amp; _f[0][0] &amp;&amp; _f[0][0][0] == 'PtgExp') {&#13;
							var _fr = _f[0][0][1][0], _fc = _f[0][0][1][1];&#13;
							var _fe = encode_cell({r:_fr, c:_fc});&#13;
							if(sharedf[_fe]) temp_val.f = ""+stringify_formula(val.formula,range,val.cell,supbooks, opts);&#13;
							else temp_val.F = ((options.dense ? (out[_fr]||[])[_fc]: out[_fe]) || {}).F;&#13;
						} else temp_val.f = ""+stringify_formula(val.formula,range,val.cell,supbooks, opts);&#13;
					}&#13;
					if(BIFF2Fmt &gt; 0) temp_val.z = BIFF2FmtTable[(temp_val.ixfe&gt;&gt;8) &amp; 0x3F];&#13;
					safe_format_xf(temp_val, options, wb.opts.Date1904);&#13;
					addcell(val.cell, temp_val, options);&#13;
					last_formula = val;&#13;
				} break;&#13;
				case 0x0007: case 0x0207 /* String */: {&#13;
					if(last_formula) { /* technically always true */&#13;
						last_formula.val = val;&#13;
						temp_val = make_cell(val, last_formula.cell.ixfe, 's');&#13;
						temp_val.XF = XFs[temp_val.ixfe];&#13;
						if(options.cellFormula) {&#13;
							temp_val.f = ""+stringify_formula(last_formula.formula, range, last_formula.cell, supbooks, opts);&#13;
						}&#13;
						if(BIFF2Fmt &gt; 0) temp_val.z = BIFF2FmtTable[(temp_val.ixfe&gt;&gt;8) &amp; 0x3F];&#13;
						safe_format_xf(temp_val, options, wb.opts.Date1904);&#13;
						addcell(last_formula.cell, temp_val, options);&#13;
						last_formula = null;&#13;
					} else throw new Error("String record expects Formula");&#13;
				} break;&#13;
				case 0x0021: case 0x0221 /* Array */: {&#13;
					arrayf.push(val);&#13;
					var _arraystart = encode_cell(val[0].s);&#13;
					cc = options.dense ? (out[val[0].s.r]||[])[val[0].s.c] : out[_arraystart];&#13;
					if(options.cellFormula &amp;&amp; cc) {&#13;
						if(!last_formula) break; /* technically unreachable */&#13;
						if(!_arraystart || !cc) break;&#13;
						cc.f = ""+stringify_formula(val[1], range, val[0], supbooks, opts);&#13;
						cc.F = encode_range(val[0]);&#13;
					}&#13;
				} break;&#13;
				case 0x04bc /* ShrFmla */: {&#13;
					if(!options.cellFormula) break;&#13;
					if(last_cell) {&#13;
						/* TODO: capture range */&#13;
						if(!last_formula) break; /* technically unreachable */&#13;
						sharedf[encode_cell(last_formula.cell)]= val[0];&#13;
						cc = options.dense ? (out[last_formula.cell.r]||[])[last_formula.cell.c] : out[encode_cell(last_formula.cell)];&#13;
						(cc||{}).f = ""+stringify_formula(val[0], range, lastcell, supbooks, opts);&#13;
					}&#13;
				} break;&#13;
				case 0x00fd /* LabelSst */:&#13;
					temp_val=make_cell(sst[val.isst].t, val.ixfe, 's');&#13;
					if(sst[val.isst].h) temp_val.h = sst[val.isst].h;&#13;
					temp_val.XF = XFs[temp_val.ixfe];&#13;
					if(BIFF2Fmt &gt; 0) temp_val.z = BIFF2FmtTable[(temp_val.ixfe&gt;&gt;8) &amp; 0x3F];&#13;
					safe_format_xf(temp_val, options, wb.opts.Date1904);&#13;
					addcell({c:val.c, r:val.r}, temp_val, options);&#13;
					break;&#13;
				case 0x0201 /* Blank */: if(options.sheetStubs) {&#13;
					temp_val = ({ixfe: val.ixfe, XF: XFs[val.ixfe], t:'z'});&#13;
					if(BIFF2Fmt &gt; 0) temp_val.z = BIFF2FmtTable[(temp_val.ixfe&gt;&gt;8) &amp; 0x3F];&#13;
					safe_format_xf(temp_val, options, wb.opts.Date1904);&#13;
					addcell({c:val.c, r:val.r}, temp_val, options);&#13;
				} break;&#13;
				case 0x00be /* MulBlank */: if(options.sheetStubs) {&#13;
					for(var _j = val.c; _j &lt;= val.C; ++_j) {&#13;
						var _ixfe = val.ixfe[_j-val.c];&#13;
						temp_val= ({ixfe:_ixfe, XF:XFs[_ixfe], t:'z'});&#13;
						if(BIFF2Fmt &gt; 0) temp_val.z = BIFF2FmtTable[(temp_val.ixfe&gt;&gt;8) &amp; 0x3F];&#13;
						safe_format_xf(temp_val, options, wb.opts.Date1904);&#13;
						addcell({c:_j, r:val.r}, temp_val, options);&#13;
					}&#13;
				} break;&#13;
				case 0x00d6 /* RString */:&#13;
				case 0x0204 /* Label */: case 0x0004 /* BIFF2STR */:&#13;
					temp_val=make_cell(val.val, val.ixfe, 's');&#13;
					temp_val.XF = XFs[temp_val.ixfe];&#13;
					if(BIFF2Fmt &gt; 0) temp_val.z = BIFF2FmtTable[(temp_val.ixfe&gt;&gt;8) &amp; 0x3F];&#13;
					safe_format_xf(temp_val, options, wb.opts.Date1904);&#13;
					addcell({c:val.c, r:val.r}, temp_val, options);&#13;
					break;&#13;
&#13;
				case 0x0000: case 0x0200 /* Dimensions */: {&#13;
					if(file_depth === 1) range = val; /* TODO: stack */&#13;
				} break;&#13;
				case 0x00fc /* SST */: {&#13;
					sst = val;&#13;
				} break;&#13;
				case 0x041e /* Format */: { /* val = [id, fmt] */&#13;
					if(opts.biff == 4) {&#13;
						BIFF2FmtTable[BIFF2Fmt++] = val[1];&#13;
						for(var b4idx = 0; b4idx &lt; BIFF2Fmt + 163; ++b4idx) if(table_fmt[b4idx] == val[1]) break;&#13;
						if(b4idx &gt;= 163) SSF__load(val[1], BIFF2Fmt + 163);&#13;
					}&#13;
					else SSF__load(val[1], val[0]);&#13;
				} break;&#13;
				case 0x001e /* BIFF2FORMAT */: {&#13;
					BIFF2FmtTable[BIFF2Fmt++] = val;&#13;
					for(var b2idx = 0; b2idx &lt; BIFF2Fmt + 163; ++b2idx) if(table_fmt[b2idx] == val) break;&#13;
					if(b2idx &gt;= 163) SSF__load(val, BIFF2Fmt + 163);&#13;
				} break;&#13;
&#13;
				case 0x00e5 /* MergeCells */: merges = merges.concat(val); break;&#13;
&#13;
				case 0x005d /* Obj */: objects[val.cmo[0]] = opts.lastobj = val; break;&#13;
				case 0x01b6 /* TxO */: opts.lastobj.TxO = val; break;&#13;
				case 0x007f /* ImData */: opts.lastobj.ImData = val; break;&#13;
&#13;
				case 0x01b8 /* HLink */: {&#13;
					for(rngR = val[0].s.r; rngR &lt;= val[0].e.r; ++rngR)&#13;
						for(rngC = val[0].s.c; rngC &lt;= val[0].e.c; ++rngC) {&#13;
							cc = options.dense ? (out[rngR]||[])[rngC] : out[encode_cell({c:rngC,r:rngR})];&#13;
							if(cc) cc.l = val[1];&#13;
						}&#13;
				} break;&#13;
				case 0x0800 /* HLinkTooltip */: {&#13;
					for(rngR = val[0].s.r; rngR &lt;= val[0].e.r; ++rngR)&#13;
						for(rngC = val[0].s.c; rngC &lt;= val[0].e.c; ++rngC) {&#13;
							cc = options.dense ? (out[rngR]||[])[rngC] : out[encode_cell({c:rngC,r:rngR})];&#13;
							if(cc &amp;&amp; cc.l) cc.l.Tooltip = val[1];&#13;
							}&#13;
				} break;&#13;
				case 0x001c /* Note */: {&#13;
					if(opts.biff &lt;= 5 &amp;&amp; opts.biff &gt;= 2) break; /* TODO: BIFF5 */&#13;
					cc = options.dense ? (out[val[0].r]||[])[val[0].c] : out[encode_cell(val[0])];&#13;
					var noteobj = objects[val[2]];&#13;
					if(!cc) {&#13;
						if(options.dense) {&#13;
							if(!out[val[0].r]) out[val[0].r] = [];&#13;
							cc = out[val[0].r][val[0].c] = ({t:"z"});&#13;
						} else {&#13;
							cc = out[encode_cell(val[0])] = ({t:"z"});&#13;
						}&#13;
						range.e.r = Math.max(range.e.r, val[0].r);&#13;
						range.s.r = Math.min(range.s.r, val[0].r);&#13;
						range.e.c = Math.max(range.e.c, val[0].c);&#13;
						range.s.c = Math.min(range.s.c, val[0].c);&#13;
					}&#13;
					if(!cc.c) cc.c = [];&#13;
					cmnt = {a:val[1],t:noteobj.TxO.t};&#13;
					cc.c.push(cmnt);&#13;
				} break;&#13;
				case 0x087d /* XFExt */: update_xfext(XFs[val.ixfe], val.ext); break;&#13;
				case 0x007d /* ColInfo */: {&#13;
					if(!opts.cellStyles) break;&#13;
					while(val.e &gt;= val.s) {&#13;
						colinfo[val.e--] = { width: val.w/256, level: (val.level || 0), hidden: !!(val.flags &amp; 1) };&#13;
						if(!seencol) { seencol = true; find_mdw_colw(val.w/256); }&#13;
						process_col(colinfo[val.e+1]);&#13;
					}&#13;
				} break;&#13;
				case 0x0208 /* Row */: {&#13;
					var rowobj = {};&#13;
					if(val.level != null) { rowinfo[val.r] = rowobj; rowobj.level = val.level; }&#13;
					if(val.hidden) { rowinfo[val.r] = rowobj; rowobj.hidden = true; }&#13;
					if(val.hpt) {&#13;
						rowinfo[val.r] = rowobj;&#13;
						rowobj.hpt = val.hpt; rowobj.hpx = pt2px(val.hpt);&#13;
					}&#13;
				} break;&#13;
				case 0x0026 /* LeftMargin */:&#13;
				case 0x0027 /* RightMargin */:&#13;
				case 0x0028 /* TopMargin */:&#13;
				case 0x0029 /* BottomMargin */:&#13;
					if(!out['!margins']) default_margins(out['!margins'] = {});&#13;
					out['!margins'][({0x26: "left", 0x27:"right", 0x28:"top", 0x29:"bottom"})[RecordType]] = val;&#13;
					break;&#13;
				case 0x00a1 /* Setup */: // TODO&#13;
					if(!out['!margins']) default_margins(out['!margins'] = {});&#13;
					out['!margins'].header = val.header;&#13;
					out['!margins'].footer = val.footer;&#13;
					break;&#13;
				case 0x023e /* Window2 */: // TODO&#13;
					// $FlowIgnore&#13;
					if(val.RTL) Workbook.Views[0].RTL = true;&#13;
					break;&#13;
				case 0x0092 /* Palette */: palette = val; break;&#13;
				case 0x0896 /* Theme */: themes = val; break;&#13;
				case 0x008c /* Country */: country = val; break;&#13;
				case 0x01ba /* CodeName */: {&#13;
if(!cur_sheet) Workbook.WBProps.CodeName = val || "ThisWorkbook";&#13;
					else wsprops.CodeName = val || wsprops.name;&#13;
				} break;&#13;
			}&#13;
		} else {&#13;
			if(!R) console.error("Missing Info for XLS Record 0x" + RecordType.toString(16));&#13;
			blob.l += length;&#13;
		}&#13;
	}&#13;
	wb.SheetNames=keys(Directory).sort(function(a,b) { return Number(a) - Number(b); }).map(function(x){return Directory[x].name;});&#13;
	if(!options.bookSheets) wb.Sheets=Sheets;&#13;
	if(!wb.SheetNames.length &amp;&amp; Preamble["!ref"]) {&#13;
		wb.SheetNames.push("Sheet1");&#13;
		/*jshint -W069 */&#13;
		if(wb.Sheets) wb.Sheets["Sheet1"] = Preamble;&#13;
		/*jshint +W069 */&#13;
	} else wb.Preamble=Preamble;&#13;
	if(wb.Sheets) FilterDatabases.forEach(function(r,i) { wb.Sheets[wb.SheetNames[i]]['!autofilter'] = r; });&#13;
	wb.Strings = sst;&#13;
	wb.SSF = dup(table_fmt);&#13;
	if(opts.enc) wb.Encryption = opts.enc;&#13;
	if(themes) wb.Themes = themes;&#13;
	wb.Metadata = {};&#13;
	if(country !== undefined) wb.Metadata.Country = country;&#13;
	if(supbooks.names.length &gt; 0) Workbook.Names = supbooks.names;&#13;
	wb.Workbook = Workbook;&#13;
	return wb;&#13;
}&#13;
&#13;
/* TODO: split props*/&#13;
var PSCLSID = {&#13;
	SI: "e0859ff2f94f6810ab9108002b27b3d9",&#13;
	DSI: "02d5cdd59c2e1b10939708002b2cf9ae",&#13;
	UDI: "05d5cdd59c2e1b10939708002b2cf9ae"&#13;
};&#13;
function parse_xls_props(cfb, props, o) {&#13;
	/* [MS-OSHARED] 2.3.3.2.2 Document Summary Information Property Set */&#13;
	var DSI = CFB.find(cfb, '/!DocumentSummaryInformation');&#13;
	if(DSI &amp;&amp; DSI.size &gt; 0) try {&#13;
		var DocSummary = parse_PropertySetStream(DSI, DocSummaryPIDDSI, PSCLSID.DSI);&#13;
		for(var d in DocSummary) props[d] = DocSummary[d];&#13;
	} catch(e) {if(o.WTF) throw e;/* empty */}&#13;
&#13;
	/* [MS-OSHARED] 2.3.3.2.1 Summary Information Property Set*/&#13;
	var SI = CFB.find(cfb, '/!SummaryInformation');&#13;
	if(SI &amp;&amp; SI.size &gt; 0) try {&#13;
		var Summary = parse_PropertySetStream(SI, SummaryPIDSI, PSCLSID.SI);&#13;
		for(var s in Summary) if(props[s] == null) props[s] = Summary[s];&#13;
	} catch(e) {if(o.WTF) throw e;/* empty */}&#13;
&#13;
	if(props.HeadingPairs &amp;&amp; props.TitlesOfParts) {&#13;
		load_props_pairs(props.HeadingPairs, props.TitlesOfParts, props, o);&#13;
		delete props.HeadingPairs; delete props.TitlesOfParts;&#13;
	}&#13;
}&#13;
function write_xls_props(wb, cfb) {&#13;
	var DSEntries = [], SEntries = [], CEntries = [];&#13;
	var i = 0, Keys;&#13;
	var DocSummaryRE = evert_key(DocSummaryPIDDSI, "n");&#13;
	var SummaryRE = evert_key(SummaryPIDSI, "n");&#13;
	if(wb.Props) {&#13;
		Keys = keys(wb.Props);&#13;
		// $FlowIgnore&#13;
		for(i = 0; i &lt; Keys.length; ++i) (Object.prototype.hasOwnProperty.call(DocSummaryRE, Keys[i]) ? DSEntries : Object.prototype.hasOwnProperty.call(SummaryRE, Keys[i]) ? SEntries : CEntries).push([Keys[i], wb.Props[Keys[i]]]);&#13;
	}&#13;
	if(wb.Custprops) {&#13;
		Keys = keys(wb.Custprops);&#13;
		// $FlowIgnore&#13;
		for(i = 0; i &lt; Keys.length; ++i) if(!Object.prototype.hasOwnProperty.call((wb.Props||{}), Keys[i])) (Object.prototype.hasOwnProperty.call(DocSummaryRE, Keys[i]) ? DSEntries : Object.prototype.hasOwnProperty.call(SummaryRE, Keys[i]) ? SEntries : CEntries).push([Keys[i], wb.Custprops[Keys[i]]]);&#13;
	}&#13;
	var CEntries2 = [];&#13;
	for(i = 0; i &lt; CEntries.length; ++i) {&#13;
		if(XLSPSSkip.indexOf(CEntries[i][0]) &gt; -1 || PseudoPropsPairs.indexOf(CEntries[i][0]) &gt; -1) continue;&#13;
		if(CEntries[i][1] == null) continue;&#13;
		CEntries2.push(CEntries[i]);&#13;
	}&#13;
	if(SEntries.length) CFB.utils.cfb_add(cfb, "/\u0005SummaryInformation", write_PropertySetStream(SEntries, PSCLSID.SI, SummaryRE, SummaryPIDSI));&#13;
	if(DSEntries.length || CEntries2.length) CFB.utils.cfb_add(cfb, "/\u0005DocumentSummaryInformation", write_PropertySetStream(DSEntries, PSCLSID.DSI, DocSummaryRE, DocSummaryPIDDSI, CEntries2.length ? CEntries2 : null, PSCLSID.UDI));&#13;
}&#13;
&#13;
function parse_xlscfb(cfb, options) {&#13;
if(!options) options = {};&#13;
fix_read_opts(options);&#13;
reset_cp();&#13;
if(options.codepage) set_ansi(options.codepage);&#13;
var CompObj, WB;&#13;
if(cfb.FullPaths) {&#13;
	if(CFB.find(cfb, '/encryption')) throw new Error("File is password-protected");&#13;
	CompObj = CFB.find(cfb, '!CompObj');&#13;
	WB = CFB.find(cfb, '/Workbook') || CFB.find(cfb, '/Book');&#13;
} else {&#13;
	switch(options.type) {&#13;
		case 'base64': cfb = s2a(Base64_decode(cfb)); break;&#13;
		case 'binary': cfb = s2a(cfb); break;&#13;
		case 'buffer': break;&#13;
		case 'array': if(!Array.isArray(cfb)) cfb = Array.prototype.slice.call(cfb); break;&#13;
	}&#13;
	prep_blob(cfb, 0);&#13;
	WB = ({content: cfb});&#13;
}&#13;
var WorkbookP;&#13;
&#13;
var _data;&#13;
if(CompObj) parse_compobj(CompObj);&#13;
if(options.bookProps &amp;&amp; !options.bookSheets) WorkbookP = ({});&#13;
else {&#13;
	var T = has_buf ? 'buffer' : 'array';&#13;
	if(WB &amp;&amp; WB.content) WorkbookP = parse_workbook(WB.content, options);&#13;
	/* Quattro Pro 7-8 */&#13;
	else if((_data=CFB.find(cfb, 'PerfectOffice_MAIN')) &amp;&amp; _data.content) WorkbookP = WK_.to_workbook(_data.content, (options.type = T, options));&#13;
	/* Quattro Pro 9 */&#13;
	else if((_data=CFB.find(cfb, 'NativeContent_MAIN')) &amp;&amp; _data.content) WorkbookP = WK_.to_workbook(_data.content, (options.type = T, options));&#13;
	/* Works 4 for Mac */&#13;
	else if((_data=CFB.find(cfb, 'MN0')) &amp;&amp; _data.content) throw new Error("Unsupported Works 4 for Mac file");&#13;
	else throw new Error("Cannot find Workbook stream");&#13;
	if(options.bookVBA &amp;&amp; cfb.FullPaths &amp;&amp; CFB.find(cfb, '/_VBA_PROJECT_CUR/VBA/dir')) WorkbookP.vbaraw = make_vba_xls(cfb);&#13;
}&#13;
&#13;
var props = {};&#13;
if(cfb.FullPaths) parse_xls_props(cfb, props, options);&#13;
&#13;
WorkbookP.Props = WorkbookP.Custprops = props; /* TODO: split up properties */&#13;
if(options.bookFiles) WorkbookP.cfb = cfb;&#13;
/*WorkbookP.CompObjP = CompObjP; // TODO: storage? */&#13;
return WorkbookP;&#13;
}&#13;
&#13;
&#13;
function write_xlscfb(wb, opts) {&#13;
	var o = opts || {};&#13;
	var cfb = CFB.utils.cfb_new({root:"R"});&#13;
	var wbpath = "/Workbook";&#13;
	switch(o.bookType || "xls") {&#13;
		case "xls": o.bookType = "biff8";&#13;
		/* falls through */&#13;
		case "xla": if(!o.bookType) o.bookType = "xla";&#13;
		/* falls through */&#13;
		case "biff8": wbpath = "/Workbook"; o.biff = 8; break;&#13;
		case "biff5": wbpath = "/Book"; o.biff = 5; break;&#13;
		default: throw new Error("invalid type " + o.bookType + " for XLS CFB");&#13;
	}&#13;
	CFB.utils.cfb_add(cfb, wbpath, write_biff_buf(wb, o));&#13;
	if(o.biff == 8 &amp;&amp; (wb.Props || wb.Custprops)) write_xls_props(wb, cfb);&#13;
	// TODO: SI, DSI, CO&#13;
	if(o.biff == 8 &amp;&amp; wb.vbaraw) fill_vba_xls(cfb, CFB.read(wb.vbaraw, {type: typeof wb.vbaraw == "string" ? "binary" : "buffer"}));&#13;
	return cfb;&#13;
}&#13;
/* [MS-XLSB] 2.3 Record Enumeration */&#13;
var XLSBRecordEnum = {&#13;
0x0000: { /* n:"BrtRowHdr", */ f:parse_BrtRowHdr },&#13;
0x0001: { /* n:"BrtCellBlank", */ f:parse_BrtCellBlank },&#13;
0x0002: { /* n:"BrtCellRk", */ f:parse_BrtCellRk },&#13;
0x0003: { /* n:"BrtCellError", */ f:parse_BrtCellError },&#13;
0x0004: { /* n:"BrtCellBool", */ f:parse_BrtCellBool },&#13;
0x0005: { /* n:"BrtCellReal", */ f:parse_BrtCellReal },&#13;
0x0006: { /* n:"BrtCellSt", */ f:parse_BrtCellSt },&#13;
0x0007: { /* n:"BrtCellIsst", */ f:parse_BrtCellIsst },&#13;
0x0008: { /* n:"BrtFmlaString", */ f:parse_BrtFmlaString },&#13;
0x0009: { /* n:"BrtFmlaNum", */ f:parse_BrtFmlaNum },&#13;
0x000A: { /* n:"BrtFmlaBool", */ f:parse_BrtFmlaBool },&#13;
0x000B: { /* n:"BrtFmlaError", */ f:parse_BrtFmlaError },&#13;
0x000C: { /* n:"BrtShortBlank", */ f:parse_BrtShortBlank },&#13;
0x000D: { /* n:"BrtShortRk", */ f:parse_BrtShortRk },&#13;
0x000E: { /* n:"BrtShortError", */ f:parse_BrtShortError },&#13;
0x000F: { /* n:"BrtShortBool", */ f:parse_BrtShortBool },&#13;
0x0010: { /* n:"BrtShortReal", */ f:parse_BrtShortReal },&#13;
0x0011: { /* n:"BrtShortSt", */ f:parse_BrtShortSt },&#13;
0x0012: { /* n:"BrtShortIsst", */ f:parse_BrtShortIsst },&#13;
0x0013: { /* n:"BrtSSTItem", */ f:parse_RichStr },&#13;
0x0014: { /* n:"BrtPCDIMissing" */ },&#13;
0x0015: { /* n:"BrtPCDINumber" */ },&#13;
0x0016: { /* n:"BrtPCDIBoolean" */ },&#13;
0x0017: { /* n:"BrtPCDIError" */ },&#13;
0x0018: { /* n:"BrtPCDIString" */ },&#13;
0x0019: { /* n:"BrtPCDIDatetime" */ },&#13;
0x001A: { /* n:"BrtPCDIIndex" */ },&#13;
0x001B: { /* n:"BrtPCDIAMissing" */ },&#13;
0x001C: { /* n:"BrtPCDIANumber" */ },&#13;
0x001D: { /* n:"BrtPCDIABoolean" */ },&#13;
0x001E: { /* n:"BrtPCDIAError" */ },&#13;
0x001F: { /* n:"BrtPCDIAString" */ },&#13;
0x0020: { /* n:"BrtPCDIADatetime" */ },&#13;
0x0021: { /* n:"BrtPCRRecord" */ },&#13;
0x0022: { /* n:"BrtPCRRecordDt" */ },&#13;
0x0023: { /* n:"BrtFRTBegin", */ T:1 },&#13;
0x0024: { /* n:"BrtFRTEnd", */ T:-1 },&#13;
0x0025: { /* n:"BrtACBegin", */ T:1 },&#13;
0x0026: { /* n:"BrtACEnd", */ T:-1 },&#13;
0x0027: { /* n:"BrtName", */ f:parse_BrtName },&#13;
0x0028: { /* n:"BrtIndexRowBlock" */ },&#13;
0x002A: { /* n:"BrtIndexBlock" */ },&#13;
0x002B: { /* n:"BrtFont", */ f:parse_BrtFont },&#13;
0x002C: { /* n:"BrtFmt", */ f:parse_BrtFmt },&#13;
0x002D: { /* n:"BrtFill", */ f:parse_BrtFill },&#13;
0x002E: { /* n:"BrtBorder", */ f:parse_BrtBorder },&#13;
0x002F: { /* n:"BrtXF", */ f:parse_BrtXF },&#13;
0x0030: { /* n:"BrtStyle" */ },&#13;
0x0031: { /* n:"BrtCellMeta", */ f:parse_Int32LE },&#13;
0x0032: { /* n:"BrtValueMeta" */ },&#13;
0x0033: { /* n:"BrtMdb" */ f:parse_BrtMdb },&#13;
0x0034: { /* n:"BrtBeginFmd", */ T:1 },&#13;
0x0035: { /* n:"BrtEndFmd", */ T:-1 },&#13;
0x0036: { /* n:"BrtBeginMdx", */ T:1 },&#13;
0x0037: { /* n:"BrtEndMdx", */ T:-1 },&#13;
0x0038: { /* n:"BrtBeginMdxTuple", */ T:1 },&#13;
0x0039: { /* n:"BrtEndMdxTuple", */ T:-1 },&#13;
0x003A: { /* n:"BrtMdxMbrIstr" */ },&#13;
0x003B: { /* n:"BrtStr" */ },&#13;
0x003C: { /* n:"BrtColInfo", */ f:parse_ColInfo },&#13;
0x003E: { /* n:"BrtCellRString", */ f:parse_BrtCellRString },&#13;
0x003F: { /* n:"BrtCalcChainItem$", */ f:parse_BrtCalcChainItem$ },&#13;
0x0040: { /* n:"BrtDVal", */ f:parse_BrtDVal },&#13;
0x0041: { /* n:"BrtSxvcellNum" */ },&#13;
0x0042: { /* n:"BrtSxvcellStr" */ },&#13;
0x0043: { /* n:"BrtSxvcellBool" */ },&#13;
0x0044: { /* n:"BrtSxvcellErr" */ },&#13;
0x0045: { /* n:"BrtSxvcellDate" */ },&#13;
0x0046: { /* n:"BrtSxvcellNil" */ },&#13;
0x0080: { /* n:"BrtFileVersion" */ },&#13;
0x0081: { /* n:"BrtBeginSheet", */ T:1 },&#13;
0x0082: { /* n:"BrtEndSheet", */ T:-1 },&#13;
0x0083: { /* n:"BrtBeginBook", */ T:1, f:parsenoop, p:0 },&#13;
0x0084: { /* n:"BrtEndBook", */ T:-1 },&#13;
0x0085: { /* n:"BrtBeginWsViews", */ T:1 },&#13;
0x0086: { /* n:"BrtEndWsViews", */ T:-1 },&#13;
0x0087: { /* n:"BrtBeginBookViews", */ T:1 },&#13;
0x0088: { /* n:"BrtEndBookViews", */ T:-1 },&#13;
0x0089: { /* n:"BrtBeginWsView", */ T:1, f:parse_BrtBeginWsView },&#13;
0x008A: { /* n:"BrtEndWsView", */ T:-1 },&#13;
0x008B: { /* n:"BrtBeginCsViews", */ T:1 },&#13;
0x008C: { /* n:"BrtEndCsViews", */ T:-1 },&#13;
0x008D: { /* n:"BrtBeginCsView", */ T:1 },&#13;
0x008E: { /* n:"BrtEndCsView", */ T:-1 },&#13;
0x008F: { /* n:"BrtBeginBundleShs", */ T:1 },&#13;
0x0090: { /* n:"BrtEndBundleShs", */ T:-1 },&#13;
0x0091: { /* n:"BrtBeginSheetData", */ T:1 },&#13;
0x0092: { /* n:"BrtEndSheetData", */ T:-1 },&#13;
0x0093: { /* n:"BrtWsProp", */ f:parse_BrtWsProp },&#13;
0x0094: { /* n:"BrtWsDim", */ f:parse_BrtWsDim, p:16 },&#13;
0x0097: { /* n:"BrtPane", */ f:parse_BrtPane },&#13;
0x0098: { /* n:"BrtSel" */ },&#13;
0x0099: { /* n:"BrtWbProp", */ f:parse_BrtWbProp },&#13;
0x009A: { /* n:"BrtWbFactoid" */ },&#13;
0x009B: { /* n:"BrtFileRecover" */ },&#13;
0x009C: { /* n:"BrtBundleSh", */ f:parse_BrtBundleSh },&#13;
0x009D: { /* n:"BrtCalcProp" */ },&#13;
0x009E: { /* n:"BrtBookView" */ },&#13;
0x009F: { /* n:"BrtBeginSst", */ T:1, f:parse_BrtBeginSst },&#13;
0x00A0: { /* n:"BrtEndSst", */ T:-1 },&#13;
0x00A1: { /* n:"BrtBeginAFilter", */ T:1, f:parse_UncheckedRfX },&#13;
0x00A2: { /* n:"BrtEndAFilter", */ T:-1 },&#13;
0x00A3: { /* n:"BrtBeginFilterColumn", */ T:1 },&#13;
0x00A4: { /* n:"BrtEndFilterColumn", */ T:-1 },&#13;
0x00A5: { /* n:"BrtBeginFilters", */ T:1 },&#13;
0x00A6: { /* n:"BrtEndFilters", */ T:-1 },&#13;
0x00A7: { /* n:"BrtFilter" */ },&#13;
0x00A8: { /* n:"BrtColorFilter" */ },&#13;
0x00A9: { /* n:"BrtIconFilter" */ },&#13;
0x00AA: { /* n:"BrtTop10Filter" */ },&#13;
0x00AB: { /* n:"BrtDynamicFilter" */ },&#13;
0x00AC: { /* n:"BrtBeginCustomFilters", */ T:1 },&#13;
0x00AD: { /* n:"BrtEndCustomFilters", */ T:-1 },&#13;
0x00AE: { /* n:"BrtCustomFilter" */ },&#13;
0x00AF: { /* n:"BrtAFilterDateGroupItem" */ },&#13;
0x00B0: { /* n:"BrtMergeCell", */ f:parse_BrtMergeCell },&#13;
0x00B1: { /* n:"BrtBeginMergeCells", */ T:1 },&#13;
0x00B2: { /* n:"BrtEndMergeCells", */ T:-1 },&#13;
0x00B3: { /* n:"BrtBeginPivotCacheDef", */ T:1 },&#13;
0x00B4: { /* n:"BrtEndPivotCacheDef", */ T:-1 },&#13;
0x00B5: { /* n:"BrtBeginPCDFields", */ T:1 },&#13;
0x00B6: { /* n:"BrtEndPCDFields", */ T:-1 },&#13;
0x00B7: { /* n:"BrtBeginPCDField", */ T:1 },&#13;
0x00B8: { /* n:"BrtEndPCDField", */ T:-1 },&#13;
0x00B9: { /* n:"BrtBeginPCDSource", */ T:1 },&#13;
0x00BA: { /* n:"BrtEndPCDSource", */ T:-1 },&#13;
0x00BB: { /* n:"BrtBeginPCDSRange", */ T:1 },&#13;
0x00BC: { /* n:"BrtEndPCDSRange", */ T:-1 },&#13;
0x00BD: { /* n:"BrtBeginPCDFAtbl", */ T:1 },&#13;
0x00BE: { /* n:"BrtEndPCDFAtbl", */ T:-1 },&#13;
0x00BF: { /* n:"BrtBeginPCDIRun", */ T:1 },&#13;
0x00C0: { /* n:"BrtEndPCDIRun", */ T:-1 },&#13;
0x00C1: { /* n:"BrtBeginPivotCacheRecords", */ T:1 },&#13;
0x00C2: { /* n:"BrtEndPivotCacheRecords", */ T:-1 },&#13;
0x00C3: { /* n:"BrtBeginPCDHierarchies", */ T:1 },&#13;
0x00C4: { /* n:"BrtEndPCDHierarchies", */ T:-1 },&#13;
0x00C5: { /* n:"BrtBeginPCDHierarchy", */ T:1 },&#13;
0x00C6: { /* n:"BrtEndPCDHierarchy", */ T:-1 },&#13;
0x00C7: { /* n:"BrtBeginPCDHFieldsUsage", */ T:1 },&#13;
0x00C8: { /* n:"BrtEndPCDHFieldsUsage", */ T:-1 },&#13;
0x00C9: { /* n:"BrtBeginExtConnection", */ T:1 },&#13;
0x00CA: { /* n:"BrtEndExtConnection", */ T:-1 },&#13;
0x00CB: { /* n:"BrtBeginECDbProps", */ T:1 },&#13;
0x00CC: { /* n:"BrtEndECDbProps", */ T:-1 },&#13;
0x00CD: { /* n:"BrtBeginECOlapProps", */ T:1 },&#13;
0x00CE: { /* n:"BrtEndECOlapProps", */ T:-1 },&#13;
0x00CF: { /* n:"BrtBeginPCDSConsol", */ T:1 },&#13;
0x00D0: { /* n:"BrtEndPCDSConsol", */ T:-1 },&#13;
0x00D1: { /* n:"BrtBeginPCDSCPages", */ T:1 },&#13;
0x00D2: { /* n:"BrtEndPCDSCPages", */ T:-1 },&#13;
0x00D3: { /* n:"BrtBeginPCDSCPage", */ T:1 },&#13;
0x00D4: { /* n:"BrtEndPCDSCPage", */ T:-1 },&#13;
0x00D5: { /* n:"BrtBeginPCDSCPItem", */ T:1 },&#13;
0x00D6: { /* n:"BrtEndPCDSCPItem", */ T:-1 },&#13;
0x00D7: { /* n:"BrtBeginPCDSCSets", */ T:1 },&#13;
0x00D8: { /* n:"BrtEndPCDSCSets", */ T:-1 },&#13;
0x00D9: { /* n:"BrtBeginPCDSCSet", */ T:1 },&#13;
0x00DA: { /* n:"BrtEndPCDSCSet", */ T:-1 },&#13;
0x00DB: { /* n:"BrtBeginPCDFGroup", */ T:1 },&#13;
0x00DC: { /* n:"BrtEndPCDFGroup", */ T:-1 },&#13;
0x00DD: { /* n:"BrtBeginPCDFGItems", */ T:1 },&#13;
0x00DE: { /* n:"BrtEndPCDFGItems", */ T:-1 },&#13;
0x00DF: { /* n:"BrtBeginPCDFGRange", */ T:1 },&#13;
0x00E0: { /* n:"BrtEndPCDFGRange", */ T:-1 },&#13;
0x00E1: { /* n:"BrtBeginPCDFGDiscrete", */ T:1 },&#13;
0x00E2: { /* n:"BrtEndPCDFGDiscrete", */ T:-1 },&#13;
0x00E3: { /* n:"BrtBeginPCDSDTupleCache", */ T:1 },&#13;
0x00E4: { /* n:"BrtEndPCDSDTupleCache", */ T:-1 },&#13;
0x00E5: { /* n:"BrtBeginPCDSDTCEntries", */ T:1 },&#13;
0x00E6: { /* n:"BrtEndPCDSDTCEntries", */ T:-1 },&#13;
0x00E7: { /* n:"BrtBeginPCDSDTCEMembers", */ T:1 },&#13;
0x00E8: { /* n:"BrtEndPCDSDTCEMembers", */ T:-1 },&#13;
0x00E9: { /* n:"BrtBeginPCDSDTCEMember", */ T:1 },&#13;
0x00EA: { /* n:"BrtEndPCDSDTCEMember", */ T:-1 },&#13;
0x00EB: { /* n:"BrtBeginPCDSDTCQueries", */ T:1 },&#13;
0x00EC: { /* n:"BrtEndPCDSDTCQueries", */ T:-1 },&#13;
0x00ED: { /* n:"BrtBeginPCDSDTCQuery", */ T:1 },&#13;
0x00EE: { /* n:"BrtEndPCDSDTCQuery", */ T:-1 },&#13;
0x00EF: { /* n:"BrtBeginPCDSDTCSets", */ T:1 },&#13;
0x00F0: { /* n:"BrtEndPCDSDTCSets", */ T:-1 },&#13;
0x00F1: { /* n:"BrtBeginPCDSDTCSet", */ T:1 },&#13;
0x00F2: { /* n:"BrtEndPCDSDTCSet", */ T:-1 },&#13;
0x00F3: { /* n:"BrtBeginPCDCalcItems", */ T:1 },&#13;
0x00F4: { /* n:"BrtEndPCDCalcItems", */ T:-1 },&#13;
0x00F5: { /* n:"BrtBeginPCDCalcItem", */ T:1 },&#13;
0x00F6: { /* n:"BrtEndPCDCalcItem", */ T:-1 },&#13;
0x00F7: { /* n:"BrtBeginPRule", */ T:1 },&#13;
0x00F8: { /* n:"BrtEndPRule", */ T:-1 },&#13;
0x00F9: { /* n:"BrtBeginPRFilters", */ T:1 },&#13;
0x00FA: { /* n:"BrtEndPRFilters", */ T:-1 },&#13;
0x00FB: { /* n:"BrtBeginPRFilter", */ T:1 },&#13;
0x00FC: { /* n:"BrtEndPRFilter", */ T:-1 },&#13;
0x00FD: { /* n:"BrtBeginPNames", */ T:1 },&#13;
0x00FE: { /* n:"BrtEndPNames", */ T:-1 },&#13;
0x00FF: { /* n:"BrtBeginPName", */ T:1 },&#13;
0x0100: { /* n:"BrtEndPName", */ T:-1 },&#13;
0x0101: { /* n:"BrtBeginPNPairs", */ T:1 },&#13;
0x0102: { /* n:"BrtEndPNPairs", */ T:-1 },&#13;
0x0103: { /* n:"BrtBeginPNPair", */ T:1 },&#13;
0x0104: { /* n:"BrtEndPNPair", */ T:-1 },&#13;
0x0105: { /* n:"BrtBeginECWebProps", */ T:1 },&#13;
0x0106: { /* n:"BrtEndECWebProps", */ T:-1 },&#13;
0x0107: { /* n:"BrtBeginEcWpTables", */ T:1 },&#13;
0x0108: { /* n:"BrtEndECWPTables", */ T:-1 },&#13;
0x0109: { /* n:"BrtBeginECParams", */ T:1 },&#13;
0x010A: { /* n:"BrtEndECParams", */ T:-1 },&#13;
0x010B: { /* n:"BrtBeginECParam", */ T:1 },&#13;
0x010C: { /* n:"BrtEndECParam", */ T:-1 },&#13;
0x010D: { /* n:"BrtBeginPCDKPIs", */ T:1 },&#13;
0x010E: { /* n:"BrtEndPCDKPIs", */ T:-1 },&#13;
0x010F: { /* n:"BrtBeginPCDKPI", */ T:1 },&#13;
0x0110: { /* n:"BrtEndPCDKPI", */ T:-1 },&#13;
0x0111: { /* n:"BrtBeginDims", */ T:1 },&#13;
0x0112: { /* n:"BrtEndDims", */ T:-1 },&#13;
0x0113: { /* n:"BrtBeginDim", */ T:1 },&#13;
0x0114: { /* n:"BrtEndDim", */ T:-1 },&#13;
0x0115: { /* n:"BrtIndexPartEnd" */ },&#13;
0x0116: { /* n:"BrtBeginStyleSheet", */ T:1 },&#13;
0x0117: { /* n:"BrtEndStyleSheet", */ T:-1 },&#13;
0x0118: { /* n:"BrtBeginSXView", */ T:1 },&#13;
0x0119: { /* n:"BrtEndSXVI", */ T:-1 },&#13;
0x011A: { /* n:"BrtBeginSXVI", */ T:1 },&#13;
0x011B: { /* n:"BrtBeginSXVIs", */ T:1 },&#13;
0x011C: { /* n:"BrtEndSXVIs", */ T:-1 },&#13;
0x011D: { /* n:"BrtBeginSXVD", */ T:1 },&#13;
0x011E: { /* n:"BrtEndSXVD", */ T:-1 },&#13;
0x011F: { /* n:"BrtBeginSXVDs", */ T:1 },&#13;
0x0120: { /* n:"BrtEndSXVDs", */ T:-1 },&#13;
0x0121: { /* n:"BrtBeginSXPI", */ T:1 },&#13;
0x0122: { /* n:"BrtEndSXPI", */ T:-1 },&#13;
0x0123: { /* n:"BrtBeginSXPIs", */ T:1 },&#13;
0x0124: { /* n:"BrtEndSXPIs", */ T:-1 },&#13;
0x0125: { /* n:"BrtBeginSXDI", */ T:1 },&#13;
0x0126: { /* n:"BrtEndSXDI", */ T:-1 },&#13;
0x0127: { /* n:"BrtBeginSXDIs", */ T:1 },&#13;
0x0128: { /* n:"BrtEndSXDIs", */ T:-1 },&#13;
0x0129: { /* n:"BrtBeginSXLI", */ T:1 },&#13;
0x012A: { /* n:"BrtEndSXLI", */ T:-1 },&#13;
0x012B: { /* n:"BrtBeginSXLIRws", */ T:1 },&#13;
0x012C: { /* n:"BrtEndSXLIRws", */ T:-1 },&#13;
0x012D: { /* n:"BrtBeginSXLICols", */ T:1 },&#13;
0x012E: { /* n:"BrtEndSXLICols", */ T:-1 },&#13;
0x012F: { /* n:"BrtBeginSXFormat", */ T:1 },&#13;
0x0130: { /* n:"BrtEndSXFormat", */ T:-1 },&#13;
0x0131: { /* n:"BrtBeginSXFormats", */ T:1 },&#13;
0x0132: { /* n:"BrtEndSxFormats", */ T:-1 },&#13;
0x0133: { /* n:"BrtBeginSxSelect", */ T:1 },&#13;
0x0134: { /* n:"BrtEndSxSelect", */ T:-1 },&#13;
0x0135: { /* n:"BrtBeginISXVDRws", */ T:1 },&#13;
0x0136: { /* n:"BrtEndISXVDRws", */ T:-1 },&#13;
0x0137: { /* n:"BrtBeginISXVDCols", */ T:1 },&#13;
0x0138: { /* n:"BrtEndISXVDCols", */ T:-1 },&#13;
0x0139: { /* n:"BrtEndSXLocation", */ T:-1 },&#13;
0x013A: { /* n:"BrtBeginSXLocation", */ T:1 },&#13;
0x013B: { /* n:"BrtEndSXView", */ T:-1 },&#13;
0x013C: { /* n:"BrtBeginSXTHs", */ T:1 },&#13;
0x013D: { /* n:"BrtEndSXTHs", */ T:-1 },&#13;
0x013E: { /* n:"BrtBeginSXTH", */ T:1 },&#13;
0x013F: { /* n:"BrtEndSXTH", */ T:-1 },&#13;
0x0140: { /* n:"BrtBeginISXTHRws", */ T:1 },&#13;
0x0141: { /* n:"BrtEndISXTHRws", */ T:-1 },&#13;
0x0142: { /* n:"BrtBeginISXTHCols", */ T:1 },&#13;
0x0143: { /* n:"BrtEndISXTHCols", */ T:-1 },&#13;
0x0144: { /* n:"BrtBeginSXTDMPS", */ T:1 },&#13;
0x0145: { /* n:"BrtEndSXTDMPs", */ T:-1 },&#13;
0x0146: { /* n:"BrtBeginSXTDMP", */ T:1 },&#13;
0x0147: { /* n:"BrtEndSXTDMP", */ T:-1 },&#13;
0x0148: { /* n:"BrtBeginSXTHItems", */ T:1 },&#13;
0x0149: { /* n:"BrtEndSXTHItems", */ T:-1 },&#13;
0x014A: { /* n:"BrtBeginSXTHItem", */ T:1 },&#13;
0x014B: { /* n:"BrtEndSXTHItem", */ T:-1 },&#13;
0x014C: { /* n:"BrtBeginMetadata", */ T:1 },&#13;
0x014D: { /* n:"BrtEndMetadata", */ T:-1 },&#13;
0x014E: { /* n:"BrtBeginEsmdtinfo", */ T:1 },&#13;
0x014F: { /* n:"BrtMdtinfo", */ f:parse_BrtMdtinfo },&#13;
0x0150: { /* n:"BrtEndEsmdtinfo", */ T:-1 },&#13;
0x0151: { /* n:"BrtBeginEsmdb", */ f:parse_BrtBeginEsmdb, T:1 },&#13;
0x0152: { /* n:"BrtEndEsmdb", */ T:-1 },&#13;
0x0153: { /* n:"BrtBeginEsfmd", */ T:1 },&#13;
0x0154: { /* n:"BrtEndEsfmd", */ T:-1 },&#13;
0x0155: { /* n:"BrtBeginSingleCells", */ T:1 },&#13;
0x0156: { /* n:"BrtEndSingleCells", */ T:-1 },&#13;
0x0157: { /* n:"BrtBeginList", */ T:1 },&#13;
0x0158: { /* n:"BrtEndList", */ T:-1 },&#13;
0x0159: { /* n:"BrtBeginListCols", */ T:1 },&#13;
0x015A: { /* n:"BrtEndListCols", */ T:-1 },&#13;
0x015B: { /* n:"BrtBeginListCol", */ T:1 },&#13;
0x015C: { /* n:"BrtEndListCol", */ T:-1 },&#13;
0x015D: { /* n:"BrtBeginListXmlCPr", */ T:1 },&#13;
0x015E: { /* n:"BrtEndListXmlCPr", */ T:-1 },&#13;
0x015F: { /* n:"BrtListCCFmla" */ },&#13;
0x0160: { /* n:"BrtListTrFmla" */ },&#13;
0x0161: { /* n:"BrtBeginExternals", */ T:1 },&#13;
0x0162: { /* n:"BrtEndExternals", */ T:-1 },&#13;
0x0163: { /* n:"BrtSupBookSrc", */ f:parse_RelID},&#13;
0x0165: { /* n:"BrtSupSelf" */ },&#13;
0x0166: { /* n:"BrtSupSame" */ },&#13;
0x0167: { /* n:"BrtSupTabs" */ },&#13;
0x0168: { /* n:"BrtBeginSupBook", */ T:1 },&#13;
0x0169: { /* n:"BrtPlaceholderName" */ },&#13;
0x016A: { /* n:"BrtExternSheet", */ f:parse_ExternSheet },&#13;
0x016B: { /* n:"BrtExternTableStart" */ },&#13;
0x016C: { /* n:"BrtExternTableEnd" */ },&#13;
0x016E: { /* n:"BrtExternRowHdr" */ },&#13;
0x016F: { /* n:"BrtExternCellBlank" */ },&#13;
0x0170: { /* n:"BrtExternCellReal" */ },&#13;
0x0171: { /* n:"BrtExternCellBool" */ },&#13;
0x0172: { /* n:"BrtExternCellError" */ },&#13;
0x0173: { /* n:"BrtExternCellString" */ },&#13;
0x0174: { /* n:"BrtBeginEsmdx", */ T:1 },&#13;
0x0175: { /* n:"BrtEndEsmdx", */ T:-1 },&#13;
0x0176: { /* n:"BrtBeginMdxSet", */ T:1 },&#13;
0x0177: { /* n:"BrtEndMdxSet", */ T:-1 },&#13;
0x0178: { /* n:"BrtBeginMdxMbrProp", */ T:1 },&#13;
0x0179: { /* n:"BrtEndMdxMbrProp", */ T:-1 },&#13;
0x017A: { /* n:"BrtBeginMdxKPI", */ T:1 },&#13;
0x017B: { /* n:"BrtEndMdxKPI", */ T:-1 },&#13;
0x017C: { /* n:"BrtBeginEsstr", */ T:1 },&#13;
0x017D: { /* n:"BrtEndEsstr", */ T:-1 },&#13;
0x017E: { /* n:"BrtBeginPRFItem", */ T:1 },&#13;
0x017F: { /* n:"BrtEndPRFItem", */ T:-1 },&#13;
0x0180: { /* n:"BrtBeginPivotCacheIDs", */ T:1 },&#13;
0x0181: { /* n:"BrtEndPivotCacheIDs", */ T:-1 },&#13;
0x0182: { /* n:"BrtBeginPivotCacheID", */ T:1 },&#13;
0x0183: { /* n:"BrtEndPivotCacheID", */ T:-1 },&#13;
0x0184: { /* n:"BrtBeginISXVIs", */ T:1 },&#13;
0x0185: { /* n:"BrtEndISXVIs", */ T:-1 },&#13;
0x0186: { /* n:"BrtBeginColInfos", */ T:1 },&#13;
0x0187: { /* n:"BrtEndColInfos", */ T:-1 },&#13;
0x0188: { /* n:"BrtBeginRwBrk", */ T:1 },&#13;
0x0189: { /* n:"BrtEndRwBrk", */ T:-1 },&#13;
0x018A: { /* n:"BrtBeginColBrk", */ T:1 },&#13;
0x018B: { /* n:"BrtEndColBrk", */ T:-1 },&#13;
0x018C: { /* n:"BrtBrk" */ },&#13;
0x018D: { /* n:"BrtUserBookView" */ },&#13;
0x018E: { /* n:"BrtInfo" */ },&#13;
0x018F: { /* n:"BrtCUsr" */ },&#13;
0x0190: { /* n:"BrtUsr" */ },&#13;
0x0191: { /* n:"BrtBeginUsers", */ T:1 },&#13;
0x0193: { /* n:"BrtEOF" */ },&#13;
0x0194: { /* n:"BrtUCR" */ },&#13;
0x0195: { /* n:"BrtRRInsDel" */ },&#13;
0x0196: { /* n:"BrtRREndInsDel" */ },&#13;
0x0197: { /* n:"BrtRRMove" */ },&#13;
0x0198: { /* n:"BrtRREndMove" */ },&#13;
0x0199: { /* n:"BrtRRChgCell" */ },&#13;
0x019A: { /* n:"BrtRREndChgCell" */ },&#13;
0x019B: { /* n:"BrtRRHeader" */ },&#13;
0x019C: { /* n:"BrtRRUserView" */ },&#13;
0x019D: { /* n:"BrtRRRenSheet" */ },&#13;
0x019E: { /* n:"BrtRRInsertSh" */ },&#13;
0x019F: { /* n:"BrtRRDefName" */ },&#13;
0x01A0: { /* n:"BrtRRNote" */ },&#13;
0x01A1: { /* n:"BrtRRConflict" */ },&#13;
0x01A2: { /* n:"BrtRRTQSIF" */ },&#13;
0x01A3: { /* n:"BrtRRFormat" */ },&#13;
0x01A4: { /* n:"BrtRREndFormat" */ },&#13;
0x01A5: { /* n:"BrtRRAutoFmt" */ },&#13;
0x01A6: { /* n:"BrtBeginUserShViews", */ T:1 },&#13;
0x01A7: { /* n:"BrtBeginUserShView", */ T:1 },&#13;
0x01A8: { /* n:"BrtEndUserShView", */ T:-1 },&#13;
0x01A9: { /* n:"BrtEndUserShViews", */ T:-1 },&#13;
0x01AA: { /* n:"BrtArrFmla", */ f:parse_BrtArrFmla },&#13;
0x01AB: { /* n:"BrtShrFmla", */ f:parse_BrtShrFmla },&#13;
0x01AC: { /* n:"BrtTable" */ },&#13;
0x01AD: { /* n:"BrtBeginExtConnections", */ T:1 },&#13;
0x01AE: { /* n:"BrtEndExtConnections", */ T:-1 },&#13;
0x01AF: { /* n:"BrtBeginPCDCalcMems", */ T:1 },&#13;
0x01B0: { /* n:"BrtEndPCDCalcMems", */ T:-1 },&#13;
0x01B1: { /* n:"BrtBeginPCDCalcMem", */ T:1 },&#13;
0x01B2: { /* n:"BrtEndPCDCalcMem", */ T:-1 },&#13;
0x01B3: { /* n:"BrtBeginPCDHGLevels", */ T:1 },&#13;
0x01B4: { /* n:"BrtEndPCDHGLevels", */ T:-1 },&#13;
0x01B5: { /* n:"BrtBeginPCDHGLevel", */ T:1 },&#13;
0x01B6: { /* n:"BrtEndPCDHGLevel", */ T:-1 },&#13;
0x01B7: { /* n:"BrtBeginPCDHGLGroups", */ T:1 },&#13;
0x01B8: { /* n:"BrtEndPCDHGLGroups", */ T:-1 },&#13;
0x01B9: { /* n:"BrtBeginPCDHGLGroup", */ T:1 },&#13;
0x01BA: { /* n:"BrtEndPCDHGLGroup", */ T:-1 },&#13;
0x01BB: { /* n:"BrtBeginPCDHGLGMembers", */ T:1 },&#13;
0x01BC: { /* n:"BrtEndPCDHGLGMembers", */ T:-1 },&#13;
0x01BD: { /* n:"BrtBeginPCDHGLGMember", */ T:1 },&#13;
0x01BE: { /* n:"BrtEndPCDHGLGMember", */ T:-1 },&#13;
0x01BF: { /* n:"BrtBeginQSI", */ T:1 },&#13;
0x01C0: { /* n:"BrtEndQSI", */ T:-1 },&#13;
0x01C1: { /* n:"BrtBeginQSIR", */ T:1 },&#13;
0x01C2: { /* n:"BrtEndQSIR", */ T:-1 },&#13;
0x01C3: { /* n:"BrtBeginDeletedNames", */ T:1 },&#13;
0x01C4: { /* n:"BrtEndDeletedNames", */ T:-1 },&#13;
0x01C5: { /* n:"BrtBeginDeletedName", */ T:1 },&#13;
0x01C6: { /* n:"BrtEndDeletedName", */ T:-1 },&#13;
0x01C7: { /* n:"BrtBeginQSIFs", */ T:1 },&#13;
0x01C8: { /* n:"BrtEndQSIFs", */ T:-1 },&#13;
0x01C9: { /* n:"BrtBeginQSIF", */ T:1 },&#13;
0x01CA: { /* n:"BrtEndQSIF", */ T:-1 },&#13;
0x01CB: { /* n:"BrtBeginAutoSortScope", */ T:1 },&#13;
0x01CC: { /* n:"BrtEndAutoSortScope", */ T:-1 },&#13;
0x01CD: { /* n:"BrtBeginConditionalFormatting", */ T:1 },&#13;
0x01CE: { /* n:"BrtEndConditionalFormatting", */ T:-1 },&#13;
0x01CF: { /* n:"BrtBeginCFRule", */ T:1 },&#13;
0x01D0: { /* n:"BrtEndCFRule", */ T:-1 },&#13;
0x01D1: { /* n:"BrtBeginIconSet", */ T:1 },&#13;
0x01D2: { /* n:"BrtEndIconSet", */ T:-1 },&#13;
0x01D3: { /* n:"BrtBeginDatabar", */ T:1 },&#13;
0x01D4: { /* n:"BrtEndDatabar", */ T:-1 },&#13;
0x01D5: { /* n:"BrtBeginColorScale", */ T:1 },&#13;
0x01D6: { /* n:"BrtEndColorScale", */ T:-1 },&#13;
0x01D7: { /* n:"BrtCFVO" */ },&#13;
0x01D8: { /* n:"BrtExternValueMeta" */ },&#13;
0x01D9: { /* n:"BrtBeginColorPalette", */ T:1 },&#13;
0x01DA: { /* n:"BrtEndColorPalette", */ T:-1 },&#13;
0x01DB: { /* n:"BrtIndexedColor" */ },&#13;
0x01DC: { /* n:"BrtMargins", */ f:parse_BrtMargins },&#13;
0x01DD: { /* n:"BrtPrintOptions" */ },&#13;
0x01DE: { /* n:"BrtPageSetup" */ },&#13;
0x01DF: { /* n:"BrtBeginHeaderFooter", */ T:1 },&#13;
0x01E0: { /* n:"BrtEndHeaderFooter", */ T:-1 },&#13;
0x01E1: { /* n:"BrtBeginSXCrtFormat", */ T:1 },&#13;
0x01E2: { /* n:"BrtEndSXCrtFormat", */ T:-1 },&#13;
0x01E3: { /* n:"BrtBeginSXCrtFormats", */ T:1 },&#13;
0x01E4: { /* n:"BrtEndSXCrtFormats", */ T:-1 },&#13;
0x01E5: { /* n:"BrtWsFmtInfo", */ f:parse_BrtWsFmtInfo },&#13;
0x01E6: { /* n:"BrtBeginMgs", */ T:1 },&#13;
0x01E7: { /* n:"BrtEndMGs", */ T:-1 },&#13;
0x01E8: { /* n:"BrtBeginMGMaps", */ T:1 },&#13;
0x01E9: { /* n:"BrtEndMGMaps", */ T:-1 },&#13;
0x01EA: { /* n:"BrtBeginMG", */ T:1 },&#13;
0x01EB: { /* n:"BrtEndMG", */ T:-1 },&#13;
0x01EC: { /* n:"BrtBeginMap", */ T:1 },&#13;
0x01ED: { /* n:"BrtEndMap", */ T:-1 },&#13;
0x01EE: { /* n:"BrtHLink", */ f:parse_BrtHLink },&#13;
0x01EF: { /* n:"BrtBeginDCon", */ T:1 },&#13;
0x01F0: { /* n:"BrtEndDCon", */ T:-1 },&#13;
0x01F1: { /* n:"BrtBeginDRefs", */ T:1 },&#13;
0x01F2: { /* n:"BrtEndDRefs", */ T:-1 },&#13;
0x01F3: { /* n:"BrtDRef" */ },&#13;
0x01F4: { /* n:"BrtBeginScenMan", */ T:1 },&#13;
0x01F5: { /* n:"BrtEndScenMan", */ T:-1 },&#13;
0x01F6: { /* n:"BrtBeginSct", */ T:1 },&#13;
0x01F7: { /* n:"BrtEndSct", */ T:-1 },&#13;
0x01F8: { /* n:"BrtSlc" */ },&#13;
0x01F9: { /* n:"BrtBeginDXFs", */ T:1 },&#13;
0x01FA: { /* n:"BrtEndDXFs", */ T:-1 },&#13;
0x01FB: { /* n:"BrtDXF" */ },&#13;
0x01FC: { /* n:"BrtBeginTableStyles", */ T:1 },&#13;
0x01FD: { /* n:"BrtEndTableStyles", */ T:-1 },&#13;
0x01FE: { /* n:"BrtBeginTableStyle", */ T:1 },&#13;
0x01FF: { /* n:"BrtEndTableStyle", */ T:-1 },&#13;
0x0200: { /* n:"BrtTableStyleElement" */ },&#13;
0x0201: { /* n:"BrtTableStyleClient" */ },&#13;
0x0202: { /* n:"BrtBeginVolDeps", */ T:1 },&#13;
0x0203: { /* n:"BrtEndVolDeps", */ T:-1 },&#13;
0x0204: { /* n:"BrtBeginVolType", */ T:1 },&#13;
0x0205: { /* n:"BrtEndVolType", */ T:-1 },&#13;
0x0206: { /* n:"BrtBeginVolMain", */ T:1 },&#13;
0x0207: { /* n:"BrtEndVolMain", */ T:-1 },&#13;
0x0208: { /* n:"BrtBeginVolTopic", */ T:1 },&#13;
0x0209: { /* n:"BrtEndVolTopic", */ T:-1 },&#13;
0x020A: { /* n:"BrtVolSubtopic" */ },&#13;
0x020B: { /* n:"BrtVolRef" */ },&#13;
0x020C: { /* n:"BrtVolNum" */ },&#13;
0x020D: { /* n:"BrtVolErr" */ },&#13;
0x020E: { /* n:"BrtVolStr" */ },&#13;
0x020F: { /* n:"BrtVolBool" */ },&#13;
0x0210: { /* n:"BrtBeginCalcChain$", */ T:1 },&#13;
0x0211: { /* n:"BrtEndCalcChain$", */ T:-1 },&#13;
0x0212: { /* n:"BrtBeginSortState", */ T:1 },&#13;
0x0213: { /* n:"BrtEndSortState", */ T:-1 },&#13;
0x0214: { /* n:"BrtBeginSortCond", */ T:1 },&#13;
0x0215: { /* n:"BrtEndSortCond", */ T:-1 },&#13;
0x0216: { /* n:"BrtBookProtection" */ },&#13;
0x0217: { /* n:"BrtSheetProtection" */ },&#13;
0x0218: { /* n:"BrtRangeProtection" */ },&#13;
0x0219: { /* n:"BrtPhoneticInfo" */ },&#13;
0x021A: { /* n:"BrtBeginECTxtWiz", */ T:1 },&#13;
0x021B: { /* n:"BrtEndECTxtWiz", */ T:-1 },&#13;
0x021C: { /* n:"BrtBeginECTWFldInfoLst", */ T:1 },&#13;
0x021D: { /* n:"BrtEndECTWFldInfoLst", */ T:-1 },&#13;
0x021E: { /* n:"BrtBeginECTwFldInfo", */ T:1 },&#13;
0x0224: { /* n:"BrtFileSharing" */ },&#13;
0x0225: { /* n:"BrtOleSize" */ },&#13;
0x0226: { /* n:"BrtDrawing", */ f:parse_RelID },&#13;
0x0227: { /* n:"BrtLegacyDrawing" */ },&#13;
0x0228: { /* n:"BrtLegacyDrawingHF" */ },&#13;
0x0229: { /* n:"BrtWebOpt" */ },&#13;
0x022A: { /* n:"BrtBeginWebPubItems", */ T:1 },&#13;
0x022B: { /* n:"BrtEndWebPubItems", */ T:-1 },&#13;
0x022C: { /* n:"BrtBeginWebPubItem", */ T:1 },&#13;
0x022D: { /* n:"BrtEndWebPubItem", */ T:-1 },&#13;
0x022E: { /* n:"BrtBeginSXCondFmt", */ T:1 },&#13;
0x022F: { /* n:"BrtEndSXCondFmt", */ T:-1 },&#13;
0x0230: { /* n:"BrtBeginSXCondFmts", */ T:1 },&#13;
0x0231: { /* n:"BrtEndSXCondFmts", */ T:-1 },&#13;
0x0232: { /* n:"BrtBkHim" */ },&#13;
0x0234: { /* n:"BrtColor" */ },&#13;
0x0235: { /* n:"BrtBeginIndexedColors", */ T:1 },&#13;
0x0236: { /* n:"BrtEndIndexedColors", */ T:-1 },&#13;
0x0239: { /* n:"BrtBeginMRUColors", */ T:1 },&#13;
0x023A: { /* n:"BrtEndMRUColors", */ T:-1 },&#13;
0x023C: { /* n:"BrtMRUColor" */ },&#13;
0x023D: { /* n:"BrtBeginDVals", */ T:1 },&#13;
0x023E: { /* n:"BrtEndDVals", */ T:-1 },&#13;
0x0241: { /* n:"BrtSupNameStart" */ },&#13;
0x0242: { /* n:"BrtSupNameValueStart" */ },&#13;
0x0243: { /* n:"BrtSupNameValueEnd" */ },&#13;
0x0244: { /* n:"BrtSupNameNum" */ },&#13;
0x0245: { /* n:"BrtSupNameErr" */ },&#13;
0x0246: { /* n:"BrtSupNameSt" */ },&#13;
0x0247: { /* n:"BrtSupNameNil" */ },&#13;
0x0248: { /* n:"BrtSupNameBool" */ },&#13;
0x0249: { /* n:"BrtSupNameFmla" */ },&#13;
0x024A: { /* n:"BrtSupNameBits" */ },&#13;
0x024B: { /* n:"BrtSupNameEnd" */ },&#13;
0x024C: { /* n:"BrtEndSupBook", */ T:-1 },&#13;
0x024D: { /* n:"BrtCellSmartTagProperty" */ },&#13;
0x024E: { /* n:"BrtBeginCellSmartTag", */ T:1 },&#13;
0x024F: { /* n:"BrtEndCellSmartTag", */ T:-1 },&#13;
0x0250: { /* n:"BrtBeginCellSmartTags", */ T:1 },&#13;
0x0251: { /* n:"BrtEndCellSmartTags", */ T:-1 },&#13;
0x0252: { /* n:"BrtBeginSmartTags", */ T:1 },&#13;
0x0253: { /* n:"BrtEndSmartTags", */ T:-1 },&#13;
0x0254: { /* n:"BrtSmartTagType" */ },&#13;
0x0255: { /* n:"BrtBeginSmartTagTypes", */ T:1 },&#13;
0x0256: { /* n:"BrtEndSmartTagTypes", */ T:-1 },&#13;
0x0257: { /* n:"BrtBeginSXFilters", */ T:1 },&#13;
0x0258: { /* n:"BrtEndSXFilters", */ T:-1 },&#13;
0x0259: { /* n:"BrtBeginSXFILTER", */ T:1 },&#13;
0x025A: { /* n:"BrtEndSXFilter", */ T:-1 },&#13;
0x025B: { /* n:"BrtBeginFills", */ T:1 },&#13;
0x025C: { /* n:"BrtEndFills", */ T:-1 },&#13;
0x025D: { /* n:"BrtBeginCellWatches", */ T:1 },&#13;
0x025E: { /* n:"BrtEndCellWatches", */ T:-1 },&#13;
0x025F: { /* n:"BrtCellWatch" */ },&#13;
0x0260: { /* n:"BrtBeginCRErrs", */ T:1 },&#13;
0x0261: { /* n:"BrtEndCRErrs", */ T:-1 },&#13;
0x0262: { /* n:"BrtCrashRecErr" */ },&#13;
0x0263: { /* n:"BrtBeginFonts", */ T:1 },&#13;
0x0264: { /* n:"BrtEndFonts", */ T:-1 },&#13;
0x0265: { /* n:"BrtBeginBorders", */ T:1 },&#13;
0x0266: { /* n:"BrtEndBorders", */ T:-1 },&#13;
0x0267: { /* n:"BrtBeginFmts", */ T:1 },&#13;
0x0268: { /* n:"BrtEndFmts", */ T:-1 },&#13;
0x0269: { /* n:"BrtBeginCellXFs", */ T:1 },&#13;
0x026A: { /* n:"BrtEndCellXFs", */ T:-1 },&#13;
0x026B: { /* n:"BrtBeginStyles", */ T:1 },&#13;
0x026C: { /* n:"BrtEndStyles", */ T:-1 },&#13;
0x0271: { /* n:"BrtBigName" */ },&#13;
0x0272: { /* n:"BrtBeginCellStyleXFs", */ T:1 },&#13;
0x0273: { /* n:"BrtEndCellStyleXFs", */ T:-1 },&#13;
0x0274: { /* n:"BrtBeginComments", */ T:1 },&#13;
0x0275: { /* n:"BrtEndComments", */ T:-1 },&#13;
0x0276: { /* n:"BrtBeginCommentAuthors", */ T:1 },&#13;
0x0277: { /* n:"BrtEndCommentAuthors", */ T:-1 },&#13;
0x0278: { /* n:"BrtCommentAuthor", */ f:parse_BrtCommentAuthor },&#13;
0x0279: { /* n:"BrtBeginCommentList", */ T:1 },&#13;
0x027A: { /* n:"BrtEndCommentList", */ T:-1 },&#13;
0x027B: { /* n:"BrtBeginComment", */ T:1, f:parse_BrtBeginComment},&#13;
0x027C: { /* n:"BrtEndComment", */ T:-1 },&#13;
0x027D: { /* n:"BrtCommentText", */ f:parse_BrtCommentText },&#13;
0x027E: { /* n:"BrtBeginOleObjects", */ T:1 },&#13;
0x027F: { /* n:"BrtOleObject" */ },&#13;
0x0280: { /* n:"BrtEndOleObjects", */ T:-1 },&#13;
0x0281: { /* n:"BrtBeginSxrules", */ T:1 },&#13;
0x0282: { /* n:"BrtEndSxRules", */ T:-1 },&#13;
0x0283: { /* n:"BrtBeginActiveXControls", */ T:1 },&#13;
0x0284: { /* n:"BrtActiveX" */ },&#13;
0x0285: { /* n:"BrtEndActiveXControls", */ T:-1 },&#13;
0x0286: { /* n:"BrtBeginPCDSDTCEMembersSortBy", */ T:1 },&#13;
0x0288: { /* n:"BrtBeginCellIgnoreECs", */ T:1 },&#13;
0x0289: { /* n:"BrtCellIgnoreEC" */ },&#13;
0x028A: { /* n:"BrtEndCellIgnoreECs", */ T:-1 },&#13;
0x028B: { /* n:"BrtCsProp", */ f:parse_BrtCsProp },&#13;
0x028C: { /* n:"BrtCsPageSetup" */ },&#13;
0x028D: { /* n:"BrtBeginUserCsViews", */ T:1 },&#13;
0x028E: { /* n:"BrtEndUserCsViews", */ T:-1 },&#13;
0x028F: { /* n:"BrtBeginUserCsView", */ T:1 },&#13;
0x0290: { /* n:"BrtEndUserCsView", */ T:-1 },&#13;
0x0291: { /* n:"BrtBeginPcdSFCIEntries", */ T:1 },&#13;
0x0292: { /* n:"BrtEndPCDSFCIEntries", */ T:-1 },&#13;
0x0293: { /* n:"BrtPCDSFCIEntry" */ },&#13;
0x0294: { /* n:"BrtBeginListParts", */ T:1 },&#13;
0x0295: { /* n:"BrtListPart" */ },&#13;
0x0296: { /* n:"BrtEndListParts", */ T:-1 },&#13;
0x0297: { /* n:"BrtSheetCalcProp" */ },&#13;
0x0298: { /* n:"BrtBeginFnGroup", */ T:1 },&#13;
0x0299: { /* n:"BrtFnGroup" */ },&#13;
0x029A: { /* n:"BrtEndFnGroup", */ T:-1 },&#13;
0x029B: { /* n:"BrtSupAddin" */ },&#13;
0x029C: { /* n:"BrtSXTDMPOrder" */ },&#13;
0x029D: { /* n:"BrtCsProtection" */ },&#13;
0x029F: { /* n:"BrtBeginWsSortMap", */ T:1 },&#13;
0x02A0: { /* n:"BrtEndWsSortMap", */ T:-1 },&#13;
0x02A1: { /* n:"BrtBeginRRSort", */ T:1 },&#13;
0x02A2: { /* n:"BrtEndRRSort", */ T:-1 },&#13;
0x02A3: { /* n:"BrtRRSortItem" */ },&#13;
0x02A4: { /* n:"BrtFileSharingIso" */ },&#13;
0x02A5: { /* n:"BrtBookProtectionIso" */ },&#13;
0x02A6: { /* n:"BrtSheetProtectionIso" */ },&#13;
0x02A7: { /* n:"BrtCsProtectionIso" */ },&#13;
0x02A8: { /* n:"BrtRangeProtectionIso" */ },&#13;
0x02A9: { /* n:"BrtDValList" */ },&#13;
0x0400: { /* n:"BrtRwDescent" */ },&#13;
0x0401: { /* n:"BrtKnownFonts" */ },&#13;
0x0402: { /* n:"BrtBeginSXTupleSet", */ T:1 },&#13;
0x0403: { /* n:"BrtEndSXTupleSet", */ T:-1 },&#13;
0x0404: { /* n:"BrtBeginSXTupleSetHeader", */ T:1 },&#13;
0x0405: { /* n:"BrtEndSXTupleSetHeader", */ T:-1 },&#13;
0x0406: { /* n:"BrtSXTupleSetHeaderItem" */ },&#13;
0x0407: { /* n:"BrtBeginSXTupleSetData", */ T:1 },&#13;
0x0408: { /* n:"BrtEndSXTupleSetData", */ T:-1 },&#13;
0x0409: { /* n:"BrtBeginSXTupleSetRow", */ T:1 },&#13;
0x040A: { /* n:"BrtEndSXTupleSetRow", */ T:-1 },&#13;
0x040B: { /* n:"BrtSXTupleSetRowItem" */ },&#13;
0x040C: { /* n:"BrtNameExt" */ },&#13;
0x040D: { /* n:"BrtPCDH14" */ },&#13;
0x040E: { /* n:"BrtBeginPCDCalcMem14", */ T:1 },&#13;
0x040F: { /* n:"BrtEndPCDCalcMem14", */ T:-1 },&#13;
0x0410: { /* n:"BrtSXTH14" */ },&#13;
0x0411: { /* n:"BrtBeginSparklineGroup", */ T:1 },&#13;
0x0412: { /* n:"BrtEndSparklineGroup", */ T:-1 },&#13;
0x0413: { /* n:"BrtSparkline" */ },&#13;
0x0414: { /* n:"BrtSXDI14" */ },&#13;
0x0415: { /* n:"BrtWsFmtInfoEx14" */ },&#13;
0x0416: { /* n:"BrtBeginConditionalFormatting14", */ T:1 },&#13;
0x0417: { /* n:"BrtEndConditionalFormatting14", */ T:-1 },&#13;
0x0418: { /* n:"BrtBeginCFRule14", */ T:1 },&#13;
0x0419: { /* n:"BrtEndCFRule14", */ T:-1 },&#13;
0x041A: { /* n:"BrtCFVO14" */ },&#13;
0x041B: { /* n:"BrtBeginDatabar14", */ T:1 },&#13;
0x041C: { /* n:"BrtBeginIconSet14", */ T:1 },&#13;
0x041D: { /* n:"BrtDVal14", */ f: parse_BrtDVal14 },&#13;
0x041E: { /* n:"BrtBeginDVals14", */ T:1 },&#13;
0x041F: { /* n:"BrtColor14" */ },&#13;
0x0420: { /* n:"BrtBeginSparklines", */ T:1 },&#13;
0x0421: { /* n:"BrtEndSparklines", */ T:-1 },&#13;
0x0422: { /* n:"BrtBeginSparklineGroups", */ T:1 },&#13;
0x0423: { /* n:"BrtEndSparklineGroups", */ T:-1 },&#13;
0x0425: { /* n:"BrtSXVD14" */ },&#13;
0x0426: { /* n:"BrtBeginSXView14", */ T:1 },&#13;
0x0427: { /* n:"BrtEndSXView14", */ T:-1 },&#13;
0x0428: { /* n:"BrtBeginSXView16", */ T:1 },&#13;
0x0429: { /* n:"BrtEndSXView16", */ T:-1 },&#13;
0x042A: { /* n:"BrtBeginPCD14", */ T:1 },&#13;
0x042B: { /* n:"BrtEndPCD14", */ T:-1 },&#13;
0x042C: { /* n:"BrtBeginExtConn14", */ T:1 },&#13;
0x042D: { /* n:"BrtEndExtConn14", */ T:-1 },&#13;
0x042E: { /* n:"BrtBeginSlicerCacheIDs", */ T:1 },&#13;
0x042F: { /* n:"BrtEndSlicerCacheIDs", */ T:-1 },&#13;
0x0430: { /* n:"BrtBeginSlicerCacheID", */ T:1 },&#13;
0x0431: { /* n:"BrtEndSlicerCacheID", */ T:-1 },&#13;
0x0433: { /* n:"BrtBeginSlicerCache", */ T:1 },&#13;
0x0434: { /* n:"BrtEndSlicerCache", */ T:-1 },&#13;
0x0435: { /* n:"BrtBeginSlicerCacheDef", */ T:1 },&#13;
0x0436: { /* n:"BrtEndSlicerCacheDef", */ T:-1 },&#13;
0x0437: { /* n:"BrtBeginSlicersEx", */ T:1 },&#13;
0x0438: { /* n:"BrtEndSlicersEx", */ T:-1 },&#13;
0x0439: { /* n:"BrtBeginSlicerEx", */ T:1 },&#13;
0x043A: { /* n:"BrtEndSlicerEx", */ T:-1 },&#13;
0x043B: { /* n:"BrtBeginSlicer", */ T:1 },&#13;
0x043C: { /* n:"BrtEndSlicer", */ T:-1 },&#13;
0x043D: { /* n:"BrtSlicerCachePivotTables" */ },&#13;
0x043E: { /* n:"BrtBeginSlicerCacheOlapImpl", */ T:1 },&#13;
0x043F: { /* n:"BrtEndSlicerCacheOlapImpl", */ T:-1 },&#13;
0x0440: { /* n:"BrtBeginSlicerCacheLevelsData", */ T:1 },&#13;
0x0441: { /* n:"BrtEndSlicerCacheLevelsData", */ T:-1 },&#13;
0x0442: { /* n:"BrtBeginSlicerCacheLevelData", */ T:1 },&#13;
0x0443: { /* n:"BrtEndSlicerCacheLevelData", */ T:-1 },&#13;
0x0444: { /* n:"BrtBeginSlicerCacheSiRanges", */ T:1 },&#13;
0x0445: { /* n:"BrtEndSlicerCacheSiRanges", */ T:-1 },&#13;
0x0446: { /* n:"BrtBeginSlicerCacheSiRange", */ T:1 },&#13;
0x0447: { /* n:"BrtEndSlicerCacheSiRange", */ T:-1 },&#13;
0x0448: { /* n:"BrtSlicerCacheOlapItem" */ },&#13;
0x0449: { /* n:"BrtBeginSlicerCacheSelections", */ T:1 },&#13;
0x044A: { /* n:"BrtSlicerCacheSelection" */ },&#13;
0x044B: { /* n:"BrtEndSlicerCacheSelections", */ T:-1 },&#13;
0x044C: { /* n:"BrtBeginSlicerCacheNative", */ T:1 },&#13;
0x044D: { /* n:"BrtEndSlicerCacheNative", */ T:-1 },&#13;
0x044E: { /* n:"BrtSlicerCacheNativeItem" */ },&#13;
0x044F: { /* n:"BrtRangeProtection14" */ },&#13;
0x0450: { /* n:"BrtRangeProtectionIso14" */ },&#13;
0x0451: { /* n:"BrtCellIgnoreEC14" */ },&#13;
0x0457: { /* n:"BrtList14" */ },&#13;
0x0458: { /* n:"BrtCFIcon" */ },&#13;
0x0459: { /* n:"BrtBeginSlicerCachesPivotCacheIDs", */ T:1 },&#13;
0x045A: { /* n:"BrtEndSlicerCachesPivotCacheIDs", */ T:-1 },&#13;
0x045B: { /* n:"BrtBeginSlicers", */ T:1 },&#13;
0x045C: { /* n:"BrtEndSlicers", */ T:-1 },&#13;
0x045D: { /* n:"BrtWbProp14" */ },&#13;
0x045E: { /* n:"BrtBeginSXEdit", */ T:1 },&#13;
0x045F: { /* n:"BrtEndSXEdit", */ T:-1 },&#13;
0x0460: { /* n:"BrtBeginSXEdits", */ T:1 },&#13;
0x0461: { /* n:"BrtEndSXEdits", */ T:-1 },&#13;
0x0462: { /* n:"BrtBeginSXChange", */ T:1 },&#13;
0x0463: { /* n:"BrtEndSXChange", */ T:-1 },&#13;
0x0464: { /* n:"BrtBeginSXChanges", */ T:1 },&#13;
0x0465: { /* n:"BrtEndSXChanges", */ T:-1 },&#13;
0x0466: { /* n:"BrtSXTupleItems" */ },&#13;
0x0468: { /* n:"BrtBeginSlicerStyle", */ T:1 },&#13;
0x0469: { /* n:"BrtEndSlicerStyle", */ T:-1 },&#13;
0x046A: { /* n:"BrtSlicerStyleElement" */ },&#13;
0x046B: { /* n:"BrtBeginStyleSheetExt14", */ T:1 },&#13;
0x046C: { /* n:"BrtEndStyleSheetExt14", */ T:-1 },&#13;
0x046D: { /* n:"BrtBeginSlicerCachesPivotCacheID", */ T:1 },&#13;
0x046E: { /* n:"BrtEndSlicerCachesPivotCacheID", */ T:-1 },&#13;
0x046F: { /* n:"BrtBeginConditionalFormattings", */ T:1 },&#13;
0x0470: { /* n:"BrtEndConditionalFormattings", */ T:-1 },&#13;
0x0471: { /* n:"BrtBeginPCDCalcMemExt", */ T:1 },&#13;
0x0472: { /* n:"BrtEndPCDCalcMemExt", */ T:-1 },&#13;
0x0473: { /* n:"BrtBeginPCDCalcMemsExt", */ T:1 },&#13;
0x0474: { /* n:"BrtEndPCDCalcMemsExt", */ T:-1 },&#13;
0x0475: { /* n:"BrtPCDField14" */ },&#13;
0x0476: { /* n:"BrtBeginSlicerStyles", */ T:1 },&#13;
0x0477: { /* n:"BrtEndSlicerStyles", */ T:-1 },&#13;
0x0478: { /* n:"BrtBeginSlicerStyleElements", */ T:1 },&#13;
0x0479: { /* n:"BrtEndSlicerStyleElements", */ T:-1 },&#13;
0x047A: { /* n:"BrtCFRuleExt" */ },&#13;
0x047B: { /* n:"BrtBeginSXCondFmt14", */ T:1 },&#13;
0x047C: { /* n:"BrtEndSXCondFmt14", */ T:-1 },&#13;
0x047D: { /* n:"BrtBeginSXCondFmts14", */ T:1 },&#13;
0x047E: { /* n:"BrtEndSXCondFmts14", */ T:-1 },&#13;
0x0480: { /* n:"BrtBeginSortCond14", */ T:1 },&#13;
0x0481: { /* n:"BrtEndSortCond14", */ T:-1 },&#13;
0x0482: { /* n:"BrtEndDVals14", */ T:-1 },&#13;
0x0483: { /* n:"BrtEndIconSet14", */ T:-1 },&#13;
0x0484: { /* n:"BrtEndDatabar14", */ T:-1 },&#13;
0x0485: { /* n:"BrtBeginColorScale14", */ T:1 },&#13;
0x0486: { /* n:"BrtEndColorScale14", */ T:-1 },&#13;
0x0487: { /* n:"BrtBeginSxrules14", */ T:1 },&#13;
0x0488: { /* n:"BrtEndSxrules14", */ T:-1 },&#13;
0x0489: { /* n:"BrtBeginPRule14", */ T:1 },&#13;
0x048A: { /* n:"BrtEndPRule14", */ T:-1 },&#13;
0x048B: { /* n:"BrtBeginPRFilters14", */ T:1 },&#13;
0x048C: { /* n:"BrtEndPRFilters14", */ T:-1 },&#13;
0x048D: { /* n:"BrtBeginPRFilter14", */ T:1 },&#13;
0x048E: { /* n:"BrtEndPRFilter14", */ T:-1 },&#13;
0x048F: { /* n:"BrtBeginPRFItem14", */ T:1 },&#13;
0x0490: { /* n:"BrtEndPRFItem14", */ T:-1 },&#13;
0x0491: { /* n:"BrtBeginCellIgnoreECs14", */ T:1 },&#13;
0x0492: { /* n:"BrtEndCellIgnoreECs14", */ T:-1 },&#13;
0x0493: { /* n:"BrtDxf14" */ },&#13;
0x0494: { /* n:"BrtBeginDxF14s", */ T:1 },&#13;
0x0495: { /* n:"BrtEndDxf14s", */ T:-1 },&#13;
0x0499: { /* n:"BrtFilter14" */ },&#13;
0x049A: { /* n:"BrtBeginCustomFilters14", */ T:1 },&#13;
0x049C: { /* n:"BrtCustomFilter14" */ },&#13;
0x049D: { /* n:"BrtIconFilter14" */ },&#13;
0x049E: { /* n:"BrtPivotCacheConnectionName" */ },&#13;
0x0800: { /* n:"BrtBeginDecoupledPivotCacheIDs", */ T:1 },&#13;
0x0801: { /* n:"BrtEndDecoupledPivotCacheIDs", */ T:-1 },&#13;
0x0802: { /* n:"BrtDecoupledPivotCacheID" */ },&#13;
0x0803: { /* n:"BrtBeginPivotTableRefs", */ T:1 },&#13;
0x0804: { /* n:"BrtEndPivotTableRefs", */ T:-1 },&#13;
0x0805: { /* n:"BrtPivotTableRef" */ },&#13;
0x0806: { /* n:"BrtSlicerCacheBookPivotTables" */ },&#13;
0x0807: { /* n:"BrtBeginSxvcells", */ T:1 },&#13;
0x0808: { /* n:"BrtEndSxvcells", */ T:-1 },&#13;
0x0809: { /* n:"BrtBeginSxRow", */ T:1 },&#13;
0x080A: { /* n:"BrtEndSxRow", */ T:-1 },&#13;
0x080C: { /* n:"BrtPcdCalcMem15" */ },&#13;
0x0813: { /* n:"BrtQsi15" */ },&#13;
0x0814: { /* n:"BrtBeginWebExtensions", */ T:1 },&#13;
0x0815: { /* n:"BrtEndWebExtensions", */ T:-1 },&#13;
0x0816: { /* n:"BrtWebExtension" */ },&#13;
0x0817: { /* n:"BrtAbsPath15" */ },&#13;
0x0818: { /* n:"BrtBeginPivotTableUISettings", */ T:1 },&#13;
0x0819: { /* n:"BrtEndPivotTableUISettings", */ T:-1 },&#13;
0x081B: { /* n:"BrtTableSlicerCacheIDs" */ },&#13;
0x081C: { /* n:"BrtTableSlicerCacheID" */ },&#13;
0x081D: { /* n:"BrtBeginTableSlicerCache", */ T:1 },&#13;
0x081E: { /* n:"BrtEndTableSlicerCache", */ T:-1 },&#13;
0x081F: { /* n:"BrtSxFilter15" */ },&#13;
0x0820: { /* n:"BrtBeginTimelineCachePivotCacheIDs", */ T:1 },&#13;
0x0821: { /* n:"BrtEndTimelineCachePivotCacheIDs", */ T:-1 },&#13;
0x0822: { /* n:"BrtTimelineCachePivotCacheID" */ },&#13;
0x0823: { /* n:"BrtBeginTimelineCacheIDs", */ T:1 },&#13;
0x0824: { /* n:"BrtEndTimelineCacheIDs", */ T:-1 },&#13;
0x0825: { /* n:"BrtBeginTimelineCacheID", */ T:1 },&#13;
0x0826: { /* n:"BrtEndTimelineCacheID", */ T:-1 },&#13;
0x0827: { /* n:"BrtBeginTimelinesEx", */ T:1 },&#13;
0x0828: { /* n:"BrtEndTimelinesEx", */ T:-1 },&#13;
0x0829: { /* n:"BrtBeginTimelineEx", */ T:1 },&#13;
0x082A: { /* n:"BrtEndTimelineEx", */ T:-1 },&#13;
0x082B: { /* n:"BrtWorkBookPr15" */ },&#13;
0x082C: { /* n:"BrtPCDH15" */ },&#13;
0x082D: { /* n:"BrtBeginTimelineStyle", */ T:1 },&#13;
0x082E: { /* n:"BrtEndTimelineStyle", */ T:-1 },&#13;
0x082F: { /* n:"BrtTimelineStyleElement" */ },&#13;
0x0830: { /* n:"BrtBeginTimelineStylesheetExt15", */ T:1 },&#13;
0x0831: { /* n:"BrtEndTimelineStylesheetExt15", */ T:-1 },&#13;
0x0832: { /* n:"BrtBeginTimelineStyles", */ T:1 },&#13;
0x0833: { /* n:"BrtEndTimelineStyles", */ T:-1 },&#13;
0x0834: { /* n:"BrtBeginTimelineStyleElements", */ T:1 },&#13;
0x0835: { /* n:"BrtEndTimelineStyleElements", */ T:-1 },&#13;
0x0836: { /* n:"BrtDxf15" */ },&#13;
0x0837: { /* n:"BrtBeginDxfs15", */ T:1 },&#13;
0x0838: { /* n:"BrtEndDxfs15", */ T:-1 },&#13;
0x0839: { /* n:"BrtSlicerCacheHideItemsWithNoData" */ },&#13;
0x083A: { /* n:"BrtBeginItemUniqueNames", */ T:1 },&#13;
0x083B: { /* n:"BrtEndItemUniqueNames", */ T:-1 },&#13;
0x083C: { /* n:"BrtItemUniqueName" */ },&#13;
0x083D: { /* n:"BrtBeginExtConn15", */ T:1 },&#13;
0x083E: { /* n:"BrtEndExtConn15", */ T:-1 },&#13;
0x083F: { /* n:"BrtBeginOledbPr15", */ T:1 },&#13;
0x0840: { /* n:"BrtEndOledbPr15", */ T:-1 },&#13;
0x0841: { /* n:"BrtBeginDataFeedPr15", */ T:1 },&#13;
0x0842: { /* n:"BrtEndDataFeedPr15", */ T:-1 },&#13;
0x0843: { /* n:"BrtTextPr15" */ },&#13;
0x0844: { /* n:"BrtRangePr15" */ },&#13;
0x0845: { /* n:"BrtDbCommand15" */ },&#13;
0x0846: { /* n:"BrtBeginDbTables15", */ T:1 },&#13;
0x0847: { /* n:"BrtEndDbTables15", */ T:-1 },&#13;
0x0848: { /* n:"BrtDbTable15" */ },&#13;
0x0849: { /* n:"BrtBeginDataModel", */ T:1 },&#13;
0x084A: { /* n:"BrtEndDataModel", */ T:-1 },&#13;
0x084B: { /* n:"BrtBeginModelTables", */ T:1 },&#13;
0x084C: { /* n:"BrtEndModelTables", */ T:-1 },&#13;
0x084D: { /* n:"BrtModelTable" */ },&#13;
0x084E: { /* n:"BrtBeginModelRelationships", */ T:1 },&#13;
0x084F: { /* n:"BrtEndModelRelationships", */ T:-1 },&#13;
0x0850: { /* n:"BrtModelRelationship" */ },&#13;
0x0851: { /* n:"BrtBeginECTxtWiz15", */ T:1 },&#13;
0x0852: { /* n:"BrtEndECTxtWiz15", */ T:-1 },&#13;
0x0853: { /* n:"BrtBeginECTWFldInfoLst15", */ T:1 },&#13;
0x0854: { /* n:"BrtEndECTWFldInfoLst15", */ T:-1 },&#13;
0x0855: { /* n:"BrtBeginECTWFldInfo15", */ T:1 },&#13;
0x0856: { /* n:"BrtFieldListActiveItem" */ },&#13;
0x0857: { /* n:"BrtPivotCacheIdVersion" */ },&#13;
0x0858: { /* n:"BrtSXDI15" */ },&#13;
0x0859: { /* n:"BrtBeginModelTimeGroupings", */ T:1 },&#13;
0x085A: { /* n:"BrtEndModelTimeGroupings", */ T:-1 },&#13;
0x085B: { /* n:"BrtBeginModelTimeGrouping", */ T:1 },&#13;
0x085C: { /* n:"BrtEndModelTimeGrouping", */ T:-1 },&#13;
0x085D: { /* n:"BrtModelTimeGroupingCalcCol" */ },&#13;
0x0C00: { /* n:"BrtUid" */ },&#13;
0x0C01: { /* n:"BrtRevisionPtr" */ },&#13;
0x1000: { /* n:"BrtBeginDynamicArrayPr", */ T:1 },&#13;
0x1001: { /* n:"BrtEndDynamicArrayPr", */ T:-1 },&#13;
0x138A: { /* n:"BrtBeginRichValueBlock", */ T:1 },&#13;
0x138B: { /* n:"BrtEndRichValueBlock", */ T:-1 },&#13;
0x13D9: { /* n:"BrtBeginRichFilters", */ T:1 },&#13;
0x13DA: { /* n:"BrtEndRichFilters", */ T:-1 },&#13;
0x13DB: { /* n:"BrtRichFilter" */ },&#13;
0x13DC: { /* n:"BrtBeginRichFilterColumn", */ T:1 },&#13;
0x13DD: { /* n:"BrtEndRichFilterColumn", */ T:-1 },&#13;
0x13DE: { /* n:"BrtBeginCustomRichFilters", */ T:1 },&#13;
0x13DF: { /* n:"BrtEndCustomRichFilters", */ T:-1 },&#13;
0x13E0: { /* n:"BrtCustomRichFilter" */ },&#13;
0x13E1: { /* n:"BrtTop10RichFilter" */ },&#13;
0x13E2: { /* n:"BrtDynamicRichFilter" */ },&#13;
0x13E4: { /* n:"BrtBeginRichSortCondition", */ T:1 },&#13;
0x13E5: { /* n:"BrtEndRichSortCondition", */ T:-1 },&#13;
0x13E6: { /* n:"BrtRichFilterDateGroupItem" */ },&#13;
0x13E7: { /* n:"BrtBeginCalcFeatures", */ T:1 },&#13;
0x13E8: { /* n:"BrtEndCalcFeatures", */ T:-1 },&#13;
0x13E9: { /* n:"BrtCalcFeature" */ },&#13;
0x13EB: { /* n:"BrtExternalLinksPr" */ },&#13;
0xFFFF: { n:"" }&#13;
};&#13;
&#13;
/* [MS-XLS] 2.3 Record Enumeration (and other sources) */&#13;
var XLSRecordEnum = {&#13;
	/* [MS-XLS] 2.3 Record Enumeration 2021-08-17 */&#13;
0x0006: { /* n:"Formula", */ f:parse_Formula },&#13;
0x000a: { /* n:"EOF", */ f:parsenoop2 },&#13;
0x000c: { /* n:"CalcCount", */ f:parseuint16 }, //&#13;
0x000d: { /* n:"CalcMode", */ f:parseuint16 }, //&#13;
0x000e: { /* n:"CalcPrecision", */ f:parsebool }, //&#13;
0x000f: { /* n:"CalcRefMode", */ f:parsebool }, //&#13;
0x0010: { /* n:"CalcDelta", */ f:parse_Xnum }, //&#13;
0x0011: { /* n:"CalcIter", */ f:parsebool }, //&#13;
0x0012: { /* n:"Protect", */ f:parsebool },&#13;
0x0013: { /* n:"Password", */ f:parseuint16 },&#13;
0x0014: { /* n:"Header", */ f:parse_XLHeaderFooter },&#13;
0x0015: { /* n:"Footer", */ f:parse_XLHeaderFooter },&#13;
0x0017: { /* n:"ExternSheet", */ f:parse_ExternSheet },&#13;
0x0018: { /* n:"Lbl", */ f:parse_Lbl },&#13;
0x0019: { /* n:"WinProtect", */ f:parsebool },&#13;
0x001a: { /* n:"VerticalPageBreaks", */ },&#13;
0x001b: { /* n:"HorizontalPageBreaks", */ },&#13;
0x001c: { /* n:"Note", */ f:parse_Note },&#13;
0x001d: { /* n:"Selection", */ },&#13;
0x0022: { /* n:"Date1904", */ f:parsebool },&#13;
0x0023: { /* n:"ExternName", */ f:parse_ExternName },&#13;
0x0026: { /* n:"LeftMargin", */ f:parse_Xnum }, // *&#13;
0x0027: { /* n:"RightMargin", */ f:parse_Xnum }, // *&#13;
0x0028: { /* n:"TopMargin", */ f:parse_Xnum }, // *&#13;
0x0029: { /* n:"BottomMargin", */ f:parse_Xnum }, // *&#13;
0x002a: { /* n:"PrintRowCol", */ f:parsebool },&#13;
0x002b: { /* n:"PrintGrid", */ f:parsebool },&#13;
0x002f: { /* n:"FilePass", */ f:parse_FilePass },&#13;
0x0031: { /* n:"Font", */ f:parse_Font },&#13;
0x0033: { /* n:"PrintSize", */ f:parseuint16 },&#13;
0x003c: { /* n:"Continue", */ },&#13;
0x003d: { /* n:"Window1", */ f:parse_Window1 },&#13;
0x0040: { /* n:"Backup", */ f:parsebool },&#13;
0x0041: { /* n:"Pane", */ f:parse_Pane },&#13;
0x0042: { /* n:"CodePage", */ f:parseuint16 },&#13;
0x004d: { /* n:"Pls", */ },&#13;
0x0050: { /* n:"DCon", */ },&#13;
0x0051: { /* n:"DConRef", */ },&#13;
0x0052: { /* n:"DConName", */ },&#13;
0x0055: { /* n:"DefColWidth", */ f:parseuint16 },&#13;
0x0059: { /* n:"XCT", */ },&#13;
0x005a: { /* n:"CRN", */ },&#13;
0x005b: { /* n:"FileSharing", */ },&#13;
0x005c: { /* n:"WriteAccess", */ f:parse_WriteAccess },&#13;
0x005d: { /* n:"Obj", */ f:parse_Obj },&#13;
0x005e: { /* n:"Uncalced", */ },&#13;
0x005f: { /* n:"CalcSaveRecalc", */ f:parsebool }, //&#13;
0x0060: { /* n:"Template", */ },&#13;
0x0061: { /* n:"Intl", */ },&#13;
0x0063: { /* n:"ObjProtect", */ f:parsebool },&#13;
0x007d: { /* n:"ColInfo", */ f:parse_ColInfo },&#13;
0x0080: { /* n:"Guts", */ f:parse_Guts },&#13;
0x0081: { /* n:"WsBool", */ f:parse_WsBool },&#13;
0x0082: { /* n:"GridSet", */ f:parseuint16 },&#13;
0x0083: { /* n:"HCenter", */ f:parsebool },&#13;
0x0084: { /* n:"VCenter", */ f:parsebool },&#13;
0x0085: { /* n:"BoundSheet8", */ f:parse_BoundSheet8 },&#13;
0x0086: { /* n:"WriteProtect", */ },&#13;
0x008c: { /* n:"Country", */ f:parse_Country },&#13;
0x008d: { /* n:"HideObj", */ f:parseuint16 },&#13;
0x0090: { /* n:"Sort", */ },&#13;
0x0092: { /* n:"Palette", */ f:parse_Palette },&#13;
0x0097: { /* n:"Sync", */ },&#13;
0x0098: { /* n:"LPr", */ },&#13;
0x0099: { /* n:"DxGCol", */ },&#13;
0x009a: { /* n:"FnGroupName", */ },&#13;
0x009b: { /* n:"FilterMode", */ },&#13;
0x009c: { /* n:"BuiltInFnGroupCount", */ f:parseuint16 },&#13;
0x009d: { /* n:"AutoFilterInfo", */ },&#13;
0x009e: { /* n:"AutoFilter", */ },&#13;
0x00a0: { /* n:"Scl", */ f:parse_Scl },&#13;
0x00a1: { /* n:"Setup", */ f:parse_Setup },&#13;
0x00ae: { /* n:"ScenMan", */ },&#13;
0x00af: { /* n:"SCENARIO", */ },&#13;
0x00b0: { /* n:"SxView", */ },&#13;
0x00b1: { /* n:"Sxvd", */ },&#13;
0x00b2: { /* n:"SXVI", */ },&#13;
0x00b4: { /* n:"SxIvd", */ },&#13;
0x00b5: { /* n:"SXLI", */ },&#13;
0x00b6: { /* n:"SXPI", */ },&#13;
0x00b8: { /* n:"DocRoute", */ },&#13;
0x00b9: { /* n:"RecipName", */ },&#13;
0x00bd: { /* n:"MulRk", */ f:parse_MulRk },&#13;
0x00be: { /* n:"MulBlank", */ f:parse_MulBlank },&#13;
0x00c1: { /* n:"Mms", */ f:parsenoop2 },&#13;
0x00c5: { /* n:"SXDI", */ },&#13;
0x00c6: { /* n:"SXDB", */ },&#13;
0x00c7: { /* n:"SXFDB", */ },&#13;
0x00c8: { /* n:"SXDBB", */ },&#13;
0x00c9: { /* n:"SXNum", */ },&#13;
0x00ca: { /* n:"SxBool", */ f:parsebool },&#13;
0x00cb: { /* n:"SxErr", */ },&#13;
0x00cc: { /* n:"SXInt", */ },&#13;
0x00cd: { /* n:"SXString", */ },&#13;
0x00ce: { /* n:"SXDtr", */ },&#13;
0x00cf: { /* n:"SxNil", */ },&#13;
0x00d0: { /* n:"SXTbl", */ },&#13;
0x00d1: { /* n:"SXTBRGIITM", */ },&#13;
0x00d2: { /* n:"SxTbpg", */ },&#13;
0x00d3: { /* n:"ObProj", */ },&#13;
0x00d5: { /* n:"SXStreamID", */ },&#13;
0x00d7: { /* n:"DBCell", */ },&#13;
0x00d8: { /* n:"SXRng", */ },&#13;
0x00d9: { /* n:"SxIsxoper", */ },&#13;
0x00da: { /* n:"BookBool", */ f:parseuint16 },&#13;
0x00dc: { /* n:"DbOrParamQry", */ },&#13;
0x00dd: { /* n:"ScenarioProtect", */ f:parsebool },&#13;
0x00de: { /* n:"OleObjectSize", */ },&#13;
0x00e0: { /* n:"XF", */ f:parse_XF },&#13;
0x00e1: { /* n:"InterfaceHdr", */ f:parse_InterfaceHdr },&#13;
0x00e2: { /* n:"InterfaceEnd", */ f:parsenoop2 },&#13;
0x00e3: { /* n:"SXVS", */ },&#13;
0x00e5: { /* n:"MergeCells", */ f:parse_MergeCells },&#13;
0x00e9: { /* n:"BkHim", */ },&#13;
0x00eb: { /* n:"MsoDrawingGroup", */ },&#13;
0x00ec: { /* n:"MsoDrawing", */ },&#13;
0x00ed: { /* n:"MsoDrawingSelection", */ },&#13;
0x00ef: { /* n:"PhoneticInfo", */ },&#13;
0x00f0: { /* n:"SxRule", */ },&#13;
0x00f1: { /* n:"SXEx", */ },&#13;
0x00f2: { /* n:"SxFilt", */ },&#13;
0x00f4: { /* n:"SxDXF", */ },&#13;
0x00f5: { /* n:"SxItm", */ },&#13;
0x00f6: { /* n:"SxName", */ },&#13;
0x00f7: { /* n:"SxSelect", */ },&#13;
0x00f8: { /* n:"SXPair", */ },&#13;
0x00f9: { /* n:"SxFmla", */ },&#13;
0x00fb: { /* n:"SxFormat", */ },&#13;
0x00fc: { /* n:"SST", */ f:parse_SST },&#13;
0x00fd: { /* n:"LabelSst", */ f:parse_LabelSst },&#13;
0x00ff: { /* n:"ExtSST", */ f:parse_ExtSST },&#13;
0x0100: { /* n:"SXVDEx", */ },&#13;
0x0103: { /* n:"SXFormula", */ },&#13;
0x0122: { /* n:"SXDBEx", */ },&#13;
0x0137: { /* n:"RRDInsDel", */ },&#13;
0x0138: { /* n:"RRDHead", */ },&#13;
0x013b: { /* n:"RRDChgCell", */ },&#13;
0x013d: { /* n:"RRTabId", */ f:parseuint16a },&#13;
0x013e: { /* n:"RRDRenSheet", */ },&#13;
0x013f: { /* n:"RRSort", */ },&#13;
0x0140: { /* n:"RRDMove", */ },&#13;
0x014a: { /* n:"RRFormat", */ },&#13;
0x014b: { /* n:"RRAutoFmt", */ },&#13;
0x014d: { /* n:"RRInsertSh", */ },&#13;
0x014e: { /* n:"RRDMoveBegin", */ },&#13;
0x014f: { /* n:"RRDMoveEnd", */ },&#13;
0x0150: { /* n:"RRDInsDelBegin", */ },&#13;
0x0151: { /* n:"RRDInsDelEnd", */ },&#13;
0x0152: { /* n:"RRDConflict", */ },&#13;
0x0153: { /* n:"RRDDefName", */ },&#13;
0x0154: { /* n:"RRDRstEtxp", */ },&#13;
0x015f: { /* n:"LRng", */ },&#13;
0x0160: { /* n:"UsesELFs", */ f:parsebool },&#13;
0x0161: { /* n:"DSF", */ f:parsenoop2 },&#13;
0x0191: { /* n:"CUsr", */ },&#13;
0x0192: { /* n:"CbUsr", */ },&#13;
0x0193: { /* n:"UsrInfo", */ },&#13;
0x0194: { /* n:"UsrExcl", */ },&#13;
0x0195: { /* n:"FileLock", */ },&#13;
0x0196: { /* n:"RRDInfo", */ },&#13;
0x0197: { /* n:"BCUsrs", */ },&#13;
0x0198: { /* n:"UsrChk", */ },&#13;
0x01a9: { /* n:"UserBView", */ },&#13;
0x01aa: { /* n:"UserSViewBegin", */ },&#13;
0x01ab: { /* n:"UserSViewEnd", */ },&#13;
0x01ac: { /* n:"RRDUserView", */ },&#13;
0x01ad: { /* n:"Qsi", */ },&#13;
0x01ae: { /* n:"SupBook", */ f:parse_SupBook },&#13;
0x01af: { /* n:"Prot4Rev", */ f:parsebool },&#13;
0x01b0: { /* n:"CondFmt", */ },&#13;
0x01b1: { /* n:"CF", */ },&#13;
0x01b2: { /* n:"DVal", */ },&#13;
0x01b5: { /* n:"DConBin", */ },&#13;
0x01b6: { /* n:"TxO", */ f:parse_TxO },&#13;
0x01b7: { /* n:"RefreshAll", */ f:parsebool }, //&#13;
0x01b8: { /* n:"HLink", */ f:parse_HLink },&#13;
0x01b9: { /* n:"Lel", */ },&#13;
0x01ba: { /* n:"CodeName", */ f:parse_XLUnicodeString },&#13;
0x01bb: { /* n:"SXFDBType", */ },&#13;
0x01bc: { /* n:"Prot4RevPass", */ f:parseuint16 },&#13;
0x01bd: { /* n:"ObNoMacros", */ },&#13;
0x01be: { /* n:"Dv", */ },&#13;
0x01c0: { /* n:"Excel9File", */ f:parsenoop2 },&#13;
0x01c1: { /* n:"RecalcId", */ f:parse_RecalcId, r:2},&#13;
0x01c2: { /* n:"EntExU2", */ f:parsenoop2 },&#13;
0x0200: { /* n:"Dimensions", */ f:parse_Dimensions },&#13;
0x0201: { /* n:"Blank", */ f:parse_Blank },&#13;
0x0203: { /* n:"Number", */ f:parse_Number },&#13;
0x0204: { /* n:"Label", */ f:parse_Label },&#13;
0x0205: { /* n:"BoolErr", */ f:parse_BoolErr },&#13;
0x0207: { /* n:"String", */ f:parse_String },&#13;
0x0208: { /* n:"Row", */ f:parse_Row },&#13;
0x020b: { /* n:"Index", */ },&#13;
0x0221: { /* n:"Array", */ f:parse_Array },&#13;
0x0225: { /* n:"DefaultRowHeight", */ f:parse_DefaultRowHeight },&#13;
0x0236: { /* n:"Table", */ },&#13;
0x023e: { /* n:"Window2", */ f:parse_Window2 },&#13;
0x027e: { /* n:"RK", */ f:parse_RK },&#13;
0x0293: { /* n:"Style", */ },&#13;
0x0418: { /* n:"BigName", */ },&#13;
0x041e: { /* n:"Format", */ f:parse_Format },&#13;
0x043c: { /* n:"ContinueBigName", */ },&#13;
0x04bc: { /* n:"ShrFmla", */ f:parse_ShrFmla },&#13;
0x0800: { /* n:"HLinkTooltip", */ f:parse_HLinkTooltip },&#13;
0x0801: { /* n:"WebPub", */ },&#13;
0x0802: { /* n:"QsiSXTag", */ },&#13;
0x0803: { /* n:"DBQueryExt", */ },&#13;
0x0804: { /* n:"ExtString", */ },&#13;
0x0805: { /* n:"TxtQry", */ },&#13;
0x0806: { /* n:"Qsir", */ },&#13;
0x0807: { /* n:"Qsif", */ },&#13;
0x0808: { /* n:"RRDTQSIF", */ },&#13;
0x0809: { /* n:"BOF", */ f:parse_BOF },&#13;
0x080a: { /* n:"OleDbConn", */ },&#13;
0x080b: { /* n:"WOpt", */ },&#13;
0x080c: { /* n:"SXViewEx", */ },&#13;
0x080d: { /* n:"SXTH", */ },&#13;
0x080e: { /* n:"SXPIEx", */ },&#13;
0x080f: { /* n:"SXVDTEx", */ },&#13;
0x0810: { /* n:"SXViewEx9", */ },&#13;
0x0812: { /* n:"ContinueFrt", */ },&#13;
0x0813: { /* n:"RealTimeData", */ },&#13;
0x0850: { /* n:"ChartFrtInfo", */ },&#13;
0x0851: { /* n:"FrtWrapper", */ },&#13;
0x0852: { /* n:"StartBlock", */ },&#13;
0x0853: { /* n:"EndBlock", */ },&#13;
0x0854: { /* n:"StartObject", */ },&#13;
0x0855: { /* n:"EndObject", */ },&#13;
0x0856: { /* n:"CatLab", */ },&#13;
0x0857: { /* n:"YMult", */ },&#13;
0x0858: { /* n:"SXViewLink", */ },&#13;
0x0859: { /* n:"PivotChartBits", */ },&#13;
0x085a: { /* n:"FrtFontList", */ },&#13;
0x0862: { /* n:"SheetExt", */ },&#13;
0x0863: { /* n:"BookExt", */ r:12},&#13;
0x0864: { /* n:"SXAddl", */ },&#13;
0x0865: { /* n:"CrErr", */ },&#13;
0x0866: { /* n:"HFPicture", */ },&#13;
0x0867: { /* n:"FeatHdr", */ f:parsenoop2 },&#13;
0x0868: { /* n:"Feat", */ },&#13;
0x086a: { /* n:"DataLabExt", */ },&#13;
0x086b: { /* n:"DataLabExtContents", */ },&#13;
0x086c: { /* n:"CellWatch", */ },&#13;
0x0871: { /* n:"FeatHdr11", */ },&#13;
0x0872: { /* n:"Feature11", */ },&#13;
0x0874: { /* n:"DropDownObjIds", */ },&#13;
0x0875: { /* n:"ContinueFrt11", */ },&#13;
0x0876: { /* n:"DConn", */ },&#13;
0x0877: { /* n:"List12", */ },&#13;
0x0878: { /* n:"Feature12", */ },&#13;
0x0879: { /* n:"CondFmt12", */ },&#13;
0x087a: { /* n:"CF12", */ },&#13;
0x087b: { /* n:"CFEx", */ },&#13;
0x087c: { /* n:"XFCRC", */ f:parse_XFCRC, r:12 },&#13;
0x087d: { /* n:"XFExt", */ f:parse_XFExt, r:12 },&#13;
0x087e: { /* n:"AutoFilter12", */ },&#13;
0x087f: { /* n:"ContinueFrt12", */ },&#13;
0x0884: { /* n:"MDTInfo", */ },&#13;
0x0885: { /* n:"MDXStr", */ },&#13;
0x0886: { /* n:"MDXTuple", */ },&#13;
0x0887: { /* n:"MDXSet", */ },&#13;
0x0888: { /* n:"MDXProp", */ },&#13;
0x0889: { /* n:"MDXKPI", */ },&#13;
0x088a: { /* n:"MDB", */ },&#13;
0x088b: { /* n:"PLV", */ },&#13;
0x088c: { /* n:"Compat12", */ f:parsebool, r:12 },&#13;
0x088d: { /* n:"DXF", */ },&#13;
0x088e: { /* n:"TableStyles", */ r:12 },&#13;
0x088f: { /* n:"TableStyle", */ },&#13;
0x0890: { /* n:"TableStyleElement", */ },&#13;
0x0892: { /* n:"StyleExt", */ },&#13;
0x0893: { /* n:"NamePublish", */ },&#13;
0x0894: { /* n:"NameCmt", */ f:parse_NameCmt, r:12 },&#13;
0x0895: { /* n:"SortData", */ },&#13;
0x0896: { /* n:"Theme", */ f:parse_Theme, r:12 },&#13;
0x0897: { /* n:"GUIDTypeLib", */ },&#13;
0x0898: { /* n:"FnGrp12", */ },&#13;
0x0899: { /* n:"NameFnGrp12", */ },&#13;
0x089a: { /* n:"MTRSettings", */ f:parse_MTRSettings, r:12 },&#13;
0x089b: { /* n:"CompressPictures", */ f:parsenoop2 },&#13;
0x089c: { /* n:"HeaderFooter", */ },&#13;
0x089d: { /* n:"CrtLayout12", */ },&#13;
0x089e: { /* n:"CrtMlFrt", */ },&#13;
0x089f: { /* n:"CrtMlFrtContinue", */ },&#13;
0x08a3: { /* n:"ForceFullCalculation", */ f:parse_ForceFullCalculation },&#13;
0x08a4: { /* n:"ShapePropsStream", */ },&#13;
0x08a5: { /* n:"TextPropsStream", */ },&#13;
0x08a6: { /* n:"RichTextStream", */ },&#13;
0x08a7: { /* n:"CrtLayout12A", */ },&#13;
0x1001: { /* n:"Units", */ },&#13;
0x1002: { /* n:"Chart", */ },&#13;
0x1003: { /* n:"Series", */ },&#13;
0x1006: { /* n:"DataFormat", */ },&#13;
0x1007: { /* n:"LineFormat", */ },&#13;
0x1009: { /* n:"MarkerFormat", */ },&#13;
0x100a: { /* n:"AreaFormat", */ },&#13;
0x100b: { /* n:"PieFormat", */ },&#13;
0x100c: { /* n:"AttachedLabel", */ },&#13;
0x100d: { /* n:"SeriesText", */ },&#13;
0x1014: { /* n:"ChartFormat", */ },&#13;
0x1015: { /* n:"Legend", */ },&#13;
0x1016: { /* n:"SeriesList", */ },&#13;
0x1017: { /* n:"Bar", */ },&#13;
0x1018: { /* n:"Line", */ },&#13;
0x1019: { /* n:"Pie", */ },&#13;
0x101a: { /* n:"Area", */ },&#13;
0x101b: { /* n:"Scatter", */ },&#13;
0x101c: { /* n:"CrtLine", */ },&#13;
0x101d: { /* n:"Axis", */ },&#13;
0x101e: { /* n:"Tick", */ },&#13;
0x101f: { /* n:"ValueRange", */ },&#13;
0x1020: { /* n:"CatSerRange", */ },&#13;
0x1021: { /* n:"AxisLine", */ },&#13;
0x1022: { /* n:"CrtLink", */ },&#13;
0x1024: { /* n:"DefaultText", */ },&#13;
0x1025: { /* n:"Text", */ },&#13;
0x1026: { /* n:"FontX", */ f:parseuint16 },&#13;
0x1027: { /* n:"ObjectLink", */ },&#13;
0x1032: { /* n:"Frame", */ },&#13;
0x1033: { /* n:"Begin", */ },&#13;
0x1034: { /* n:"End", */ },&#13;
0x1035: { /* n:"PlotArea", */ },&#13;
0x103a: { /* n:"Chart3d", */ },&#13;
0x103c: { /* n:"PicF", */ },&#13;
0x103d: { /* n:"DropBar", */ },&#13;
0x103e: { /* n:"Radar", */ },&#13;
0x103f: { /* n:"Surf", */ },&#13;
0x1040: { /* n:"RadarArea", */ },&#13;
0x1041: { /* n:"AxisParent", */ },&#13;
0x1043: { /* n:"LegendException", */ },&#13;
0x1044: { /* n:"ShtProps", */ f:parse_ShtProps },&#13;
0x1045: { /* n:"SerToCrt", */ },&#13;
0x1046: { /* n:"AxesUsed", */ },&#13;
0x1048: { /* n:"SBaseRef", */ },&#13;
0x104a: { /* n:"SerParent", */ },&#13;
0x104b: { /* n:"SerAuxTrend", */ },&#13;
0x104e: { /* n:"IFmtRecord", */ },&#13;
0x104f: { /* n:"Pos", */ },&#13;
0x1050: { /* n:"AlRuns", */ },&#13;
0x1051: { /* n:"BRAI", */ },&#13;
0x105b: { /* n:"SerAuxErrBar", */ },&#13;
0x105c: { /* n:"ClrtClient", */ f:parse_ClrtClient },&#13;
0x105d: { /* n:"SerFmt", */ },&#13;
0x105f: { /* n:"Chart3DBarShape", */ },&#13;
0x1060: { /* n:"Fbi", */ },&#13;
0x1061: { /* n:"BopPop", */ },&#13;
0x1062: { /* n:"AxcExt", */ },&#13;
0x1063: { /* n:"Dat", */ },&#13;
0x1064: { /* n:"PlotGrowth", */ },&#13;
0x1065: { /* n:"SIIndex", */ },&#13;
0x1066: { /* n:"GelFrame", */ },&#13;
0x1067: { /* n:"BopPopCustom", */ },&#13;
0x1068: { /* n:"Fbi2", */ },&#13;
&#13;
0x0000: { /* n:"Dimensions", */ f:parse_Dimensions },&#13;
0x0001: { /* n:"BIFF2BLANK", */ },&#13;
0x0002: { /* n:"BIFF2INT", */ f:parse_BIFF2INT },&#13;
0x0003: { /* n:"BIFF2NUM", */ f:parse_BIFF2NUM },&#13;
0x0004: { /* n:"BIFF2STR", */ f:parse_BIFF2STR },&#13;
0x0005: { /* n:"BoolErr", */ f:parse_BoolErr },&#13;
0x0007: { /* n:"String", */ f:parse_BIFF2STRING },&#13;
0x0008: { /* n:"BIFF2ROW", */ },&#13;
0x0009: { /* n:"BOF", */ f:parse_BOF },&#13;
0x000b: { /* n:"Index", */ },&#13;
0x0016: { /* n:"ExternCount", */ f:parseuint16 },&#13;
0x001e: { /* n:"BIFF2FORMAT", */ f:parse_BIFF2Format },&#13;
0x001f: { /* n:"BIFF2FMTCNT", */ }, /* 16-bit cnt of BIFF2FORMAT records */&#13;
0x0020: { /* n:"BIFF2COLINFO", */ },&#13;
0x0021: { /* n:"Array", */ f:parse_Array },&#13;
0x0024: { /* n:"COLWIDTH", */ },&#13;
0x0025: { /* n:"DefaultRowHeight", */ f:parse_DefaultRowHeight },&#13;
	// 0x2c ??&#13;
	// 0x2d ??&#13;
	// 0x2e ??&#13;
	// 0x30 FONTCOUNT: number of fonts&#13;
0x0032: { /* n:"BIFF2FONTXTRA", */ f:parse_BIFF2FONTXTRA },&#13;
	// 0x35: INFOOPTS&#13;
	// 0x36: TABLE (BIFF2 only)&#13;
	// 0x37: TABLE2 (BIFF2 only)&#13;
	// 0x38: WNDESK&#13;
	// 0x39 ??&#13;
	// 0x3a: BEGINPREF&#13;
	// 0x3b: ENDPREF&#13;
0x003e: { /* n:"BIFF2WINDOW2", */ },&#13;
	// 0x3f ??&#13;
	// 0x46: SHOWSCROLL&#13;
	// 0x47: SHOWFORMULA&#13;
	// 0x48: STATUSBAR&#13;
	// 0x49: SHORTMENUS&#13;
	// 0x4A:&#13;
	// 0x4B:&#13;
	// 0x4C:&#13;
	// 0x4E:&#13;
	// 0x4F:&#13;
	// 0x58: TOOLBAR (BIFF3)&#13;
&#13;
	/* - - - */&#13;
0x0034: { /* n:"DDEObjName", */ },&#13;
0x0043: { /* n:"BIFF2XF", */ },&#13;
0x0044: { /* n:"BIFF2XFINDEX", */ f:parseuint16 },&#13;
0x0045: { /* n:"BIFF2FONTCLR", */ },&#13;
0x0056: { /* n:"BIFF4FMTCNT", */ }, /* 16-bit cnt, similar to BIFF2 */&#13;
0x007e: { /* n:"RK", */ }, /* Not necessarily same as 0x027e */&#13;
0x007f: { /* n:"ImData", */ f:parse_ImData },&#13;
0x0087: { /* n:"Addin", */ },&#13;
0x0088: { /* n:"Edg", */ },&#13;
0x0089: { /* n:"Pub", */ },&#13;
	// 0x8A&#13;
	// 0x8B LH: alternate menu key flag (BIFF3/4)&#13;
	// 0x8E&#13;
	// 0x8F&#13;
0x0091: { /* n:"Sub", */ },&#13;
	// 0x93 STYLE&#13;
0x0094: { /* n:"LHRecord", */ },&#13;
0x0095: { /* n:"LHNGraph", */ },&#13;
0x0096: { /* n:"Sound", */ },&#13;
	// 0xA2 FNPROTO: function prototypes (BIFF4)&#13;
	// 0xA3&#13;
	// 0xA8&#13;
0x00a9: { /* n:"CoordList", */ },&#13;
0x00ab: { /* n:"GCW", */ },&#13;
0x00bc: { /* n:"ShrFmla", */ }, /* Not necessarily same as 0x04bc */&#13;
0x00bf: { /* n:"ToolbarHdr", */ },&#13;
0x00c0: { /* n:"ToolbarEnd", */ },&#13;
0x00c2: { /* n:"AddMenu", */ },&#13;
0x00c3: { /* n:"DelMenu", */ },&#13;
0x00d6: { /* n:"RString", */ f:parse_RString },&#13;
0x00df: { /* n:"UDDesc", */ },&#13;
0x00ea: { /* n:"TabIdConf", */ },&#13;
0x0162: { /* n:"XL5Modify", */ },&#13;
0x01a5: { /* n:"FileSharing2", */ },&#13;
0x0206: { /* n:"Formula", */ f:parse_Formula },&#13;
0x0209: { /* n:"BOF", */ f:parse_BOF },&#13;
0x0218: { /* n:"Lbl", */ f:parse_Lbl },&#13;
0x0223: { /* n:"ExternName", */ f:parse_ExternName },&#13;
0x0231: { /* n:"Font", */ },&#13;
0x0243: { /* n:"BIFF3XF", */ },&#13;
0x0406: { /* n:"Formula", */ f:parse_Formula },&#13;
0x0409: { /* n:"BOF", */ f:parse_BOF },&#13;
0x0443: { /* n:"BIFF4XF", */ },&#13;
0x086d: { /* n:"FeatInfo", */ },&#13;
0x0873: { /* n:"FeatInfo11", */ },&#13;
0x0881: { /* n:"SXAddl12", */ },&#13;
0x08c0: { /* n:"AutoWebPub", */ },&#13;
0x08c1: { /* n:"ListObj", */ },&#13;
0x08c2: { /* n:"ListField", */ },&#13;
0x08c3: { /* n:"ListDV", */ },&#13;
0x08c4: { /* n:"ListCondFmt", */ },&#13;
0x08c5: { /* n:"ListCF", */ },&#13;
0x08c6: { /* n:"FMQry", */ },&#13;
0x08c7: { /* n:"FMSQry", */ },&#13;
0x08c8: { /* n:"PLV", */ },&#13;
0x08c9: { /* n:"LnExt", */ },&#13;
0x08ca: { /* n:"MkrExt", */ },&#13;
0x08cb: { /* n:"CrtCoopt", */ },&#13;
0x08d6: { /* n:"FRTArchId$", */ r:12 },&#13;
&#13;
	/* --- multiplan 4 records --- */&#13;
0x0065: { /* n:"", */ }, // one per window&#13;
0x0066: { /* n:"", */ }, // calc settings&#13;
0x0069: { /* n:"", */ }, // print header&#13;
0x006a: { /* n:"", */ }, // print footer&#13;
0x006b: { /* n:"", */ }, // print settings&#13;
0x006d: { /* n:"", */ }, // one per window&#13;
0x0070: { /* n:"", */ }, // includes default col width&#13;
0x0072: { /* n:"", */ }, // includes selected cell&#13;
&#13;
0x7262: {}&#13;
};&#13;
&#13;
function write_biff_rec(ba, type, payload, length) {&#13;
	var t = type;&#13;
	if(isNaN(t)) return;&#13;
	var len = length || (payload||[]).length || 0;&#13;
	var o = ba.next(4);&#13;
	o.write_shift(2, t);&#13;
	o.write_shift(2, len);&#13;
	if(len &gt; 0 &amp;&amp; is_buf(payload)) ba.push(payload);&#13;
}&#13;
&#13;
function write_biff_continue(ba, type, payload, length) {&#13;
	var len = length || (payload||[]).length || 0;&#13;
	if(len &lt;= 8224) return write_biff_rec(ba, type, payload, len);&#13;
	var t = type;&#13;
	if(isNaN(t)) return;&#13;
	var parts = payload.parts || [], sidx = 0;&#13;
	var i = 0, w = 0;&#13;
	while(w + (parts[sidx] || 8224) &lt;= 8224) { w+= (parts[sidx] || 8224); sidx++; }&#13;
	var o = ba.next(4);&#13;
	o.write_shift(2, t);&#13;
	o.write_shift(2, w);&#13;
	ba.push(payload.slice(i, i + w));&#13;
	i += w;&#13;
	while(i &lt; len) {&#13;
		o = ba.next(4);&#13;
		o.write_shift(2, 0x3c); // TODO: figure out correct continue type&#13;
		w = 0;&#13;
		while(w + (parts[sidx] || 8224) &lt;= 8224) { w+= (parts[sidx] || 8224); sidx++; }&#13;
		o.write_shift(2, w);&#13;
		ba.push(payload.slice(i, i+w)); i+= w;&#13;
	}&#13;
}&#13;
&#13;
function write_BIFF2Cell(out, r, c) {&#13;
	if(!out) out = new_buf(7);&#13;
	out.write_shift(2, r);&#13;
	out.write_shift(2, c);&#13;
	out.write_shift(2, 0);&#13;
	out.write_shift(1, 0);&#13;
	return out;&#13;
}&#13;
&#13;
function write_BIFF2BERR(r, c, val, t) {&#13;
	var out = new_buf(9);&#13;
	write_BIFF2Cell(out, r, c);&#13;
	write_Bes(val, t || 'b', out);&#13;
	return out;&#13;
}&#13;
&#13;
/* TODO: codepage, large strings */&#13;
function write_BIFF2LABEL(r, c, val) {&#13;
	var out = new_buf(8 + 2*val.length);&#13;
	write_BIFF2Cell(out, r, c);&#13;
	out.write_shift(1, val.length);&#13;
	out.write_shift(val.length, val, 'sbcs');&#13;
	return out.l &lt; out.length ? out.slice(0, out.l) : out;&#13;
}&#13;
&#13;
function write_ws_biff2_cell(ba, cell, R, C) {&#13;
	if(cell.v != null) switch(cell.t) {&#13;
		case 'd': case 'n':&#13;
			var v = cell.t == 'd' ? datenum(parseDate(cell.v)) : cell.v;&#13;
			if((v == (v|0)) &amp;&amp; (v &gt;= 0) &amp;&amp; (v &lt; 65536))&#13;
				write_biff_rec(ba, 0x0002, write_BIFF2INT(R, C, v));&#13;
			else&#13;
				write_biff_rec(ba, 0x0003, write_BIFF2NUM(R,C, v));&#13;
			return;&#13;
		case 'b': case 'e': write_biff_rec(ba, 0x0005, write_BIFF2BERR(R, C, cell.v, cell.t)); return;&#13;
		/* TODO: codepage, sst */&#13;
		case 's': case 'str':&#13;
			write_biff_rec(ba, 0x0004, write_BIFF2LABEL(R, C, cell.v == null ? "" : String(cell.v).slice(0,255)));&#13;
			return;&#13;
	}&#13;
	write_biff_rec(ba, 0x0001, write_BIFF2Cell(null, R, C));&#13;
}&#13;
&#13;
function write_ws_biff2(ba, ws, idx, opts) {&#13;
	var dense = Array.isArray(ws);&#13;
	var range = safe_decode_range(ws['!ref'] || "A1"), ref, rr = "", cols = [];&#13;
	if(range.e.c &gt; 0xFF || range.e.r &gt; 0x3FFF) {&#13;
		if(opts.WTF) throw new Error("Range " + (ws['!ref'] || "A1") + " exceeds format limit A1:IV16384");&#13;
		range.e.c = Math.min(range.e.c, 0xFF);&#13;
		range.e.r = Math.min(range.e.c, 0x3FFF);&#13;
		ref = encode_range(range);&#13;
	}&#13;
	for(var R = range.s.r; R &lt;= range.e.r; ++R) {&#13;
		rr = encode_row(R);&#13;
		for(var C = range.s.c; C &lt;= range.e.c; ++C) {&#13;
			if(R === range.s.r) cols[C] = encode_col(C);&#13;
			ref = cols[C] + rr;&#13;
			var cell = dense ? (ws[R]||[])[C] : ws[ref];&#13;
			if(!cell) continue;&#13;
			/* write cell */&#13;
			write_ws_biff2_cell(ba, cell, R, C, opts);&#13;
		}&#13;
	}&#13;
}&#13;
&#13;
/* Based on test files */&#13;
function write_biff2_buf(wb, opts) {&#13;
	var o = opts || {};&#13;
	if(DENSE != null &amp;&amp; o.dense == null) o.dense = DENSE;&#13;
	var ba = buf_array();&#13;
	var idx = 0;&#13;
	for(var i=0;i&lt;wb.SheetNames.length;++i) if(wb.SheetNames[i] == o.sheet) idx=i;&#13;
	if(idx == 0 &amp;&amp; !!o.sheet &amp;&amp; wb.SheetNames[0] != o.sheet) throw new Error("Sheet not found: " + o.sheet);&#13;
	write_biff_rec(ba, (o.biff == 4 ? 0x0409 : (o.biff == 3 ? 0x0209 : 0x0009)), write_BOF(wb, 0x10, o));&#13;
	/* ... */&#13;
	write_ws_biff2(ba, wb.Sheets[wb.SheetNames[idx]], idx, o, wb);&#13;
	/* ... */&#13;
	write_biff_rec(ba, 0x000A);&#13;
	return ba.end();&#13;
}&#13;
&#13;
function write_FONTS_biff8(ba, data, opts) {&#13;
	write_biff_rec(ba, 0x0031 /* Font */, write_Font({&#13;
		sz:12,&#13;
		color: {theme:1},&#13;
		name: "Arial",&#13;
		family: 2,&#13;
		scheme: "minor"&#13;
	}, opts));&#13;
}&#13;
&#13;
&#13;
function write_FMTS_biff8(ba, NF, opts) {&#13;
	if(!NF) return;&#13;
	[[5,8],[23,26],[41,44],[/*63*/50,/*66],[164,*/392]].forEach(function(r) {&#13;
for(var i = r[0]; i &lt;= r[1]; ++i) if(NF[i] != null) write_biff_rec(ba, 0x041E /* Format */, write_Format(i, NF[i], opts));&#13;
	});&#13;
}&#13;
&#13;
function write_FEAT(ba, ws) {&#13;
	/* [MS-XLS] 2.4.112 */&#13;
	var o = new_buf(19);&#13;
	o.write_shift(4, 0x867); o.write_shift(4, 0); o.write_shift(4, 0);&#13;
	o.write_shift(2, 3); o.write_shift(1, 1); o.write_shift(4, 0);&#13;
	write_biff_rec(ba, 0x0867 /* FeatHdr */, o);&#13;
	/* [MS-XLS] 2.4.111 */&#13;
	o = new_buf(39);&#13;
	o.write_shift(4, 0x868); o.write_shift(4, 0); o.write_shift(4, 0);&#13;
	o.write_shift(2, 3); o.write_shift(1, 0); o.write_shift(4, 0);&#13;
	o.write_shift(2, 1); o.write_shift(4, 4); o.write_shift(2, 0);&#13;
	write_Ref8U(safe_decode_range(ws['!ref']||"A1"), o);&#13;
	o.write_shift(4, 4);&#13;
	write_biff_rec(ba, 0x0868 /* Feat */, o);&#13;
}&#13;
&#13;
function write_CELLXFS_biff8(ba, opts) {&#13;
	for(var i = 0; i &lt; 16; ++i) write_biff_rec(ba, 0x00e0 /* XF */, write_XF({numFmtId:0, style:true}, 0, opts));&#13;
	opts.cellXfs.forEach(function(c) {&#13;
		write_biff_rec(ba, 0x00e0 /* XF */, write_XF(c, 0, opts));&#13;
	});&#13;
}&#13;
&#13;
function write_ws_biff8_hlinks(ba, ws) {&#13;
	for(var R=0; R&lt;ws['!links'].length; ++R) {&#13;
		var HL = ws['!links'][R];&#13;
		write_biff_rec(ba, 0x01b8 /* HLink */, write_HLink(HL));&#13;
		if(HL[1].Tooltip) write_biff_rec(ba, 0x0800 /* HLinkTooltip */, write_HLinkTooltip(HL));&#13;
	}&#13;
	delete ws['!links'];&#13;
}&#13;
&#13;
function write_ws_cols_biff8(ba, cols) {&#13;
	if(!cols) return;&#13;
	var cnt = 0;&#13;
	cols.forEach(function(col, idx) {&#13;
		if(++cnt &lt;= 256 &amp;&amp; col) {&#13;
			write_biff_rec(ba, 0x007d /* ColInfo */, write_ColInfo(col_obj_w(idx, col), idx));&#13;
		}&#13;
	});&#13;
}&#13;
&#13;
function write_ws_biff8_cell(ba, cell, R, C, opts) {&#13;
	var os = 16 + get_cell_style(opts.cellXfs, cell, opts);&#13;
	if(cell.v == null &amp;&amp; !cell.bf) {&#13;
		write_biff_rec(ba, 0x0201 /* Blank */, write_XLSCell(R, C, os));&#13;
		return;&#13;
	}&#13;
	if(cell.bf) write_biff_rec(ba, 0x0006 /* Formula */, write_Formula(cell, R, C, opts, os));&#13;
	else switch(cell.t) {&#13;
		case 'd': case 'n':&#13;
			var v = cell.t == 'd' ? datenum(parseDate(cell.v)) : cell.v;&#13;
			/* TODO: emit RK as appropriate */&#13;
			write_biff_rec(ba, 0x0203 /* Number */, write_Number(R, C, v, os, opts));&#13;
			break;&#13;
		case 'b': case 'e':&#13;
			write_biff_rec(ba, 0x0205 /* BoolErr */, write_BoolErr(R, C, cell.v, os, opts, cell.t));&#13;
			break;&#13;
		/* TODO: codepage, sst */&#13;
		case 's': case 'str':&#13;
			if(opts.bookSST) {&#13;
				var isst = get_sst_id(opts.Strings, cell.v == null ? "" : String(cell.v), opts.revStrings);&#13;
				write_biff_rec(ba, 0x00fd /* LabelSst */, write_LabelSst(R, C, isst, os, opts));&#13;
			} else write_biff_rec(ba, 0x0204 /* Label */, write_Label(R, C, (cell.v == null ? "" : String(cell.v)).slice(0,255), os, opts));&#13;
			break;&#13;
		default:&#13;
			write_biff_rec(ba, 0x0201 /* Blank */, write_XLSCell(R, C, os));&#13;
	}&#13;
}&#13;
&#13;
/* [MS-XLS] 2.1.7.20.5 */&#13;
function write_ws_biff8(idx, opts, wb) {&#13;
	var ba = buf_array();&#13;
	var s = wb.SheetNames[idx], ws = wb.Sheets[s] || {};&#13;
	var _WB = ((wb||{}).Workbook||{});&#13;
	var _sheet = ((_WB.Sheets||[])[idx]||{});&#13;
	var dense = Array.isArray(ws);&#13;
	var b8 = opts.biff == 8;&#13;
	var ref, rr = "", cols = [];&#13;
	var range = safe_decode_range(ws['!ref'] || "A1");&#13;
	var MAX_ROWS = b8 ? 65536 : 16384;&#13;
	if(range.e.c &gt; 0xFF || range.e.r &gt;= MAX_ROWS) {&#13;
		if(opts.WTF) throw new Error("Range " + (ws['!ref'] || "A1") + " exceeds format limit A1:IV16384");&#13;
		range.e.c = Math.min(range.e.c, 0xFF);&#13;
		range.e.r = Math.min(range.e.c, MAX_ROWS-1);&#13;
	}&#13;
&#13;
	write_biff_rec(ba, 0x0809, write_BOF(wb, 0x10, opts));&#13;
	/* [Uncalced] Index */&#13;
	write_biff_rec(ba, 0x000d /* CalcMode */, writeuint16(1));&#13;
	write_biff_rec(ba, 0x000c /* CalcCount */, writeuint16(100));&#13;
	write_biff_rec(ba, 0x000f /* CalcRefMode */, writebool(true));&#13;
	write_biff_rec(ba, 0x0011 /* CalcIter */, writebool(false));&#13;
	write_biff_rec(ba, 0x0010 /* CalcDelta */, write_Xnum(0.001));&#13;
	write_biff_rec(ba, 0x005f /* CalcSaveRecalc */, writebool(true));&#13;
	write_biff_rec(ba, 0x002a /* PrintRowCol */, writebool(false));&#13;
	write_biff_rec(ba, 0x002b /* PrintGrid */, writebool(false));&#13;
	write_biff_rec(ba, 0x0082 /* GridSet */, writeuint16(1));&#13;
	write_biff_rec(ba, 0x0080 /* Guts */, write_Guts([0,0]));&#13;
	/* DefaultRowHeight WsBool [Sync] [LPr] [HorizontalPageBreaks] [VerticalPageBreaks] */&#13;
	/* Header (string) */&#13;
	/* Footer (string) */&#13;
	write_biff_rec(ba, 0x0083 /* HCenter */, writebool(false));&#13;
	write_biff_rec(ba, 0x0084 /* VCenter */, writebool(false));&#13;
	/* ... */&#13;
	if(b8) write_ws_cols_biff8(ba, ws["!cols"]);&#13;
	/* ... */&#13;
	write_biff_rec(ba, 0x0200 /* Dimensions */, write_Dimensions(range, opts));&#13;
	/* ... */&#13;
&#13;
	if(b8) ws['!links'] = [];&#13;
	var comments = [];&#13;
	for(var R = range.s.r; R &lt;= range.e.r; ++R) {&#13;
		rr = encode_row(R);&#13;
		for(var C = range.s.c; C &lt;= range.e.c; ++C) {&#13;
			if(R === range.s.r) cols[C] = encode_col(C);&#13;
			ref = cols[C] + rr;&#13;
			var cell = dense ? (ws[R]||[])[C] : ws[ref];&#13;
			if(!cell) continue;&#13;
			/* write cell */&#13;
			write_ws_biff8_cell(ba, cell, R, C, opts);&#13;
			if(b8 &amp;&amp; cell.l) ws['!links'].push([ref, cell.l]);&#13;
			if(b8 &amp;&amp; cell.c) comments.push([ref, cell.c]);&#13;
		}&#13;
	}&#13;
	var cname = _sheet.CodeName || _sheet.name || s;&#13;
	/* ... */&#13;
	// if(b8) comments.forEach(function(comment) { write_biff_rec(ba, 0x001c /* Note */, write_NoteSh(comment)); });&#13;
	/* ... */&#13;
	if(b8) write_biff_rec(ba, 0x023e /* Window2 */, write_Window2((_WB.Views||[])[0]));&#13;
	/* ... */&#13;
	if(b8 &amp;&amp; (ws['!merges']||[]).length) write_biff_rec(ba, 0x00e5 /* MergeCells */, write_MergeCells(ws['!merges']));&#13;
	/* [LRng] *QUERYTABLE [PHONETICINFO] CONDFMTS */&#13;
	if(b8) write_ws_biff8_hlinks(ba, ws);&#13;
	/* [DVAL] */&#13;
	write_biff_rec(ba, 0x01ba /* CodeName */, write_XLUnicodeString(cname, opts));&#13;
	/* *WebPub *CellWatch [SheetExt] */&#13;
	if(b8) write_FEAT(ba, ws);&#13;
	/* *FEAT11 *RECORD12 */&#13;
	write_biff_rec(ba, 0x000a /* EOF */);&#13;
	return ba.end();&#13;
}&#13;
&#13;
/* [MS-XLS] 2.1.7.20.3 */&#13;
function write_biff8_global(wb, bufs, opts) {&#13;
	var A = buf_array();&#13;
	var _WB = ((wb||{}).Workbook||{});&#13;
	var _sheets = (_WB.Sheets||[]);&#13;
	var _wb = _WB.WBProps||{};&#13;
	var b8 = opts.biff == 8, b5 = opts.biff == 5;&#13;
	write_biff_rec(A, 0x0809, write_BOF(wb, 0x05, opts));&#13;
	if(opts.bookType == "xla") write_biff_rec(A, 0x0087 /* Addin */);&#13;
	write_biff_rec(A, 0x00e1 /* InterfaceHdr */, b8 ? writeuint16(0x04b0) : null);&#13;
	write_biff_rec(A, 0x00c1 /* Mms */, writezeroes(2));&#13;
	if(b5) write_biff_rec(A, 0x00bf /* ToolbarHdr */);&#13;
	if(b5) write_biff_rec(A, 0x00c0 /* ToolbarEnd */);&#13;
	write_biff_rec(A, 0x00e2 /* InterfaceEnd */);&#13;
	write_biff_rec(A, 0x005c /* WriteAccess */, write_WriteAccess("xlsx", opts));&#13;
	/* [FileSharing] */&#13;
	write_biff_rec(A, 0x0042 /* CodePage */, writeuint16(b8 ? 0x04b0 : 0x04E4));&#13;
	/* *2047 Lel */&#13;
	if(b8) write_biff_rec(A, 0x0161 /* DSF */, writeuint16(0));&#13;
	if(b8) write_biff_rec(A, 0x01c0 /* Excel9File */);&#13;
	write_biff_rec(A, 0x013d /* RRTabId */, write_RRTabId(wb.SheetNames.length));&#13;
	if(b8 &amp;&amp; wb.vbaraw) write_biff_rec(A, 0x00d3 /* ObProj */);&#13;
	/* [ObNoMacros] */&#13;
	if(b8 &amp;&amp; wb.vbaraw) {&#13;
		var cname = _wb.CodeName || "ThisWorkbook";&#13;
		write_biff_rec(A, 0x01ba /* CodeName */, write_XLUnicodeString(cname, opts));&#13;
	}&#13;
	write_biff_rec(A, 0x009c /* BuiltInFnGroupCount */, writeuint16(0x11));&#13;
	/* *FnGroupName *FnGrp12 */&#13;
	/* *Lbl */&#13;
	/* [OleObjectSize] */&#13;
	write_biff_rec(A, 0x0019 /* WinProtect */, writebool(false));&#13;
	write_biff_rec(A, 0x0012 /* Protect */, writebool(false));&#13;
	write_biff_rec(A, 0x0013 /* Password */, writeuint16(0));&#13;
	if(b8) write_biff_rec(A, 0x01af /* Prot4Rev */, writebool(false));&#13;
	if(b8) write_biff_rec(A, 0x01bc /* Prot4RevPass */, writeuint16(0));&#13;
	write_biff_rec(A, 0x003d /* Window1 */, write_Window1(opts));&#13;
	write_biff_rec(A, 0x0040 /* Backup */, writebool(false));&#13;
	write_biff_rec(A, 0x008d /* HideObj */, writeuint16(0));&#13;
	write_biff_rec(A, 0x0022 /* Date1904 */, writebool(safe1904(wb)=="true"));&#13;
	write_biff_rec(A, 0x000e /* CalcPrecision */, writebool(true));&#13;
	if(b8) write_biff_rec(A, 0x01b7 /* RefreshAll */, writebool(false));&#13;
	write_biff_rec(A, 0x00DA /* BookBool */, writeuint16(0));&#13;
	/* ... */&#13;
	write_FONTS_biff8(A, wb, opts);&#13;
	write_FMTS_biff8(A, wb.SSF, opts);&#13;
	write_CELLXFS_biff8(A, opts);&#13;
	/* ... */&#13;
	if(b8) write_biff_rec(A, 0x0160 /* UsesELFs */, writebool(false));&#13;
	var a = A.end();&#13;
&#13;
	var C = buf_array();&#13;
	/* METADATA [MTRSettings] [ForceFullCalculation] */&#13;
	if(b8) write_biff_rec(C, 0x008C /* Country */, write_Country());&#13;
	/* *SUPBOOK *LBL *RTD [RecalcId] *HFPicture *MSODRAWINGGROUP */&#13;
&#13;
	/* BIFF8: [SST *Continue] ExtSST */&#13;
	if(b8 &amp;&amp; opts.Strings) write_biff_continue(C, 0x00FC /* SST */, write_SST(opts.Strings, opts));&#13;
&#13;
	/* *WebPub [WOpt] [CrErr] [BookExt] *FeatHdr *DConn [THEME] [CompressPictures] [Compat12] [GUIDTypeLib] */&#13;
	write_biff_rec(C, 0x000A /* EOF */);&#13;
	var c = C.end();&#13;
&#13;
	var B = buf_array();&#13;
	var blen = 0, j = 0;&#13;
	for(j = 0; j &lt; wb.SheetNames.length; ++j) blen += (b8 ? 12 : 11) + (b8 ? 2 : 1) * wb.SheetNames[j].length;&#13;
	var start = a.length + blen + c.length;&#13;
	for(j = 0; j &lt; wb.SheetNames.length; ++j) {&#13;
		var _sheet = _sheets[j] || ({});&#13;
		write_biff_rec(B, 0x0085 /* BoundSheet8 */, write_BoundSheet8({pos:start, hs:_sheet.Hidden||0, dt:0, name:wb.SheetNames[j]}, opts));&#13;
		start += bufs[j].length;&#13;
	}&#13;
	/* 1*BoundSheet8 */&#13;
	var b = B.end();&#13;
	if(blen != b.length) throw new Error("BS8 " + blen + " != " + b.length);&#13;
&#13;
	var out = [];&#13;
	if(a.length) out.push(a);&#13;
	if(b.length) out.push(b);&#13;
	if(c.length) out.push(c);&#13;
	return bconcat(out);&#13;
}&#13;
&#13;
/* [MS-XLS] 2.1.7.20 Workbook Stream */&#13;
function write_biff8_buf(wb, opts) {&#13;
	var o = opts || {};&#13;
	var bufs = [];&#13;
&#13;
	if(wb &amp;&amp; !wb.SSF) {&#13;
		wb.SSF = dup(table_fmt);&#13;
	}&#13;
	if(wb &amp;&amp; wb.SSF) {&#13;
		make_ssf(); SSF_load_table(wb.SSF);&#13;
		// $FlowIgnore&#13;
		o.revssf = evert_num(wb.SSF); o.revssf[wb.SSF[65535]] = 0;&#13;
		o.ssf = wb.SSF;&#13;
	}&#13;
&#13;
	o.Strings = []; o.Strings.Count = 0; o.Strings.Unique = 0;&#13;
	fix_write_opts(o);&#13;
&#13;
	o.cellXfs = [];&#13;
	get_cell_style(o.cellXfs, {}, {revssf:{"General":0}});&#13;
&#13;
	if(!wb.Props) wb.Props = {};&#13;
&#13;
	for(var i = 0; i &lt; wb.SheetNames.length; ++i) bufs[bufs.length] = write_ws_biff8(i, o, wb);&#13;
	bufs.unshift(write_biff8_global(wb, bufs, o));&#13;
	return bconcat(bufs);&#13;
}&#13;
&#13;
function write_biff_buf(wb, opts) {&#13;
	for(var i = 0; i &lt;= wb.SheetNames.length; ++i) {&#13;
		var ws = wb.Sheets[wb.SheetNames[i]];&#13;
		if(!ws || !ws["!ref"]) continue;&#13;
		var range = decode_range(ws["!ref"]);&#13;
		if(range.e.c &gt; 255) { // note: 255 is IV&#13;
			if(typeof console != "undefined" &amp;&amp; console.error) console.error("Worksheet '" + wb.SheetNames[i] + "' extends beyond column IV (255).  Data may be lost.");&#13;
		}&#13;
	}&#13;
&#13;
	var o = opts || {};&#13;
	switch(o.biff || 2) {&#13;
		case 8: case 5: return write_biff8_buf(wb, opts);&#13;
		case 4: case 3: case 2: return write_biff2_buf(wb, opts);&#13;
	}&#13;
	throw new Error("invalid type " + o.bookType + " for BIFF");&#13;
}&#13;
/* note: browser DOM element cannot see mso- style attrs, must parse */&#13;
function html_to_sheet(str, _opts) {&#13;
	var opts = _opts || {};&#13;
	if(DENSE != null &amp;&amp; opts.dense == null) opts.dense = DENSE;&#13;
	var ws = opts.dense ? ([]) : ({});&#13;
	str = str.replace(/&lt;!--.*?--&gt;/g, "");&#13;
	var mtch = str.match(/&lt;table/i);&#13;
	if(!mtch) throw new Error("Invalid HTML: could not find &lt;table&gt;");&#13;
	var mtch2 = str.match(/&lt;\/table/i);&#13;
	var i = mtch.index, j = mtch2 &amp;&amp; mtch2.index || str.length;&#13;
	var rows = split_regex(str.slice(i, j), /(:?&lt;tr[^&gt;]*&gt;)/i, "&lt;tr&gt;");&#13;
	var R = -1, C = 0, RS = 0, CS = 0;&#13;
	var range = {s:{r:10000000, c:10000000},e:{r:0,c:0}};&#13;
	var merges = [];&#13;
	for(i = 0; i &lt; rows.length; ++i) {&#13;
		var row = rows[i].trim();&#13;
		var hd = row.slice(0,3).toLowerCase();&#13;
		if(hd == "&lt;tr") { ++R; if(opts.sheetRows &amp;&amp; opts.sheetRows &lt;= R) { --R; break; } C = 0; continue; }&#13;
		if(hd != "&lt;td" &amp;&amp; hd != "&lt;th") continue;&#13;
		var cells = row.split(/&lt;\/t[dh]&gt;/i);&#13;
		for(j = 0; j &lt; cells.length; ++j) {&#13;
			var cell = cells[j].trim();&#13;
			if(!cell.match(/&lt;t[dh]/i)) continue;&#13;
			var m = cell, cc = 0;&#13;
			/* TODO: parse styles etc */&#13;
			while(m.charAt(0) == "&lt;" &amp;&amp; (cc = m.indexOf("&gt;")) &gt; -1) m = m.slice(cc+1);&#13;
			for(var midx = 0; midx &lt; merges.length; ++midx) {&#13;
				var _merge = merges[midx];&#13;
				if(_merge.s.c == C &amp;&amp; _merge.s.r &lt; R &amp;&amp; R &lt;= _merge.e.r) { C = _merge.e.c + 1; midx = -1; }&#13;
			}&#13;
			var tag = parsexmltag(cell.slice(0, cell.indexOf("&gt;")));&#13;
			CS = tag.colspan ? +tag.colspan : 1;&#13;
			if((RS = +tag.rowspan)&gt;1 || CS&gt;1) merges.push({s:{r:R,c:C},e:{r:R + (RS||1) - 1, c:C + CS - 1}});&#13;
			var _t = tag.t || tag["data-t"] || "";&#13;
			/* TODO: generate stub cells */&#13;
			if(!m.length) { C += CS; continue; }&#13;
			m = htmldecode(m);&#13;
			if(range.s.r &gt; R) range.s.r = R; if(range.e.r &lt; R) range.e.r = R;&#13;
			if(range.s.c &gt; C) range.s.c = C; if(range.e.c &lt; C) range.e.c = C;&#13;
			if(!m.length) { C += CS; continue; }&#13;
			var o = {t:'s', v:m};&#13;
			if(opts.raw || !m.trim().length || _t == 's'){}&#13;
			else if(m === 'TRUE') o = {t:'b', v:true};&#13;
			else if(m === 'FALSE') o = {t:'b', v:false};&#13;
			else if(!isNaN(fuzzynum(m))) o = {t:'n', v:fuzzynum(m)};&#13;
			else if(!isNaN(fuzzydate(m).getDate())) {&#13;
				o = ({t:'d', v:parseDate(m)});&#13;
				if(!opts.cellDates) o = ({t:'n', v:datenum(o.v)});&#13;
				o.z = opts.dateNF || table_fmt[14];&#13;
			}&#13;
			if(opts.dense) { if(!ws[R]) ws[R] = []; ws[R][C] = o; }&#13;
			else ws[encode_cell({r:R, c:C})] = o;&#13;
			C += CS;&#13;
		}&#13;
	}&#13;
	ws['!ref'] = encode_range(range);&#13;
	if(merges.length) ws["!merges"] = merges;&#13;
	return ws;&#13;
}&#13;
function make_html_row(ws, r, R, o) {&#13;
	var M = (ws['!merges'] ||[]);&#13;
	var oo = [];&#13;
	var sp = ({});&#13;
	for(var C = r.s.c; C &lt;= r.e.c; ++C) {&#13;
		var RS = 0, CS = 0;&#13;
		for(var j = 0; j &lt; M.length; ++j) {&#13;
			if(M[j].s.r &gt; R || M[j].s.c &gt; C) continue;&#13;
			if(M[j].e.r &lt; R || M[j].e.c &lt; C) continue;&#13;
			if(M[j].s.r &lt; R || M[j].s.c &lt; C) { RS = -1; break; }&#13;
			RS = M[j].e.r - M[j].s.r + 1; CS = M[j].e.c - M[j].s.c + 1; break;&#13;
		}&#13;
		if(RS &lt; 0) continue;&#13;
		var coord = encode_cell({r:R,c:C});&#13;
		var cell = o.dense ? (ws[R]||[])[C] : ws[coord];&#13;
		/* TODO: html entities */&#13;
		var w = (cell &amp;&amp; cell.v != null) &amp;&amp; (cell.h || escapehtml(cell.w || (format_cell(cell), cell.w) || "")) || "";&#13;
		sp = ({});&#13;
		if(RS &gt; 1) sp.rowspan = RS;&#13;
		if(CS &gt; 1) sp.colspan = CS;&#13;
		if(o.editable) w = '&lt;span contenteditable="true"&gt;' + w + '&lt;/span&gt;';&#13;
		else if(cell) {&#13;
			sp["data-t"] = cell &amp;&amp; cell.t || 'z';&#13;
			if(cell.v != null) sp["data-v"] = cell.v;&#13;
			if(cell.z != null) sp["data-z"] = cell.z;&#13;
			if(cell.l &amp;&amp; (cell.l.Target || "#").charAt(0) != "#") w = '&lt;a href="' + cell.l.Target +'"&gt;' + w + '&lt;/a&gt;';&#13;
		}&#13;
		sp.id = (o.id || "sjs") + "-" + coord;&#13;
		oo.push(writextag('td', w, sp));&#13;
	}&#13;
	var preamble = "&lt;tr&gt;";&#13;
	return preamble + oo.join("") + "&lt;/tr&gt;";&#13;
}&#13;
&#13;
var HTML_BEGIN = '&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"/&gt;&lt;title&gt;xlsx Table Export&lt;/title&gt;&lt;/head&gt;&lt;body&gt;';&#13;
var HTML_END = '&lt;/body&gt;&lt;/html&gt;';&#13;
&#13;
function html_to_workbook(str, opts) {&#13;
	var mtch = str.match(/&lt;table[\s\S]*?&gt;[\s\S]*?&lt;\/table&gt;/gi);&#13;
	if(!mtch || mtch.length == 0) throw new Error("Invalid HTML: could not find &lt;table&gt;");&#13;
	if(mtch.length == 1) {&#13;
		var w = sheet_to_workbook(html_to_sheet(mtch[0], opts), opts);&#13;
		w.bookType = "html";&#13;
		return w;&#13;
	}&#13;
	var wb = book_new();&#13;
	mtch.forEach(function(s, idx) { book_append_sheet(wb, html_to_sheet(s, opts), "Sheet" + (idx+1)); });&#13;
	wb.bookType = "html";&#13;
	return wb;&#13;
}&#13;
&#13;
function make_html_preamble(ws, R, o) {&#13;
	var out = [];&#13;
	return out.join("") + '&lt;table' + (o &amp;&amp; o.id ? ' id="' + o.id + '"' : "") + '&gt;';&#13;
}&#13;
&#13;
function sheet_to_html(ws, opts/*, wb:?Workbook*/) {&#13;
	var o = opts || {};&#13;
	var header = o.header != null ? o.header : HTML_BEGIN;&#13;
	var footer = o.footer != null ? o.footer : HTML_END;&#13;
	var out = [header];&#13;
	var r = decode_range(ws['!ref']);&#13;
	o.dense = Array.isArray(ws);&#13;
	out.push(make_html_preamble(ws, r, o));&#13;
	for(var R = r.s.r; R &lt;= r.e.r; ++R) out.push(make_html_row(ws, r, R, o));&#13;
	out.push("&lt;/table&gt;" + footer);&#13;
	return out.join("");&#13;
}&#13;
&#13;
function sheet_add_dom(ws, table, _opts) {&#13;
	var rows = table.rows;&#13;
	if(!rows) {&#13;
		/* not an HTML TABLE */&#13;
		throw "Unsupported origin when " + table.tagName + " is not a TABLE";&#13;
	}&#13;
&#13;
	var opts = _opts || {};&#13;
	if(DENSE != null) opts.dense = DENSE;&#13;
	var or_R = 0, or_C = 0;&#13;
	if(opts.origin != null) {&#13;
		if(typeof opts.origin == 'number') or_R = opts.origin;&#13;
		else {&#13;
			var _origin = typeof opts.origin == "string" ? decode_cell(opts.origin) : opts.origin;&#13;
			or_R = _origin.r; or_C = _origin.c;&#13;
		}&#13;
	}&#13;
&#13;
	var sheetRows = Math.min(opts.sheetRows||10000000, rows.length);&#13;
	var range = {s:{r:0,c:0},e:{r:or_R,c:or_C}};&#13;
	if(ws["!ref"]) {&#13;
		var _range = decode_range(ws["!ref"]);&#13;
		range.s.r = Math.min(range.s.r, _range.s.r);&#13;
		range.s.c = Math.min(range.s.c, _range.s.c);&#13;
		range.e.r = Math.max(range.e.r, _range.e.r);&#13;
		range.e.c = Math.max(range.e.c, _range.e.c);&#13;
		if(or_R == -1) range.e.r = or_R = _range.e.r + 1;&#13;
	}&#13;
	var merges = [], midx = 0;&#13;
	var rowinfo = ws["!rows"] || (ws["!rows"] = []);&#13;
	var _R = 0, R = 0, _C = 0, C = 0, RS = 0, CS = 0;&#13;
	if(!ws["!cols"]) ws['!cols'] = [];&#13;
	for(; _R &lt; rows.length &amp;&amp; R &lt; sheetRows; ++_R) {&#13;
		var row = rows[_R];&#13;
		if (is_dom_element_hidden(row)) {&#13;
			if (opts.display) continue;&#13;
			rowinfo[R] = {hidden: true};&#13;
		}&#13;
		var elts = (row.cells);&#13;
		for(_C = C = 0; _C &lt; elts.length; ++_C) {&#13;
			var elt = elts[_C];&#13;
			if (opts.display &amp;&amp; is_dom_element_hidden(elt)) continue;&#13;
			var v = elt.hasAttribute('data-v') ? elt.getAttribute('data-v') : elt.hasAttribute('v') ? elt.getAttribute('v') : htmldecode(elt.innerHTML);&#13;
			var z = elt.getAttribute('data-z') || elt.getAttribute('z');&#13;
			for(midx = 0; midx &lt; merges.length; ++midx) {&#13;
				var m = merges[midx];&#13;
				if(m.s.c == C + or_C &amp;&amp; m.s.r &lt; R + or_R &amp;&amp; R + or_R &lt;= m.e.r) { C = m.e.c+1 - or_C; midx = -1; }&#13;
			}&#13;
			/* TODO: figure out how to extract nonstandard mso- style */&#13;
			CS = +elt.getAttribute("colspan") || 1;&#13;
			if( ((RS = (+elt.getAttribute("rowspan") || 1)))&gt;1 || CS&gt;1) merges.push({s:{r:R + or_R,c:C + or_C},e:{r:R + or_R + (RS||1) - 1, c:C + or_C + (CS||1) - 1}});&#13;
			var o = {t:'s', v:v};&#13;
			var _t = elt.getAttribute("data-t") || elt.getAttribute("t") || "";&#13;
			if(v != null) {&#13;
				if(v.length == 0) o.t = _t || 'z';&#13;
				else if(opts.raw || v.trim().length == 0 || _t == "s"){}&#13;
				else if(v === 'TRUE') o = {t:'b', v:true};&#13;
				else if(v === 'FALSE') o = {t:'b', v:false};&#13;
				else if(!isNaN(fuzzynum(v))) o = {t:'n', v:fuzzynum(v)};&#13;
				else if(!isNaN(fuzzydate(v).getDate())) {&#13;
					o = ({t:'d', v:parseDate(v)});&#13;
					if(!opts.cellDates) o = ({t:'n', v:datenum(o.v)});&#13;
					o.z = opts.dateNF || table_fmt[14];&#13;
				}&#13;
			}&#13;
			if(o.z === undefined &amp;&amp; z != null) o.z = z;&#13;
			/* The first link is used.  Links are assumed to be fully specified.&#13;
			 * TODO: The right way to process relative links is to make a new &lt;a&gt; */&#13;
			var l = "", Aelts = elt.getElementsByTagName("A");&#13;
			if(Aelts &amp;&amp; Aelts.length) for(var Aelti = 0; Aelti &lt; Aelts.length; ++Aelti)	if(Aelts[Aelti].hasAttribute("href")) {&#13;
				l = Aelts[Aelti].getAttribute("href"); if(l.charAt(0) != "#") break;&#13;
			}&#13;
			if(l &amp;&amp; l.charAt(0) != "#" &amp;&amp;	l.slice(0, 11).toLowerCase() != 'javascript:') o.l = ({ Target: l });&#13;
			if(opts.dense) { if(!ws[R + or_R]) ws[R + or_R] = []; ws[R + or_R][C + or_C] = o; }&#13;
			else ws[encode_cell({c:C + or_C, r:R + or_R})] = o;&#13;
			if(range.e.c &lt; C + or_C) range.e.c = C + or_C;&#13;
			C += CS;&#13;
		}&#13;
		++R;&#13;
	}&#13;
	if(merges.length) ws['!merges'] = (ws["!merges"] || []).concat(merges);&#13;
	range.e.r = Math.max(range.e.r, R - 1 + or_R);&#13;
	ws['!ref'] = encode_range(range);&#13;
	if(R &gt;= sheetRows) ws['!fullref'] = encode_range((range.e.r = rows.length-_R+R-1 + or_R,range)); // We can count the real number of rows to parse but we don't to improve the performance&#13;
	return ws;&#13;
}&#13;
&#13;
function parse_dom_table(table, _opts) {&#13;
	var opts = _opts || {};&#13;
	var ws = opts.dense ? ([]) : ({});&#13;
	return sheet_add_dom(ws, table, _opts);&#13;
}&#13;
&#13;
function table_to_book(table, opts) {&#13;
	var o = sheet_to_workbook(parse_dom_table(table, opts), opts);&#13;
	//o.bookType = "dom"; // TODO: define a type for this&#13;
	return o;&#13;
}&#13;
&#13;
function is_dom_element_hidden(element) {&#13;
	var display = '';&#13;
	var get_computed_style = get_get_computed_style_function(element);&#13;
	if(get_computed_style) display = get_computed_style(element).getPropertyValue('display');&#13;
	if(!display) display = element.style &amp;&amp; element.style.display;&#13;
	return display === 'none';&#13;
}&#13;
&#13;
/* global getComputedStyle */&#13;
function get_get_computed_style_function(element) {&#13;
	// The proper getComputedStyle implementation is the one defined in the element window&#13;
	if(element.ownerDocument.defaultView &amp;&amp; typeof element.ownerDocument.defaultView.getComputedStyle === 'function') return element.ownerDocument.defaultView.getComputedStyle;&#13;
	// If it is not available, try to get one from the global namespace&#13;
	if(typeof getComputedStyle === 'function') return getComputedStyle;&#13;
	return null;&#13;
}&#13;
/* OpenDocument */&#13;
function parse_text_p(text) {&#13;
	/* 6.1.2 White Space Characters */&#13;
	var fixed = text&#13;
		.replace(/[\t\r\n]/g, " ").trim().replace(/ +/g, " ")&#13;
		.replace(/&lt;text:s\/&gt;/g," ")&#13;
		.replace(/&lt;text:s text:c="(\d+)"\/&gt;/g, function($$,$1) { return Array(parseInt($1,10)+1).join(" "); })&#13;
		.replace(/&lt;text:tab[^&gt;]*\/&gt;/g,"\t")&#13;
		.replace(/&lt;text:line-break\/&gt;/g,"\n");&#13;
	var v = unescapexml(fixed.replace(/&lt;[^&gt;]*&gt;/g,""));&#13;
&#13;
	return [v];&#13;
}&#13;
&#13;
/* Note: ODS can stick styles in content.xml or styles.xml, FODS blurs lines */&#13;
function parse_ods_styles(d, _opts, _nfm) {&#13;
	var number_format_map = _nfm || {};&#13;
	var str = xlml_normalize(d);&#13;
	xlmlregex.lastIndex = 0;&#13;
	str = str.replace(/&lt;!--([\s\S]*?)--&gt;/mg,"").replace(/&lt;!DOCTYPE[^\[]*\[[^\]]*\]&gt;/gm,"");&#13;
	var Rn, NFtag, NF = "", tNF = "", y, etpos = 0, tidx = -1, infmt = false, payload = "";&#13;
	while((Rn = xlmlregex.exec(str))) {&#13;
		switch((Rn[3]=Rn[3].replace(/_.*$/,""))) {&#13;
		/* Number Format Definitions */&#13;
		case 'number-style': // &lt;number:number-style&gt; 16.29.2&#13;
		case 'currency-style': // &lt;number:currency-style&gt; 16.29.8&#13;
		case 'percentage-style': // &lt;number:percentage-style&gt; 16.29.10&#13;
		case 'date-style': // &lt;number:date-style&gt; 16.29.11&#13;
		case 'time-style': // &lt;number:time-style&gt; 16.29.19&#13;
		case 'text-style': // &lt;number:text-style&gt; 16.29.26&#13;
			if(Rn[1]==='/') {&#13;
				infmt = false;&#13;
				if(NFtag['truncate-on-overflow'] == "false") {&#13;
					if(NF.match(/h/)) NF = NF.replace(/h+/, "[$&amp;]");&#13;
					else if(NF.match(/m/)) NF = NF.replace(/m+/, "[$&amp;]");&#13;
					else if(NF.match(/s/)) NF = NF.replace(/s+/, "[$&amp;]");&#13;
				}&#13;
				number_format_map[NFtag.name] = NF;&#13;
				NF = "";&#13;
			} else if(Rn[0].charAt(Rn[0].length-2) !== '/') {&#13;
				infmt = true;&#13;
				NF = "";&#13;
				NFtag = parsexmltag(Rn[0], false);&#13;
			} break;&#13;
&#13;
		// LibreOffice bug https://bugs.documentfoundation.org/show_bug.cgi?id=149484&#13;
		case 'boolean-style': // &lt;number:boolean-style&gt; 16.29.24&#13;
			if(Rn[1]==='/') {&#13;
				infmt = false;&#13;
				number_format_map[NFtag.name] = "General";&#13;
				NF = "";&#13;
			} else if(Rn[0].charAt(Rn[0].length-2) !== '/') {&#13;
				infmt = true;&#13;
				NF = "";&#13;
				NFtag = parsexmltag(Rn[0], false);&#13;
			} break;&#13;
&#13;
		/* Number Format Elements */&#13;
		case 'boolean': // &lt;number:boolean&gt; 16.29.25&#13;
			NF += "General"; // ODF spec is unfortunately underspecified here&#13;
			break;&#13;
&#13;
		case 'text': // &lt;number:text&gt; 16.29.27&#13;
			if(Rn[1]==='/') {&#13;
				payload = str.slice(tidx, xlmlregex.lastIndex - Rn[0].length);&#13;
				// NOTE: Excel has a different interpretation of "%%" and friends&#13;
				if(payload == "%" &amp;&amp; NFtag[0] == '&lt;number:percentage-style') NF += "%";&#13;
				else NF += '"' + payload.replace(/"/g, '""') + '"';&#13;
			} else if(Rn[0].charAt(Rn[0].length-2) !== '/') {&#13;
				tidx = xlmlregex.lastIndex;&#13;
			} break;&#13;
&#13;
&#13;
		case 'day': { // &lt;number:day&gt; 16.29.12&#13;
			y = parsexmltag(Rn[0], false);&#13;
			switch(y["style"]) {&#13;
				case "short": NF += "d"; break;&#13;
				case "long": NF += "dd"; break;&#13;
				default: NF += "dd"; break; // TODO: error condition&#13;
			}&#13;
		} break;&#13;
&#13;
		case 'day-of-week': { // &lt;number:day-of-week&gt; 16.29.16&#13;
			y = parsexmltag(Rn[0], false);&#13;
			switch(y["style"]) {&#13;
				case "short": NF += "ddd"; break;&#13;
				case "long": NF += "dddd"; break;&#13;
				default: NF += "ddd"; break;&#13;
			}&#13;
		} break;&#13;
&#13;
		case 'era': { // &lt;number:era&gt; 16.29.15 TODO: proper mapping&#13;
			y = parsexmltag(Rn[0], false);&#13;
			switch(y["style"]) {&#13;
				case "short": NF += "ee"; break;&#13;
				case "long": NF += "eeee"; break;&#13;
				default: NF += "eeee"; break; // TODO: error condition&#13;
			}&#13;
		} break;&#13;
&#13;
		case 'hours': { // &lt;number:hours&gt; 16.29.20&#13;
			y = parsexmltag(Rn[0], false);&#13;
			switch(y["style"]) {&#13;
				case "short": NF += "h"; break;&#13;
				case "long": NF += "hh"; break;&#13;
				default: NF += "hh"; break; // TODO: error condition&#13;
			}&#13;
		} break;&#13;
&#13;
		case 'minutes': { // &lt;number:minutes&gt; 16.29.21&#13;
			y = parsexmltag(Rn[0], false);&#13;
			switch(y["style"]) {&#13;
				case "short": NF += "m"; break;&#13;
				case "long": NF += "mm"; break;&#13;
				default: NF += "mm"; break; // TODO: error condition&#13;
			}&#13;
		} break;&#13;
&#13;
		case 'month': { // &lt;number:month&gt; 16.29.13&#13;
			y = parsexmltag(Rn[0], false);&#13;
			if(y["textual"]) NF += "mm";&#13;
			switch(y["style"]) {&#13;
				case "short": NF += "m"; break;&#13;
				case "long": NF += "mm"; break;&#13;
				default: NF += "m"; break;&#13;
			}&#13;
		} break;&#13;
&#13;
		case 'seconds': { // &lt;number:seconds&gt; 16.29.22&#13;
			y = parsexmltag(Rn[0], false);&#13;
			switch(y["style"]) {&#13;
				case "short": NF += "s"; break;&#13;
				case "long": NF += "ss"; break;&#13;
				default: NF += "ss"; break; // TODO: error condition&#13;
			}&#13;
			if(y["decimal-places"]) NF += "." + fill("0", +y["decimal-places"]);&#13;
		} break;&#13;
&#13;
		case 'year': { // &lt;number:year&gt; 16.29.14&#13;
			y = parsexmltag(Rn[0], false);&#13;
			switch(y["style"]) {&#13;
				case "short": NF += "yy"; break;&#13;
				case "long": NF += "yyyy"; break;&#13;
				default: NF += "yy"; break; // TODO: error condition&#13;
			}&#13;
		} break;&#13;
&#13;
		case 'am-pm': // &lt;number:am-pm&gt; 16.29.23&#13;
			NF += "AM/PM"; // LO autocorrects A/P -&gt; AM/PM&#13;
			break;&#13;
&#13;
		case 'week-of-year': // &lt;number:week-of-year&gt; 16.29.17&#13;
		case 'quarter': // &lt;number:quarter&gt; 16.29.18&#13;
			console.error("Excel does not support ODS format token " + Rn[3]);&#13;
			break;&#13;
&#13;
		case 'fill-character': // &lt;number:fill-character&gt; 16.29.5&#13;
			if(Rn[1]==='/') {&#13;
				payload = str.slice(tidx, xlmlregex.lastIndex - Rn[0].length);&#13;
				// NOTE: Excel has a different interpretation of "%%" and friends&#13;
				NF += '"' + payload.replace(/"/g, '""') + '"*';&#13;
			} else if(Rn[0].charAt(Rn[0].length-2) !== '/') {&#13;
				tidx = xlmlregex.lastIndex;&#13;
			} break;&#13;
&#13;
		case 'scientific-number': // &lt;number:scientific-number&gt; 16.29.6&#13;
			// TODO: find a mapping for all parameters&#13;
			y = parsexmltag(Rn[0], false);&#13;
			NF += "0." + fill("0", +y["min-decimal-places"] || +y["decimal-places"] || 2) + fill("?", +y["decimal-places"] - +y["min-decimal-places"] || 0) + "E" + (parsexmlbool(y["forced-exponent-sign"]) ? "+" : "") + fill("0", +y["min-exponent-digits"] || 2);&#13;
			break;&#13;
&#13;
		case 'fraction': // &lt;number:fraction&gt; 16.29.7&#13;
			// TODO: find a mapping for all parameters&#13;
			y = parsexmltag(Rn[0], false);&#13;
			if(!+y["min-integer-digits"]) NF += "#";&#13;
			else NF += fill("0", +y["min-integer-digits"]);&#13;
			NF += " ";&#13;
			NF += fill("?", +y["min-numerator-digits"] || 1);&#13;
			NF += "/";&#13;
			if(+y["denominator-value"]) NF += y["denominator-value"];&#13;
			else NF += fill("?", +y["min-denominator-digits"] || 1);&#13;
			break;&#13;
&#13;
		case 'currency-symbol': // &lt;number:currency-symbol&gt; 16.29.9&#13;
			// TODO: localization with [$-...]&#13;
			if(Rn[1]==='/') {&#13;
				NF += '"' + str.slice(tidx, xlmlregex.lastIndex - Rn[0].length).replace(/"/g, '""') + '"';&#13;
			} else if(Rn[0].charAt(Rn[0].length-2) !== '/') {&#13;
				tidx = xlmlregex.lastIndex;&#13;
			} else NF += "$";&#13;
			break;&#13;
&#13;
		case 'text-properties': // &lt;style:text-properties&gt; 16.29.29&#13;
			y = parsexmltag(Rn[0], false);&#13;
			switch((y["color"]||"").toLowerCase().replace("#", "")) {&#13;
				case "ff0000": case "red": NF = "[Red]" + NF; break;&#13;
			}&#13;
			break;&#13;
&#13;
		case 'text-content': // &lt;number:text-content&gt; 16.29.28&#13;
			NF += "@";&#13;
			break;&#13;
&#13;
		case 'map': // &lt;style:map&gt; 16.3&#13;
			// TODO: handle more complex maps&#13;
			y = parsexmltag(Rn[0], false);&#13;
			if(unescapexml(y["condition"]) == "value()&gt;=0") NF = number_format_map[y["apply-style-name"]] + ";" + NF;&#13;
			else console.error("ODS number format may be incorrect: " + y["condition"]);&#13;
			break;&#13;
&#13;
		case 'number': // &lt;number:number&gt; 16.29.3&#13;
			// TODO: handle all the attributes&#13;
			if(Rn[1]==='/') break;&#13;
			y = parsexmltag(Rn[0], false);&#13;
			tNF = "";&#13;
			tNF += fill("0", +y["min-integer-digits"] || 1);&#13;
			if(parsexmlbool(y["grouping"])) tNF = commaify(fill("#", Math.max(0, 4 - tNF.length)) + tNF);&#13;
			if(+y["min-decimal-places"] || +y["decimal-places"]) tNF += ".";&#13;
			if(+y["min-decimal-places"]) tNF += fill("0", +y["min-decimal-places"] || 1);&#13;
			if(+y["decimal-places"] - (+y["min-decimal-places"]||0)) tNF += fill("0", +y["decimal-places"] - (+y["min-decimal-places"]||0)); // TODO: should this be "#" ?&#13;
			NF += tNF;&#13;
			break;&#13;
&#13;
		case 'embedded-text': // &lt;number:embedded-text&gt; 16.29.4&#13;
			// TODO: verify interplay with grouping et al&#13;
			if(Rn[1]==='/') {&#13;
				if(etpos == 0) NF += '"' + str.slice(tidx, xlmlregex.lastIndex - Rn[0].length).replace(/"/g, '""') + '"';&#13;
				else NF = NF.slice(0, etpos) + '"' + str.slice(tidx, xlmlregex.lastIndex - Rn[0].length).replace(/"/g, '""') + '"' + NF.slice(etpos);&#13;
			} else if(Rn[0].charAt(Rn[0].length-2) !== '/') {&#13;
				tidx = xlmlregex.lastIndex;&#13;
				etpos = -+parsexmltag(Rn[0], false)["position"] || 0;&#13;
			} break;&#13;
&#13;
	}}&#13;
	return number_format_map;&#13;
}&#13;
&#13;
function parse_content_xml(d, _opts, _nfm) {&#13;
		var opts = _opts || {};&#13;
		if(DENSE != null &amp;&amp; opts.dense == null) opts.dense = DENSE;&#13;
		var str = xlml_normalize(d);&#13;
		var state = [], tmp;&#13;
		var tag;&#13;
		var nfidx, NF = "", pidx = 0;&#13;
		var sheetag;&#13;
		var rowtag;&#13;
		var Sheets = {}, SheetNames = [];&#13;
		var ws = opts.dense ? ([]) : ({});&#13;
		var Rn, q;&#13;
		var ctag = ({value:""});&#13;
		var textp = "", textpidx = 0, textptag;&#13;
		var textR = [];&#13;
		var R = -1, C = -1, range = {s: {r:1000000,c:10000000}, e: {r:0, c:0}};&#13;
		var row_ol = 0;&#13;
		var number_format_map = _nfm || {}, styles = {};&#13;
		var merges = [], mrange = {}, mR = 0, mC = 0;&#13;
		var rowinfo = [], rowpeat = 1, colpeat = 1;&#13;
		var arrayf = [];&#13;
		var WB = {Names:[], WBProps:{}};&#13;
		var atag = ({});&#13;
		var _Ref = ["", ""];&#13;
		var comments = [], comment = ({});&#13;
		var creator = "", creatoridx = 0;&#13;
		var isstub = false, intable = false;&#13;
		var i = 0;&#13;
		var baddate = 0;&#13;
		xlmlregex.lastIndex = 0;&#13;
		str = str.replace(/&lt;!--([\s\S]*?)--&gt;/mg,"").replace(/&lt;!DOCTYPE[^\[]*\[[^\]]*\]&gt;/gm,"");&#13;
		while((Rn = xlmlregex.exec(str))) switch((Rn[3]=Rn[3].replace(/_.*$/,""))) {&#13;
&#13;
			case 'table': case '工作表': // 9.1.2 &lt;table:table&gt;&#13;
				if(Rn[1]==='/') {&#13;
					if(range.e.c &gt;= range.s.c &amp;&amp; range.e.r &gt;= range.s.r) ws['!ref'] = encode_range(range);&#13;
					else ws['!ref'] = "A1:A1";&#13;
					if(opts.sheetRows &gt; 0 &amp;&amp; opts.sheetRows &lt;= range.e.r) {&#13;
						ws['!fullref'] = ws['!ref'];&#13;
						range.e.r = opts.sheetRows - 1;&#13;
						ws['!ref'] = encode_range(range);&#13;
					}&#13;
					if(merges.length) ws['!merges'] = merges;&#13;
					if(rowinfo.length) ws["!rows"] = rowinfo;&#13;
					sheetag.name = sheetag['名称'] || sheetag.name;&#13;
					if(typeof JSON !== 'undefined') JSON.stringify(sheetag);&#13;
					SheetNames.push(sheetag.name);&#13;
					Sheets[sheetag.name] = ws;&#13;
					intable = false;&#13;
				}&#13;
				else if(Rn[0].charAt(Rn[0].length-2) !== '/') {&#13;
					sheetag = parsexmltag(Rn[0], false);&#13;
					R = C = -1;&#13;
					range.s.r = range.s.c = 10000000; range.e.r = range.e.c = 0;&#13;
					ws = opts.dense ? ([]) : ({}); merges = [];&#13;
					rowinfo = [];&#13;
					intable = true;&#13;
				}&#13;
				break;&#13;
&#13;
			case 'table-row-group': // 9.1.9 &lt;table:table-row-group&gt;&#13;
				if(Rn[1] === "/") --row_ol; else ++row_ol;&#13;
				break;&#13;
			case 'table-row': case '行': // 9.1.3 &lt;table:table-row&gt;&#13;
				if(Rn[1] === '/') { R+=rowpeat; rowpeat = 1; break; }&#13;
				rowtag = parsexmltag(Rn[0], false);&#13;
				if(rowtag['行号']) R = rowtag['行号'] - 1; else if(R == -1) R = 0;&#13;
				rowpeat = +rowtag['number-rows-repeated'] || 1;&#13;
				/* TODO: remove magic */&#13;
				if(rowpeat &lt; 10) for(i = 0; i &lt; rowpeat; ++i) if(row_ol &gt; 0) rowinfo[R + i] = {level: row_ol};&#13;
				C = -1; break;&#13;
			case 'covered-table-cell': // 9.1.5 &lt;table:covered-table-cell&gt;&#13;
				if(Rn[1] !== '/') ++C;&#13;
				if(opts.sheetStubs) {&#13;
					if(opts.dense) { if(!ws[R]) ws[R] = []; ws[R][C] = {t:'z'}; }&#13;
					else ws[encode_cell({r:R,c:C})] = {t:'z'};&#13;
				}&#13;
				textp = ""; textR = [];&#13;
				break; /* stub */&#13;
			case 'table-cell': case '数据':&#13;
				if(Rn[0].charAt(Rn[0].length-2) === '/') {&#13;
					++C;&#13;
					ctag = parsexmltag(Rn[0], false);&#13;
					colpeat = parseInt(ctag['number-columns-repeated']||"1", 10);&#13;
					q = ({t:'z', v:null});&#13;
					if(ctag.formula &amp;&amp; opts.cellFormula != false) q.f = ods_to_csf_formula(unescapexml(ctag.formula));&#13;
					if(ctag["style-name"] &amp;&amp; styles[ctag["style-name"]]) q.z = styles[ctag["style-name"]];&#13;
					if((ctag['数据类型'] || ctag['value-type']) == "string") {&#13;
						q.t = "s"; q.v = unescapexml(ctag['string-value'] || "");&#13;
						if(opts.dense) {&#13;
							if(!ws[R]) ws[R] = [];&#13;
							ws[R][C] = q;&#13;
						} else {&#13;
							ws[encode_cell({r:R,c:C})] = q;&#13;
						}&#13;
					}&#13;
					C+= colpeat-1;&#13;
				} else if(Rn[1]!=='/') {&#13;
					++C;&#13;
					textp = ""; textpidx = 0; textR = [];&#13;
					colpeat = 1;&#13;
					var rptR = rowpeat ? R + rowpeat - 1 : R;&#13;
					if(C &gt; range.e.c) range.e.c = C;&#13;
					if(C &lt; range.s.c) range.s.c = C;&#13;
					if(R &lt; range.s.r) range.s.r = R;&#13;
					if(rptR &gt; range.e.r) range.e.r = rptR;&#13;
					ctag = parsexmltag(Rn[0], false);&#13;
					comments = []; comment = ({});&#13;
					q = ({t:ctag['数据类型'] || ctag['value-type'], v:null});&#13;
					if(ctag["style-name"] &amp;&amp; styles[ctag["style-name"]]) q.z = styles[ctag["style-name"]];&#13;
					if(opts.cellFormula) {&#13;
						if(ctag.formula) ctag.formula = unescapexml(ctag.formula);&#13;
						if(ctag['number-matrix-columns-spanned'] &amp;&amp; ctag['number-matrix-rows-spanned']) {&#13;
							mR = parseInt(ctag['number-matrix-rows-spanned'],10) || 0;&#13;
							mC = parseInt(ctag['number-matrix-columns-spanned'],10) || 0;&#13;
							mrange = {s: {r:R,c:C}, e:{r:R + mR-1,c:C + mC-1}};&#13;
							q.F = encode_range(mrange);&#13;
							arrayf.push([mrange, q.F]);&#13;
						}&#13;
						if(ctag.formula) q.f = ods_to_csf_formula(ctag.formula);&#13;
						else for(i = 0; i &lt; arrayf.length; ++i)&#13;
							if(R &gt;= arrayf[i][0].s.r &amp;&amp; R &lt;= arrayf[i][0].e.r)&#13;
								if(C &gt;= arrayf[i][0].s.c &amp;&amp; C &lt;= arrayf[i][0].e.c)&#13;
									q.F = arrayf[i][1];&#13;
					}&#13;
					if(ctag['number-columns-spanned'] || ctag['number-rows-spanned']) {&#13;
						mR = parseInt(ctag['number-rows-spanned'],10) || 0;&#13;
						mC = parseInt(ctag['number-columns-spanned'],10) || 0;&#13;
						mrange = {s: {r:R,c:C}, e:{r:R + mR-1,c:C + mC-1}};&#13;
						merges.push(mrange);&#13;
					}&#13;
&#13;
					/* 19.675.2 table:number-columns-repeated */&#13;
					if(ctag['number-columns-repeated']) colpeat = parseInt(ctag['number-columns-repeated'], 10);&#13;
&#13;
					/* 19.385 office:value-type */&#13;
					switch(q.t) {&#13;
						case 'boolean': q.t = 'b'; q.v = parsexmlbool(ctag['boolean-value']) || (+ctag['boolean-value'] &gt;= 1); break;&#13;
						case 'float': q.t = 'n'; q.v = parseFloat(ctag.value); break;&#13;
						case 'percentage': q.t = 'n'; q.v = parseFloat(ctag.value); break;&#13;
						case 'currency': q.t = 'n'; q.v = parseFloat(ctag.value); break;&#13;
						case 'date': q.t = 'd'; q.v = parseDate(ctag['date-value']);&#13;
							if(!opts.cellDates) { q.t = 'n'; q.v = datenum(q.v, WB.WBProps.date1904) - baddate; }&#13;
							if(!q.z) q.z = 'm/d/yy'; break;&#13;
						case 'time': q.t = 'n'; q.v = parse_isodur(ctag['time-value'])/86400;&#13;
							if(opts.cellDates) { q.t = 'd'; q.v = numdate(q.v); }&#13;
							if(!q.z) q.z = 'HH:MM:SS'; break;&#13;
						case 'number': q.t = 'n'; q.v = parseFloat(ctag['数据数值']); break;&#13;
						default:&#13;
							if(q.t === 'string' || q.t === 'text' || !q.t) {&#13;
								q.t = 's';&#13;
								if(ctag['string-value'] != null) { textp = unescapexml(ctag['string-value']); textR = []; }&#13;
							} else throw new Error('Unsupported value type ' + q.t);&#13;
					}&#13;
				} else {&#13;
					isstub = false;&#13;
					if(q.t === 's') {&#13;
						q.v = textp || '';&#13;
						if(textR.length) q.R = textR;&#13;
						isstub = textpidx == 0;&#13;
					}&#13;
					if(atag.Target) q.l = atag;&#13;
					if(comments.length &gt; 0) { q.c = comments; comments = []; }&#13;
					if(textp &amp;&amp; opts.cellText !== false) q.w = textp;&#13;
					if(isstub) { q.t = "z"; delete q.v; }&#13;
					if(!isstub || opts.sheetStubs) {&#13;
						if(!(opts.sheetRows &amp;&amp; opts.sheetRows &lt;= R)) {&#13;
							for(var rpt = 0; rpt &lt; rowpeat; ++rpt) {&#13;
								colpeat = parseInt(ctag['number-columns-repeated']||"1", 10);&#13;
								if(opts.dense) {&#13;
									if(!ws[R + rpt]) ws[R + rpt] = [];&#13;
									ws[R + rpt][C] = rpt == 0 ? q : dup(q);&#13;
									while(--colpeat &gt; 0) ws[R + rpt][C + colpeat] = dup(q);&#13;
								} else {&#13;
									ws[encode_cell({r:R + rpt,c:C})] = q;&#13;
									while(--colpeat &gt; 0) ws[encode_cell({r:R + rpt,c:C + colpeat})] = dup(q);&#13;
								}&#13;
								if(range.e.c &lt;= C) range.e.c = C;&#13;
							}&#13;
						}&#13;
					}&#13;
					colpeat = parseInt(ctag['number-columns-repeated']||"1", 10);&#13;
					C += colpeat-1; colpeat = 0;&#13;
					q = {};&#13;
					textp = ""; textR = [];&#13;
				}&#13;
				atag = ({});&#13;
				break; // 9.1.4 &lt;table:table-cell&gt;&#13;
&#13;
			/* pure state */&#13;
			case 'document': // TODO: &lt;office:document&gt; is the root for FODS&#13;
			case 'document-content': case '电子表格文档': // 3.1.3.2 &lt;office:document-content&gt;&#13;
			case 'spreadsheet': case '主体': // 3.7 &lt;office:spreadsheet&gt;&#13;
			case 'scripts': // 3.12 &lt;office:scripts&gt;&#13;
			case 'styles': // TODO &lt;office:styles&gt;&#13;
			case 'font-face-decls': // 3.14 &lt;office:font-face-decls&gt;&#13;
			case 'master-styles': // 3.15.4 &lt;office:master-styles&gt; -- relevant for FODS&#13;
				if(Rn[1]==='/'){if((tmp=state.pop())[0]!==Rn[3]) throw "Bad state: "+tmp;}&#13;
				else if(Rn[0].charAt(Rn[0].length-2) !== '/') state.push([Rn[3], true]);&#13;
				break;&#13;
&#13;
			case 'annotation': // 14.1 &lt;office:annotation&gt;&#13;
				if(Rn[1]==='/'){&#13;
					if((tmp=state.pop())[0]!==Rn[3]) throw "Bad state: "+tmp;&#13;
					comment.t = textp;&#13;
					if(textR.length) comment.R = textR;&#13;
					comment.a = creator;&#13;
					comments.push(comment);&#13;
				}&#13;
				else if(Rn[0].charAt(Rn[0].length-2) !== '/') {state.push([Rn[3], false]);}&#13;
				creator = ""; creatoridx = 0;&#13;
				textp = ""; textpidx = 0; textR = [];&#13;
				break;&#13;
&#13;
			case 'creator': // 4.3.2.7 &lt;dc:creator&gt;&#13;
				if(Rn[1]==='/') { creator = str.slice(creatoridx,Rn.index); }&#13;
				else creatoridx = Rn.index + Rn[0].length;&#13;
				break;&#13;
&#13;
			/* ignore state */&#13;
			case 'meta': case '元数据': // TODO: &lt;office:meta&gt; &lt;uof:元数据&gt; FODS/UOF&#13;
			case 'settings': // TODO: &lt;office:settings&gt;&#13;
			case 'config-item-set': // TODO: &lt;office:config-item-set&gt;&#13;
			case 'config-item-map-indexed': // TODO: &lt;office:config-item-map-indexed&gt;&#13;
			case 'config-item-map-entry': // TODO: &lt;office:config-item-map-entry&gt;&#13;
			case 'config-item-map-named': // TODO: &lt;office:config-item-map-entry&gt;&#13;
			case 'shapes': // 9.2.8 &lt;table:shapes&gt;&#13;
			case 'frame': // 10.4.2 &lt;draw:frame&gt;&#13;
			case 'text-box': // 10.4.3 &lt;draw:text-box&gt;&#13;
			case 'image': // 10.4.4 &lt;draw:image&gt;&#13;
			case 'data-pilot-tables': // 9.6.2 &lt;table:data-pilot-tables&gt;&#13;
			case 'list-style': // 16.30 &lt;text:list-style&gt;&#13;
			case 'form': // 13.13 &lt;form:form&gt;&#13;
			case 'dde-links': // 9.8 &lt;table:dde-links&gt;&#13;
			case 'event-listeners': // TODO&#13;
			case 'chart': // TODO&#13;
				if(Rn[1]==='/'){if((tmp=state.pop())[0]!==Rn[3]) throw "Bad state: "+tmp;}&#13;
				else if(Rn[0].charAt(Rn[0].length-2) !== '/') state.push([Rn[3], false]);&#13;
				textp = ""; textpidx = 0; textR = [];&#13;
				break;&#13;
&#13;
			case 'scientific-number': // &lt;number:scientific-number&gt;&#13;
			case 'currency-symbol': // &lt;number:currency-symbol&gt;&#13;
			case 'fill-character': // 16.29.5 &lt;number:fill-character&gt;&#13;
				break;&#13;
&#13;
			case 'text-style': // 16.27.25 &lt;number:text-style&gt;&#13;
			case 'boolean-style': // 16.27.23 &lt;number:boolean-style&gt;&#13;
			case 'number-style': // 16.27.2 &lt;number:number-style&gt;&#13;
			case 'currency-style': // 16.29.8 &lt;number:currency-style&gt;&#13;
			case 'percentage-style': // 16.27.9 &lt;number:percentage-style&gt;&#13;
			case 'date-style': // 16.27.10 &lt;number:date-style&gt;&#13;
			case 'time-style': // 16.27.18 &lt;number:time-style&gt;&#13;
				if(Rn[1]==='/'){&#13;
					var xlmlidx = xlmlregex.lastIndex;&#13;
					parse_ods_styles(str.slice(nfidx, xlmlregex.lastIndex), _opts, number_format_map);&#13;
					xlmlregex.lastIndex = xlmlidx;&#13;
				} else if(Rn[0].charAt(Rn[0].length-2) !== '/') {&#13;
					nfidx = xlmlregex.lastIndex - Rn[0].length;&#13;
				} break;&#13;
&#13;
			case 'script': break; // 3.13 &lt;office:script&gt;&#13;
			case 'libraries': break; // TODO: &lt;ooo:libraries&gt;&#13;
			case 'automatic-styles': break; // 3.15.3 &lt;office:automatic-styles&gt;&#13;
&#13;
			case 'default-style': // TODO: &lt;style:default-style&gt;&#13;
			case 'page-layout': break; // TODO: &lt;style:page-layout&gt;&#13;
			case 'style': { // 16.2 &lt;style:style&gt;&#13;
				var styletag = parsexmltag(Rn[0], false);&#13;
				if(styletag["family"] == "table-cell" &amp;&amp; number_format_map[styletag["data-style-name"]]) styles[styletag["name"]] = number_format_map[styletag["data-style-name"]];&#13;
			} break;&#13;
			case 'map': break; // 16.3 &lt;style:map&gt;&#13;
			case 'font-face': break; // 16.21 &lt;style:font-face&gt;&#13;
&#13;
			case 'paragraph-properties': break; // 17.6 &lt;style:paragraph-properties&gt;&#13;
			case 'table-properties': break; // 17.15 &lt;style:table-properties&gt;&#13;
			case 'table-column-properties': break; // 17.16 &lt;style:table-column-properties&gt;&#13;
			case 'table-row-properties': break; // 17.17 &lt;style:table-row-properties&gt;&#13;
			case 'table-cell-properties': break; // 17.18 &lt;style:table-cell-properties&gt;&#13;
&#13;
			case 'number': // 16.27.3 &lt;number:number&gt;&#13;
				break;&#13;
&#13;
			case 'fraction': break; // TODO 16.27.6 &lt;number:fraction&gt;&#13;
&#13;
			case 'day': // 16.27.11 &lt;number:day&gt;&#13;
			case 'month': // 16.27.12 &lt;number:month&gt;&#13;
			case 'year': // 16.27.13 &lt;number:year&gt;&#13;
			case 'era': // 16.27.14 &lt;number:era&gt;&#13;
			case 'day-of-week': // 16.27.15 &lt;number:day-of-week&gt;&#13;
			case 'week-of-year': // 16.27.16 &lt;number:week-of-year&gt;&#13;
			case 'quarter': // 16.27.17 &lt;number:quarter&gt;&#13;
			case 'hours': // 16.27.19 &lt;number:hours&gt;&#13;
			case 'minutes': // 16.27.20 &lt;number:minutes&gt;&#13;
			case 'seconds': // 16.27.21 &lt;number:seconds&gt;&#13;
			case 'am-pm': // 16.27.22 &lt;number:am-pm&gt;&#13;
				break;&#13;
&#13;
			case 'boolean': break; // 16.27.24 &lt;number:boolean&gt;&#13;
			case 'text': // 16.27.26 &lt;number:text&gt;&#13;
				if(Rn[0].slice(-2) === "/&gt;") break;&#13;
				else if(Rn[1]==="/") switch(state[state.length-1][0]) {&#13;
					case 'number-style':&#13;
					case 'date-style':&#13;
					case 'time-style':&#13;
						NF += str.slice(pidx, Rn.index);&#13;
						break;&#13;
				}&#13;
				else pidx = Rn.index + Rn[0].length;&#13;
				break;&#13;
&#13;
			case 'named-range': // 9.4.12 &lt;table:named-range&gt;&#13;
				tag = parsexmltag(Rn[0], false);&#13;
				_Ref = ods_to_csf_3D(tag['cell-range-address']);&#13;
				var nrange = ({Name:tag.name, Ref:_Ref[0] + '!' + _Ref[1]});&#13;
				if(intable) nrange.Sheet = SheetNames.length;&#13;
				WB.Names.push(nrange);&#13;
				break;&#13;
&#13;
			case 'text-content': break; // 16.27.27 &lt;number:text-content&gt;&#13;
			case 'text-properties': break; // 16.27.27 &lt;style:text-properties&gt;&#13;
			case 'embedded-text': break; // 16.27.4 &lt;number:embedded-text&gt;&#13;
&#13;
			case 'body': case '电子表格': break; // 3.3 16.9.6 19.726.3&#13;
&#13;
			case 'forms': break; // 12.25.2 13.2&#13;
			case 'table-column': break; // 9.1.6 &lt;table:table-column&gt;&#13;
			case 'table-header-rows': break; // 9.1.7 &lt;table:table-header-rows&gt;&#13;
			case 'table-rows': break; // 9.1.12 &lt;table:table-rows&gt;&#13;
			/* TODO: outline levels */&#13;
			case 'table-column-group': break; // 9.1.10 &lt;table:table-column-group&gt;&#13;
			case 'table-header-columns': break; // 9.1.11 &lt;table:table-header-columns&gt;&#13;
			case 'table-columns': break; // 9.1.12 &lt;table:table-columns&gt;&#13;
&#13;
			case 'null-date': // 9.4.2 &lt;table:null-date&gt;&#13;
				tag = parsexmltag(Rn[0], false);&#13;
				switch(tag["date-value"]) {&#13;
					case "1904-01-01": WB.WBProps.date1904 = true;&#13;
					/* falls through */&#13;
					case "1900-01-01": baddate = 0;&#13;
				}&#13;
				break;&#13;
&#13;
			case 'graphic-properties': break; // 17.21 &lt;style:graphic-properties&gt;&#13;
			case 'calculation-settings': break; // 9.4.1 &lt;table:calculation-settings&gt;&#13;
			case 'named-expressions': break; // 9.4.11 &lt;table:named-expressions&gt;&#13;
			case 'label-range': break; // 9.4.9 &lt;table:label-range&gt;&#13;
			case 'label-ranges': break; // 9.4.10 &lt;table:label-ranges&gt;&#13;
			case 'named-expression': break; // 9.4.13 &lt;table:named-expression&gt;&#13;
			case 'sort': break; // 9.4.19 &lt;table:sort&gt;&#13;
			case 'sort-by': break; // 9.4.20 &lt;table:sort-by&gt;&#13;
			case 'sort-groups': break; // 9.4.22 &lt;table:sort-groups&gt;&#13;
&#13;
			case 'tab': break; // 6.1.4 &lt;text:tab&gt;&#13;
			case 'line-break': break; // 6.1.5 &lt;text:line-break&gt;&#13;
			case 'span': break; // 6.1.7 &lt;text:span&gt;&#13;
			case 'p': case '文本串': // 5.1.3 &lt;text:p&gt;&#13;
				if(['master-styles'].indexOf(state[state.length-1][0]) &gt; -1) break;&#13;
				if(Rn[1]==='/' &amp;&amp; (!ctag || !ctag['string-value'])) {&#13;
					var ptp = parse_text_p(str.slice(textpidx,Rn.index), textptag);&#13;
					textp = (textp.length &gt; 0 ? textp + "\n" : "") + ptp[0];&#13;
				} else { textptag = parsexmltag(Rn[0], false); textpidx = Rn.index + Rn[0].length; }&#13;
				break; // &lt;text:p&gt;&#13;
			case 's': break; // &lt;text:s&gt;&#13;
&#13;
			case 'database-range': // 9.4.15 &lt;table:database-range&gt;&#13;
				if(Rn[1]==='/') break;&#13;
				try {&#13;
					_Ref = ods_to_csf_3D(parsexmltag(Rn[0])['target-range-address']);&#13;
					Sheets[_Ref[0]]['!autofilter'] = { ref:_Ref[1] };&#13;
				} catch(e) {/* empty */}&#13;
				break;&#13;
&#13;
			case 'date': break; // &lt;*:date&gt;&#13;
&#13;
			case 'object': break; // 10.4.6.2 &lt;draw:object&gt;&#13;
			case 'title': case '标题': break; // &lt;*:title&gt; OR &lt;uof:标题&gt;&#13;
			case 'desc': break; // &lt;*:desc&gt;&#13;
			case 'binary-data': break; // 10.4.5 TODO: b64 blob&#13;
&#13;
			/* 9.2 Advanced Tables */&#13;
			case 'table-source': break; // 9.2.6&#13;
			case 'scenario': break; // 9.2.6&#13;
&#13;
			case 'iteration': break; // 9.4.3 &lt;table:iteration&gt;&#13;
			case 'content-validations': break; // 9.4.4 &lt;table:&#13;
			case 'content-validation': break; // 9.4.5 &lt;table:&#13;
			case 'help-message': break; // 9.4.6 &lt;table:&#13;
			case 'error-message': break; // 9.4.7 &lt;table:&#13;
			case 'database-ranges': break; // 9.4.14 &lt;table:database-ranges&gt;&#13;
			case 'filter': break; // 9.5.2 &lt;table:filter&gt;&#13;
			case 'filter-and': break; // 9.5.3 &lt;table:filter-and&gt;&#13;
			case 'filter-or': break; // 9.5.4 &lt;table:filter-or&gt;&#13;
			case 'filter-condition': break; // 9.5.5 &lt;table:filter-condition&gt;&#13;
&#13;
			case 'list-level-style-bullet': break; // 16.31 &lt;text:&#13;
			case 'list-level-style-number': break; // 16.32 &lt;text:&#13;
			case 'list-level-properties': break; // 17.19 &lt;style:&#13;
&#13;
			/* 7.3 Document Fields */&#13;
			case 'sender-firstname': // 7.3.6.2&#13;
			case 'sender-lastname': // 7.3.6.3&#13;
			case 'sender-initials': // 7.3.6.4&#13;
			case 'sender-title': // 7.3.6.5&#13;
			case 'sender-position': // 7.3.6.6&#13;
			case 'sender-email': // 7.3.6.7&#13;
			case 'sender-phone-private': // 7.3.6.8&#13;
			case 'sender-fax': // 7.3.6.9&#13;
			case 'sender-company': // 7.3.6.10&#13;
			case 'sender-phone-work': // 7.3.6.11&#13;
			case 'sender-street': // 7.3.6.12&#13;
			case 'sender-city': // 7.3.6.13&#13;
			case 'sender-postal-code': // 7.3.6.14&#13;
			case 'sender-country': // 7.3.6.15&#13;
			case 'sender-state-or-province': // 7.3.6.16&#13;
			case 'author-name': // 7.3.7.1&#13;
			case 'author-initials': // 7.3.7.2&#13;
			case 'chapter': // 7.3.8&#13;
			case 'file-name': // 7.3.9&#13;
			case 'template-name': // 7.3.9&#13;
			case 'sheet-name': // 7.3.9&#13;
				break;&#13;
&#13;
			case 'event-listener':&#13;
				break;&#13;
			/* TODO: FODS Properties */&#13;
			case 'initial-creator':&#13;
			case 'creation-date':&#13;
			case 'print-date':&#13;
			case 'generator':&#13;
			case 'document-statistic':&#13;
			case 'user-defined':&#13;
			case 'editing-duration':&#13;
			case 'editing-cycles':&#13;
				break;&#13;
&#13;
			/* TODO: FODS Config */&#13;
			case 'config-item':&#13;
				break;&#13;
&#13;
			/* TODO: style tokens */&#13;
			case 'page-number': break; // TODO &lt;text:page-number&gt;&#13;
			case 'page-count': break; // TODO &lt;text:page-count&gt;&#13;
			case 'time': break; // TODO &lt;text:time&gt;&#13;
&#13;
			/* 9.3 Advanced Table Cells */&#13;
			case 'cell-range-source': break; // 9.3.1 &lt;table:&#13;
			case 'detective': break; // 9.3.2 &lt;table:&#13;
			case 'operation': break; // 9.3.3 &lt;table:&#13;
			case 'highlighted-range': break; // 9.3.4 &lt;table:&#13;
&#13;
			/* 9.6 Data Pilot Tables &lt;table: */&#13;
			case 'data-pilot-table': // 9.6.3&#13;
			case 'source-cell-range': // 9.6.5&#13;
			case 'source-service': // 9.6.6&#13;
			case 'data-pilot-field': // 9.6.7&#13;
			case 'data-pilot-level': // 9.6.8&#13;
			case 'data-pilot-subtotals': // 9.6.9&#13;
			case 'data-pilot-subtotal': // 9.6.10&#13;
			case 'data-pilot-members': // 9.6.11&#13;
			case 'data-pilot-member': // 9.6.12&#13;
			case 'data-pilot-display-info': // 9.6.13&#13;
			case 'data-pilot-sort-info': // 9.6.14&#13;
			case 'data-pilot-layout-info': // 9.6.15&#13;
			case 'data-pilot-field-reference': // 9.6.16&#13;
			case 'data-pilot-groups': // 9.6.17&#13;
			case 'data-pilot-group': // 9.6.18&#13;
			case 'data-pilot-group-member': // 9.6.19&#13;
				break;&#13;
&#13;
			/* 10.3 Drawing Shapes */&#13;
			case 'rect': // 10.3.2&#13;
				break;&#13;
&#13;
			/* 14.6 DDE Connections */&#13;
			case 'dde-connection-decls': // 14.6.2 &lt;text:&#13;
			case 'dde-connection-decl': // 14.6.3 &lt;text:&#13;
			case 'dde-link': // 14.6.4 &lt;table:&#13;
			case 'dde-source': // 14.6.5 &lt;office:&#13;
				break;&#13;
&#13;
			case 'properties': break; // 13.7 &lt;form:properties&gt;&#13;
			case 'property': break; // 13.8 &lt;form:property&gt;&#13;
&#13;
			case 'a': // 6.1.8 hyperlink&#13;
				if(Rn[1]!== '/') {&#13;
					atag = parsexmltag(Rn[0], false);&#13;
					if(!atag.href) break;&#13;
					atag.Target = unescapexml(atag.href); delete atag.href;&#13;
					if(atag.Target.charAt(0) == "#" &amp;&amp; atag.Target.indexOf(".") &gt; -1) {&#13;
						_Ref = ods_to_csf_3D(atag.Target.slice(1));&#13;
						atag.Target = "#" + _Ref[0] + "!" + _Ref[1];&#13;
					} else if(atag.Target.match(/^\.\.[\\\/]/)) atag.Target = atag.Target.slice(3);&#13;
				}&#13;
				break;&#13;
&#13;
			/* non-standard */&#13;
			case 'table-protection': break;&#13;
			case 'data-pilot-grand-total': break; // &lt;table:&#13;
			case 'office-document-common-attrs': break; // bare&#13;
			default: switch(Rn[2]) {&#13;
				case 'dc:':       // TODO: properties&#13;
				case 'calcext:':  // ignore undocumented extensions&#13;
				case 'loext:':    // ignore undocumented extensions&#13;
				case 'ooo:':      // ignore undocumented extensions&#13;
				case 'chartooo:': // ignore undocumented extensions&#13;
				case 'draw:':     // TODO: drawing&#13;
				case 'style:':    // TODO: styles&#13;
				case 'chart:':    // TODO: charts&#13;
				case 'form:':     // TODO: forms&#13;
				case 'uof:':      // TODO: uof&#13;
				case '表:':       // TODO: uof&#13;
				case '字:':       // TODO: uof&#13;
					break;&#13;
				default: if(opts.WTF) throw new Error(Rn);&#13;
			}&#13;
		}&#13;
		var out = ({&#13;
			Sheets: Sheets,&#13;
			SheetNames: SheetNames,&#13;
			Workbook: WB&#13;
		});&#13;
		if(opts.bookSheets) delete out.Sheets;&#13;
		return out;&#13;
}&#13;
&#13;
function parse_ods(zip, opts) {&#13;
	opts = opts || ({});&#13;
	if(safegetzipfile(zip, 'META-INF/manifest.xml')) parse_manifest(getzipdata(zip, 'META-INF/manifest.xml'), opts);&#13;
	var styles = getzipstr(zip, 'styles.xml');&#13;
	var Styles = styles &amp;&amp; parse_ods_styles(utf8read(styles), opts);&#13;
	var content = getzipstr(zip, 'content.xml');&#13;
	if(!content) throw new Error("Missing content.xml in ODS / UOF file");&#13;
	var wb = parse_content_xml(utf8read(content), opts, Styles);&#13;
	if(safegetzipfile(zip, 'meta.xml')) wb.Props = parse_core_props(getzipdata(zip, 'meta.xml'));&#13;
	wb.bookType = "ods";&#13;
	return wb;&#13;
}&#13;
function parse_fods(data, opts) {&#13;
	var wb = parse_content_xml(data, opts);&#13;
	wb.bookType = "fods";&#13;
	return wb;&#13;
}&#13;
&#13;
/* OpenDocument */&#13;
var write_styles_ods = /* @__PURE__ */(function() {&#13;
	var master_styles = [&#13;
		'&lt;office:master-styles&gt;',&#13;
			'&lt;style:master-page style:name="mp1" style:page-layout-name="mp1"&gt;',&#13;
				'&lt;style:header/&gt;',&#13;
				'&lt;style:header-left style:display="false"/&gt;',&#13;
				'&lt;style:footer/&gt;',&#13;
				'&lt;style:footer-left style:display="false"/&gt;',&#13;
			'&lt;/style:master-page&gt;',&#13;
		'&lt;/office:master-styles&gt;'&#13;
	].join("");&#13;
&#13;
	var payload = '&lt;office:document-styles ' + wxt_helper({&#13;
		'xmlns:office':   "urn:oasis:names:tc:opendocument:xmlns:office:1.0",&#13;
		'xmlns:table':    "urn:oasis:names:tc:opendocument:xmlns:table:1.0",&#13;
		'xmlns:style':    "urn:oasis:names:tc:opendocument:xmlns:style:1.0",&#13;
		'xmlns:text':     "urn:oasis:names:tc:opendocument:xmlns:text:1.0",&#13;
		'xmlns:draw':     "urn:oasis:names:tc:opendocument:xmlns:drawing:1.0",&#13;
		'xmlns:fo':       "urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0",&#13;
		'xmlns:xlink':    "http://www.w3.org/1999/xlink",&#13;
		'xmlns:dc':       "http://purl.org/dc/elements/1.1/",&#13;
		'xmlns:number':   "urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0",&#13;
		'xmlns:svg':      "urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0",&#13;
		'xmlns:of':       "urn:oasis:names:tc:opendocument:xmlns:of:1.2",&#13;
		'office:version': "1.2"&#13;
	}) + '&gt;' + master_styles + '&lt;/office:document-styles&gt;';&#13;
&#13;
	return function wso() {&#13;
		return XML_HEADER + payload;&#13;
	};&#13;
})();&#13;
&#13;
// TODO: find out if anyone actually read the spec.  LO has some wild errors&#13;
function write_number_format_ods(nf, nfidx) {&#13;
	var type = "number", payload = "", nopts = { "style:name": nfidx }, c = "", i = 0;&#13;
	nf = nf.replace(/"[$]"/g, "$");&#13;
	/* TODO: replace with an actual parser based on a real grammar */&#13;
	j: {&#13;
		// TODO: support style maps&#13;
		if(nf.indexOf(";") &gt; -1) {&#13;
			console.error("Unsupported ODS Style Map exported.  Using first branch of " + nf);&#13;
			nf = nf.slice(0, nf.indexOf(";"));&#13;
		}&#13;
&#13;
		if(nf == "@") { type = "text"; payload = "&lt;number:text-content/&gt;"; break j; }&#13;
&#13;
		/* currency flag */&#13;
		if(nf.indexOf(/\$/) &gt; -1) { type = "currency"; }&#13;
&#13;
		/* opening string literal */&#13;
		if(nf[i] == '"') {&#13;
			c = "";&#13;
			while(nf[++i] != '"' || nf[++i] == '"') c += nf[i]; --i;&#13;
			if(nf[i+1] == "*") {&#13;
				i++;&#13;
				payload += '&lt;number:fill-character&gt;' + escapexml(c.replace(/""/g, '"')) + '&lt;/number:fill-character&gt;';&#13;
			} else {&#13;
				payload += '&lt;number:text&gt;' + escapexml(c.replace(/""/g, '"')) + '&lt;/number:text&gt;';&#13;
			}&#13;
			nf = nf.slice(i+1); i = 0;&#13;
		}&#13;
&#13;
		/* fractions */&#13;
		var t = nf.match(/# (\?+)\/(\?+)/);&#13;
		if(t) { payload += writextag("number:fraction", null, {"number:min-integer-digits":0, "number:min-numerator-digits": t[1].length, "number:max-denominator-value": Math.max(+(t[1].replace(/./g, "9")), +(t[2].replace(/./g, "9"))) }); break j; }&#13;
		if((t=nf.match(/# (\?+)\/(\d+)/))) { payload += writextag("number:fraction", null, {"number:min-integer-digits":0, "number:min-numerator-digits": t[1].length, "number:denominator-value": +t[2]}); break j; }&#13;
&#13;
		/* percentages */&#13;
		if((t=nf.match(/(\d+)(|\.\d+)%/))) { type = "percentage"; payload += writextag("number:number", null, {"number:decimal-places": t[2] &amp;&amp; t.length - 1 || 0, "number:min-decimal-places": t[2] &amp;&amp; t.length - 1 || 0, "number:min-integer-digits": t[1].length }) + "&lt;number:text&gt;%&lt;/number:text&gt;"; break j; }&#13;
&#13;
		/* datetime */&#13;
		var has_time = false;&#13;
		if(["y","m","d"].indexOf(nf[0]) &gt; -1) {&#13;
			type = "date";&#13;
			k: for(; i &lt; nf.length; ++i) switch((c = nf[i].toLowerCase())) {&#13;
				case "h": case "s": has_time = true; --i; break k;&#13;
				case "m":&#13;
					l: for(var h = i+1; h &lt; nf.length; ++h) switch(nf[h]) {&#13;
						case "y": case "d": break l;&#13;
						case "h": case "s": has_time = true; --i; break k;&#13;
					}&#13;
					/* falls through */&#13;
				case "y": case "d":&#13;
					while((nf[++i]||"").toLowerCase() == c[0]) c += c[0]; --i;&#13;
					switch(c) {&#13;
						case "y": case "yy": payload += "&lt;number:year/&gt;"; break;&#13;
						case "yyy": case "yyyy": payload += '&lt;number:year number:style="long"/&gt;'; break;&#13;
						case "mmmmm": console.error("ODS has no equivalent of format |mmmmm|");&#13;
							/* falls through */&#13;
						case "m": case "mm": case "mmm": case "mmmm":&#13;
							payload += '&lt;number:month number:style="' + (c.length % 2 ? "short" : "long") + '" number:textual="' + (c.length &gt;= 3 ? "true" : "false") + '"/&gt;';&#13;
							break;&#13;
						case "d": case "dd": payload += '&lt;number:day number:style="' + (c.length % 2 ? "short" : "long") + '"/&gt;'; break;&#13;
						case "ddd": case "dddd": payload += '&lt;number:day-of-week number:style="' + (c.length % 2 ? "short" : "long") + '"/&gt;'; break;&#13;
					}&#13;
					break;&#13;
				case '"':&#13;
					while(nf[++i] != '"' || nf[++i] == '"') c += nf[i]; --i;&#13;
					payload += '&lt;number:text&gt;' + escapexml(c.slice(1).replace(/""/g, '"')) + '&lt;/number:text&gt;';&#13;
					break;&#13;
				case '/': payload += '&lt;number:text&gt;' + escapexml(c) + '&lt;/number:text&gt;'; break;&#13;
				default: console.error("unrecognized character " + c + " in ODF format " + nf);&#13;
			}&#13;
			if(!has_time) break j;&#13;
			nf = nf.slice(i+1); i = 0;&#13;
		}&#13;
		if(nf.match(/^\[?[hms]/)) {&#13;
			if(type == "number") type = "time";&#13;
			if(nf.match(/\[/)) {&#13;
				nf = nf.replace(/[\[\]]/g, "");&#13;
				nopts['number:truncate-on-overflow'] = "false";&#13;
			}&#13;
			for(; i &lt; nf.length; ++i) switch((c = nf[i].toLowerCase())) {&#13;
				case "h": case "m": case "s":&#13;
					while((nf[++i]||"").toLowerCase() == c[0]) c += c[0]; --i;&#13;
					switch(c) {&#13;
						case "h": case "hh": payload += '&lt;number:hours number:style="' + (c.length % 2 ? "short" : "long") + '"/&gt;'; break;&#13;
						case "m": case "mm": payload += '&lt;number:minutes number:style="' + (c.length % 2 ? "short" : "long") + '"/&gt;'; break;&#13;
						case "s": case "ss":&#13;
							if(nf[i+1] == ".") do { c += nf[i+1]; ++i; } while(nf[i+1] == "0");&#13;
							payload += '&lt;number:seconds number:style="' + (c.match("ss") ? "long" : "short") + '"' + (c.match(/\./) ? ' number:decimal-places="' + (c.match(/0+/)||[""])[0].length + '"' : "")+ '/&gt;'; break;&#13;
					}&#13;
					break;&#13;
				case '"':&#13;
					while(nf[++i] != '"' || nf[++i] == '"') c += nf[i]; --i;&#13;
					payload += '&lt;number:text&gt;' + escapexml(c.slice(1).replace(/""/g, '"')) + '&lt;/number:text&gt;';&#13;
					break;&#13;
				case '/': payload += '&lt;number:text&gt;' + escapexml(c) + '&lt;/number:text&gt;'; break;&#13;
				case "a":&#13;
					if(nf.slice(i, i+3).toLowerCase() == "a/p") { payload += '&lt;number:am-pm/&gt;'; i += 2; break; } // Note: ODF does not support A/P&#13;
					if(nf.slice(i, i+5).toLowerCase() == "am/pm")  { payload += '&lt;number:am-pm/&gt;'; i += 4; break; }&#13;
					/* falls through */&#13;
				default: console.error("unrecognized character " + c + " in ODF format " + nf);&#13;
			}&#13;
			break j;&#13;
		}&#13;
&#13;
		/* currency flag */&#13;
		if(nf.indexOf(/\$/) &gt; -1) { type = "currency"; }&#13;
&#13;
		/* should be in a char loop */&#13;
		if(nf[0] == "$") { payload += '&lt;number:currency-symbol number:language="en" number:country="US"&gt;$&lt;/number:currency-symbol&gt;'; nf = nf.slice(1); i = 0; }&#13;
		i = 0; if(nf[i] == '"') {&#13;
			while(nf[++i] != '"' || nf[++i] == '"') c += nf[i]; --i;&#13;
			if(nf[i+1] == "*") {&#13;
				i++;&#13;
				payload += '&lt;number:fill-character&gt;' + escapexml(c.replace(/""/g, '"')) + '&lt;/number:fill-character&gt;';&#13;
			} else {&#13;
				payload += '&lt;number:text&gt;' + escapexml(c.replace(/""/g, '"')) + '&lt;/number:text&gt;';&#13;
			}&#13;
			nf = nf.slice(i+1); i = 0;&#13;
		}&#13;
&#13;
		/* number TODO: interstitial text e.g. 000)000-0000 */&#13;
		var np = nf.match(/([#0][0#,]*)(\.[0#]*|)(E[+]?0*|)/i);&#13;
		if(!np || !np[0]) console.error("Could not find numeric part of " + nf);&#13;
		else {&#13;
			var base = np[1].replace(/,/g, "");&#13;
			payload += '&lt;number:' + (np[3] ? "scientific-" : "")+ 'number' +&#13;
				' number:min-integer-digits="' + (base.indexOf("0") == -1 ? "0" : base.length - base.indexOf("0")) + '"' +&#13;
				(np[0].indexOf(",") &gt; -1 ? ' number:grouping="true"' : "") +&#13;
				(np[2] &amp;&amp; ' number:decimal-places="' + (np[2].length - 1) + '"' || ' number:decimal-places="0"') +&#13;
				(np[3] &amp;&amp; np[3].indexOf("+") &gt; -1 ? ' number:forced-exponent-sign="true"' : "" ) +&#13;
				(np[3] ? ' number:min-exponent-digits="' + np[3].match(/0+/)[0].length + '"' : "" ) +&#13;
				'&gt;' +&#13;
				/* TODO: interstitial text placeholders */&#13;
				'&lt;/number:' + (np[3] ? "scientific-" : "") + 'number&gt;';&#13;
			i = np.index + np[0].length;&#13;
		}&#13;
&#13;
		/* residual text */&#13;
		if(nf[i] == '"') {&#13;
			c = "";&#13;
			while(nf[++i] != '"' || nf[++i] == '"') c += nf[i]; --i;&#13;
			payload += '&lt;number:text&gt;' + escapexml(c.replace(/""/g, '"')) + '&lt;/number:text&gt;';&#13;
		}&#13;
	}&#13;
&#13;
	if(!payload) { console.error("Could not generate ODS number format for |" + nf + "|"); return ""; }&#13;
	return writextag("number:" + type + "-style", payload, nopts);&#13;
}&#13;
&#13;
function write_names_ods(Names, SheetNames, idx) {&#13;
	var scoped = Names.filter(function(name) { return name.Sheet == (idx == -1 ? null : idx); });&#13;
	if(!scoped.length) return "";&#13;
	return "      &lt;table:named-expressions&gt;\n" + scoped.map(function(name) {&#13;
		var odsref =  csf_to_ods_3D(name.Ref);&#13;
		return "        " + writextag("table:named-range", null, {&#13;
			"table:name": name.Name,&#13;
			"table:cell-range-address": odsref,&#13;
			"table:base-cell-address": odsref.replace(/[\.]?[^\.]*$/, ".$A$1")&#13;
		});&#13;
	}).join("\n") + "\n      &lt;/table:named-expressions&gt;\n";&#13;
}&#13;
var write_content_ods = /* @__PURE__ */(function() {&#13;
	/* 6.1.2 White Space Characters */&#13;
	var write_text_p = function(text) {&#13;
		return escapexml(text)&#13;
			.replace(/  +/g, function($$){return '&lt;text:s text:c="'+$$.length+'"/&gt;';})&#13;
			.replace(/\t/g, "&lt;text:tab/&gt;")&#13;
			.replace(/\n/g, "&lt;/text:p&gt;&lt;text:p&gt;")&#13;
			.replace(/^ /, "&lt;text:s/&gt;").replace(/ $/, "&lt;text:s/&gt;");&#13;
	};&#13;
&#13;
	var null_cell_xml = '          &lt;table:table-cell /&gt;\n';&#13;
	var covered_cell_xml = '          &lt;table:covered-table-cell/&gt;\n';&#13;
	var write_ws = function(ws, wb, i, opts, nfs) {&#13;
		/* Section 9 Tables */&#13;
		var o = [];&#13;
		o.push('      &lt;table:table table:name="' + escapexml(wb.SheetNames[i]) + '" table:style-name="ta1"&gt;\n');&#13;
		var R=0,C=0, range = decode_range(ws['!ref']||"A1");&#13;
		var marr = ws['!merges'] || [], mi = 0;&#13;
		var dense = Array.isArray(ws);&#13;
		if(ws["!cols"]) {&#13;
			for(C = 0; C &lt;= range.e.c; ++C) o.push('        &lt;table:table-column' + (ws["!cols"][C] ? ' table:style-name="co' + ws["!cols"][C].ods + '"' : '') + '&gt;&lt;/table:table-column&gt;\n');&#13;
		}&#13;
		var H = "", ROWS = ws["!rows"]||[];&#13;
		for(R = 0; R &lt; range.s.r; ++R) {&#13;
			H = ROWS[R] ? ' table:style-name="ro' + ROWS[R].ods + '"' : "";&#13;
			o.push('        &lt;table:table-row' + H + '&gt;&lt;/table:table-row&gt;\n');&#13;
		}&#13;
		for(; R &lt;= range.e.r; ++R) {&#13;
			H = ROWS[R] ? ' table:style-name="ro' + ROWS[R].ods + '"' : "";&#13;
			o.push('        &lt;table:table-row' + H + '&gt;\n');&#13;
			for(C=0; C &lt; range.s.c; ++C) o.push(null_cell_xml);&#13;
			for(; C &lt;= range.e.c; ++C) {&#13;
				var skip = false, ct = {}, textp = "";&#13;
				for(mi = 0; mi != marr.length; ++mi) {&#13;
					if(marr[mi].s.c &gt; C) continue;&#13;
					if(marr[mi].s.r &gt; R) continue;&#13;
					if(marr[mi].e.c &lt; C) continue;&#13;
					if(marr[mi].e.r &lt; R) continue;&#13;
					if(marr[mi].s.c != C || marr[mi].s.r != R) skip = true;&#13;
					ct['table:number-columns-spanned'] = (marr[mi].e.c - marr[mi].s.c + 1);&#13;
					ct['table:number-rows-spanned'] =    (marr[mi].e.r - marr[mi].s.r + 1);&#13;
					break;&#13;
				}&#13;
				if(skip) { o.push(covered_cell_xml); continue; }&#13;
				var ref = encode_cell({r:R, c:C}), cell = dense ? (ws[R]||[])[C]: ws[ref];&#13;
				if(cell &amp;&amp; cell.f) {&#13;
					ct['table:formula'] = escapexml(csf_to_ods_formula(cell.f));&#13;
					if(cell.F) {&#13;
						if(cell.F.slice(0, ref.length) == ref) {&#13;
							var _Fref = decode_range(cell.F);&#13;
							ct['table:number-matrix-columns-spanned'] = (_Fref.e.c - _Fref.s.c + 1);&#13;
							ct['table:number-matrix-rows-spanned'] =    (_Fref.e.r - _Fref.s.r + 1);&#13;
						}&#13;
					}&#13;
				}&#13;
				if(!cell) { o.push(null_cell_xml); continue; }&#13;
				switch(cell.t) {&#13;
					case 'b':&#13;
						textp = (cell.v ? 'TRUE' : 'FALSE');&#13;
						ct['office:value-type'] = "boolean";&#13;
						ct['office:boolean-value'] = (cell.v ? 'true' : 'false');&#13;
						break;&#13;
					case 'n':&#13;
						textp = (cell.w||String(cell.v||0));&#13;
						ct['office:value-type'] = "float";&#13;
						ct['office:value'] = (cell.v||0);&#13;
						break;&#13;
					case 's': case 'str':&#13;
						textp = cell.v == null ? "" : cell.v;&#13;
						ct['office:value-type'] = "string";&#13;
						break;&#13;
					case 'd':&#13;
						textp = (cell.w||(parseDate(cell.v).toISOString()));&#13;
						ct['office:value-type'] = "date";&#13;
						ct['office:date-value'] = (parseDate(cell.v).toISOString());&#13;
						ct['table:style-name'] = "ce1";&#13;
						break;&#13;
					//case 'e':&#13;
					default: o.push(null_cell_xml); continue;&#13;
				}&#13;
				var text_p = write_text_p(textp);&#13;
				if(cell.l &amp;&amp; cell.l.Target) {&#13;
					var _tgt = cell.l.Target;&#13;
					_tgt = _tgt.charAt(0) == "#" ? "#" + csf_to_ods_3D(_tgt.slice(1)) : _tgt;&#13;
					// TODO: choose correct parent path format based on link delimiters&#13;
					if(_tgt.charAt(0) != "#" &amp;&amp; !_tgt.match(/^\w+:/)) _tgt = '../' + _tgt;&#13;
					text_p = writextag('text:a', text_p, {'xlink:href': _tgt.replace(/&amp;/g, "&amp;amp;")});&#13;
				}&#13;
				if(nfs[cell.z]) ct["table:style-name"] = "ce" + nfs[cell.z].slice(1);&#13;
				o.push('          ' + writextag('table:table-cell', writextag('text:p', text_p, {}), ct) + '\n');&#13;
			}&#13;
			o.push('        &lt;/table:table-row&gt;\n');&#13;
		}&#13;
		if((wb.Workbook||{}).Names) o.push(write_names_ods(wb.Workbook.Names, wb.SheetNames, i));&#13;
		o.push('      &lt;/table:table&gt;\n');&#13;
		return o.join("");&#13;
	};&#13;
&#13;
	var write_automatic_styles_ods = function(o, wb) {&#13;
		o.push(' &lt;office:automatic-styles&gt;\n');&#13;
&#13;
		/* column styles */&#13;
		var cidx = 0;&#13;
		wb.SheetNames.map(function(n) { return wb.Sheets[n]; }).forEach(function(ws) {&#13;
			if(!ws) return;&#13;
			if(ws["!cols"]) {&#13;
				for(var C = 0; C &lt; ws["!cols"].length; ++C) if(ws["!cols"][C]) {&#13;
					var colobj = ws["!cols"][C];&#13;
					if(colobj.width == null &amp;&amp; colobj.wpx == null &amp;&amp; colobj.wch == null) continue;&#13;
					process_col(colobj);&#13;
					colobj.ods = cidx;&#13;
					var w = ws["!cols"][C].wpx + "px";&#13;
					o.push('  &lt;style:style style:name="co' + cidx + '" style:family="table-column"&gt;\n');&#13;
					o.push('   &lt;style:table-column-properties fo:break-before="auto" style:column-width="' + w + '"/&gt;\n');&#13;
					o.push('  &lt;/style:style&gt;\n');&#13;
					++cidx;&#13;
				}&#13;
			}&#13;
		});&#13;
&#13;
		/* row styles */&#13;
		var ridx = 0;&#13;
		wb.SheetNames.map(function(n) { return wb.Sheets[n]; }).forEach(function(ws) {&#13;
			if(!ws) return;&#13;
			if(ws["!rows"]) {&#13;
				for(var R = 0; R &lt; ws["!rows"].length; ++R) if(ws["!rows"][R]) {&#13;
					ws["!rows"][R].ods = ridx;&#13;
					var h = ws["!rows"][R].hpx + "px";&#13;
					o.push('  &lt;style:style style:name="ro' + ridx + '" style:family="table-row"&gt;\n');&#13;
					o.push('   &lt;style:table-row-properties fo:break-before="auto" style:row-height="' + h + '"/&gt;\n');&#13;
					o.push('  &lt;/style:style&gt;\n');&#13;
					++ridx;&#13;
				}&#13;
			}&#13;
		});&#13;
&#13;
		/* table */&#13;
		o.push('  &lt;style:style style:name="ta1" style:family="table" style:master-page-name="mp1"&gt;\n');&#13;
		o.push('   &lt;style:table-properties table:display="true" style:writing-mode="lr-tb"/&gt;\n');&#13;
		o.push('  &lt;/style:style&gt;\n');&#13;
&#13;
		o.push('  &lt;number:date-style style:name="N37" number:automatic-order="true"&gt;\n');&#13;
		o.push('   &lt;number:month number:style="long"/&gt;\n');&#13;
		o.push('   &lt;number:text&gt;/&lt;/number:text&gt;\n');&#13;
		o.push('   &lt;number:day number:style="long"/&gt;\n');&#13;
		o.push('   &lt;number:text&gt;/&lt;/number:text&gt;\n');&#13;
		o.push('   &lt;number:year/&gt;\n');&#13;
		o.push('  &lt;/number:date-style&gt;\n');&#13;
&#13;
		/* number formats, table cells, text */&#13;
		var nfs = {};&#13;
		var nfi = 69;&#13;
		wb.SheetNames.map(function(n) { return wb.Sheets[n]; }).forEach(function(ws) {&#13;
			if(!ws) return;&#13;
			var range = decode_range(ws["!ref"]);&#13;
			for(var R = 0; R &lt;= range.e.r; ++R) for(var C = 0; C &lt;= range.e.c; ++C) {&#13;
				var c = Array.isArray(ws) ? (ws[R]||[])[C] : ws[encode_cell({r:R,c:C})];&#13;
				if(!c || !c.z || c.z.toLowerCase() == "general") continue;&#13;
				if(!nfs[c.z]) {&#13;
					var out = write_number_format_ods(c.z, "N" + nfi);&#13;
					if(out) { nfs[c.z] = "N" + nfi; ++nfi; o.push(out + "\n"); }&#13;
				}&#13;
			}&#13;
		});&#13;
		o.push('  &lt;style:style style:name="ce1" style:family="table-cell" style:parent-style-name="Default" style:data-style-name="N37"/&gt;\n');&#13;
		keys(nfs).forEach(function(nf) {&#13;
			o.push('&lt;style:style style:name="ce' + nfs[nf].slice(1) + '" style:family="table-cell" style:parent-style-name="Default" style:data-style-name="' + nfs[nf] + '"/&gt;\n');&#13;
		});&#13;
&#13;
		/* page-layout */&#13;
&#13;
		o.push(' &lt;/office:automatic-styles&gt;\n');&#13;
		return nfs;&#13;
	};&#13;
&#13;
	return function wcx(wb, opts) {&#13;
		var o = [XML_HEADER];&#13;
		/* 3.1.3.2 */&#13;
		var attr = wxt_helper({&#13;
			'xmlns:office':       "urn:oasis:names:tc:opendocument:xmlns:office:1.0",&#13;
			'xmlns:table':        "urn:oasis:names:tc:opendocument:xmlns:table:1.0",&#13;
			'xmlns:style':        "urn:oasis:names:tc:opendocument:xmlns:style:1.0",&#13;
			'xmlns:text':         "urn:oasis:names:tc:opendocument:xmlns:text:1.0",&#13;
			'xmlns:draw':         "urn:oasis:names:tc:opendocument:xmlns:drawing:1.0",&#13;
			'xmlns:fo':           "urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0",&#13;
			'xmlns:xlink':        "http://www.w3.org/1999/xlink",&#13;
			'xmlns:dc':           "http://purl.org/dc/elements/1.1/",&#13;
			'xmlns:meta':         "urn:oasis:names:tc:opendocument:xmlns:meta:1.0",&#13;
			'xmlns:number':       "urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0",&#13;
			'xmlns:presentation': "urn:oasis:names:tc:opendocument:xmlns:presentation:1.0",&#13;
			'xmlns:svg':          "urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0",&#13;
			'xmlns:chart':        "urn:oasis:names:tc:opendocument:xmlns:chart:1.0",&#13;
			'xmlns:dr3d':         "urn:oasis:names:tc:opendocument:xmlns:dr3d:1.0",&#13;
			'xmlns:math':         "http://www.w3.org/1998/Math/MathML",&#13;
			'xmlns:form':         "urn:oasis:names:tc:opendocument:xmlns:form:1.0",&#13;
			'xmlns:script':       "urn:oasis:names:tc:opendocument:xmlns:script:1.0",&#13;
			'xmlns:ooo':          "http://openoffice.org/2004/office",&#13;
			'xmlns:ooow':         "http://openoffice.org/2004/writer",&#13;
			'xmlns:oooc':         "http://openoffice.org/2004/calc",&#13;
			'xmlns:dom':          "http://www.w3.org/2001/xml-events",&#13;
			'xmlns:xforms':       "http://www.w3.org/2002/xforms",&#13;
			'xmlns:xsd':          "http://www.w3.org/2001/XMLSchema",&#13;
			'xmlns:xsi':          "http://www.w3.org/2001/XMLSchema-instance",&#13;
			'xmlns:sheet':        "urn:oasis:names:tc:opendocument:sh33tjs:1.0",&#13;
			'xmlns:rpt':          "http://openoffice.org/2005/report",&#13;
			'xmlns:of':           "urn:oasis:names:tc:opendocument:xmlns:of:1.2",&#13;
			'xmlns:xhtml':        "http://www.w3.org/1999/xhtml",&#13;
			'xmlns:grddl':        "http://www.w3.org/2003/g/data-view#",&#13;
			'xmlns:tableooo':     "http://openoffice.org/2009/table",&#13;
			'xmlns:drawooo':      "http://openoffice.org/2010/draw",&#13;
			'xmlns:calcext':      "urn:org:documentfoundation:names:experimental:calc:xmlns:calcext:1.0",&#13;
			'xmlns:loext':        "urn:org:documentfoundation:names:experimental:office:xmlns:loext:1.0",&#13;
			'xmlns:field':        "urn:openoffice:names:experimental:ooo-ms-interop:xmlns:field:1.0",&#13;
			'xmlns:formx':        "urn:openoffice:names:experimental:ooxml-odf-interop:xmlns:form:1.0",&#13;
			'xmlns:css3t':        "http://www.w3.org/TR/css3-text/",&#13;
			'office:version':     "1.2"&#13;
		});&#13;
&#13;
		var fods = wxt_helper({&#13;
			'xmlns:config':    "urn:oasis:names:tc:opendocument:xmlns:config:1.0",&#13;
			'office:mimetype': "application/vnd.oasis.opendocument.spreadsheet"&#13;
		});&#13;
&#13;
		if(opts.bookType == "fods") {&#13;
			o.push('&lt;office:document' + attr + fods + '&gt;\n');&#13;
			o.push(write_meta_ods().replace(/&lt;office:document-meta.*?&gt;/, "").replace(/&lt;\/office:document-meta&gt;/, "") + "\n");&#13;
			// TODO: settings (equiv of settings.xml for ODS)&#13;
		} else o.push('&lt;office:document-content' + attr  + '&gt;\n');&#13;
		// o.push('  &lt;office:scripts/&gt;\n');&#13;
		var nfs = write_automatic_styles_ods(o, wb);&#13;
		o.push('  &lt;office:body&gt;\n');&#13;
		o.push('    &lt;office:spreadsheet&gt;\n');&#13;
		if(((wb.Workbook||{}).WBProps||{}).date1904) o.push('      &lt;table:calculation-settings table:case-sensitive="false" table:search-criteria-must-apply-to-whole-cell="true" table:use-wildcards="true" table:use-regular-expressions="false" table:automatic-find-labels="false"&gt;\n        &lt;table:null-date table:date-value="1904-01-01"/&gt;\n      &lt;/table:calculation-settings&gt;\n');&#13;
		for(var i = 0; i != wb.SheetNames.length; ++i) o.push(write_ws(wb.Sheets[wb.SheetNames[i]], wb, i, opts, nfs));&#13;
		if((wb.Workbook||{}).Names) o.push(write_names_ods(wb.Workbook.Names, wb.SheetNames, -1));&#13;
		o.push('    &lt;/office:spreadsheet&gt;\n');&#13;
		o.push('  &lt;/office:body&gt;\n');&#13;
		if(opts.bookType == "fods") o.push('&lt;/office:document&gt;');&#13;
		else o.push('&lt;/office:document-content&gt;');&#13;
		return o.join("");&#13;
	};&#13;
})();&#13;
&#13;
function write_ods(wb, opts) {&#13;
	if(opts.bookType == "fods") return write_content_ods(wb, opts);&#13;
&#13;
	var zip = zip_new();&#13;
	var f = "";&#13;
&#13;
	var manifest = [];&#13;
	var rdf = [];&#13;
&#13;
	/* Part 3 Section 3.3 MIME Media Type */&#13;
	f = "mimetype";&#13;
	zip_add_file(zip, f, "application/vnd.oasis.opendocument.spreadsheet");&#13;
&#13;
	/* Part 1 Section 2.2 Documents */&#13;
	f = "content.xml";&#13;
	zip_add_file(zip, f, write_content_ods(wb, opts));&#13;
	manifest.push([f, "text/xml"]);&#13;
	rdf.push([f, "ContentFile"]);&#13;
&#13;
	/* TODO: these are hard-coded styles to satiate excel */&#13;
	f = "styles.xml";&#13;
	zip_add_file(zip, f, write_styles_ods(wb, opts));&#13;
	manifest.push([f, "text/xml"]);&#13;
	rdf.push([f, "StylesFile"]);&#13;
&#13;
	/* TODO: this is hard-coded to satiate excel */&#13;
	f = "meta.xml";&#13;
	zip_add_file(zip, f, XML_HEADER + write_meta_ods());&#13;
	manifest.push([f, "text/xml"]);&#13;
	rdf.push([f, "MetadataFile"]);&#13;
&#13;
	/* Part 3 Section 6 Metadata Manifest File */&#13;
	f = "manifest.rdf";&#13;
	zip_add_file(zip, f, write_rdf(rdf/*, opts*/));&#13;
	manifest.push([f, "application/rdf+xml"]);&#13;
&#13;
	/* Part 3 Section 4 Manifest File */&#13;
	f = "META-INF/manifest.xml";&#13;
	zip_add_file(zip, f, write_manifest(manifest/*, opts*/));&#13;
&#13;
	return zip;&#13;
}&#13;
&#13;
/*! sheetjs (C) 2013-present xlsx -- http://sheetjs.com */&#13;
var subarray = function() {&#13;
  try {&#13;
    if (typeof Uint8Array == "undefined")&#13;
      return "slice";&#13;
    if (typeof Uint8Array.prototype.subarray == "undefined")&#13;
      return "slice";&#13;
    if (typeof Buffer !== "undefined") {&#13;
      if (typeof Buffer.prototype.subarray == "undefined")&#13;
        return "slice";&#13;
      if ((typeof Buffer.from == "function" ? Buffer.from([72, 62]) : new Buffer([72, 62])) instanceof Uint8Array)&#13;
        return "subarray";&#13;
      return "slice";&#13;
    }&#13;
    return "subarray";&#13;
  } catch (e) {&#13;
    return "slice";&#13;
  }&#13;
}();&#13;
function u8_to_dataview(array) {&#13;
  return new DataView(array.buffer, array.byteOffset, array.byteLength);&#13;
}&#13;
function u8str(u8) {&#13;
  return typeof TextDecoder != "undefined" ? new TextDecoder().decode(u8) : utf8read(a2s(u8));&#13;
}&#13;
function stru8(str) {&#13;
  return typeof TextEncoder != "undefined" ? new TextEncoder().encode(str) : s2a(utf8write(str));&#13;
}&#13;
function u8contains(body, search) {&#13;
  var L = body.indexOf(search[0]);&#13;
  if (L == -1)&#13;
    return false;&#13;
  outer:&#13;
    for (; L &lt;= body.length - search.length; ++L) {&#13;
      for (var j = 0; j &lt; search.length; ++j)&#13;
        if (body[L + j] != search[j])&#13;
          continue outer;&#13;
      return true;&#13;
    }&#13;
  return false;&#13;
}&#13;
function u8concat(u8a) {&#13;
  var len = u8a.reduce(function(acc, x) {&#13;
    return acc + x.length;&#13;
  }, 0);&#13;
  var out = new Uint8Array(len);&#13;
  var off = 0;&#13;
  u8a.forEach(function(u8) {&#13;
    out.set(u8, off);&#13;
    off += u8.length;&#13;
  });&#13;
  return out;&#13;
}&#13;
function popcnt(x) {&#13;
  x -= x &gt;&gt; 1 &amp; 1431655765;&#13;
  x = (x &amp; 858993459) + (x &gt;&gt; 2 &amp; 858993459);&#13;
  return (x + (x &gt;&gt; 4) &amp; 252645135) * 16843009 &gt;&gt;&gt; 24;&#13;
}&#13;
function readDecimal128LE(buf, offset) {&#13;
  var exp = (buf[offset + 15] &amp; 127) &lt;&lt; 7 | buf[offset + 14] &gt;&gt; 1;&#13;
  var mantissa = buf[offset + 14] &amp; 1;&#13;
  for (var j = offset + 13; j &gt;= offset; --j)&#13;
    mantissa = mantissa * 256 + buf[j];&#13;
  return (buf[offset + 15] &amp; 128 ? -mantissa : mantissa) * Math.pow(10, exp - 6176);&#13;
}&#13;
function writeDecimal128LE(buf, offset, value) {&#13;
  var exp = Math.floor(value == 0 ? 0 : Math.LOG10E * Math.log(Math.abs(value))) + 6176 - 16;&#13;
  var mantissa = value / Math.pow(10, exp - 6176);&#13;
  buf[offset + 15] |= exp &gt;&gt; 7;&#13;
  buf[offset + 14] |= (exp &amp; 127) &lt;&lt; 1;&#13;
  for (var i = 0; mantissa &gt;= 1; ++i, mantissa /= 256)&#13;
    buf[offset + i] = mantissa &amp; 255;&#13;
  buf[offset + 15] |= value &gt;= 0 ? 0 : 128;&#13;
}&#13;
function parse_varint49(buf, ptr) {&#13;
  var l = ptr ? ptr[0] : 0;&#13;
  var usz = buf[l] &amp; 127;&#13;
  varint:&#13;
    if (buf[l++] &gt;= 128) {&#13;
      usz |= (buf[l] &amp; 127) &lt;&lt; 7;&#13;
      if (buf[l++] &lt; 128)&#13;
        break varint;&#13;
      usz |= (buf[l] &amp; 127) &lt;&lt; 14;&#13;
      if (buf[l++] &lt; 128)&#13;
        break varint;&#13;
      usz |= (buf[l] &amp; 127) &lt;&lt; 21;&#13;
      if (buf[l++] &lt; 128)&#13;
        break varint;&#13;
      usz += (buf[l] &amp; 127) * Math.pow(2, 28);&#13;
      ++l;&#13;
      if (buf[l++] &lt; 128)&#13;
        break varint;&#13;
      usz += (buf[l] &amp; 127) * Math.pow(2, 35);&#13;
      ++l;&#13;
      if (buf[l++] &lt; 128)&#13;
        break varint;&#13;
      usz += (buf[l] &amp; 127) * Math.pow(2, 42);&#13;
      ++l;&#13;
      if (buf[l++] &lt; 128)&#13;
        break varint;&#13;
    }&#13;
  if (ptr)&#13;
    ptr[0] = l;&#13;
  return usz;&#13;
}&#13;
function write_varint49(v) {&#13;
  var usz = new Uint8Array(7);&#13;
  usz[0] = v &amp; 127;&#13;
  var L = 1;&#13;
  sz:&#13;
    if (v &gt; 127) {&#13;
      usz[L - 1] |= 128;&#13;
      usz[L] = v &gt;&gt; 7 &amp; 127;&#13;
      ++L;&#13;
      if (v &lt;= 16383)&#13;
        break sz;&#13;
      usz[L - 1] |= 128;&#13;
      usz[L] = v &gt;&gt; 14 &amp; 127;&#13;
      ++L;&#13;
      if (v &lt;= 2097151)&#13;
        break sz;&#13;
      usz[L - 1] |= 128;&#13;
      usz[L] = v &gt;&gt; 21 &amp; 127;&#13;
      ++L;&#13;
      if (v &lt;= 268435455)&#13;
        break sz;&#13;
      usz[L - 1] |= 128;&#13;
      usz[L] = v / 256 &gt;&gt;&gt; 21 &amp; 127;&#13;
      ++L;&#13;
      if (v &lt;= 34359738367)&#13;
        break sz;&#13;
      usz[L - 1] |= 128;&#13;
      usz[L] = v / 65536 &gt;&gt;&gt; 21 &amp; 127;&#13;
      ++L;&#13;
      if (v &lt;= 4398046511103)&#13;
        break sz;&#13;
      usz[L - 1] |= 128;&#13;
      usz[L] = v / 16777216 &gt;&gt;&gt; 21 &amp; 127;&#13;
      ++L;&#13;
    }&#13;
  return usz[subarray](0, L);&#13;
}&#13;
function parse_packed_varints(buf) {&#13;
  var ptr = [0];&#13;
  var out = [];&#13;
  while (ptr[0] &lt; buf.length)&#13;
    out.push(parse_varint49(buf, ptr));&#13;
  return out;&#13;
}&#13;
function write_packed_varints(nums) {&#13;
  return u8concat(nums.map(function(x) {&#13;
    return write_varint49(x);&#13;
  }));&#13;
}&#13;
function varint_to_i32(buf) {&#13;
  var l = 0, i32 = buf[l] &amp; 127;&#13;
  varint:&#13;
    if (buf[l++] &gt;= 128) {&#13;
      i32 |= (buf[l] &amp; 127) &lt;&lt; 7;&#13;
      if (buf[l++] &lt; 128)&#13;
        break varint;&#13;
      i32 |= (buf[l] &amp; 127) &lt;&lt; 14;&#13;
      if (buf[l++] &lt; 128)&#13;
        break varint;&#13;
      i32 |= (buf[l] &amp; 127) &lt;&lt; 21;&#13;
      if (buf[l++] &lt; 128)&#13;
        break varint;&#13;
      i32 |= (buf[l] &amp; 127) &lt;&lt; 28;&#13;
    }&#13;
  return i32;&#13;
}&#13;
function varint_to_u64(buf) {&#13;
  var l = 0, lo = buf[l] &amp; 127, hi = 0;&#13;
  varint:&#13;
    if (buf[l++] &gt;= 128) {&#13;
      lo |= (buf[l] &amp; 127) &lt;&lt; 7;&#13;
      if (buf[l++] &lt; 128)&#13;
        break varint;&#13;
      lo |= (buf[l] &amp; 127) &lt;&lt; 14;&#13;
      if (buf[l++] &lt; 128)&#13;
        break varint;&#13;
      lo |= (buf[l] &amp; 127) &lt;&lt; 21;&#13;
      if (buf[l++] &lt; 128)&#13;
        break varint;&#13;
      lo |= (buf[l] &amp; 127) &lt;&lt; 28;&#13;
      hi = buf[l] &gt;&gt; 4 &amp; 7;&#13;
      if (buf[l++] &lt; 128)&#13;
        break varint;&#13;
      hi |= (buf[l] &amp; 127) &lt;&lt; 3;&#13;
      if (buf[l++] &lt; 128)&#13;
        break varint;&#13;
      hi |= (buf[l] &amp; 127) &lt;&lt; 10;&#13;
      if (buf[l++] &lt; 128)&#13;
        break varint;&#13;
      hi |= (buf[l] &amp; 127) &lt;&lt; 17;&#13;
      if (buf[l++] &lt; 128)&#13;
        break varint;&#13;
      hi |= (buf[l] &amp; 127) &lt;&lt; 24;&#13;
      if (buf[l++] &lt; 128)&#13;
        break varint;&#13;
      hi |= (buf[l] &amp; 127) &lt;&lt; 31;&#13;
    }&#13;
  return [lo &gt;&gt;&gt; 0, hi &gt;&gt;&gt; 0];&#13;
}&#13;
function parse_shallow(buf) {&#13;
  var out = [], ptr = [0];&#13;
  while (ptr[0] &lt; buf.length) {&#13;
    var off = ptr[0];&#13;
    var num = parse_varint49(buf, ptr);&#13;
    var type = num &amp; 7;&#13;
    num = Math.floor(num / 8);&#13;
    var len = 0;&#13;
    var res;&#13;
    if (num == 0)&#13;
      break;&#13;
    switch (type) {&#13;
      case 0:&#13;
        {&#13;
          var l = ptr[0];&#13;
          while (buf[ptr[0]++] &gt;= 128)&#13;
            ;&#13;
          res = buf[subarray](l, ptr[0]);&#13;
        }&#13;
        break;&#13;
      case 5:&#13;
        len = 4;&#13;
        res = buf[subarray](ptr[0], ptr[0] + len);&#13;
        ptr[0] += len;&#13;
        break;&#13;
      case 1:&#13;
        len = 8;&#13;
        res = buf[subarray](ptr[0], ptr[0] + len);&#13;
        ptr[0] += len;&#13;
        break;&#13;
      case 2:&#13;
        len = parse_varint49(buf, ptr);&#13;
        res = buf[subarray](ptr[0], ptr[0] + len);&#13;
        ptr[0] += len;&#13;
        break;&#13;
      case 3:&#13;
      case 4:&#13;
      default:&#13;
        throw new Error("PB Type ".concat(type, " for Field ").concat(num, " at offset ").concat(off));&#13;
    }&#13;
    var v = { data: res, type: type };&#13;
    if (out[num] == null)&#13;
      out[num] = [v];&#13;
    else&#13;
      out[num].push(v);&#13;
  }&#13;
  return out;&#13;
}&#13;
function write_shallow(proto) {&#13;
  var out = [];&#13;
  proto.forEach(function(field, idx) {&#13;
    if (idx == 0)&#13;
      return;&#13;
    field.forEach(function(item) {&#13;
      if (!item.data)&#13;
        return;&#13;
      out.push(write_varint49(idx * 8 + item.type));&#13;
      if (item.type == 2)&#13;
        out.push(write_varint49(item.data.length));&#13;
      out.push(item.data);&#13;
    });&#13;
  });&#13;
  return u8concat(out);&#13;
}&#13;
function mappa(data, cb) {&#13;
  return (data == null ? void 0 : data.map(function(d) {&#13;
    return cb(d.data);&#13;
  })) || [];&#13;
}&#13;
function parse_iwa_file(buf) {&#13;
  var _a;&#13;
  var out = [], ptr = [0];&#13;
  while (ptr[0] &lt; buf.length) {&#13;
    var len = parse_varint49(buf, ptr);&#13;
    var ai = parse_shallow(buf[subarray](ptr[0], ptr[0] + len));&#13;
    ptr[0] += len;&#13;
    var res = {&#13;
      id: varint_to_i32(ai[1][0].data),&#13;
      messages: []&#13;
    };&#13;
    ai[2].forEach(function(b) {&#13;
      var mi = parse_shallow(b.data);&#13;
      var fl = varint_to_i32(mi[3][0].data);&#13;
      res.messages.push({&#13;
        meta: mi,&#13;
        data: buf[subarray](ptr[0], ptr[0] + fl)&#13;
      });&#13;
      ptr[0] += fl;&#13;
    });&#13;
    if ((_a = ai[3]) == null ? void 0 : _a[0])&#13;
      res.merge = varint_to_i32(ai[3][0].data) &gt;&gt;&gt; 0 &gt; 0;&#13;
    out.push(res);&#13;
  }&#13;
  return out;&#13;
}&#13;
function write_iwa_file(ias) {&#13;
  var bufs = [];&#13;
  ias.forEach(function(ia) {&#13;
    var ai = [&#13;
      [],&#13;
      [{ data: write_varint49(ia.id), type: 0 }],&#13;
      []&#13;
    ];&#13;
    if (ia.merge != null)&#13;
      ai[3] = [{ data: write_varint49(+!!ia.merge), type: 0 }];&#13;
    var midata = [];&#13;
    ia.messages.forEach(function(mi) {&#13;
      midata.push(mi.data);&#13;
      mi.meta[3] = [{ type: 0, data: write_varint49(mi.data.length) }];&#13;
      ai[2].push({ data: write_shallow(mi.meta), type: 2 });&#13;
    });&#13;
    var aipayload = write_shallow(ai);&#13;
    bufs.push(write_varint49(aipayload.length));&#13;
    bufs.push(aipayload);&#13;
    midata.forEach(function(mid) {&#13;
      return bufs.push(mid);&#13;
    });&#13;
  });&#13;
  return u8concat(bufs);&#13;
}&#13;
function parse_snappy_chunk(type, buf) {&#13;
  if (type != 0)&#13;
    throw new Error("Unexpected Snappy chunk type ".concat(type));&#13;
  var ptr = [0];&#13;
  var usz = parse_varint49(buf, ptr);&#13;
  var chunks = [];&#13;
  while (ptr[0] &lt; buf.length) {&#13;
    var tag = buf[ptr[0]] &amp; 3;&#13;
    if (tag == 0) {&#13;
      var len = buf[ptr[0]++] &gt;&gt; 2;&#13;
      if (len &lt; 60)&#13;
        ++len;&#13;
      else {&#13;
        var c = len - 59;&#13;
        len = buf[ptr[0]];&#13;
        if (c &gt; 1)&#13;
          len |= buf[ptr[0] + 1] &lt;&lt; 8;&#13;
        if (c &gt; 2)&#13;
          len |= buf[ptr[0] + 2] &lt;&lt; 16;&#13;
        if (c &gt; 3)&#13;
          len |= buf[ptr[0] + 3] &lt;&lt; 24;&#13;
        len &gt;&gt;&gt;= 0;&#13;
        len++;&#13;
        ptr[0] += c;&#13;
      }&#13;
      chunks.push(buf[subarray](ptr[0], ptr[0] + len));&#13;
      ptr[0] += len;&#13;
      continue;&#13;
    } else {&#13;
      var offset = 0, length = 0;&#13;
      if (tag == 1) {&#13;
        length = (buf[ptr[0]] &gt;&gt; 2 &amp; 7) + 4;&#13;
        offset = (buf[ptr[0]++] &amp; 224) &lt;&lt; 3;&#13;
        offset |= buf[ptr[0]++];&#13;
      } else {&#13;
        length = (buf[ptr[0]++] &gt;&gt; 2) + 1;&#13;
        if (tag == 2) {&#13;
          offset = buf[ptr[0]] | buf[ptr[0] + 1] &lt;&lt; 8;&#13;
          ptr[0] += 2;&#13;
        } else {&#13;
          offset = (buf[ptr[0]] | buf[ptr[0] + 1] &lt;&lt; 8 | buf[ptr[0] + 2] &lt;&lt; 16 | buf[ptr[0] + 3] &lt;&lt; 24) &gt;&gt;&gt; 0;&#13;
          ptr[0] += 4;&#13;
        }&#13;
      }&#13;
      if (offset == 0)&#13;
        throw new Error("Invalid offset 0");&#13;
      var j = chunks.length - 1, off = offset;&#13;
      while (j &gt;= 0 &amp;&amp; off &gt;= chunks[j].length) {&#13;
        off -= chunks[j].length;&#13;
        --j;&#13;
      }&#13;
      if (j &lt; 0) {&#13;
        if (off == 0)&#13;
          off = chunks[j = 0].length;&#13;
        else&#13;
          throw new Error("Invalid offset beyond length");&#13;
      }&#13;
      if (length &lt; off)&#13;
        chunks.push(chunks[j][subarray](chunks[j].length - off, chunks[j].length - off + length));&#13;
      else {&#13;
        if (off &gt; 0) {&#13;
          chunks.push(chunks[j][subarray](chunks[j].length - off));&#13;
          length -= off;&#13;
        }&#13;
        ++j;&#13;
        while (length &gt;= chunks[j].length) {&#13;
          chunks.push(chunks[j]);&#13;
          length -= chunks[j].length;&#13;
          ++j;&#13;
        }&#13;
        if (length)&#13;
          chunks.push(chunks[j][subarray](0, length));&#13;
      }&#13;
      if (chunks.length &gt; 100)&#13;
        chunks = [u8concat(chunks)];&#13;
    }&#13;
  }&#13;
  if (chunks.reduce(function(acc, u8) {&#13;
    return acc + u8.length;&#13;
  }, 0) != usz)&#13;
    throw new Error("Unexpected length: ".concat(chunks.reduce(function(acc, u8) {&#13;
      return acc + u8.length;&#13;
    }, 0), " != ").concat(usz));&#13;
  return chunks;&#13;
}&#13;
function decompress_iwa_file(buf) {&#13;
  if (Array.isArray(buf))&#13;
    buf = new Uint8Array(buf);&#13;
  var out = [];&#13;
  var l = 0;&#13;
  while (l &lt; buf.length) {&#13;
    var t = buf[l++];&#13;
    var len = buf[l] | buf[l + 1] &lt;&lt; 8 | buf[l + 2] &lt;&lt; 16;&#13;
    l += 3;&#13;
    out.push.apply(out, parse_snappy_chunk(t, buf[subarray](l, l + len)));&#13;
    l += len;&#13;
  }&#13;
  if (l !== buf.length)&#13;
    throw new Error("data is not a valid framed stream!");&#13;
  return u8concat(out);&#13;
}&#13;
function compress_iwa_file(buf) {&#13;
  var out = [];&#13;
  var l = 0;&#13;
  while (l &lt; buf.length) {&#13;
    var c = Math.min(buf.length - l, 268435455);&#13;
    var frame = new Uint8Array(4);&#13;
    out.push(frame);&#13;
    var usz = write_varint49(c);&#13;
    var L = usz.length;&#13;
    out.push(usz);&#13;
    if (c &lt;= 60) {&#13;
      L++;&#13;
      out.push(new Uint8Array([c - 1 &lt;&lt; 2]));&#13;
    } else if (c &lt;= 256) {&#13;
      L += 2;&#13;
      out.push(new Uint8Array([240, c - 1 &amp; 255]));&#13;
    } else if (c &lt;= 65536) {&#13;
      L += 3;&#13;
      out.push(new Uint8Array([244, c - 1 &amp; 255, c - 1 &gt;&gt; 8 &amp; 255]));&#13;
    } else if (c &lt;= 16777216) {&#13;
      L += 4;&#13;
      out.push(new Uint8Array([248, c - 1 &amp; 255, c - 1 &gt;&gt; 8 &amp; 255, c - 1 &gt;&gt; 16 &amp; 255]));&#13;
    } else if (c &lt;= 4294967296) {&#13;
      L += 5;&#13;
      out.push(new Uint8Array([252, c - 1 &amp; 255, c - 1 &gt;&gt; 8 &amp; 255, c - 1 &gt;&gt; 16 &amp; 255, c - 1 &gt;&gt;&gt; 24 &amp; 255]));&#13;
    }&#13;
    out.push(buf[subarray](l, l + c));&#13;
    L += c;&#13;
    frame[0] = 0;&#13;
    frame[1] = L &amp; 255;&#13;
    frame[2] = L &gt;&gt; 8 &amp; 255;&#13;
    frame[3] = L &gt;&gt; 16 &amp; 255;&#13;
    l += c;&#13;
  }&#13;
  return u8concat(out);&#13;
}&#13;
var numbers_lut_new = function() {&#13;
  return { sst: [], rsst: [], ofmt: [], nfmt: [] };&#13;
};&#13;
function numbers_format_cell(cell, t, flags, ofmt, nfmt) {&#13;
  var _a, _b, _c, _d;&#13;
  var ctype = t &amp; 255, ver = t &gt;&gt; 8;&#13;
  var fmt = ver &gt;= 5 ? nfmt : ofmt;&#13;
  dur:&#13;
    if (flags &amp; (ver &gt; 4 ? 8 : 4) &amp;&amp; cell.t == "n" &amp;&amp; ctype == 7) {&#13;
      var dstyle = ((_a = fmt[7]) == null ? void 0 : _a[0]) ? parse_varint49(fmt[7][0].data) : -1;&#13;
      if (dstyle == -1)&#13;
        break dur;&#13;
      var dmin = ((_b = fmt[15]) == null ? void 0 : _b[0]) ? parse_varint49(fmt[15][0].data) : -1;&#13;
      var dmax = ((_c = fmt[16]) == null ? void 0 : _c[0]) ? parse_varint49(fmt[16][0].data) : -1;&#13;
      var auto = ((_d = fmt[40]) == null ? void 0 : _d[0]) ? parse_varint49(fmt[40][0].data) : -1;&#13;
      var d = cell.v, dd = d;&#13;
      autodur:&#13;
        if (auto) {&#13;
          if (d == 0) {&#13;
            dmin = dmax = 2;&#13;
            break autodur;&#13;
          }&#13;
          if (d &gt;= 604800)&#13;
            dmin = 1;&#13;
          else if (d &gt;= 86400)&#13;
            dmin = 2;&#13;
          else if (d &gt;= 3600)&#13;
            dmin = 4;&#13;
          else if (d &gt;= 60)&#13;
            dmin = 8;&#13;
          else if (d &gt;= 1)&#13;
            dmin = 16;&#13;
          else&#13;
            dmin = 32;&#13;
          if (Math.floor(d) != d)&#13;
            dmax = 32;&#13;
          else if (d % 60)&#13;
            dmax = 16;&#13;
          else if (d % 3600)&#13;
            dmax = 8;&#13;
          else if (d % 86400)&#13;
            dmax = 4;&#13;
          else if (d % 604800)&#13;
            dmax = 2;&#13;
          if (dmax &lt; dmin)&#13;
            dmax = dmin;&#13;
        }&#13;
      if (dmin == -1 || dmax == -1)&#13;
        break dur;&#13;
      var dstr = [], zstr = [];&#13;
      if (dmin == 1) {&#13;
        dd = d / 604800;&#13;
        if (dmax == 1) {&#13;
          zstr.push('d"d"');&#13;
        } else {&#13;
          dd |= 0;&#13;
          d -= 604800 * dd;&#13;
        }&#13;
        dstr.push(dd + (dstyle == 2 ? " week" + (dd == 1 ? "" : "s") : dstyle == 1 ? "w" : ""));&#13;
      }&#13;
      if (dmin &lt;= 2 &amp;&amp; dmax &gt;= 2) {&#13;
        dd = d / 86400;&#13;
        if (dmax &gt; 2) {&#13;
          dd |= 0;&#13;
          d -= 86400 * dd;&#13;
        }&#13;
        zstr.push('d"d"');&#13;
        dstr.push(dd + (dstyle == 2 ? " day" + (dd == 1 ? "" : "s") : dstyle == 1 ? "d" : ""));&#13;
      }&#13;
      if (dmin &lt;= 4 &amp;&amp; dmax &gt;= 4) {&#13;
        dd = d / 3600;&#13;
        if (dmax &gt; 4) {&#13;
          dd |= 0;&#13;
          d -= 3600 * dd;&#13;
        }&#13;
        zstr.push((dmin &gt;= 4 ? "[h]" : "h") + '"h"');&#13;
        dstr.push(dd + (dstyle == 2 ? " hour" + (dd == 1 ? "" : "s") : dstyle == 1 ? "h" : ""));&#13;
      }&#13;
      if (dmin &lt;= 8 &amp;&amp; dmax &gt;= 8) {&#13;
        dd = d / 60;&#13;
        if (dmax &gt; 8) {&#13;
          dd |= 0;&#13;
          d -= 60 * dd;&#13;
        }&#13;
        zstr.push((dmin &gt;= 8 ? "[m]" : "m") + '"m"');&#13;
        if (dstyle == 0)&#13;
          dstr.push((dmin == 8 &amp;&amp; dmax == 8 || dd &gt;= 10 ? "" : "0") + dd);&#13;
        else&#13;
          dstr.push(dd + (dstyle == 2 ? " minute" + (dd == 1 ? "" : "s") : dstyle == 1 ? "m" : ""));&#13;
      }&#13;
      if (dmin &lt;= 16 &amp;&amp; dmax &gt;= 16) {&#13;
        dd = d;&#13;
        if (dmax &gt; 16) {&#13;
          dd |= 0;&#13;
          d -= dd;&#13;
        }&#13;
        zstr.push((dmin &gt;= 16 ? "[s]" : "s") + '"s"');&#13;
        if (dstyle == 0)&#13;
          dstr.push((dmax == 16 &amp;&amp; dmin == 16 || dd &gt;= 10 ? "" : "0") + dd);&#13;
        else&#13;
          dstr.push(dd + (dstyle == 2 ? " second" + (dd == 1 ? "" : "s") : dstyle == 1 ? "s" : ""));&#13;
      }&#13;
      if (dmax &gt;= 32) {&#13;
        dd = Math.round(1e3 * d);&#13;
        if (dmin &lt; 32)&#13;
          zstr.push('.000"ms"');&#13;
        if (dstyle == 0)&#13;
          dstr.push((dd &gt;= 100 ? "" : dd &gt;= 10 ? "0" : "00") + dd);&#13;
        else&#13;
          dstr.push(dd + (dstyle == 2 ? " millisecond" + (dd == 1 ? "" : "s") : dstyle == 1 ? "ms" : ""));&#13;
      }&#13;
      cell.w = dstr.join(dstyle == 0 ? ":" : " ");&#13;
      cell.z = zstr.join(dstyle == 0 ? '":"' : " ");&#13;
      if (dstyle == 0)&#13;
        cell.w = cell.w.replace(/:(\d\d\d)$/, ".$1");&#13;
    }&#13;
}&#13;
function parse_old_storage(buf, lut, v) {&#13;
  var dv = u8_to_dataview(buf);&#13;
  var flags = dv.getUint32(4, true);&#13;
  var ridx = -1, sidx = -1, zidx = -1, ieee = NaN, dt = new Date(2001, 0, 1);&#13;
  var doff = v &gt; 1 ? 12 : 8;&#13;
  if (flags &amp; 2) {&#13;
    zidx = dv.getUint32(doff, true);&#13;
    doff += 4;&#13;
  }&#13;
  doff += popcnt(flags &amp; (v &gt; 1 ? 3468 : 396)) * 4;&#13;
  if (flags &amp; 512) {&#13;
    ridx = dv.getUint32(doff, true);&#13;
    doff += 4;&#13;
  }&#13;
  doff += popcnt(flags &amp; (v &gt; 1 ? 12288 : 4096)) * 4;&#13;
  if (flags &amp; 16) {&#13;
    sidx = dv.getUint32(doff, true);&#13;
    doff += 4;&#13;
  }&#13;
  if (flags &amp; 32) {&#13;
    ieee = dv.getFloat64(doff, true);&#13;
    doff += 8;&#13;
  }&#13;
  if (flags &amp; 64) {&#13;
    dt.setTime(dt.getTime() + dv.getFloat64(doff, true) * 1e3);&#13;
    doff += 8;&#13;
  }&#13;
  if (v &gt; 1) {&#13;
    flags = dv.getUint32(8, true) &gt;&gt;&gt; 16;&#13;
    if (flags &amp; 255) {&#13;
      if (zidx == -1)&#13;
        zidx = dv.getUint32(doff, true);&#13;
      doff += 4;&#13;
    }&#13;
  }&#13;
  var ret;&#13;
  var t = buf[v &gt;= 4 ? 1 : 2];&#13;
  switch (t) {&#13;
    case 0:&#13;
      return void 0;&#13;
    case 2:&#13;
      ret = { t: "n", v: ieee };&#13;
      break;&#13;
    case 3:&#13;
      ret = { t: "s", v: lut.sst[sidx] };&#13;
      break;&#13;
    case 5:&#13;
      ret = { t: "d", v: dt };&#13;
      break;&#13;
    case 6:&#13;
      ret = { t: "b", v: ieee &gt; 0 };&#13;
      break;&#13;
    case 7:&#13;
      ret = { t: "n", v: ieee };&#13;
      break;&#13;
    case 8:&#13;
      ret = { t: "e", v: 0 };&#13;
      break;&#13;
    case 9:&#13;
      {&#13;
        if (ridx &gt; -1)&#13;
          ret = { t: "s", v: lut.rsst[ridx] };&#13;
        else&#13;
          throw new Error("Unsupported cell type ".concat(buf[subarray](0, 4)));&#13;
      }&#13;
      break;&#13;
    default:&#13;
      throw new Error("Unsupported cell type ".concat(buf[subarray](0, 4)));&#13;
  }&#13;
  if (zidx &gt; -1)&#13;
    numbers_format_cell(ret, t | v &lt;&lt; 8, flags, lut.ofmt[zidx], lut.nfmt[zidx]);&#13;
  if (t == 7)&#13;
    ret.v /= 86400;&#13;
  return ret;&#13;
}&#13;
function parse_new_storage(buf, lut) {&#13;
  var dv = u8_to_dataview(buf);&#13;
  var flags = dv.getUint32(4, true);&#13;
  var fields = dv.getUint32(8, true);&#13;
  var doff = 12;&#13;
  var ridx = -1, sidx = -1, zidx = -1, d128 = NaN, ieee = NaN, dt = new Date(2001, 0, 1);&#13;
  if (fields &amp; 1) {&#13;
    d128 = readDecimal128LE(buf, doff);&#13;
    doff += 16;&#13;
  }&#13;
  if (fields &amp; 2) {&#13;
    ieee = dv.getFloat64(doff, true);&#13;
    doff += 8;&#13;
  }&#13;
  if (fields &amp; 4) {&#13;
    dt.setTime(dt.getTime() + dv.getFloat64(doff, true) * 1e3);&#13;
    doff += 8;&#13;
  }&#13;
  if (fields &amp; 8) {&#13;
    sidx = dv.getUint32(doff, true);&#13;
    doff += 4;&#13;
  }&#13;
  if (fields &amp; 16) {&#13;
    ridx = dv.getUint32(doff, true);&#13;
    doff += 4;&#13;
  }&#13;
  var ret;&#13;
  var t = buf[1];&#13;
  switch (t) {&#13;
    case 0:&#13;
      return void 0;&#13;
    case 2:&#13;
      ret = { t: "n", v: d128 };&#13;
      break;&#13;
    case 3:&#13;
      ret = { t: "s", v: lut.sst[sidx] };&#13;
      break;&#13;
    case 5:&#13;
      ret = { t: "d", v: dt };&#13;
      break;&#13;
    case 6:&#13;
      ret = { t: "b", v: ieee &gt; 0 };&#13;
      break;&#13;
    case 7:&#13;
      ret = { t: "n", v: ieee };&#13;
      break;&#13;
    case 8:&#13;
      ret = { t: "e", v: 0 };&#13;
      break;&#13;
    case 9:&#13;
      ret = { t: "s", v: lut.rsst[ridx] };&#13;
      break;&#13;
    case 10:&#13;
      ret = { t: "n", v: d128 };&#13;
      break;&#13;
    default:&#13;
      throw new Error("Unsupported cell type ".concat(buf[1], " : ").concat(fields &amp; 31, " : ").concat(buf[subarray](0, 4)));&#13;
  }&#13;
  doff += popcnt(fields &amp; 8160) * 4;&#13;
  if (fields &amp; 516096) {&#13;
    if (zidx == -1)&#13;
      zidx = dv.getUint32(doff, true);&#13;
    doff += 4;&#13;
  }&#13;
  if (zidx &gt; -1)&#13;
    numbers_format_cell(ret, t | 5 &lt;&lt; 8, fields &gt;&gt; 13, lut.ofmt[zidx], lut.nfmt[zidx]);&#13;
  if (t == 7)&#13;
    ret.v /= 86400;&#13;
  return ret;&#13;
}&#13;
function write_new_storage(cell, sst) {&#13;
  var out = new Uint8Array(32), dv = u8_to_dataview(out), l = 12, flags = 0;&#13;
  out[0] = 5;&#13;
  switch (cell.t) {&#13;
    case "n":&#13;
      out[1] = 2;&#13;
      writeDecimal128LE(out, l, cell.v);&#13;
      flags |= 1;&#13;
      l += 16;&#13;
      break;&#13;
    case "b":&#13;
      out[1] = 6;&#13;
      dv.setFloat64(l, cell.v ? 1 : 0, true);&#13;
      flags |= 2;&#13;
      l += 8;&#13;
      break;&#13;
    case "s":&#13;
      var s = cell.v == null ? "" : String(cell.v);&#13;
      var isst = sst.indexOf(s);&#13;
      if (isst == -1)&#13;
        sst[isst = sst.length] = s;&#13;
      out[1] = 3;&#13;
      dv.setUint32(l, isst, true);&#13;
      flags |= 8;&#13;
      l += 4;&#13;
      break;&#13;
    default:&#13;
      throw "unsupported cell type " + cell.t;&#13;
  }&#13;
  dv.setUint32(8, flags, true);&#13;
  return out[subarray](0, l);&#13;
}&#13;
function write_old_storage(cell, sst) {&#13;
  var out = new Uint8Array(32), dv = u8_to_dataview(out), l = 12, flags = 0;&#13;
  out[0] = 4;&#13;
  switch (cell.t) {&#13;
    case "n":&#13;
      out[2] = 2;&#13;
      dv.setFloat64(l, cell.v, true);&#13;
      flags |= 32;&#13;
      l += 8;&#13;
      break;&#13;
    case "b":&#13;
      out[2] = 6;&#13;
      dv.setFloat64(l, cell.v ? 1 : 0, true);&#13;
      flags |= 32;&#13;
      l += 8;&#13;
      break;&#13;
    case "s":&#13;
      var s = cell.v == null ? "" : String(cell.v);&#13;
      var isst = sst.indexOf(s);&#13;
      if (isst == -1)&#13;
        sst[isst = sst.length] = s;&#13;
      out[2] = 3;&#13;
      dv.setUint32(l, isst, true);&#13;
      flags |= 16;&#13;
      l += 4;&#13;
      break;&#13;
    default:&#13;
      throw "unsupported cell type " + cell.t;&#13;
  }&#13;
  dv.setUint32(8, flags, true);&#13;
  return out[subarray](0, l);&#13;
}&#13;
function parse_cell_storage(buf, lut) {&#13;
  switch (buf[0]) {&#13;
    case 0:&#13;
    case 1:&#13;
    case 2:&#13;
    case 3:&#13;
    case 4:&#13;
      return parse_old_storage(buf, lut, buf[0]);&#13;
    case 5:&#13;
      return parse_new_storage(buf, lut);&#13;
    default:&#13;
      throw new Error("Unsupported payload version ".concat(buf[0]));&#13;
  }&#13;
}&#13;
function parse_TSP_Reference(buf) {&#13;
  var pb = parse_shallow(buf);&#13;
  return parse_varint49(pb[1][0].data);&#13;
}&#13;
function write_TSP_Reference(idx) {&#13;
  return write_shallow([&#13;
    [],&#13;
    [{ type: 0, data: write_varint49(idx) }]&#13;
  ]);&#13;
}&#13;
function numbers_add_oref(iwa, ref) {&#13;
  var _a;&#13;
  var orefs = ((_a = iwa.messages[0].meta[5]) == null ? void 0 : _a[0]) ? parse_packed_varints(iwa.messages[0].meta[5][0].data) : [];&#13;
  var orefidx = orefs.indexOf(ref);&#13;
  if (orefidx == -1) {&#13;
    orefs.push(ref);&#13;
    iwa.messages[0].meta[5] = [{ type: 2, data: write_packed_varints(orefs) }];&#13;
  }&#13;
}&#13;
function numbers_del_oref(iwa, ref) {&#13;
  var _a;&#13;
  var orefs = ((_a = iwa.messages[0].meta[5]) == null ? void 0 : _a[0]) ? parse_packed_varints(iwa.messages[0].meta[5][0].data) : [];&#13;
  iwa.messages[0].meta[5] = [{ type: 2, data: write_packed_varints(orefs.filter(function(r) {&#13;
    return r != ref;&#13;
  })) }];&#13;
}&#13;
function parse_TST_TableDataList(M, root) {&#13;
  var pb = parse_shallow(root.data);&#13;
  var type = varint_to_i32(pb[1][0].data);&#13;
  var entries = pb[3];&#13;
  var data = [];&#13;
  (entries || []).forEach(function(entry) {&#13;
    var le = parse_shallow(entry.data);&#13;
    if (!le[1])&#13;
      return;&#13;
    var key = varint_to_i32(le[1][0].data) &gt;&gt;&gt; 0;&#13;
    switch (type) {&#13;
      case 1:&#13;
        data[key] = u8str(le[3][0].data);&#13;
        break;&#13;
      case 8:&#13;
        {&#13;
          var rt = M[parse_TSP_Reference(le[9][0].data)][0];&#13;
          var rtp = parse_shallow(rt.data);&#13;
          var rtpref = M[parse_TSP_Reference(rtp[1][0].data)][0];&#13;
          var mtype = varint_to_i32(rtpref.meta[1][0].data);&#13;
          if (mtype != 2001)&#13;
            throw new Error("2000 unexpected reference to ".concat(mtype));&#13;
          var tswpsa = parse_shallow(rtpref.data);&#13;
          data[key] = tswpsa[3].map(function(x) {&#13;
            return u8str(x.data);&#13;
          }).join("");&#13;
        }&#13;
        break;&#13;
      case 2:&#13;
        data[key] = parse_shallow(le[6][0].data);&#13;
        break;&#13;
      default:&#13;
        throw type;&#13;
    }&#13;
  });&#13;
  return data;&#13;
}&#13;
function parse_TST_TileRowInfo(u8, type) {&#13;
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;&#13;
  var pb = parse_shallow(u8);&#13;
  var R = varint_to_i32(pb[1][0].data) &gt;&gt;&gt; 0;&#13;
  var cnt = varint_to_i32(pb[2][0].data) &gt;&gt;&gt; 0;&#13;
  var wide_offsets = ((_b = (_a = pb[8]) == null ? void 0 : _a[0]) == null ? void 0 : _b.data) &amp;&amp; varint_to_i32(pb[8][0].data) &gt; 0 || false;&#13;
  var used_storage_u8, used_storage;&#13;
  if (((_d = (_c = pb[7]) == null ? void 0 : _c[0]) == null ? void 0 : _d.data) &amp;&amp; type != 0) {&#13;
    used_storage_u8 = (_f = (_e = pb[7]) == null ? void 0 : _e[0]) == null ? void 0 : _f.data;&#13;
    used_storage = (_h = (_g = pb[6]) == null ? void 0 : _g[0]) == null ? void 0 : _h.data;&#13;
  } else if (((_j = (_i = pb[4]) == null ? void 0 : _i[0]) == null ? void 0 : _j.data) &amp;&amp; type != 1) {&#13;
    used_storage_u8 = (_l = (_k = pb[4]) == null ? void 0 : _k[0]) == null ? void 0 : _l.data;&#13;
    used_storage = (_n = (_m = pb[3]) == null ? void 0 : _m[0]) == null ? void 0 : _n.data;&#13;
  } else&#13;
    throw "NUMBERS Tile missing ".concat(type, " cell storage");&#13;
  var width = wide_offsets ? 4 : 1;&#13;
  var used_storage_offsets = u8_to_dataview(used_storage_u8);&#13;
  var offsets = [];&#13;
  for (var C = 0; C &lt; used_storage_u8.length / 2; ++C) {&#13;
    var off = used_storage_offsets.getUint16(C * 2, true);&#13;
    if (off &lt; 65535)&#13;
      offsets.push([C, off]);&#13;
  }&#13;
  if (offsets.length != cnt)&#13;
    throw "Expected ".concat(cnt, " cells, found ").concat(offsets.length);&#13;
  var cells = [];&#13;
  for (C = 0; C &lt; offsets.length - 1; ++C)&#13;
    cells[offsets[C][0]] = used_storage[subarray](offsets[C][1] * width, offsets[C + 1][1] * width);&#13;
  if (offsets.length &gt;= 1)&#13;
    cells[offsets[offsets.length - 1][0]] = used_storage[subarray](offsets[offsets.length - 1][1] * width);&#13;
  return { R: R, cells: cells };&#13;
}&#13;
function parse_TST_Tile(M, root) {&#13;
  var _a;&#13;
  var pb = parse_shallow(root.data);&#13;
  var storage = -1;&#13;
  if ((_a = pb == null ? void 0 : pb[7]) == null ? void 0 : _a[0]) {&#13;
    if (varint_to_i32(pb[7][0].data) &gt;&gt;&gt; 0)&#13;
      storage = 1;&#13;
    else&#13;
      storage = 0;&#13;
  }&#13;
  var ri = mappa(pb[5], function(u8) {&#13;
    return parse_TST_TileRowInfo(u8, storage);&#13;
  });&#13;
  return {&#13;
    nrows: varint_to_i32(pb[4][0].data) &gt;&gt;&gt; 0,&#13;
    data: ri.reduce(function(acc, x) {&#13;
      if (!acc[x.R])&#13;
        acc[x.R] = [];&#13;
      x.cells.forEach(function(cell, C) {&#13;
        if (acc[x.R][C])&#13;
          throw new Error("Duplicate cell r=".concat(x.R, " c=").concat(C));&#13;
        acc[x.R][C] = cell;&#13;
      });&#13;
      return acc;&#13;
    }, [])&#13;
  };&#13;
}&#13;
function parse_TST_TableModelArchive(M, root, ws) {&#13;
  var _a, _b, _c, _d, _e, _f;&#13;
  var pb = parse_shallow(root.data);&#13;
  var range = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } };&#13;
  range.e.r = (varint_to_i32(pb[6][0].data) &gt;&gt;&gt; 0) - 1;&#13;
  if (range.e.r &lt; 0)&#13;
    throw new Error("Invalid row varint ".concat(pb[6][0].data));&#13;
  range.e.c = (varint_to_i32(pb[7][0].data) &gt;&gt;&gt; 0) - 1;&#13;
  if (range.e.c &lt; 0)&#13;
    throw new Error("Invalid col varint ".concat(pb[7][0].data));&#13;
  ws["!ref"] = encode_range(range);&#13;
  var dense = Array.isArray(ws);&#13;
  var store = parse_shallow(pb[4][0].data);&#13;
  var lut = numbers_lut_new();&#13;
  if ((_a = store[4]) == null ? void 0 : _a[0])&#13;
    lut.sst = parse_TST_TableDataList(M, M[parse_TSP_Reference(store[4][0].data)][0]);&#13;
  if ((_b = store[11]) == null ? void 0 : _b[0])&#13;
    lut.ofmt = parse_TST_TableDataList(M, M[parse_TSP_Reference(store[11][0].data)][0]);&#13;
  if ((_c = store[17]) == null ? void 0 : _c[0])&#13;
    lut.rsst = parse_TST_TableDataList(M, M[parse_TSP_Reference(store[17][0].data)][0]);&#13;
  if ((_d = store[22]) == null ? void 0 : _d[0])&#13;
    lut.nfmt = parse_TST_TableDataList(M, M[parse_TSP_Reference(store[22][0].data)][0]);&#13;
  var tile = parse_shallow(store[3][0].data);&#13;
  var _R = 0;&#13;
  tile[1].forEach(function(t) {&#13;
    var tl = parse_shallow(t.data);&#13;
    var ref2 = M[parse_TSP_Reference(tl[2][0].data)][0];&#13;
    var mtype2 = varint_to_i32(ref2.meta[1][0].data);&#13;
    if (mtype2 != 6002)&#13;
      throw new Error("6001 unexpected reference to ".concat(mtype2));&#13;
    var _tile = parse_TST_Tile(M, ref2);&#13;
    _tile.data.forEach(function(row, R) {&#13;
      row.forEach(function(buf, C) {&#13;
        var res = parse_cell_storage(buf, lut);&#13;
        if (res) {&#13;
          if (dense) {&#13;
            if (!ws[_R + R])&#13;
              ws[_R + R] = [];&#13;
            ws[_R + R][C] = res;&#13;
          } else {&#13;
            var addr = encode_cell({ r: _R + R, c: C });&#13;
            ws[addr] = res;&#13;
          }&#13;
        }&#13;
      });&#13;
    });&#13;
    _R += _tile.nrows;&#13;
  });&#13;
  if ((_e = store[13]) == null ? void 0 : _e[0]) {&#13;
    var ref = M[parse_TSP_Reference(store[13][0].data)][0];&#13;
    var mtype = varint_to_i32(ref.meta[1][0].data);&#13;
    if (mtype != 6144)&#13;
      throw new Error("Expected merge type 6144, found ".concat(mtype));&#13;
    ws["!merges"] = (_f = parse_shallow(ref.data)) == null ? void 0 : _f[1].map(function(pi) {&#13;
      var merge = parse_shallow(pi.data);&#13;
      var origin = u8_to_dataview(parse_shallow(merge[1][0].data)[1][0].data), size = u8_to_dataview(parse_shallow(merge[2][0].data)[1][0].data);&#13;
      return {&#13;
        s: { r: origin.getUint16(0, true), c: origin.getUint16(2, true) },&#13;
        e: {&#13;
          r: origin.getUint16(0, true) + size.getUint16(0, true) - 1,&#13;
          c: origin.getUint16(2, true) + size.getUint16(2, true) - 1&#13;
        }&#13;
      };&#13;
    });&#13;
  }&#13;
}&#13;
function parse_TST_TableInfoArchive(M, root, opts) {&#13;
  var pb = parse_shallow(root.data);&#13;
  var out;&#13;
  if (!(opts == null ? void 0 : opts.dense))&#13;
    out = { "!ref": "A1" };&#13;
  else&#13;
    out = [];&#13;
  out["!ref"] = "A1";&#13;
  var tableref = M[parse_TSP_Reference(pb[2][0].data)];&#13;
  var mtype = varint_to_i32(tableref[0].meta[1][0].data);&#13;
  if (mtype != 6001)&#13;
    throw new Error("6000 unexpected reference to ".concat(mtype));&#13;
  parse_TST_TableModelArchive(M, tableref[0], out);&#13;
  return out;&#13;
}&#13;
function parse_TN_SheetArchive(M, root, opts) {&#13;
  var _a;&#13;
  var pb = parse_shallow(root.data);&#13;
  var out = {&#13;
    name: ((_a = pb[1]) == null ? void 0 : _a[0]) ? u8str(pb[1][0].data) : "",&#13;
    sheets: []&#13;
  };&#13;
  var shapeoffs = mappa(pb[2], parse_TSP_Reference);&#13;
  shapeoffs.forEach(function(off) {&#13;
    M[off].forEach(function(m) {&#13;
      var mtype = varint_to_i32(m.meta[1][0].data);&#13;
      if (mtype == 6e3)&#13;
        out.sheets.push(parse_TST_TableInfoArchive(M, m, opts));&#13;
    });&#13;
  });&#13;
  return out;&#13;
}&#13;
function parse_TN_DocumentArchive(M, root, opts) {&#13;
  var _a;&#13;
  var out = book_new();&#13;
  var pb = parse_shallow(root.data);&#13;
  if ((_a = pb[2]) == null ? void 0 : _a[0])&#13;
    throw new Error("Keynote presentations are not supported");&#13;
  var sheetoffs = mappa(pb[1], parse_TSP_Reference);&#13;
  sheetoffs.forEach(function(off) {&#13;
    M[off].forEach(function(m) {&#13;
      var mtype = varint_to_i32(m.meta[1][0].data);&#13;
      if (mtype == 2) {&#13;
        var root2 = parse_TN_SheetArchive(M, m, opts);&#13;
        root2.sheets.forEach(function(sheet, idx) {&#13;
          book_append_sheet(out, sheet, idx == 0 ? root2.name : root2.name + "_" + idx, true);&#13;
        });&#13;
      }&#13;
    });&#13;
  });&#13;
  if (out.SheetNames.length == 0)&#13;
    throw new Error("Empty NUMBERS file");&#13;
  out.bookType = "numbers";&#13;
  return out;&#13;
}&#13;
function parse_numbers_iwa(cfb, opts) {&#13;
  var _a, _b, _c, _d, _e, _f, _g;&#13;
  var M = {}, indices = [];&#13;
  cfb.FullPaths.forEach(function(p) {&#13;
    if (p.match(/\.iwpv2/))&#13;
      throw new Error("Unsupported password protection");&#13;
  });&#13;
  cfb.FileIndex.forEach(function(s) {&#13;
    if (!s.name.match(/\.iwa$/))&#13;
      return;&#13;
    if (s.content[0] == 98)&#13;
      return;&#13;
    var o;&#13;
    try {&#13;
      o = decompress_iwa_file(s.content);&#13;
    } catch (e) {&#13;
      return console.log("?? " + s.content.length + " " + (e.message || e));&#13;
    }&#13;
    var packets;&#13;
    try {&#13;
      packets = parse_iwa_file(o);&#13;
    } catch (e) {&#13;
      return console.log("## " + (e.message || e));&#13;
    }&#13;
    packets.forEach(function(packet) {&#13;
      M[packet.id] = packet.messages;&#13;
      indices.push(packet.id);&#13;
    });&#13;
  });&#13;
  if (!indices.length)&#13;
    throw new Error("File has no messages");&#13;
  if (((_c = (_b = (_a = M == null ? void 0 : M[1]) == null ? void 0 : _a[0].meta) == null ? void 0 : _b[1]) == null ? void 0 : _c[0].data) &amp;&amp; varint_to_i32(M[1][0].meta[1][0].data) == 1e4)&#13;
    throw new Error("Pages documents are not supported");&#13;
  var docroot = ((_g = (_f = (_e = (_d = M == null ? void 0 : M[1]) == null ? void 0 : _d[0]) == null ? void 0 : _e.meta) == null ? void 0 : _f[1]) == null ? void 0 : _g[0].data) &amp;&amp; varint_to_i32(M[1][0].meta[1][0].data) == 1 &amp;&amp; M[1][0];&#13;
  if (!docroot)&#13;
    indices.forEach(function(idx) {&#13;
      M[idx].forEach(function(iwam) {&#13;
        var mtype = varint_to_i32(iwam.meta[1][0].data) &gt;&gt;&gt; 0;&#13;
        if (mtype == 1) {&#13;
          if (!docroot)&#13;
            docroot = iwam;&#13;
          else&#13;
            throw new Error("Document has multiple roots");&#13;
        }&#13;
      });&#13;
    });&#13;
  if (!docroot)&#13;
    throw new Error("Cannot find Document root");&#13;
  return parse_TN_DocumentArchive(M, docroot, opts);&#13;
}&#13;
function write_TST_TileRowInfo(data, SST, wide) {&#13;
  var _a, _b;&#13;
  var tri = [&#13;
    [],&#13;
    [{ type: 0, data: write_varint49(0) }],&#13;
    [{ type: 0, data: write_varint49(0) }],&#13;
    [{ type: 2, data: new Uint8Array([]) }],&#13;
    [{ type: 2, data: new Uint8Array(Array.from({ length: 510 }, function() {&#13;
      return 255;&#13;
    })) }],&#13;
    [{ type: 0, data: write_varint49(5) }],&#13;
    [{ type: 2, data: new Uint8Array([]) }],&#13;
    [{ type: 2, data: new Uint8Array(Array.from({ length: 510 }, function() {&#13;
      return 255;&#13;
    })) }],&#13;
    [{ type: 0, data: write_varint49(1) }]&#13;
  ];&#13;
  if (!((_a = tri[6]) == null ? void 0 : _a[0]) || !((_b = tri[7]) == null ? void 0 : _b[0]))&#13;
    throw "Mutation only works on post-BNC storages!";&#13;
  var cnt = 0;&#13;
  if (tri[7][0].data.length &lt; 2 * data.length) {&#13;
    var new_7 = new Uint8Array(2 * data.length);&#13;
    new_7.set(tri[7][0].data);&#13;
    tri[7][0].data = new_7;&#13;
  }&#13;
  if (tri[4][0].data.length &lt; 2 * data.length) {&#13;
    var new_4 = new Uint8Array(2 * data.length);&#13;
    new_4.set(tri[4][0].data);&#13;
    tri[4][0].data = new_4;&#13;
  }&#13;
  var dv = u8_to_dataview(tri[7][0].data), last_offset = 0, cell_storage = [];&#13;
  var _dv = u8_to_dataview(tri[4][0].data), _last_offset = 0, _cell_storage = [];&#13;
  var width = wide ? 4 : 1;&#13;
  for (var C = 0; C &lt; data.length; ++C) {&#13;
    if (data[C] == null) {&#13;
      dv.setUint16(C * 2, 65535, true);&#13;
      _dv.setUint16(C * 2, 65535);&#13;
      continue;&#13;
    }&#13;
    dv.setUint16(C * 2, last_offset / width, true);&#13;
    _dv.setUint16(C * 2, _last_offset / width, true);&#13;
    var celload, _celload;&#13;
    switch (typeof data[C]) {&#13;
      case "string":&#13;
        celload = write_new_storage({ t: "s", v: data[C] }, SST);&#13;
        _celload = write_old_storage({ t: "s", v: data[C] }, SST);&#13;
        break;&#13;
      case "number":&#13;
        celload = write_new_storage({ t: "n", v: data[C] }, SST);&#13;
        _celload = write_old_storage({ t: "n", v: data[C] }, SST);&#13;
        break;&#13;
      case "boolean":&#13;
        celload = write_new_storage({ t: "b", v: data[C] }, SST);&#13;
        _celload = write_old_storage({ t: "b", v: data[C] }, SST);&#13;
        break;&#13;
      default:&#13;
        if (data[C] instanceof Date) {&#13;
          celload = write_new_storage({ t: "s", v: data[C].toISOString() }, SST);&#13;
          _celload = write_old_storage({ t: "s", v: data[C].toISOString() }, SST);&#13;
          break;&#13;
        }&#13;
        throw new Error("Unsupported value " + data[C]);&#13;
    }&#13;
    cell_storage.push(celload);&#13;
    last_offset += celload.length;&#13;
    {&#13;
      _cell_storage.push(_celload);&#13;
      _last_offset += _celload.length;&#13;
    }&#13;
    ++cnt;&#13;
  }&#13;
  tri[2][0].data = write_varint49(cnt);&#13;
  tri[5][0].data = write_varint49(5);&#13;
  for (; C &lt; tri[7][0].data.length / 2; ++C) {&#13;
    dv.setUint16(C * 2, 65535, true);&#13;
    _dv.setUint16(C * 2, 65535, true);&#13;
  }&#13;
  tri[6][0].data = u8concat(cell_storage);&#13;
  tri[3][0].data = u8concat(_cell_storage);&#13;
  tri[8] = [{ type: 0, data: write_varint49(wide ? 1 : 0) }];&#13;
  return tri;&#13;
}&#13;
function write_iwam(type, payload) {&#13;
  return {&#13;
    meta: [&#13;
      [],&#13;
      [{ type: 0, data: write_varint49(type) }]&#13;
    ],&#13;
    data: payload&#13;
  };&#13;
}&#13;
function get_unique_msgid(dep, dependents) {&#13;
  if (!dependents.last)&#13;
    dependents.last = 927262;&#13;
  for (var i = dependents.last; i &lt; 2e6; ++i)&#13;
    if (!dependents[i]) {&#13;
      dependents[dependents.last = i] = dep;&#13;
      return i;&#13;
    }&#13;
  throw new Error("Too many messages");&#13;
}&#13;
function build_numbers_deps(cfb) {&#13;
  var dependents = {};&#13;
  var indices = [];&#13;
  cfb.FileIndex.map(function(fi, idx) {&#13;
    return [fi, cfb.FullPaths[idx]];&#13;
  }).forEach(function(row) {&#13;
    var fi = row[0], fp = row[1];&#13;
    if (fi.type != 2)&#13;
      return;&#13;
    if (!fi.name.match(/\.iwa/))&#13;
      return;&#13;
    if (fi.name.match(/OperationStorage/))&#13;
      return;&#13;
    parse_iwa_file(decompress_iwa_file(fi.content)).forEach(function(packet) {&#13;
      indices.push(packet.id);&#13;
      dependents[packet.id] = { deps: [], location: fp, type: varint_to_i32(packet.messages[0].meta[1][0].data) };&#13;
    });&#13;
  });&#13;
  indices.sort(function(x, y) {&#13;
    return x - y;&#13;
  });&#13;
  var indices_varint = indices.filter(function(x) {&#13;
    return x &gt; 1;&#13;
  }).map(function(x) {&#13;
    return [x, write_varint49(x)];&#13;
  });&#13;
  cfb.FileIndex.forEach(function(fi) {&#13;
    if (!fi.name.match(/\.iwa/))&#13;
      return;&#13;
    if (fi.name.match(/OperationStorage/))&#13;
      return;&#13;
    parse_iwa_file(decompress_iwa_file(fi.content)).forEach(function(ia) {&#13;
      indices_varint.forEach(function(ivi) {&#13;
        if (ia.messages.some(function(mess) {&#13;
          return varint_to_i32(mess.meta[1][0].data) != 11006 &amp;&amp; u8contains(mess.data, ivi[1]);&#13;
        })) {&#13;
          dependents[ivi[0]].deps.push(ia.id);&#13;
        }&#13;
      });&#13;
    });&#13;
  });&#13;
  return dependents;&#13;
}&#13;
function write_numbers_iwa(wb, opts) {&#13;
  if (!opts || !opts.numbers)&#13;
    throw new Error("Must pass a `numbers` option -- check the README");&#13;
  var cfb = CFB.read(opts.numbers, { type: "base64" });&#13;
  var deps = build_numbers_deps(cfb);&#13;
  var docroot = numbers_iwa_find(cfb, deps, 1);&#13;
  if (docroot == null)&#13;
    throw "Could not find message ".concat(1, " in Numbers template");&#13;
  var sheetrefs = mappa(parse_shallow(docroot.messages[0].data)[1], parse_TSP_Reference);&#13;
  if (sheetrefs.length &gt; 1)&#13;
    throw new Error("Template NUMBERS file must have exactly one sheet");&#13;
  wb.SheetNames.forEach(function(name, idx) {&#13;
    if (idx &gt;= 1) {&#13;
      numbers_add_ws(cfb, deps, idx + 1);&#13;
      docroot = numbers_iwa_find(cfb, deps, 1);&#13;
      sheetrefs = mappa(parse_shallow(docroot.messages[0].data)[1], parse_TSP_Reference);&#13;
    }&#13;
    write_numbers_ws(cfb, deps, wb.Sheets[name], name, idx, sheetrefs[idx]);&#13;
  });&#13;
  return cfb;&#13;
}&#13;
function numbers_iwa_doit(cfb, deps, id, cb) {&#13;
  var entry = CFB.find(cfb, deps[id].location);&#13;
  if (!entry)&#13;
    throw "Could not find ".concat(deps[id].location, " in Numbers template");&#13;
  var x = parse_iwa_file(decompress_iwa_file(entry.content));&#13;
  var ainfo = x.find(function(packet) {&#13;
    return packet.id == id;&#13;
  });&#13;
  cb(ainfo, x);&#13;
  entry.content = compress_iwa_file(write_iwa_file(x));&#13;
  entry.size = entry.content.length;&#13;
}&#13;
function numbers_iwa_find(cfb, deps, id) {&#13;
  var entry = CFB.find(cfb, deps[id].location);&#13;
  if (!entry)&#13;
    throw "Could not find ".concat(deps[id].location, " in Numbers template");&#13;
  var x = parse_iwa_file(decompress_iwa_file(entry.content));&#13;
  var ainfo = x.find(function(packet) {&#13;
    return packet.id == id;&#13;
  });&#13;
  return ainfo;&#13;
}&#13;
function numbers_add_ws(cfb, deps, wsidx) {&#13;
  var sheetref = -1, newsheetref = -1;&#13;
  var remap = {};&#13;
  numbers_iwa_doit(cfb, deps, 1, function(docroot, arch) {&#13;
    var doc = parse_shallow(docroot.messages[0].data);&#13;
    sheetref = parse_TSP_Reference(parse_shallow(docroot.messages[0].data)[1][0].data);&#13;
    newsheetref = get_unique_msgid({ deps: [1], location: deps[sheetref].location, type: 2 }, deps);&#13;
    remap[sheetref] = newsheetref;&#13;
    numbers_add_oref(docroot, newsheetref);&#13;
    doc[1].push({ type: 2, data: write_TSP_Reference(newsheetref) });&#13;
    var sheet = numbers_iwa_find(cfb, deps, sheetref);&#13;
    sheet.id = newsheetref;&#13;
    if (deps[1].location == deps[newsheetref].location)&#13;
      arch.push(sheet);&#13;
    else&#13;
      numbers_iwa_doit(cfb, deps, newsheetref, function(_, x) {&#13;
        return x.push(sheet);&#13;
      });&#13;
    docroot.messages[0].data = write_shallow(doc);&#13;
  });&#13;
  var tiaref = -1;&#13;
  numbers_iwa_doit(cfb, deps, newsheetref, function(sheetroot, arch) {&#13;
    var sa = parse_shallow(sheetroot.messages[0].data);&#13;
    for (var i = 3; i &lt;= 69; ++i)&#13;
      delete sa[i];&#13;
    var drawables = mappa(sa[2], parse_TSP_Reference);&#13;
    drawables.forEach(function(n) {&#13;
      return numbers_del_oref(sheetroot, n);&#13;
    });&#13;
    tiaref = get_unique_msgid({ deps: [newsheetref], location: deps[drawables[0]].location, type: deps[drawables[0]].type }, deps);&#13;
    numbers_add_oref(sheetroot, tiaref);&#13;
    remap[drawables[0]] = tiaref;&#13;
    sa[2] = [{ type: 2, data: write_TSP_Reference(tiaref) }];&#13;
    var tia = numbers_iwa_find(cfb, deps, drawables[0]);&#13;
    tia.id = tiaref;&#13;
    if (deps[drawables[0]].location == deps[newsheetref].location)&#13;
      arch.push(tia);&#13;
    else {&#13;
      var loc2 = deps[newsheetref].location;&#13;
      loc2 = loc2.replace(/^Root Entry\//, "");&#13;
      loc2 = loc2.replace(/^Index\//, "").replace(/\.iwa$/, "");&#13;
      numbers_iwa_doit(cfb, deps, 2, function(ai) {&#13;
        var mlist = parse_shallow(ai.messages[0].data);&#13;
        var parentidx = mlist[3].findIndex(function(m) {&#13;
          var _a, _b;&#13;
          var mm = parse_shallow(m.data);&#13;
          if ((_a = mm[3]) == null ? void 0 : _a[0])&#13;
            return u8str(mm[3][0].data) == loc2;&#13;
          if (((_b = mm[2]) == null ? void 0 : _b[0]) &amp;&amp; u8str(mm[2][0].data) == loc2)&#13;
            return true;&#13;
          return false;&#13;
        });&#13;
        var parent = parse_shallow(mlist[3][parentidx].data);&#13;
        if (!parent[6])&#13;
          parent[6] = [];&#13;
        parent[6].push({&#13;
          type: 2,&#13;
          data: write_shallow([&#13;
            [],&#13;
            [{ type: 0, data: write_varint49(tiaref) }]&#13;
          ])&#13;
        });&#13;
        mlist[3][parentidx].data = write_shallow(parent);&#13;
        ai.messages[0].data = write_shallow(mlist);&#13;
      });&#13;
      numbers_iwa_doit(cfb, deps, tiaref, function(_, x) {&#13;
        return x.push(tia);&#13;
      });&#13;
    }&#13;
    sheetroot.messages[0].data = write_shallow(sa);&#13;
  });&#13;
  var tmaref = -1;&#13;
  numbers_iwa_doit(cfb, deps, tiaref, function(tiaroot, arch) {&#13;
    var tia = parse_shallow(tiaroot.messages[0].data);&#13;
    var da = parse_shallow(tia[1][0].data);&#13;
    for (var i = 3; i &lt;= 69; ++i)&#13;
      delete da[i];&#13;
    var dap = parse_TSP_Reference(da[2][0].data);&#13;
    da[2][0].data = write_TSP_Reference(remap[dap]);&#13;
    tia[1][0].data = write_shallow(da);&#13;
    var oldtmaref = parse_TSP_Reference(tia[2][0].data);&#13;
    numbers_del_oref(tiaroot, oldtmaref);&#13;
    tmaref = get_unique_msgid({ deps: [tiaref], location: deps[oldtmaref].location, type: deps[oldtmaref].type }, deps);&#13;
    numbers_add_oref(tiaroot, tmaref);&#13;
    remap[oldtmaref] = tmaref;&#13;
    tia[2][0].data = write_TSP_Reference(tmaref);&#13;
    var tma = numbers_iwa_find(cfb, deps, oldtmaref);&#13;
    tma.id = tmaref;&#13;
    if (deps[tiaref].location == deps[tmaref].location)&#13;
      arch.push(tma);&#13;
    else&#13;
      numbers_iwa_doit(cfb, deps, tmaref, function(_, x) {&#13;
        return x.push(tma);&#13;
      });&#13;
    tiaroot.messages[0].data = write_shallow(tia);&#13;
  });&#13;
  var loc = deps[tmaref].location;&#13;
  loc = loc.replace(/^Root Entry\//, "");&#13;
  loc = loc.replace(/^Index\//, "").replace(/\.iwa$/, "");&#13;
  numbers_iwa_doit(cfb, deps, tmaref, function(tmaroot, arch) {&#13;
    var _a, _b;&#13;
    var tma = parse_shallow(tmaroot.messages[0].data);&#13;
    var uuid = u8str(tma[1][0].data), new_uuid = uuid.replace(/-[A-Z0-9]*/, "-".concat(wsidx.toString(16).padStart(4, "0")));&#13;
    tma[1][0].data = stru8(new_uuid);&#13;
    [12, 13, 29, 31, 32, 33, 39, 44, 47, 81, 82, 84].forEach(function(n) {&#13;
      return delete tma[n];&#13;
    });&#13;
    if (tma[45]) {&#13;
      var srrta = parse_shallow(tma[45][0].data);&#13;
      var ref = parse_TSP_Reference(srrta[1][0].data);&#13;
      numbers_del_oref(tmaroot, ref);&#13;
      delete tma[45];&#13;
    }&#13;
    if (tma[70]) {&#13;
      var hsoa = parse_shallow(tma[70][0].data);&#13;
      (_a = hsoa[2]) == null ? void 0 : _a.forEach(function(item) {&#13;
        var hsa = parse_shallow(item.data);&#13;
        [2, 3].map(function(n) {&#13;
          return hsa[n][0];&#13;
        }).forEach(function(hseadata) {&#13;
          var hsea = parse_shallow(hseadata.data);&#13;
          if (!hsea[8])&#13;
            return;&#13;
          var ref2 = parse_TSP_Reference(hsea[8][0].data);&#13;
          numbers_del_oref(tmaroot, ref2);&#13;
        });&#13;
      });&#13;
      delete tma[70];&#13;
    }&#13;
    [&#13;
      46,&#13;
      30,&#13;
      34,&#13;
      35,&#13;
      36,&#13;
      38,&#13;
      48,&#13;
      49,&#13;
      60,&#13;
      61,&#13;
      62,&#13;
      63,&#13;
      64,&#13;
      71,&#13;
      72,&#13;
      73,&#13;
      74,&#13;
      75,&#13;
      85,&#13;
      86,&#13;
      87,&#13;
      88,&#13;
      89&#13;
    ].forEach(function(n) {&#13;
      if (!tma[n])&#13;
        return;&#13;
      var ref2 = parse_TSP_Reference(tma[n][0].data);&#13;
      delete tma[n];&#13;
      numbers_del_oref(tmaroot, ref2);&#13;
    });&#13;
    var store = parse_shallow(tma[4][0].data);&#13;
    {&#13;
      [2, 4, 5, 6, 11, 12, 13, 15, 16, 17, 18, 19, 20, 21, 22].forEach(function(n) {&#13;
        var _a2;&#13;
        if (!((_a2 = store[n]) == null ? void 0 : _a2[0]))&#13;
          return;&#13;
        var oldref = parse_TSP_Reference(store[n][0].data);&#13;
        var newref = get_unique_msgid({ deps: [tmaref], location: deps[oldref].location, type: deps[oldref].type }, deps);&#13;
        numbers_del_oref(tmaroot, oldref);&#13;
        numbers_add_oref(tmaroot, newref);&#13;
        remap[oldref] = newref;&#13;
        var msg = numbers_iwa_find(cfb, deps, oldref);&#13;
        msg.id = newref;&#13;
        if (deps[oldref].location == deps[tmaref].location)&#13;
          arch.push(msg);&#13;
        else {&#13;
          deps[newref].location = deps[oldref].location.replace(oldref.toString(), newref.toString());&#13;
          if (deps[newref].location == deps[oldref].location)&#13;
            deps[newref].location = deps[newref].location.replace(/\.iwa/, "-".concat(newref, ".iwa"));&#13;
          CFB.utils.cfb_add(cfb, deps[newref].location, compress_iwa_file(write_iwa_file([msg])));&#13;
          var newloc = deps[newref].location;&#13;
          newloc = newloc.replace(/^Root Entry\//, "");&#13;
          newloc = newloc.replace(/^Index\//, "").replace(/\.iwa$/, "");&#13;
          numbers_iwa_doit(cfb, deps, 2, function(ai) {&#13;
            var mlist = parse_shallow(ai.messages[0].data);&#13;
            mlist[3].push({ type: 2, data: write_shallow([&#13;
              [],&#13;
              [{ type: 0, data: write_varint49(newref) }],&#13;
              [{ type: 2, data: stru8(newloc.replace(/-.*$/, "")) }],&#13;
              [{ type: 2, data: stru8(newloc) }],&#13;
              [{ type: 2, data: new Uint8Array([2, 0, 0]) }],&#13;
              [{ type: 2, data: new Uint8Array([2, 0, 0]) }],&#13;
              [],&#13;
              [],&#13;
              [],&#13;
              [],&#13;
              [{ type: 0, data: write_varint49(0) }],&#13;
              [],&#13;
              [{ type: 0, data: write_varint49(0) }]&#13;
            ]) });&#13;
            mlist[1] = [{ type: 0, data: write_varint49(Math.max(newref + 1, parse_varint49(mlist[1][0].data))) }];&#13;
            var parentidx = mlist[3].findIndex(function(m) {&#13;
              var _a3, _b2;&#13;
              var mm = parse_shallow(m.data);&#13;
              if ((_a3 = mm[3]) == null ? void 0 : _a3[0])&#13;
                return u8str(mm[3][0].data) == loc;&#13;
              if (((_b2 = mm[2]) == null ? void 0 : _b2[0]) &amp;&amp; u8str(mm[2][0].data) == loc)&#13;
                return true;&#13;
              return false;&#13;
            });&#13;
            var parent = parse_shallow(mlist[3][parentidx].data);&#13;
            if (!parent[6])&#13;
              parent[6] = [];&#13;
            parent[6].push({&#13;
              type: 2,&#13;
              data: write_shallow([&#13;
                [],&#13;
                [{ type: 0, data: write_varint49(newref) }]&#13;
              ])&#13;
            });&#13;
            mlist[3][parentidx].data = write_shallow(parent);&#13;
            ai.messages[0].data = write_shallow(mlist);&#13;
          });&#13;
        }&#13;
        store[n][0].data = write_TSP_Reference(newref);&#13;
      });&#13;
      var row_headers = parse_shallow(store[1][0].data);&#13;
      {&#13;
        (_b = row_headers[2]) == null ? void 0 : _b.forEach(function(tspref) {&#13;
          var oldref = parse_TSP_Reference(tspref.data);&#13;
          var newref = get_unique_msgid({ deps: [tmaref], location: deps[oldref].location, type: deps[oldref].type }, deps);&#13;
          numbers_del_oref(tmaroot, oldref);&#13;
          numbers_add_oref(tmaroot, newref);&#13;
          remap[oldref] = newref;&#13;
          var msg = numbers_iwa_find(cfb, deps, oldref);&#13;
          msg.id = newref;&#13;
          if (deps[oldref].location == deps[tmaref].location) {&#13;
            arch.push(msg);&#13;
          } else {&#13;
            deps[newref].location = deps[oldref].location.replace(oldref.toString(), newref.toString());&#13;
            if (deps[newref].location == deps[oldref].location)&#13;
              deps[newref].location = deps[newref].location.replace(/\.iwa/, "-".concat(newref, ".iwa"));&#13;
            CFB.utils.cfb_add(cfb, deps[newref].location, compress_iwa_file(write_iwa_file([msg])));&#13;
            var newloc = deps[newref].location;&#13;
            newloc = newloc.replace(/^Root Entry\//, "");&#13;
            newloc = newloc.replace(/^Index\//, "").replace(/\.iwa$/, "");&#13;
            numbers_iwa_doit(cfb, deps, 2, function(ai) {&#13;
              var mlist = parse_shallow(ai.messages[0].data);&#13;
              mlist[3].push({ type: 2, data: write_shallow([&#13;
                [],&#13;
                [{ type: 0, data: write_varint49(newref) }],&#13;
                [{ type: 2, data: stru8(newloc.replace(/-.*$/, "")) }],&#13;
                [{ type: 2, data: stru8(newloc) }],&#13;
                [{ type: 2, data: new Uint8Array([2, 0, 0]) }],&#13;
                [{ type: 2, data: new Uint8Array([2, 0, 0]) }],&#13;
                [],&#13;
                [],&#13;
                [],&#13;
                [],&#13;
                [{ type: 0, data: write_varint49(0) }],&#13;
                [],&#13;
                [{ type: 0, data: write_varint49(0) }]&#13;
              ]) });&#13;
              mlist[1] = [{ type: 0, data: write_varint49(Math.max(newref + 1, parse_varint49(mlist[1][0].data))) }];&#13;
              var parentidx = mlist[3].findIndex(function(m) {&#13;
                var _a2, _b2;&#13;
                var mm = parse_shallow(m.data);&#13;
                if ((_a2 = mm[3]) == null ? void 0 : _a2[0])&#13;
                  return u8str(mm[3][0].data) == loc;&#13;
                if (((_b2 = mm[2]) == null ? void 0 : _b2[0]) &amp;&amp; u8str(mm[2][0].data) == loc)&#13;
                  return true;&#13;
                return false;&#13;
              });&#13;
              var parent = parse_shallow(mlist[3][parentidx].data);&#13;
              if (!parent[6])&#13;
                parent[6] = [];&#13;
              parent[6].push({&#13;
                type: 2,&#13;
                data: write_shallow([&#13;
                  [],&#13;
                  [{ type: 0, data: write_varint49(newref) }]&#13;
                ])&#13;
              });&#13;
              mlist[3][parentidx].data = write_shallow(parent);&#13;
              ai.messages[0].data = write_shallow(mlist);&#13;
            });&#13;
          }&#13;
          tspref.data = write_TSP_Reference(newref);&#13;
        });&#13;
      }&#13;
      store[1][0].data = write_shallow(row_headers);&#13;
      var tiles = parse_shallow(store[3][0].data);&#13;
      {&#13;
        tiles[1].forEach(function(t) {&#13;
          var tst = parse_shallow(t.data);&#13;
          var oldtileref = parse_TSP_Reference(tst[2][0].data);&#13;
          var newtileref = remap[oldtileref];&#13;
          if (!remap[oldtileref]) {&#13;
            newtileref = get_unique_msgid({ deps: [tmaref], location: "", type: deps[oldtileref].type }, deps);&#13;
            deps[newtileref].location = "Root Entry/Index/Tables/Tile-".concat(newtileref, ".iwa");&#13;
            remap[oldtileref] = newtileref;&#13;
            var oldtile = numbers_iwa_find(cfb, deps, oldtileref);&#13;
            oldtile.id = newtileref;&#13;
            numbers_del_oref(tmaroot, oldtileref);&#13;
            numbers_add_oref(tmaroot, newtileref);&#13;
            CFB.utils.cfb_add(cfb, "/Index/Tables/Tile-".concat(newtileref, ".iwa"), compress_iwa_file(write_iwa_file([oldtile])));&#13;
            numbers_iwa_doit(cfb, deps, 2, function(ai) {&#13;
              var mlist = parse_shallow(ai.messages[0].data);&#13;
              mlist[3].push({ type: 2, data: write_shallow([&#13;
                [],&#13;
                [{ type: 0, data: write_varint49(newtileref) }],&#13;
                [{ type: 2, data: stru8("Tables/Tile") }],&#13;
                [{ type: 2, data: stru8("Tables/Tile-".concat(newtileref)) }],&#13;
                [{ type: 2, data: new Uint8Array([2, 0, 0]) }],&#13;
                [{ type: 2, data: new Uint8Array([2, 0, 0]) }],&#13;
                [],&#13;
                [],&#13;
                [],&#13;
                [],&#13;
                [{ type: 0, data: write_varint49(0) }],&#13;
                [],&#13;
                [{ type: 0, data: write_varint49(0) }]&#13;
              ]) });&#13;
              mlist[1] = [{ type: 0, data: write_varint49(Math.max(newtileref + 1, parse_varint49(mlist[1][0].data))) }];&#13;
              var parentidx = mlist[3].findIndex(function(m) {&#13;
                var _a2, _b2;&#13;
                var mm = parse_shallow(m.data);&#13;
                if ((_a2 = mm[3]) == null ? void 0 : _a2[0])&#13;
                  return u8str(mm[3][0].data) == loc;&#13;
                if (((_b2 = mm[2]) == null ? void 0 : _b2[0]) &amp;&amp; u8str(mm[2][0].data) == loc)&#13;
                  return true;&#13;
                return false;&#13;
              });&#13;
              var parent = parse_shallow(mlist[3][parentidx].data);&#13;
              if (!parent[6])&#13;
                parent[6] = [];&#13;
              parent[6].push({&#13;
                type: 2,&#13;
                data: write_shallow([&#13;
                  [],&#13;
                  [{ type: 0, data: write_varint49(newtileref) }]&#13;
                ])&#13;
              });&#13;
              mlist[3][parentidx].data = write_shallow(parent);&#13;
              ai.messages[0].data = write_shallow(mlist);&#13;
            });&#13;
          }&#13;
          tst[2][0].data = write_TSP_Reference(newtileref);&#13;
          t.data = write_shallow(tst);&#13;
        });&#13;
      }&#13;
      store[3][0].data = write_shallow(tiles);&#13;
    }&#13;
    tma[4][0].data = write_shallow(store);&#13;
    tmaroot.messages[0].data = write_shallow(tma);&#13;
  });&#13;
}&#13;
function write_numbers_ws(cfb, deps, ws, wsname, sheetidx, rootref) {&#13;
  var drawables = [];&#13;
  numbers_iwa_doit(cfb, deps, rootref, function(docroot) {&#13;
    var sheetref = parse_shallow(docroot.messages[0].data);&#13;
    {&#13;
      sheetref[1] = [{ type: 2, data: stru8(wsname) }];&#13;
      drawables = mappa(sheetref[2], parse_TSP_Reference);&#13;
    }&#13;
    docroot.messages[0].data = write_shallow(sheetref);&#13;
  });&#13;
  var tia = numbers_iwa_find(cfb, deps, drawables[0]);&#13;
  var tmaref = parse_TSP_Reference(parse_shallow(tia.messages[0].data)[2][0].data);&#13;
  numbers_iwa_doit(cfb, deps, tmaref, function(docroot, x) {&#13;
    return write_numbers_tma(cfb, deps, ws, docroot, x, tmaref);&#13;
  });&#13;
}&#13;
var USE_WIDE_ROWS = true;&#13;
function write_numbers_tma(cfb, deps, ws, tmaroot, tmafile, tmaref) {&#13;
  var range = decode_range(ws["!ref"]);&#13;
  range.s.r = range.s.c = 0;&#13;
  var trunc = false;&#13;
  if (range.e.c &gt; 999) {&#13;
    trunc = true;&#13;
    range.e.c = 999;&#13;
  }&#13;
  if (range.e.r &gt; 999999) {&#13;
    trunc = true;&#13;
    range.e.r = 999999;&#13;
  }&#13;
  if (trunc)&#13;
    console.error("Truncating to ".concat(encode_range(range)));&#13;
  var data = sheet_to_json(ws, { range: range, header: 1 });&#13;
  var SST = ["~Sh33tJ5~"];&#13;
  var loc = deps[tmaref].location;&#13;
  loc = loc.replace(/^Root Entry\//, "");&#13;
  loc = loc.replace(/^Index\//, "").replace(/\.iwa$/, "");&#13;
  var pb = parse_shallow(tmaroot.messages[0].data);&#13;
  {&#13;
    pb[6][0].data = write_varint49(range.e.r + 1);&#13;
    pb[7][0].data = write_varint49(range.e.c + 1);&#13;
    delete pb[46];&#13;
    var store = parse_shallow(pb[4][0].data);&#13;
    {&#13;
      var row_header_ref = parse_TSP_Reference(parse_shallow(store[1][0].data)[2][0].data);&#13;
      numbers_iwa_doit(cfb, deps, row_header_ref, function(rowhead, _x) {&#13;
        var _a;&#13;
        var base_bucket = parse_shallow(rowhead.messages[0].data);&#13;
        if ((_a = base_bucket == null ? void 0 : base_bucket[2]) == null ? void 0 : _a[0])&#13;
          for (var R2 = 0; R2 &lt; data.length; ++R2) {&#13;
            var _bucket = parse_shallow(base_bucket[2][0].data);&#13;
            _bucket[1][0].data = write_varint49(R2);&#13;
            _bucket[4][0].data = write_varint49(data[R2].length);&#13;
            base_bucket[2][R2] = { type: base_bucket[2][0].type, data: write_shallow(_bucket) };&#13;
          }&#13;
        rowhead.messages[0].data = write_shallow(base_bucket);&#13;
      });&#13;
      var col_header_ref = parse_TSP_Reference(store[2][0].data);&#13;
      numbers_iwa_doit(cfb, deps, col_header_ref, function(colhead, _x) {&#13;
        var base_bucket = parse_shallow(colhead.messages[0].data);&#13;
        for (var C = 0; C &lt;= range.e.c; ++C) {&#13;
          var _bucket = parse_shallow(base_bucket[2][0].data);&#13;
          _bucket[1][0].data = write_varint49(C);&#13;
          _bucket[4][0].data = write_varint49(range.e.r + 1);&#13;
          base_bucket[2][C] = { type: base_bucket[2][0].type, data: write_shallow(_bucket) };&#13;
        }&#13;
        colhead.messages[0].data = write_shallow(base_bucket);&#13;
      });&#13;
      var rbtree = parse_shallow(store[9][0].data);&#13;
      rbtree[1] = [];&#13;
      var tilestore = parse_shallow(store[3][0].data);&#13;
      {&#13;
        var tstride = 256;&#13;
        tilestore[2] = [{ type: 0, data: write_varint49(tstride) }];&#13;
        var tileref = parse_TSP_Reference(parse_shallow(tilestore[1][0].data)[2][0].data);&#13;
        var save_token = function() {&#13;
          var metadata = numbers_iwa_find(cfb, deps, 2);&#13;
          var mlist = parse_shallow(metadata.messages[0].data);&#13;
          var mlst = mlist[3].filter(function(m) {&#13;
            return parse_varint49(parse_shallow(m.data)[1][0].data) == tileref;&#13;
          });&#13;
          return (mlst == null ? void 0 : mlst.length) ? parse_varint49(parse_shallow(mlst[0].data)[12][0].data) : 0;&#13;
        }();&#13;
        {&#13;
          CFB.utils.cfb_del(cfb, deps[tileref].location);&#13;
          numbers_iwa_doit(cfb, deps, 2, function(ai) {&#13;
            var mlist = parse_shallow(ai.messages[0].data);&#13;
            mlist[3] = mlist[3].filter(function(m) {&#13;
              return parse_varint49(parse_shallow(m.data)[1][0].data) != tileref;&#13;
            });&#13;
            var parentidx = mlist[3].findIndex(function(m) {&#13;
              var _a, _b;&#13;
              var mm = parse_shallow(m.data);&#13;
              if ((_a = mm[3]) == null ? void 0 : _a[0])&#13;
                return u8str(mm[3][0].data) == loc;&#13;
              if (((_b = mm[2]) == null ? void 0 : _b[0]) &amp;&amp; u8str(mm[2][0].data) == loc)&#13;
                return true;&#13;
              return false;&#13;
            });&#13;
            var parent = parse_shallow(mlist[3][parentidx].data);&#13;
            if (!parent[6])&#13;
              parent[6] = [];&#13;
            parent[6] = parent[6].filter(function(m) {&#13;
              return parse_varint49(parse_shallow(m.data)[1][0].data) != tileref;&#13;
            });&#13;
            mlist[3][parentidx].data = write_shallow(parent);&#13;
            ai.messages[0].data = write_shallow(mlist);&#13;
          });&#13;
          numbers_del_oref(tmaroot, tileref);&#13;
        }&#13;
        tilestore[1] = [];&#13;
        var ntiles = Math.ceil((range.e.r + 1) / tstride);&#13;
        for (var tidx = 0; tidx &lt; ntiles; ++tidx) {&#13;
          var newtileid = get_unique_msgid({&#13;
            deps: [],&#13;
            location: "",&#13;
            type: 6002&#13;
          }, deps);&#13;
          deps[newtileid].location = "Root Entry/Index/Tables/Tile-".concat(newtileid, ".iwa");&#13;
          var tiledata = [&#13;
            [],&#13;
            [{ type: 0, data: write_varint49(0) }],&#13;
            [{ type: 0, data: write_varint49(Math.min(range.e.r + 1, (tidx + 1) * tstride)) }],&#13;
            [{ type: 0, data: write_varint49(0) }],&#13;
            [{ type: 0, data: write_varint49(Math.min((tidx + 1) * tstride, range.e.r + 1) - tidx * tstride) }],&#13;
            [],&#13;
            [{ type: 0, data: write_varint49(5) }],&#13;
            [{ type: 0, data: write_varint49(1) }],&#13;
            [{ type: 0, data: write_varint49(USE_WIDE_ROWS ? 1 : 0) }]&#13;
          ];&#13;
          for (var R = tidx * tstride; R &lt;= Math.min(range.e.r, (tidx + 1) * tstride - 1); ++R) {&#13;
            var tilerow = write_TST_TileRowInfo(data[R], SST, USE_WIDE_ROWS);&#13;
            tilerow[1][0].data = write_varint49(R - tidx * tstride);&#13;
            tiledata[5].push({ data: write_shallow(tilerow), type: 2 });&#13;
          }&#13;
          tilestore[1].push({ type: 2, data: write_shallow([&#13;
            [],&#13;
            [{ type: 0, data: write_varint49(tidx) }],&#13;
            [{ type: 2, data: write_TSP_Reference(newtileid) }]&#13;
          ]) });&#13;
          var newtile = {&#13;
            id: newtileid,&#13;
            messages: [write_iwam(6002, write_shallow(tiledata))]&#13;
          };&#13;
          var tilecontent = compress_iwa_file(write_iwa_file([newtile]));&#13;
          CFB.utils.cfb_add(cfb, "/Index/Tables/Tile-".concat(newtileid, ".iwa"), tilecontent);&#13;
          numbers_iwa_doit(cfb, deps, 2, function(ai) {&#13;
            var mlist = parse_shallow(ai.messages[0].data);&#13;
            mlist[3].push({ type: 2, data: write_shallow([&#13;
              [],&#13;
              [{ type: 0, data: write_varint49(newtileid) }],&#13;
              [{ type: 2, data: stru8("Tables/Tile") }],&#13;
              [{ type: 2, data: stru8("Tables/Tile-".concat(newtileid)) }],&#13;
              [{ type: 2, data: new Uint8Array([2, 0, 0]) }],&#13;
              [{ type: 2, data: new Uint8Array([2, 0, 0]) }],&#13;
              [],&#13;
              [],&#13;
              [],&#13;
              [],&#13;
              [{ type: 0, data: write_varint49(0) }],&#13;
              [],&#13;
              [{ type: 0, data: write_varint49(save_token) }]&#13;
            ]) });&#13;
            mlist[1] = [{ type: 0, data: write_varint49(Math.max(newtileid + 1, parse_varint49(mlist[1][0].data))) }];&#13;
            var parentidx = mlist[3].findIndex(function(m) {&#13;
              var _a, _b;&#13;
              var mm = parse_shallow(m.data);&#13;
              if ((_a = mm[3]) == null ? void 0 : _a[0])&#13;
                return u8str(mm[3][0].data) == loc;&#13;
              if (((_b = mm[2]) == null ? void 0 : _b[0]) &amp;&amp; u8str(mm[2][0].data) == loc)&#13;
                return true;&#13;
              return false;&#13;
            });&#13;
            var parent = parse_shallow(mlist[3][parentidx].data);&#13;
            if (!parent[6])&#13;
              parent[6] = [];&#13;
            parent[6].push({&#13;
              type: 2,&#13;
              data: write_shallow([&#13;
                [],&#13;
                [{ type: 0, data: write_varint49(newtileid) }]&#13;
              ])&#13;
            });&#13;
            mlist[3][parentidx].data = write_shallow(parent);&#13;
            ai.messages[0].data = write_shallow(mlist);&#13;
          });&#13;
          numbers_add_oref(tmaroot, newtileid);&#13;
          rbtree[1].push({ type: 2, data: write_shallow([&#13;
            [],&#13;
            [{ type: 0, data: write_varint49(tidx * tstride) }],&#13;
            [{ type: 0, data: write_varint49(tidx) }]&#13;
          ]) });&#13;
        }&#13;
      }&#13;
      store[3][0].data = write_shallow(tilestore);&#13;
      store[9][0].data = write_shallow(rbtree);&#13;
      store[10] = [{ type: 2, data: new Uint8Array([]) }];&#13;
      if (ws["!merges"]) {&#13;
        var mergeid = get_unique_msgid({&#13;
          type: 6144,&#13;
          deps: [tmaref],&#13;
          location: deps[tmaref].location&#13;
        }, deps);&#13;
        tmafile.push({&#13;
          id: mergeid,&#13;
          messages: [write_iwam(6144, write_shallow([&#13;
            [],&#13;
            ws["!merges"].map(function(m) {&#13;
              return { type: 2, data: write_shallow([&#13;
                [],&#13;
                [{ type: 2, data: write_shallow([&#13;
                  [],&#13;
                  [{ type: 5, data: new Uint8Array(new Uint16Array([m.s.r, m.s.c]).buffer) }]&#13;
                ]) }],&#13;
                [{ type: 2, data: write_shallow([&#13;
                  [],&#13;
                  [{ type: 5, data: new Uint8Array(new Uint16Array([m.e.r - m.s.r + 1, m.e.c - m.s.c + 1]).buffer) }]&#13;
                ]) }]&#13;
              ]) };&#13;
            })&#13;
          ]))]&#13;
        });&#13;
        store[13] = [{ type: 2, data: write_TSP_Reference(mergeid) }];&#13;
        numbers_iwa_doit(cfb, deps, 2, function(ai) {&#13;
          var mlist = parse_shallow(ai.messages[0].data);&#13;
          var parentidx = mlist[3].findIndex(function(m) {&#13;
            var _a, _b;&#13;
            var mm = parse_shallow(m.data);&#13;
            if ((_a = mm[3]) == null ? void 0 : _a[0])&#13;
              return u8str(mm[3][0].data) == loc;&#13;
            if (((_b = mm[2]) == null ? void 0 : _b[0]) &amp;&amp; u8str(mm[2][0].data) == loc)&#13;
              return true;&#13;
            return false;&#13;
          });&#13;
          var parent = parse_shallow(mlist[3][parentidx].data);&#13;
          if (!parent[6])&#13;
            parent[6] = [];&#13;
          parent[6].push({&#13;
            type: 2,&#13;
            data: write_shallow([&#13;
              [],&#13;
              [{ type: 0, data: write_varint49(mergeid) }]&#13;
            ])&#13;
          });&#13;
          mlist[3][parentidx].data = write_shallow(parent);&#13;
          ai.messages[0].data = write_shallow(mlist);&#13;
        });&#13;
        numbers_add_oref(tmaroot, mergeid);&#13;
      } else&#13;
        delete store[13];&#13;
      var sstref = parse_TSP_Reference(store[4][0].data);&#13;
      numbers_iwa_doit(cfb, deps, sstref, function(sstroot) {&#13;
        var sstdata = parse_shallow(sstroot.messages[0].data);&#13;
        {&#13;
          sstdata[3] = [];&#13;
          SST.forEach(function(str, i) {&#13;
            if (i == 0)&#13;
              return;&#13;
            sstdata[3].push({ type: 2, data: write_shallow([&#13;
              [],&#13;
              [{ type: 0, data: write_varint49(i) }],&#13;
              [{ type: 0, data: write_varint49(1) }],&#13;
              [{ type: 2, data: stru8(str) }]&#13;
            ]) });&#13;
          });&#13;
        }&#13;
        sstroot.messages[0].data = write_shallow(sstdata);&#13;
      });&#13;
    }&#13;
    pb[4][0].data = write_shallow(store);&#13;
  }&#13;
  tmaroot.messages[0].data = write_shallow(pb);&#13;
}&#13;
function fix_opts_func(defaults) {&#13;
	return function fix_opts(opts) {&#13;
		for(var i = 0; i != defaults.length; ++i) {&#13;
			var d = defaults[i];&#13;
			if(opts[d[0]] === undefined) opts[d[0]] = d[1];&#13;
			if(d[2] === 'n') opts[d[0]] = Number(opts[d[0]]);&#13;
		}&#13;
	};&#13;
}&#13;
&#13;
function fix_read_opts(opts) {&#13;
fix_opts_func([&#13;
	['cellNF', false], /* emit cell number format string as .z */&#13;
	['cellHTML', true], /* emit html string as .h */&#13;
	['cellFormula', true], /* emit formulae as .f */&#13;
	['cellStyles', false], /* emits style/theme as .s */&#13;
	['cellText', true], /* emit formatted text as .w */&#13;
	['cellDates', false], /* emit date cells with type `d` */&#13;
&#13;
	['sheetStubs', false], /* emit empty cells */&#13;
	['sheetRows', 0, 'n'], /* read n rows (0 = read all rows) */&#13;
&#13;
	['bookDeps', false], /* parse calculation chains */&#13;
	['bookSheets', false], /* only try to get sheet names (no Sheets) */&#13;
	['bookProps', false], /* only try to get properties (no Sheets) */&#13;
	['bookFiles', false], /* include raw file structure (keys, files, cfb) */&#13;
	['bookVBA', false], /* include vba raw data (vbaraw) */&#13;
&#13;
	['password',''], /* password */&#13;
	['WTF', false] /* WTF mode (throws errors) */&#13;
])(opts);&#13;
}&#13;
&#13;
function fix_write_opts(opts) {&#13;
fix_opts_func([&#13;
	['cellDates', false], /* write date cells with type `d` */&#13;
&#13;
	['bookSST', false], /* Generate Shared String Table */&#13;
&#13;
	['bookType', 'xlsx'], /* Type of workbook (xlsx/m/b) */&#13;
&#13;
	['compression', false], /* Use file compression */&#13;
&#13;
	['WTF', false] /* WTF mode (throws errors) */&#13;
])(opts);&#13;
}&#13;
function get_sheet_type(n) {&#13;
	if(RELS.WS.indexOf(n) &gt; -1) return "sheet";&#13;
	if(RELS.CS &amp;&amp; n == RELS.CS) return "chart";&#13;
	if(RELS.DS &amp;&amp; n == RELS.DS) return "dialog";&#13;
	if(RELS.MS &amp;&amp; n == RELS.MS) return "macro";&#13;
	return (n &amp;&amp; n.length) ? n : "sheet";&#13;
}&#13;
function safe_parse_wbrels(wbrels, sheets) {&#13;
	if(!wbrels) return 0;&#13;
	try {&#13;
		wbrels = sheets.map(function pwbr(w) { if(!w.id) w.id = w.strRelID; return [w.name, wbrels['!id'][w.id].Target, get_sheet_type(wbrels['!id'][w.id].Type)]; });&#13;
	} catch(e) { return null; }&#13;
	return !wbrels || wbrels.length === 0 ? null : wbrels;&#13;
}&#13;
&#13;
function safe_parse_sheet(zip, path, relsPath, sheet, idx, sheetRels, sheets, stype, opts, wb, themes, styles) {&#13;
	try {&#13;
		sheetRels[sheet]=parse_rels(getzipstr(zip, relsPath, true), path);&#13;
		var data = getzipdata(zip, path);&#13;
		var _ws;&#13;
		switch(stype) {&#13;
			case 'sheet':  _ws = parse_ws(data, path, idx, opts, sheetRels[sheet], wb, themes, styles); break;&#13;
			case 'chart':  _ws = parse_cs(data, path, idx, opts, sheetRels[sheet], wb, themes, styles);&#13;
				if(!_ws || !_ws['!drawel']) break;&#13;
				var dfile = resolve_path(_ws['!drawel'].Target, path);&#13;
				var drelsp = get_rels_path(dfile);&#13;
				var draw = parse_drawing(getzipstr(zip, dfile, true), parse_rels(getzipstr(zip, drelsp, true), dfile));&#13;
				var chartp = resolve_path(draw, dfile);&#13;
				var crelsp = get_rels_path(chartp);&#13;
				_ws = parse_chart(getzipstr(zip, chartp, true), chartp, opts, parse_rels(getzipstr(zip, crelsp, true), chartp), wb, _ws);&#13;
				break;&#13;
			case 'macro':  _ws = parse_ms(data, path, idx, opts, sheetRels[sheet], wb, themes, styles); break;&#13;
			case 'dialog': _ws = parse_ds(data, path, idx, opts, sheetRels[sheet], wb, themes, styles); break;&#13;
			default: throw new Error("Unrecognized sheet type " + stype);&#13;
		}&#13;
		sheets[sheet] = _ws;&#13;
&#13;
		/* scan rels for comments and threaded comments */&#13;
		var comments = [], tcomments = [];&#13;
		if(sheetRels &amp;&amp; sheetRels[sheet]) keys(sheetRels[sheet]).forEach(function(n) {&#13;
			var dfile = "";&#13;
			if(sheetRels[sheet][n].Type == RELS.CMNT) {&#13;
				dfile = resolve_path(sheetRels[sheet][n].Target, path);&#13;
				comments = parse_cmnt(getzipdata(zip, dfile, true), dfile, opts);&#13;
				if(!comments || !comments.length) return;&#13;
				sheet_insert_comments(_ws, comments, false);&#13;
			}&#13;
			if(sheetRels[sheet][n].Type == RELS.TCMNT) {&#13;
				dfile = resolve_path(sheetRels[sheet][n].Target, path);&#13;
				tcomments = tcomments.concat(parse_tcmnt_xml(getzipdata(zip, dfile, true), opts));&#13;
			}&#13;
		});&#13;
		if(tcomments &amp;&amp; tcomments.length) sheet_insert_comments(_ws, tcomments, true, opts.people || []);&#13;
	} catch(e) { if(opts.WTF) throw e; }&#13;
}&#13;
&#13;
function strip_front_slash(x) { return x.charAt(0) == '/' ? x.slice(1) : x; }&#13;
&#13;
function parse_zip(zip, opts) {&#13;
	make_ssf();&#13;
	opts = opts || {};&#13;
	fix_read_opts(opts);&#13;
&#13;
	/* OpenDocument Part 3 Section 2.2.1 OpenDocument Package */&#13;
	if(safegetzipfile(zip, 'META-INF/manifest.xml')) return parse_ods(zip, opts);&#13;
	/* UOC */&#13;
	if(safegetzipfile(zip, 'objectdata.xml')) return parse_ods(zip, opts);&#13;
	/* Numbers */&#13;
	if(safegetzipfile(zip, 'Index/Document.iwa')) {&#13;
		if(typeof Uint8Array == "undefined") throw new Error('NUMBERS file parsing requires Uint8Array support');&#13;
		if(typeof parse_numbers_iwa != "undefined") {&#13;
			if(zip.FileIndex) return parse_numbers_iwa(zip, opts);&#13;
			var _zip = CFB.utils.cfb_new();&#13;
			zipentries(zip).forEach(function(e) { zip_add_file(_zip, e, getzipbin(zip, e)); });&#13;
			return parse_numbers_iwa(_zip, opts);&#13;
		}&#13;
		throw new Error('Unsupported NUMBERS file');&#13;
	}&#13;
	if(!safegetzipfile(zip, '[Content_Types].xml')) {&#13;
		if(safegetzipfile(zip, 'index.xml.gz')) throw new Error('Unsupported NUMBERS 08 file');&#13;
		if(safegetzipfile(zip, 'index.xml')) throw new Error('Unsupported NUMBERS 09 file');&#13;
		var index_zip = CFB.find(zip, 'Index.zip');&#13;
		if(index_zip) {&#13;
			opts = dup(opts);&#13;
			delete opts.type;&#13;
			if(typeof index_zip.content == "string") opts.type = "binary";&#13;
			// TODO: Bun buffer bug&#13;
			if(typeof Bun !== "undefined" &amp;&amp; Buffer.isBuffer(index_zip.content)) return readSync(new Uint8Array(index_zip.content), opts);&#13;
			return readSync(index_zip.content, opts);&#13;
		}&#13;
		throw new Error('Unsupported ZIP file');&#13;
	}&#13;
&#13;
	var entries = zipentries(zip);&#13;
	var dir = parse_ct((getzipstr(zip, '[Content_Types].xml')));&#13;
	var xlsb = false;&#13;
	var sheets, binname;&#13;
	if(dir.workbooks.length === 0) {&#13;
		binname = "xl/workbook.xml";&#13;
		if(getzipdata(zip,binname, true)) dir.workbooks.push(binname);&#13;
	}&#13;
	if(dir.workbooks.length === 0) {&#13;
		binname = "xl/workbook.bin";&#13;
		if(!getzipdata(zip,binname,true)) throw new Error("Could not find workbook");&#13;
		dir.workbooks.push(binname);&#13;
		xlsb = true;&#13;
	}&#13;
	if(dir.workbooks[0].slice(-3) == "bin") xlsb = true;&#13;
&#13;
	var themes = ({});&#13;
	var styles = ({});&#13;
	if(!opts.bookSheets &amp;&amp; !opts.bookProps) {&#13;
		strs = [];&#13;
		if(dir.sst) try { strs=parse_sst(getzipdata(zip, strip_front_slash(dir.sst)), dir.sst, opts); } catch(e) { if(opts.WTF) throw e; }&#13;
&#13;
		if(opts.cellStyles &amp;&amp; dir.themes.length) themes = parse_theme_xml(getzipstr(zip, dir.themes[0].replace(/^\//,''), true)||"", opts);&#13;
&#13;
		if(dir.style) styles = parse_sty(getzipdata(zip, strip_front_slash(dir.style)), dir.style, themes, opts);&#13;
	}&#13;
&#13;
	/*var externbooks = */dir.links.map(function(link) {&#13;
		try {&#13;
			var rels = parse_rels(getzipstr(zip, get_rels_path(strip_front_slash(link))), link);&#13;
			return parse_xlink(getzipdata(zip, strip_front_slash(link)), rels, link, opts);&#13;
		} catch(e) {}&#13;
	});&#13;
&#13;
	var wb = parse_wb(getzipdata(zip, strip_front_slash(dir.workbooks[0])), dir.workbooks[0], opts);&#13;
&#13;
	var props = {}, propdata = "";&#13;
&#13;
	if(dir.coreprops.length) {&#13;
		propdata = getzipdata(zip, strip_front_slash(dir.coreprops[0]), true);&#13;
		if(propdata) props = parse_core_props(propdata);&#13;
		if(dir.extprops.length !== 0) {&#13;
			propdata = getzipdata(zip, strip_front_slash(dir.extprops[0]), true);&#13;
			if(propdata) parse_ext_props(propdata, props, opts);&#13;
		}&#13;
	}&#13;
&#13;
	var custprops = {};&#13;
	if(!opts.bookSheets || opts.bookProps) {&#13;
		if (dir.custprops.length !== 0) {&#13;
			propdata = getzipstr(zip, strip_front_slash(dir.custprops[0]), true);&#13;
			if(propdata) custprops = parse_cust_props(propdata, opts);&#13;
		}&#13;
	}&#13;
&#13;
	var out = ({});&#13;
	if(opts.bookSheets || opts.bookProps) {&#13;
		if(wb.Sheets) sheets = wb.Sheets.map(function pluck(x){ return x.name; });&#13;
		else if(props.Worksheets &amp;&amp; props.SheetNames.length &gt; 0) sheets=props.SheetNames;&#13;
		if(opts.bookProps) { out.Props = props; out.Custprops = custprops; }&#13;
		if(opts.bookSheets &amp;&amp; typeof sheets !== 'undefined') out.SheetNames = sheets;&#13;
		if(opts.bookSheets ? out.SheetNames : opts.bookProps) return out;&#13;
	}&#13;
	sheets = {};&#13;
&#13;
	var deps = {};&#13;
	if(opts.bookDeps &amp;&amp; dir.calcchain) deps=parse_cc(getzipdata(zip, strip_front_slash(dir.calcchain)),dir.calcchain,opts);&#13;
&#13;
	var i=0;&#13;
	var sheetRels = ({});&#13;
	var path, relsPath;&#13;
&#13;
	{&#13;
		var wbsheets = wb.Sheets;&#13;
		props.Worksheets = wbsheets.length;&#13;
		props.SheetNames = [];&#13;
		for(var j = 0; j != wbsheets.length; ++j) {&#13;
			props.SheetNames[j] = wbsheets[j].name;&#13;
		}&#13;
	}&#13;
&#13;
	var wbext = xlsb ? "bin" : "xml";&#13;
	var wbrelsi = dir.workbooks[0].lastIndexOf("/");&#13;
	var wbrelsfile = (dir.workbooks[0].slice(0, wbrelsi+1) + "_rels/" + dir.workbooks[0].slice(wbrelsi+1) + ".rels").replace(/^\//,"");&#13;
	if(!safegetzipfile(zip, wbrelsfile)) wbrelsfile = 'xl/_rels/workbook.' + wbext + '.rels';&#13;
	var wbrels = parse_rels(getzipstr(zip, wbrelsfile, true), wbrelsfile.replace(/_rels.*/, "s5s"));&#13;
&#13;
	if((dir.metadata || []).length &gt;= 1) {&#13;
		/* TODO: MDX and other types of metadata */&#13;
		opts.xlmeta = parse_xlmeta(getzipdata(zip, strip_front_slash(dir.metadata[0])),dir.metadata[0],opts);&#13;
	}&#13;
&#13;
	if((dir.people || []).length &gt;= 1) {&#13;
		opts.people = parse_people_xml(getzipdata(zip, strip_front_slash(dir.people[0])),opts);&#13;
	}&#13;
&#13;
	if(wbrels) wbrels = safe_parse_wbrels(wbrels, wb.Sheets);&#13;
&#13;
	/* Numbers iOS hack */&#13;
	var nmode = (getzipdata(zip,"xl/worksheets/sheet.xml",true))?1:0;&#13;
	wsloop: for(i = 0; i != props.Worksheets; ++i) {&#13;
		var stype = "sheet";&#13;
		if(wbrels &amp;&amp; wbrels[i]) {&#13;
			path = 'xl/' + (wbrels[i][1]).replace(/[\/]?xl\//, "");&#13;
			if(!safegetzipfile(zip, path)) path = wbrels[i][1];&#13;
			if(!safegetzipfile(zip, path)) path = wbrelsfile.replace(/_rels\/.*$/,"") + wbrels[i][1];&#13;
			stype = wbrels[i][2];&#13;
		} else {&#13;
			path = 'xl/worksheets/sheet'+(i+1-nmode)+"." + wbext;&#13;
			path = path.replace(/sheet0\./,"sheet.");&#13;
		}&#13;
		relsPath = path.replace(/^(.*)(\/)([^\/]*)$/, "$1/_rels/$3.rels");&#13;
		if(opts &amp;&amp; opts.sheets != null) switch(typeof opts.sheets) {&#13;
			case "number": if(i != opts.sheets) continue wsloop; break;&#13;
			case "string": if(props.SheetNames[i].toLowerCase() != opts.sheets.toLowerCase()) continue wsloop; break;&#13;
			default: if(Array.isArray &amp;&amp; Array.isArray(opts.sheets)) {&#13;
				var snjseen = false;&#13;
				for(var snj = 0; snj != opts.sheets.length; ++snj) {&#13;
					if(typeof opts.sheets[snj] == "number" &amp;&amp; opts.sheets[snj] == i) snjseen=1;&#13;
					if(typeof opts.sheets[snj] == "string" &amp;&amp; opts.sheets[snj].toLowerCase() == props.SheetNames[i].toLowerCase()) snjseen = 1;&#13;
				}&#13;
				if(!snjseen) continue wsloop;&#13;
			}&#13;
		}&#13;
		safe_parse_sheet(zip, path, relsPath, props.SheetNames[i], i, sheetRels, sheets, stype, opts, wb, themes, styles);&#13;
	}&#13;
&#13;
	out = ({&#13;
		Directory: dir,&#13;
		Workbook: wb,&#13;
		Props: props,&#13;
		Custprops: custprops,&#13;
		Deps: deps,&#13;
		Sheets: sheets,&#13;
		SheetNames: props.SheetNames,&#13;
		Strings: strs,&#13;
		Styles: styles,&#13;
		Themes: themes,&#13;
		SSF: dup(table_fmt)&#13;
	});&#13;
	if(opts &amp;&amp; opts.bookFiles) {&#13;
		if(zip.files) {&#13;
			out.keys = entries;&#13;
			out.files = zip.files;&#13;
		} else {&#13;
			out.keys = [];&#13;
			out.files = {};&#13;
			zip.FullPaths.forEach(function(p, idx) {&#13;
				p = p.replace(/^Root Entry[\/]/, "");&#13;
				out.keys.push(p);&#13;
				out.files[p] = zip.FileIndex[idx];&#13;
			});&#13;
		}&#13;
	}&#13;
	if(opts &amp;&amp; opts.bookVBA) {&#13;
		if(dir.vba.length &gt; 0) out.vbaraw = getzipdata(zip,strip_front_slash(dir.vba[0]),true);&#13;
		else if(dir.defaults &amp;&amp; dir.defaults.bin === CT_VBA) out.vbaraw = getzipdata(zip, 'xl/vbaProject.bin',true);&#13;
	}&#13;
	// TODO: pass back content types metdata for xlsm/xlsx resolution&#13;
	out.bookType = xlsb ? "xlsb" : "xlsx";&#13;
	return out;&#13;
}&#13;
&#13;
/* [MS-OFFCRYPTO] 2.1.1 */&#13;
function parse_xlsxcfb(cfb, _opts) {&#13;
	var opts = _opts || {};&#13;
	var f = 'Workbook', data = CFB.find(cfb, f);&#13;
	try {&#13;
	f = '/!DataSpaces/Version';&#13;
	data = CFB.find(cfb, f); if(!data || !data.content) throw new Error("ECMA-376 Encrypted file missing " + f);&#13;
	/*var version = */parse_DataSpaceVersionInfo(data.content);&#13;
&#13;
	/* 2.3.4.1 */&#13;
	f = '/!DataSpaces/DataSpaceMap';&#13;
	data = CFB.find(cfb, f); if(!data || !data.content) throw new Error("ECMA-376 Encrypted file missing " + f);&#13;
	var dsm = parse_DataSpaceMap(data.content);&#13;
	if(dsm.length !== 1 || dsm[0].comps.length !== 1 || dsm[0].comps[0].t !== 0 || dsm[0].name !== "StrongEncryptionDataSpace" || dsm[0].comps[0].v !== "EncryptedPackage")&#13;
		throw new Error("ECMA-376 Encrypted file bad " + f);&#13;
&#13;
	/* 2.3.4.2 */&#13;
	f = '/!DataSpaces/DataSpaceInfo/StrongEncryptionDataSpace';&#13;
	data = CFB.find(cfb, f); if(!data || !data.content) throw new Error("ECMA-376 Encrypted file missing " + f);&#13;
	var seds = parse_DataSpaceDefinition(data.content);&#13;
	if(seds.length != 1 || seds[0] != "StrongEncryptionTransform")&#13;
		throw new Error("ECMA-376 Encrypted file bad " + f);&#13;
&#13;
	/* 2.3.4.3 */&#13;
	f = '/!DataSpaces/TransformInfo/StrongEncryptionTransform/!Primary';&#13;
	data = CFB.find(cfb, f); if(!data || !data.content) throw new Error("ECMA-376 Encrypted file missing " + f);&#13;
	/*var hdr = */parse_Primary(data.content);&#13;
	} catch(e) {}&#13;
&#13;
	f = '/EncryptionInfo';&#13;
	data = CFB.find(cfb, f); if(!data || !data.content) throw new Error("ECMA-376 Encrypted file missing " + f);&#13;
	var einfo = parse_EncryptionInfo(data.content);&#13;
&#13;
	/* 2.3.4.4 */&#13;
	f = '/EncryptedPackage';&#13;
	data = CFB.find(cfb, f); if(!data || !data.content) throw new Error("ECMA-376 Encrypted file missing " + f);&#13;
&#13;
/*global decrypt_agile */&#13;
if(einfo[0] == 0x04 &amp;&amp; typeof decrypt_agile !== 'undefined') return decrypt_agile(einfo[1], data.content, opts.password || "", opts);&#13;
/*global decrypt_std76 */&#13;
if(einfo[0] == 0x02 &amp;&amp; typeof decrypt_std76 !== 'undefined') return decrypt_std76(einfo[1], data.content, opts.password || "", opts);&#13;
	throw new Error("File is password-protected");&#13;
}&#13;
&#13;
function write_zip_xlsb(wb, opts) {&#13;
	if(wb &amp;&amp; !wb.SSF) {&#13;
		wb.SSF = dup(table_fmt);&#13;
	}&#13;
	if(wb &amp;&amp; wb.SSF) {&#13;
		make_ssf(); SSF_load_table(wb.SSF);&#13;
		// $FlowIgnore&#13;
		opts.revssf = evert_num(wb.SSF); opts.revssf[wb.SSF[65535]] = 0;&#13;
		opts.ssf = wb.SSF;&#13;
	}&#13;
	opts.rels = {}; opts.wbrels = {};&#13;
	opts.Strings = []; opts.Strings.Count = 0; opts.Strings.Unique = 0;&#13;
	if(browser_has_Map) opts.revStrings = new Map();&#13;
	else { opts.revStrings = {}; opts.revStrings.foo = []; delete opts.revStrings.foo; }&#13;
	var wbext = "bin";&#13;
	var vbafmt = true;&#13;
	var ct = new_ct();&#13;
	fix_write_opts(opts = opts || {});&#13;
	var zip = zip_new();&#13;
	var f = "", rId = 0;&#13;
&#13;
	opts.cellXfs = [];&#13;
	get_cell_style(opts.cellXfs, {}, {revssf:{"General":0}});&#13;
&#13;
	if(!wb.Props) wb.Props = {};&#13;
&#13;
	f = "docProps/core.xml";&#13;
	zip_add_file(zip, f, write_core_props(wb.Props, opts));&#13;
	ct.coreprops.push(f);&#13;
	add_rels(opts.rels, 2, f, RELS.CORE_PROPS);&#13;
&#13;
f = "docProps/app.xml";&#13;
	if(wb.Props &amp;&amp; wb.Props.SheetNames){/* empty */}&#13;
	else if(!wb.Workbook || !wb.Workbook.Sheets) wb.Props.SheetNames = wb.SheetNames;&#13;
	else {&#13;
		var _sn = [];&#13;
		for(var _i = 0; _i &lt; wb.SheetNames.length; ++_i)&#13;
			if((wb.Workbook.Sheets[_i]||{}).Hidden != 2) _sn.push(wb.SheetNames[_i]);&#13;
		wb.Props.SheetNames = _sn;&#13;
	}&#13;
	wb.Props.Worksheets = wb.Props.SheetNames.length;&#13;
	zip_add_file(zip, f, write_ext_props(wb.Props, opts));&#13;
	ct.extprops.push(f);&#13;
	add_rels(opts.rels, 3, f, RELS.EXT_PROPS);&#13;
&#13;
	if(wb.Custprops !== wb.Props &amp;&amp; keys(wb.Custprops||{}).length &gt; 0) {&#13;
		f = "docProps/custom.xml";&#13;
		zip_add_file(zip, f, write_cust_props(wb.Custprops, opts));&#13;
		ct.custprops.push(f);&#13;
		add_rels(opts.rels, 4, f, RELS.CUST_PROPS);&#13;
	}&#13;
&#13;
	for(rId=1;rId &lt;= wb.SheetNames.length; ++rId) {&#13;
		var wsrels = {'!id':{}};&#13;
		var ws = wb.Sheets[wb.SheetNames[rId-1]];&#13;
		var _type = (ws || {})["!type"] || "sheet";&#13;
		switch(_type) {&#13;
		case "chart":&#13;
			/* falls through */&#13;
		default:&#13;
			f = "xl/worksheets/sheet" + rId + "." + wbext;&#13;
			zip_add_file(zip, f, write_ws_bin(rId-1, opts, wb, wsrels));&#13;
			ct.sheets.push(f);&#13;
			add_rels(opts.wbrels, -1, "worksheets/sheet" + rId + "." + wbext, RELS.WS[0]);&#13;
		}&#13;
&#13;
		if(ws) {&#13;
			var comments = ws['!comments'];&#13;
			var need_vml = false;&#13;
			var cf = "";&#13;
			if(comments &amp;&amp; comments.length &gt; 0) {&#13;
				cf = "xl/comments" + rId + "." + wbext;&#13;
				zip_add_file(zip, cf, write_comments_bin(comments, opts));&#13;
				ct.comments.push(cf);&#13;
				add_rels(wsrels, -1, "../comments" + rId + "." + wbext, RELS.CMNT);&#13;
				need_vml = true;&#13;
			}&#13;
			if(ws['!legacy']) {&#13;
				if(need_vml) zip_add_file(zip, "xl/drawings/vmlDrawing" + (rId) + ".vml", write_vml(rId, ws['!comments']));&#13;
			}&#13;
			delete ws['!comments'];&#13;
			delete ws['!legacy'];&#13;
		}&#13;
&#13;
		if(wsrels['!id'].rId1) zip_add_file(zip, get_rels_path(f), write_rels(wsrels));&#13;
	}&#13;
&#13;
	if(opts.Strings != null &amp;&amp; opts.Strings.length &gt; 0) {&#13;
		f = "xl/sharedStrings." + wbext;&#13;
		zip_add_file(zip, f, write_sst_bin(opts.Strings, opts));&#13;
		ct.strs.push(f);&#13;
		add_rels(opts.wbrels, -1, "sharedStrings." + wbext, RELS.SST);&#13;
	}&#13;
&#13;
	f = "xl/workbook." + wbext;&#13;
	zip_add_file(zip, f, write_wb_bin(wb, opts));&#13;
	ct.workbooks.push(f);&#13;
	add_rels(opts.rels, 1, f, RELS.WB);&#13;
&#13;
	/* TODO: something more intelligent with themes */&#13;
&#13;
	f = "xl/theme/theme1.xml";&#13;
	var ww = write_theme(wb.Themes, opts);&#13;
	zip_add_file(zip, f, ww);&#13;
	ct.themes.push(f);&#13;
	add_rels(opts.wbrels, -1, "theme/theme1.xml", RELS.THEME);&#13;
&#13;
	/* TODO: something more intelligent with styles */&#13;
&#13;
	f = "xl/styles." + wbext;&#13;
	zip_add_file(zip, f, write_sty_bin(wb, opts));&#13;
	ct.styles.push(f);&#13;
	add_rels(opts.wbrels, -1, "styles." + wbext, RELS.STY);&#13;
&#13;
	if(wb.vbaraw &amp;&amp; vbafmt) {&#13;
		f = "xl/vbaProject.bin";&#13;
		zip_add_file(zip, f, wb.vbaraw);&#13;
		ct.vba.push(f);&#13;
		add_rels(opts.wbrels, -1, "vbaProject.bin", RELS.VBA);&#13;
	}&#13;
&#13;
	f = "xl/metadata." + wbext;&#13;
	zip_add_file(zip, f, write_xlmeta_bin());&#13;
	ct.metadata.push(f);&#13;
	add_rels(opts.wbrels, -1, "metadata." + wbext, RELS.XLMETA);&#13;
&#13;
	zip_add_file(zip, "[Content_Types].xml", write_ct(ct, opts));&#13;
	zip_add_file(zip, '_rels/.rels', write_rels(opts.rels));&#13;
	zip_add_file(zip, 'xl/_rels/workbook.' + wbext + '.rels', write_rels(opts.wbrels));&#13;
&#13;
	delete opts.revssf; delete opts.ssf;&#13;
	return zip;&#13;
}&#13;
&#13;
function write_zip_xlsx(wb, opts) {&#13;
	if(wb &amp;&amp; !wb.SSF) {&#13;
		wb.SSF = dup(table_fmt);&#13;
	}&#13;
	if(wb &amp;&amp; wb.SSF) {&#13;
		make_ssf(); SSF_load_table(wb.SSF);&#13;
		// $FlowIgnore&#13;
		opts.revssf = evert_num(wb.SSF); opts.revssf[wb.SSF[65535]] = 0;&#13;
		opts.ssf = wb.SSF;&#13;
	}&#13;
	opts.rels = {}; opts.wbrels = {};&#13;
	opts.Strings = []; opts.Strings.Count = 0; opts.Strings.Unique = 0;&#13;
	if(browser_has_Map) opts.revStrings = new Map();&#13;
	else { opts.revStrings = {}; opts.revStrings.foo = []; delete opts.revStrings.foo; }&#13;
	var wbext = "xml";&#13;
	var vbafmt = VBAFMTS.indexOf(opts.bookType) &gt; -1;&#13;
	var ct = new_ct();&#13;
	fix_write_opts(opts = opts || {});&#13;
	var zip = zip_new();&#13;
	var f = "", rId = 0;&#13;
&#13;
	opts.cellXfs = [];&#13;
	get_cell_style(opts.cellXfs, {}, {revssf:{"General":0}});&#13;
&#13;
	if(!wb.Props) wb.Props = {};&#13;
&#13;
	f = "docProps/core.xml";&#13;
	zip_add_file(zip, f, write_core_props(wb.Props, opts));&#13;
	ct.coreprops.push(f);&#13;
	add_rels(opts.rels, 2, f, RELS.CORE_PROPS);&#13;
&#13;
f = "docProps/app.xml";&#13;
	if(wb.Props &amp;&amp; wb.Props.SheetNames){/* empty */}&#13;
	else if(!wb.Workbook || !wb.Workbook.Sheets) wb.Props.SheetNames = wb.SheetNames;&#13;
	else {&#13;
		var _sn = [];&#13;
		for(var _i = 0; _i &lt; wb.SheetNames.length; ++_i)&#13;
			if((wb.Workbook.Sheets[_i]||{}).Hidden != 2) _sn.push(wb.SheetNames[_i]);&#13;
		wb.Props.SheetNames = _sn;&#13;
	}&#13;
	wb.Props.Worksheets = wb.Props.SheetNames.length;&#13;
	zip_add_file(zip, f, write_ext_props(wb.Props, opts));&#13;
	ct.extprops.push(f);&#13;
	add_rels(opts.rels, 3, f, RELS.EXT_PROPS);&#13;
&#13;
	if(wb.Custprops !== wb.Props &amp;&amp; keys(wb.Custprops||{}).length &gt; 0) {&#13;
		f = "docProps/custom.xml";&#13;
		zip_add_file(zip, f, write_cust_props(wb.Custprops, opts));&#13;
		ct.custprops.push(f);&#13;
		add_rels(opts.rels, 4, f, RELS.CUST_PROPS);&#13;
	}&#13;
&#13;
	var people = ["SheetJ5"];&#13;
	opts.tcid = 0;&#13;
&#13;
	for(rId=1;rId &lt;= wb.SheetNames.length; ++rId) {&#13;
		var wsrels = {'!id':{}};&#13;
		var ws = wb.Sheets[wb.SheetNames[rId-1]];&#13;
		var _type = (ws || {})["!type"] || "sheet";&#13;
		switch(_type) {&#13;
		case "chart":&#13;
			/* falls through */&#13;
		default:&#13;
			f = "xl/worksheets/sheet" + rId + "." + wbext;&#13;
			zip_add_file(zip, f, write_ws_xml(rId-1, opts, wb, wsrels));&#13;
			ct.sheets.push(f);&#13;
			add_rels(opts.wbrels, -1, "worksheets/sheet" + rId + "." + wbext, RELS.WS[0]);&#13;
		}&#13;
&#13;
		if(ws) {&#13;
			var comments = ws['!comments'];&#13;
			var need_vml = false;&#13;
			var cf = "";&#13;
			if(comments &amp;&amp; comments.length &gt; 0) {&#13;
				var needtc = false;&#13;
				comments.forEach(function(carr) {&#13;
					carr[1].forEach(function(c) { if(c.T == true) needtc = true; });&#13;
				});&#13;
				if(needtc) {&#13;
					cf = "xl/threadedComments/threadedComment" + rId + ".xml";&#13;
					zip_add_file(zip, cf, write_tcmnt_xml(comments, people, opts));&#13;
					ct.threadedcomments.push(cf);&#13;
					add_rels(wsrels, -1, "../threadedComments/threadedComment" + rId + ".xml", RELS.TCMNT);&#13;
				}&#13;
&#13;
				cf = "xl/comments" + rId + "." + wbext;&#13;
				zip_add_file(zip, cf, write_comments_xml(comments, opts));&#13;
				ct.comments.push(cf);&#13;
				add_rels(wsrels, -1, "../comments" + rId + "." + wbext, RELS.CMNT);&#13;
				need_vml = true;&#13;
			}&#13;
			if(ws['!legacy']) {&#13;
				if(need_vml) zip_add_file(zip, "xl/drawings/vmlDrawing" + (rId) + ".vml", write_vml(rId, ws['!comments']));&#13;
			}&#13;
			delete ws['!comments'];&#13;
			delete ws['!legacy'];&#13;
		}&#13;
&#13;
		if(wsrels['!id'].rId1) zip_add_file(zip, get_rels_path(f), write_rels(wsrels));&#13;
	}&#13;
&#13;
	if(opts.Strings != null &amp;&amp; opts.Strings.length &gt; 0) {&#13;
		f = "xl/sharedStrings." + wbext;&#13;
		zip_add_file(zip, f, write_sst_xml(opts.Strings, opts));&#13;
		ct.strs.push(f);&#13;
		add_rels(opts.wbrels, -1, "sharedStrings." + wbext, RELS.SST);&#13;
	}&#13;
&#13;
	f = "xl/workbook." + wbext;&#13;
	zip_add_file(zip, f, write_wb_xml(wb, opts));&#13;
	ct.workbooks.push(f);&#13;
	add_rels(opts.rels, 1, f, RELS.WB);&#13;
&#13;
	/* TODO: something more intelligent with themes */&#13;
&#13;
	f = "xl/theme/theme1.xml";&#13;
	zip_add_file(zip, f, write_theme(wb.Themes, opts));&#13;
	ct.themes.push(f);&#13;
	add_rels(opts.wbrels, -1, "theme/theme1.xml", RELS.THEME);&#13;
&#13;
	/* TODO: something more intelligent with styles */&#13;
&#13;
	f = "xl/styles." + wbext;&#13;
	zip_add_file(zip, f, write_sty_xml(wb, opts));&#13;
	ct.styles.push(f);&#13;
	add_rels(opts.wbrels, -1, "styles." + wbext, RELS.STY);&#13;
&#13;
	if(wb.vbaraw &amp;&amp; vbafmt) {&#13;
		f = "xl/vbaProject.bin";&#13;
		zip_add_file(zip, f, wb.vbaraw);&#13;
		ct.vba.push(f);&#13;
		add_rels(opts.wbrels, -1, "vbaProject.bin", RELS.VBA);&#13;
	}&#13;
&#13;
	f = "xl/metadata." + wbext;&#13;
	zip_add_file(zip, f, write_xlmeta_xml());&#13;
	ct.metadata.push(f);&#13;
	add_rels(opts.wbrels, -1, "metadata." + wbext, RELS.XLMETA);&#13;
&#13;
	if(people.length &gt; 1) {&#13;
		f = "xl/persons/person.xml";&#13;
		zip_add_file(zip, f, write_people_xml(people, opts));&#13;
		ct.people.push(f);&#13;
		add_rels(opts.wbrels, -1, "persons/person.xml", RELS.PEOPLE);&#13;
	}&#13;
&#13;
	zip_add_file(zip, "[Content_Types].xml", write_ct(ct, opts));&#13;
	zip_add_file(zip, '_rels/.rels', write_rels(opts.rels));&#13;
	zip_add_file(zip, 'xl/_rels/workbook.' + wbext + '.rels', write_rels(opts.wbrels));&#13;
&#13;
	delete opts.revssf; delete opts.ssf;&#13;
	return zip;&#13;
}&#13;
&#13;
function firstbyte(f,o) {&#13;
	var x = "";&#13;
	switch((o||{}).type || "base64") {&#13;
		case 'buffer': return [f[0], f[1], f[2], f[3], f[4], f[5], f[6], f[7]];&#13;
		case 'base64': x = Base64_decode(f.slice(0,12)); break;&#13;
		case 'binary': x = f; break;&#13;
		case 'array':  return [f[0], f[1], f[2], f[3], f[4], f[5], f[6], f[7]];&#13;
		default: throw new Error("Unrecognized type " + (o &amp;&amp; o.type || "undefined"));&#13;
	}&#13;
	return [x.charCodeAt(0), x.charCodeAt(1), x.charCodeAt(2), x.charCodeAt(3), x.charCodeAt(4), x.charCodeAt(5), x.charCodeAt(6), x.charCodeAt(7)];&#13;
}&#13;
&#13;
function read_cfb(cfb, opts) {&#13;
	if(CFB.find(cfb, "EncryptedPackage")) return parse_xlsxcfb(cfb, opts);&#13;
	return parse_xlscfb(cfb, opts);&#13;
}&#13;
&#13;
function read_zip(data, opts) {&#13;
	var zip, d = data;&#13;
	var o = opts||{};&#13;
	if(!o.type) o.type = (has_buf &amp;&amp; Buffer.isBuffer(data)) ? "buffer" : "base64";&#13;
	zip = zip_read(d, o);&#13;
	return parse_zip(zip, o);&#13;
}&#13;
&#13;
function read_plaintext(data, o) {&#13;
	var i = 0;&#13;
	main: while(i &lt; data.length) switch(data.charCodeAt(i)) {&#13;
		case 0x0A: case 0x0D: case 0x20: ++i; break;&#13;
		case 0x3C: return parse_xlml(data.slice(i),o);&#13;
		default: break main;&#13;
	}&#13;
	return PRN.to_workbook(data, o);&#13;
}&#13;
&#13;
function read_plaintext_raw(data, o) {&#13;
	var str = "", bytes = firstbyte(data, o);&#13;
	switch(o.type) {&#13;
		case 'base64': str = Base64_decode(data); break;&#13;
		case 'binary': str = data; break;&#13;
		case 'buffer': str = data.toString('binary'); break;&#13;
		case 'array': str = cc2str(data); break;&#13;
		default: throw new Error("Unrecognized type " + o.type);&#13;
	}&#13;
	if(bytes[0] == 0xEF &amp;&amp; bytes[1] == 0xBB &amp;&amp; bytes[2] == 0xBF) str = utf8read(str);&#13;
	o.type = "binary";&#13;
	return read_plaintext(str, o);&#13;
}&#13;
&#13;
function read_utf16(data, o) {&#13;
	var d = data;&#13;
	if(o.type == 'base64') d = Base64_decode(d);&#13;
	d = typeof $cptable !== "undefined" ? $cptable.utils.decode(1200, d.slice(2), 'str') : utf16leread(d.slice(2));&#13;
	o.type = "binary";&#13;
	return read_plaintext(d, o);&#13;
}&#13;
&#13;
function bstrify(data) {&#13;
	return !data.match(/[^\x00-\x7F]/) ? data : utf8write(data);&#13;
}&#13;
&#13;
function read_prn(data, d, o, str) {&#13;
	if(str) { o.type = "string"; return PRN.to_workbook(data, o); }&#13;
	return PRN.to_workbook(d, o);&#13;
}&#13;
&#13;
function readSync(data, opts) {&#13;
	reset_cp();&#13;
	var o = opts||{};&#13;
	if(o.codepage &amp;&amp; typeof $cptable === "undefined") console.error("Codepage tables are not loaded.  Non-ASCII characters may not give expected results");&#13;
	if(typeof ArrayBuffer !== 'undefined' &amp;&amp; data instanceof ArrayBuffer) return readSync(new Uint8Array(data), (o = dup(o), o.type = "array", o));&#13;
	if(typeof Uint8Array !== 'undefined' &amp;&amp; data instanceof Uint8Array &amp;&amp; !o.type) o.type = typeof Deno !== "undefined" ? "buffer" : "array";&#13;
	var d = data, n = [0,0,0,0], str = false;&#13;
	if(o.cellStyles) { o.cellNF = true; o.sheetStubs = true; }&#13;
	_ssfopts = {};&#13;
	if(o.dateNF) _ssfopts.dateNF = o.dateNF;&#13;
	if(!o.type) o.type = (has_buf &amp;&amp; Buffer.isBuffer(data)) ? "buffer" : "base64";&#13;
	if(o.type == "file") { o.type = has_buf ? "buffer" : "binary"; d = read_binary(data); if(typeof Uint8Array !== 'undefined' &amp;&amp; !has_buf) o.type = "array"; }&#13;
	if(o.type == "string") { str = true; o.type = "binary"; o.codepage = 65001; d = bstrify(data); }&#13;
	if(o.type == 'array' &amp;&amp; typeof Uint8Array !== 'undefined' &amp;&amp; data instanceof Uint8Array &amp;&amp; typeof ArrayBuffer !== 'undefined') {&#13;
		// $FlowIgnore&#13;
		var ab=new ArrayBuffer(3), vu=new Uint8Array(ab); vu.foo="bar";&#13;
		// $FlowIgnore&#13;
		if(!vu.foo) {o=dup(o); o.type='array'; return readSync(ab2a(d), o);}&#13;
	}&#13;
	switch((n = firstbyte(d, o))[0]) {&#13;
		case 0xD0: if(n[1] === 0xCF &amp;&amp; n[2] === 0x11 &amp;&amp; n[3] === 0xE0 &amp;&amp; n[4] === 0xA1 &amp;&amp; n[5] === 0xB1 &amp;&amp; n[6] === 0x1A &amp;&amp; n[7] === 0xE1) return read_cfb(CFB.read(d, o), o); break;&#13;
		case 0x09: if(n[1] &lt;= 0x08) return parse_xlscfb(d, o); break;&#13;
		case 0x3C: return parse_xlml(d, o);&#13;
		case 0x49:&#13;
			if(n[1] === 0x49 &amp;&amp; n[2] === 0x2a &amp;&amp; n[3] === 0x00) throw new Error("TIFF Image File is not a spreadsheet");&#13;
			if(n[1] === 0x44) return read_wb_ID(d, o);&#13;
			break;&#13;
		case 0x54: if(n[1] === 0x41 &amp;&amp; n[2] === 0x42 &amp;&amp; n[3] === 0x4C) return DIF.to_workbook(d, o); break;&#13;
		case 0x50: return (n[1] === 0x4B &amp;&amp; n[2] &lt; 0x09 &amp;&amp; n[3] &lt; 0x09) ? read_zip(d, o) : read_prn(data, d, o, str);&#13;
		case 0xEF: return n[3] === 0x3C ? parse_xlml(d, o) : read_prn(data, d, o, str);&#13;
		case 0xFF:&#13;
			if(n[1] === 0xFE) { return read_utf16(d, o); }&#13;
			else if(n[1] === 0x00 &amp;&amp; n[2] === 0x02 &amp;&amp; n[3] === 0x00) return WK_.to_workbook(d, o);&#13;
			break;&#13;
		case 0x00:&#13;
			if(n[1] === 0x00) {&#13;
				if(n[2] &gt;= 0x02 &amp;&amp; n[3] === 0x00) return WK_.to_workbook(d, o);&#13;
				if(n[2] === 0x00 &amp;&amp; (n[3] === 0x08 || n[3] === 0x09)) return WK_.to_workbook(d, o);&#13;
			}&#13;
			break;&#13;
		case 0x03: case 0x83: case 0x8B: case 0x8C: return DBF.to_workbook(d, o);&#13;
		case 0x7B: if(n[1] === 0x5C &amp;&amp; n[2] === 0x72 &amp;&amp; n[3] === 0x74) return rtf_to_workbook(d, o); break;&#13;
		case 0x0A: case 0x0D: case 0x20: return read_plaintext_raw(d, o);&#13;
		case 0x89: if(n[1] === 0x50 &amp;&amp; n[2] === 0x4E &amp;&amp; n[3] === 0x47) throw new Error("PNG Image File is not a spreadsheet"); break;&#13;
		case 0x08: if(n[1] === 0xE7) throw new Error("Unsupported Multiplan 1.x file!"); break;&#13;
		case 0x0C:&#13;
			if(n[1] === 0xEC) throw new Error("Unsupported Multiplan 2.x file!");&#13;
			if(n[1] === 0xED) throw new Error("Unsupported Multiplan 3.x file!");&#13;
			break;&#13;
	}&#13;
	if(DBF_SUPPORTED_VERSIONS.indexOf(n[0]) &gt; -1 &amp;&amp; n[2] &lt;= 12 &amp;&amp; n[3] &lt;= 31) return DBF.to_workbook(d, o);&#13;
	return read_prn(data, d, o, str);&#13;
}&#13;
&#13;
function readFileSync(filename, opts) {&#13;
	var o = opts||{}; o.type = 'file';&#13;
	return readSync(filename, o);&#13;
}&#13;
function write_cfb_ctr(cfb, o) {&#13;
	switch(o.type) {&#13;
		case "base64": case "binary": break;&#13;
		case "buffer": case "array": o.type = ""; break;&#13;
		case "file": return write_dl(o.file, CFB.write(cfb, {type:has_buf ? 'buffer' : ""}));&#13;
		case "string": throw new Error("'string' output type invalid for '" + o.bookType + "' files");&#13;
		default: throw new Error("Unrecognized type " + o.type);&#13;
	}&#13;
	return CFB.write(cfb, o);&#13;
}&#13;
&#13;
function write_zip(wb, opts) {&#13;
	switch(opts.bookType) {&#13;
		case "ods": return write_ods(wb, opts);&#13;
		case "numbers": return write_numbers_iwa(wb, opts);&#13;
		case "xlsb": return write_zip_xlsb(wb, opts);&#13;
		default: return write_zip_xlsx(wb, opts);&#13;
	}&#13;
}&#13;
&#13;
function write_zip_type(wb, opts) {&#13;
	var o = dup(opts||{});&#13;
	var z = write_zip(wb, o);&#13;
	return write_zip_denouement(z, o);&#13;
}&#13;
function write_zip_typeXLSX(wb, opts) {&#13;
	var o = dup(opts||{});&#13;
	var z = write_zip_xlsx(wb, o);&#13;
	return write_zip_denouement(z, o);&#13;
}&#13;
function write_zip_denouement(z, o) {&#13;
	var oopts = {};&#13;
	var ftype = has_buf ? "nodebuffer" : (typeof Uint8Array !== "undefined" ? "array" : "string");&#13;
	if(o.compression) oopts.compression = 'DEFLATE';&#13;
	if(o.password) oopts.type = ftype;&#13;
	else switch(o.type) {&#13;
		case "base64": oopts.type = "base64"; break;&#13;
		case "binary": oopts.type = "string"; break;&#13;
		case "string": throw new Error("'string' output type invalid for '" + o.bookType + "' files");&#13;
		case "buffer":&#13;
		case "file": oopts.type = ftype; break;&#13;
		default: throw new Error("Unrecognized type " + o.type);&#13;
	}&#13;
	var out = z.FullPaths ? CFB.write(z, {fileType:"zip", type: {"nodebuffer": "buffer", "string": "binary"}[oopts.type] || oopts.type, compression: !!o.compression}) : z.generate(oopts);&#13;
	if(typeof Deno !== "undefined") {&#13;
		if(typeof out == "string") {&#13;
			if(o.type == "binary" || o.type == "base64") return out;&#13;
			out = new Uint8Array(s2ab(out));&#13;
		}&#13;
	}&#13;
/*jshint -W083 */&#13;
	if(o.password &amp;&amp; typeof encrypt_agile !== 'undefined') return write_cfb_ctr(encrypt_agile(out, o.password), o); // eslint-disable-line no-undef&#13;
/*jshint +W083 */&#13;
	if(o.type === "file") return write_dl(o.file, out);&#13;
	return o.type == "string" ? utf8read(out) : out;&#13;
}&#13;
&#13;
function write_cfb_type(wb, opts) {&#13;
	var o = opts||{};&#13;
	var cfb = write_xlscfb(wb, o);&#13;
	return write_cfb_ctr(cfb, o);&#13;
}&#13;
&#13;
function write_string_type(out, opts, bom) {&#13;
	if(!bom) bom = "";&#13;
	var o = bom + out;&#13;
	switch(opts.type) {&#13;
		case "base64": return Base64_encode(utf8write(o));&#13;
		case "binary": return utf8write(o);&#13;
		case "string": return out;&#13;
		case "file": return write_dl(opts.file, o, 'utf8');&#13;
		case "buffer": {&#13;
			if(has_buf) return Buffer_from(o, 'utf8');&#13;
			else if(typeof TextEncoder !== "undefined") return new TextEncoder().encode(o);&#13;
			else return write_string_type(o, {type:'binary'}).split("").map(function(c) { return c.charCodeAt(0); });&#13;
		}&#13;
	}&#13;
	throw new Error("Unrecognized type " + opts.type);&#13;
}&#13;
&#13;
function write_stxt_type(out, opts) {&#13;
	switch(opts.type) {&#13;
		case "base64": return Base64_encode_pass(out);&#13;
		case "binary": return out;&#13;
		case "string": return out; /* override in sheet_to_txt */&#13;
		case "file": return write_dl(opts.file, out, 'binary');&#13;
		case "buffer": {&#13;
			if(has_buf) return Buffer_from(out, 'binary');&#13;
			else return out.split("").map(function(c) { return c.charCodeAt(0); });&#13;
		}&#13;
	}&#13;
	throw new Error("Unrecognized type " + opts.type);&#13;
}&#13;
&#13;
/* TODO: test consistency */&#13;
function write_binary_type(out, opts) {&#13;
	switch(opts.type) {&#13;
		case "string":&#13;
		case "base64":&#13;
		case "binary":&#13;
			var bstr = "";&#13;
			// $FlowIgnore&#13;
			for(var i = 0; i &lt; out.length; ++i) bstr += String.fromCharCode(out[i]);&#13;
			return opts.type == 'base64' ? Base64_encode(bstr) : opts.type == 'string' ? utf8read(bstr) : bstr;&#13;
		case "file": return write_dl(opts.file, out);&#13;
		case "buffer": return out;&#13;
		default: throw new Error("Unrecognized type " + opts.type);&#13;
	}&#13;
}&#13;
&#13;
function writeSyncXLSX(wb, opts) {&#13;
	reset_cp();&#13;
	check_wb(wb);&#13;
	var o = dup(opts||{});&#13;
	if(o.cellStyles) { o.cellNF = true; o.sheetStubs = true; }&#13;
	if(o.type == "array") { o.type = "binary"; var out = (writeSyncXLSX(wb, o)); o.type = "array"; return s2ab(out); }&#13;
	return write_zip_typeXLSX(wb, o);&#13;
}&#13;
&#13;
function writeSync(wb, opts) {&#13;
	reset_cp();&#13;
	check_wb(wb);&#13;
	var o = dup(opts||{});&#13;
	if(o.cellStyles) { o.cellNF = true; o.sheetStubs = true; }&#13;
	if(o.type == "array") { o.type = "binary"; var out = (writeSync(wb, o)); o.type = "array"; return s2ab(out); }&#13;
	var idx = 0;&#13;
	if(o.sheet) {&#13;
		if(typeof o.sheet == "number") idx = o.sheet;&#13;
		else idx = wb.SheetNames.indexOf(o.sheet);&#13;
		if(!wb.SheetNames[idx]) throw new Error("Sheet not found: " + o.sheet + " : " + (typeof o.sheet));&#13;
	}&#13;
	switch(o.bookType || 'xlsb') {&#13;
		case 'xml':&#13;
		case 'xlml': return write_string_type(write_xlml(wb, o), o);&#13;
		case 'slk':&#13;
		case 'sylk': return write_string_type(SYLK.from_sheet(wb.Sheets[wb.SheetNames[idx]], o, wb), o);&#13;
		case 'htm':&#13;
		case 'html': return write_string_type(sheet_to_html(wb.Sheets[wb.SheetNames[idx]], o), o);&#13;
		case 'txt': return write_stxt_type(sheet_to_txt(wb.Sheets[wb.SheetNames[idx]], o), o);&#13;
		case 'csv': return write_string_type(sheet_to_csv(wb.Sheets[wb.SheetNames[idx]], o), o, "\ufeff");&#13;
		case 'dif': return write_string_type(DIF.from_sheet(wb.Sheets[wb.SheetNames[idx]], o), o);&#13;
		case 'dbf': return write_binary_type(DBF.from_sheet(wb.Sheets[wb.SheetNames[idx]], o), o);&#13;
		case 'prn': return write_string_type(PRN.from_sheet(wb.Sheets[wb.SheetNames[idx]], o), o);&#13;
		case 'rtf': return write_string_type(sheet_to_rtf(wb.Sheets[wb.SheetNames[idx]], o), o);&#13;
		case 'eth': return write_string_type(ETH.from_sheet(wb.Sheets[wb.SheetNames[idx]], o), o);&#13;
		case 'fods': return write_string_type(write_ods(wb, o), o);&#13;
		case 'wk1': return write_binary_type(WK_.sheet_to_wk1(wb.Sheets[wb.SheetNames[idx]], o), o);&#13;
		case 'wk3': return write_binary_type(WK_.book_to_wk3(wb, o), o);&#13;
		case 'biff2': if(!o.biff) o.biff = 2; /* falls through */&#13;
		case 'biff3': if(!o.biff) o.biff = 3; /* falls through */&#13;
		case 'biff4': if(!o.biff) o.biff = 4; return write_binary_type(write_biff_buf(wb, o), o);&#13;
		case 'biff5': if(!o.biff) o.biff = 5; /* falls through */&#13;
		case 'biff8':&#13;
		case 'xla':&#13;
		case 'xls': if(!o.biff) o.biff = 8; return write_cfb_type(wb, o);&#13;
		case 'xlsx':&#13;
		case 'xlsm':&#13;
		case 'xlam':&#13;
		case 'xlsb':&#13;
		case 'numbers':&#13;
		case 'ods': return write_zip_type(wb, o);&#13;
		default: throw new Error ("Unrecognized bookType |" + o.bookType + "|");&#13;
	}&#13;
}&#13;
&#13;
function resolve_book_type(o) {&#13;
	if(o.bookType) return;&#13;
	var _BT = {&#13;
		"xls": "biff8",&#13;
		"htm": "html",&#13;
		"slk": "sylk",&#13;
		"socialcalc": "eth",&#13;
		"Sh33tJS": "WTF"&#13;
	};&#13;
	var ext = o.file.slice(o.file.lastIndexOf(".")).toLowerCase();&#13;
	if(ext.match(/^\.[a-z]+$/)) o.bookType = ext.slice(1);&#13;
	o.bookType = _BT[o.bookType] || o.bookType;&#13;
}&#13;
&#13;
function writeFileSync(wb, filename, opts) {&#13;
	var o = opts||{}; o.type = 'file';&#13;
	o.file = filename;&#13;
	resolve_book_type(o);&#13;
	return writeSync(wb, o);&#13;
}&#13;
&#13;
function writeFileSyncXLSX(wb, filename, opts) {&#13;
	var o = opts||{}; o.type = 'file';&#13;
	o.file = filename;&#13;
	resolve_book_type(o);&#13;
	return writeSyncXLSX(wb, o);&#13;
}&#13;
&#13;
&#13;
function writeFileAsync(filename, wb, opts, cb) {&#13;
	var o = opts||{}; o.type = 'file';&#13;
	o.file = filename;&#13;
	resolve_book_type(o);&#13;
	o.type = 'buffer';&#13;
	var _cb = cb; if(!(_cb instanceof Function)) _cb = (opts);&#13;
	return _fs.writeFile(filename, writeSync(wb, o), _cb);&#13;
}&#13;
function make_json_row(sheet, r, R, cols, header, hdr, dense, o) {&#13;
	var rr = encode_row(R);&#13;
	var defval = o.defval, raw = o.raw || !Object.prototype.hasOwnProperty.call(o, "raw");&#13;
	var isempty = true;&#13;
	var row = (header === 1) ? [] : {};&#13;
	if(header !== 1) {&#13;
		if(Object.defineProperty) try { Object.defineProperty(row, '__rowNum__', {value:R, enumerable:false}); } catch(e) { row.__rowNum__ = R; }&#13;
		else row.__rowNum__ = R;&#13;
	}&#13;
	if(!dense || sheet[R]) for (var C = r.s.c; C &lt;= r.e.c; ++C) {&#13;
		var val = dense ? sheet[R][C] : sheet[cols[C] + rr];&#13;
		if(val === undefined || val.t === undefined) {&#13;
			if(defval === undefined) continue;&#13;
			if(hdr[C] != null) { row[hdr[C]] = defval; }&#13;
			continue;&#13;
		}&#13;
		var v = val.v;&#13;
		switch(val.t){&#13;
			case 'z': if(v == null) break; continue;&#13;
			case 'e': v = (v == 0 ? null : void 0); break;&#13;
			case 's': case 'd': case 'b': case 'n': break;&#13;
			default: throw new Error('unrecognized type ' + val.t);&#13;
		}&#13;
		if(hdr[C] != null) {&#13;
			if(v == null) {&#13;
				if(val.t == "e" &amp;&amp; v === null) row[hdr[C]] = null;&#13;
				else if(defval !== undefined) row[hdr[C]] = defval;&#13;
				else if(raw &amp;&amp; v === null) row[hdr[C]] = null;&#13;
				else continue;&#13;
			} else {&#13;
				row[hdr[C]] = raw &amp;&amp; (val.t !== "n" || (val.t === "n" &amp;&amp; o.rawNumbers !== false)) ? v : format_cell(val,v,o);&#13;
			}&#13;
			if(v != null) isempty = false;&#13;
		}&#13;
	}&#13;
	return { row: row, isempty: isempty };&#13;
}&#13;
&#13;
&#13;
function sheet_to_json(sheet, opts) {&#13;
	if(sheet == null || sheet["!ref"] == null) return [];&#13;
	var val = {t:'n',v:0}, header = 0, offset = 1, hdr = [], v=0, vv="";&#13;
	var r = {s:{r:0,c:0},e:{r:0,c:0}};&#13;
	var o = opts || {};&#13;
	var range = o.range != null ? o.range : sheet["!ref"];&#13;
	if(o.header === 1) header = 1;&#13;
	else if(o.header === "A") header = 2;&#13;
	else if(Array.isArray(o.header)) header = 3;&#13;
	else if(o.header == null) header = 0;&#13;
	switch(typeof range) {&#13;
		case 'string': r = safe_decode_range(range); break;&#13;
		case 'number': r = safe_decode_range(sheet["!ref"]); r.s.r = range; break;&#13;
		default: r = range;&#13;
	}&#13;
	if(header &gt; 0) offset = 0;&#13;
	var rr = encode_row(r.s.r);&#13;
	var cols = [];&#13;
	var out = [];&#13;
	var outi = 0, counter = 0;&#13;
	var dense = Array.isArray(sheet);&#13;
	var R = r.s.r, C = 0;&#13;
	var header_cnt = {};&#13;
	if(dense &amp;&amp; !sheet[R]) sheet[R] = [];&#13;
	var colinfo = o.skipHidden &amp;&amp; sheet["!cols"] || [];&#13;
	var rowinfo = o.skipHidden &amp;&amp; sheet["!rows"] || [];&#13;
	for(C = r.s.c; C &lt;= r.e.c; ++C) {&#13;
		if(((colinfo[C]||{}).hidden)) continue;&#13;
		cols[C] = encode_col(C);&#13;
		val = dense ? sheet[R][C] : sheet[cols[C] + rr];&#13;
		switch(header) {&#13;
			case 1: hdr[C] = C - r.s.c; break;&#13;
			case 2: hdr[C] = cols[C]; break;&#13;
			case 3: hdr[C] = o.header[C - r.s.c]; break;&#13;
			default:&#13;
				if(val == null) val = {w: "__EMPTY", t: "s"};&#13;
				vv = v = format_cell(val, null, o);&#13;
				counter = header_cnt[v] || 0;&#13;
				if(!counter) header_cnt[v] = 1;&#13;
				else {&#13;
					do { vv = v + "_" + (counter++); } while(header_cnt[vv]); header_cnt[v] = counter;&#13;
					header_cnt[vv] = 1;&#13;
				}&#13;
				hdr[C] = vv;&#13;
		}&#13;
	}&#13;
	for (R = r.s.r + offset; R &lt;= r.e.r; ++R) {&#13;
		if ((rowinfo[R]||{}).hidden) continue;&#13;
		var row = make_json_row(sheet, r, R, cols, header, hdr, dense, o);&#13;
		if((row.isempty === false) || (header === 1 ? o.blankrows !== false : !!o.blankrows)) out[outi++] = row.row;&#13;
	}&#13;
	out.length = outi;&#13;
	return out;&#13;
}&#13;
&#13;
var qreg = /"/g;&#13;
function make_csv_row(sheet, r, R, cols, fs, rs, FS, o) {&#13;
	var isempty = true;&#13;
	var row = [], txt = "", rr = encode_row(R);&#13;
	for(var C = r.s.c; C &lt;= r.e.c; ++C) {&#13;
		if (!cols[C]) continue;&#13;
		var val = o.dense ? (sheet[R]||[])[C]: sheet[cols[C] + rr];&#13;
		if(val == null) txt = "";&#13;
		else if(val.v != null) {&#13;
			isempty = false;&#13;
			txt = ''+(o.rawNumbers &amp;&amp; val.t == "n" ? val.v : format_cell(val, null, o));&#13;
			for(var i = 0, cc = 0; i !== txt.length; ++i) if((cc = txt.charCodeAt(i)) === fs || cc === rs || cc === 34 || o.forceQuotes) {txt = "\"" + txt.replace(qreg, '""') + "\""; break; }&#13;
			if(txt == "ID") txt = '"ID"';&#13;
		} else if(val.f != null &amp;&amp; !val.F) {&#13;
			isempty = false;&#13;
			txt = '=' + val.f; if(txt.indexOf(",") &gt;= 0) txt = '"' + txt.replace(qreg, '""') + '"';&#13;
		} else txt = "";&#13;
		/* NOTE: Excel CSV does not support array formulae */&#13;
		row.push(txt);&#13;
	}&#13;
	if(o.blankrows === false &amp;&amp; isempty) return null;&#13;
	return row.join(FS);&#13;
}&#13;
&#13;
function sheet_to_csv(sheet, opts) {&#13;
	var out = [];&#13;
	var o = opts == null ? {} : opts;&#13;
	if(sheet == null || sheet["!ref"] == null) return "";&#13;
	var r = safe_decode_range(sheet["!ref"]);&#13;
	var FS = o.FS !== undefined ? o.FS : ",", fs = FS.charCodeAt(0);&#13;
	var RS = o.RS !== undefined ? o.RS : "\n", rs = RS.charCodeAt(0);&#13;
	var endregex = new RegExp((FS=="|" ? "\\|" : FS)+"+$");&#13;
	var row = "", cols = [];&#13;
	o.dense = Array.isArray(sheet);&#13;
	var colinfo = o.skipHidden &amp;&amp; sheet["!cols"] || [];&#13;
	var rowinfo = o.skipHidden &amp;&amp; sheet["!rows"] || [];&#13;
	for(var C = r.s.c; C &lt;= r.e.c; ++C) if (!((colinfo[C]||{}).hidden)) cols[C] = encode_col(C);&#13;
	var w = 0;&#13;
	for(var R = r.s.r; R &lt;= r.e.r; ++R) {&#13;
		if ((rowinfo[R]||{}).hidden) continue;&#13;
		row = make_csv_row(sheet, r, R, cols, fs, rs, FS, o);&#13;
		if(row == null) { continue; }&#13;
		if(o.strip) row = row.replace(endregex,"");&#13;
		if(row || (o.blankrows !== false)) out.push((w++ ? RS : "") + row);&#13;
	}&#13;
	delete o.dense;&#13;
	return out.join("");&#13;
}&#13;
&#13;
function sheet_to_txt(sheet, opts) {&#13;
	if(!opts) opts = {}; opts.FS = "\t"; opts.RS = "\n";&#13;
	var s = sheet_to_csv(sheet, opts);&#13;
	if(typeof $cptable == 'undefined' || opts.type == 'string') return s;&#13;
	var o = $cptable.utils.encode(1200, s, 'str');&#13;
	return String.fromCharCode(255) + String.fromCharCode(254) + o;&#13;
}&#13;
&#13;
function sheet_to_formulae(sheet) {&#13;
	var y = "", x, val="";&#13;
	if(sheet == null || sheet["!ref"] == null) return [];&#13;
	var r = safe_decode_range(sheet['!ref']), rr = "", cols = [], C;&#13;
	var cmds = [];&#13;
	var dense = Array.isArray(sheet);&#13;
	for(C = r.s.c; C &lt;= r.e.c; ++C) cols[C] = encode_col(C);&#13;
	for(var R = r.s.r; R &lt;= r.e.r; ++R) {&#13;
		rr = encode_row(R);&#13;
		for(C = r.s.c; C &lt;= r.e.c; ++C) {&#13;
			y = cols[C] + rr;&#13;
			x = dense ? (sheet[R]||[])[C] : sheet[y];&#13;
			val = "";&#13;
			if(x === undefined) continue;&#13;
			else if(x.F != null) {&#13;
				y = x.F;&#13;
				if(!x.f) continue;&#13;
				val = x.f;&#13;
				if(y.indexOf(":") == -1) y = y + ":" + y;&#13;
			}&#13;
			if(x.f != null) val = x.f;&#13;
			else if(x.t == 'z') continue;&#13;
			else if(x.t == 'n' &amp;&amp; x.v != null) val = "" + x.v;&#13;
			else if(x.t == 'b') val = x.v ? "TRUE" : "FALSE";&#13;
			else if(x.w !== undefined) val = "'" + x.w;&#13;
			else if(x.v === undefined) continue;&#13;
			else if(x.t == 's') val = "'" + x.v;&#13;
			else val = ""+x.v;&#13;
			cmds[cmds.length] = y + "=" + val;&#13;
		}&#13;
	}&#13;
	return cmds;&#13;
}&#13;
&#13;
function sheet_add_json(_ws, js, opts) {&#13;
	var o = opts || {};&#13;
	var dense = _ws ? Array.isArray(_ws) : o.dense;&#13;
	if(DENSE != null &amp;&amp; dense == null) dense = DENSE;&#13;
	var offset = +!o.skipHeader;&#13;
	var ws = _ws || (dense ? ([]) : ({}));&#13;
	var _R = 0, _C = 0;&#13;
	if(ws &amp;&amp; o.origin != null) {&#13;
		if(typeof o.origin == 'number') _R = o.origin;&#13;
		else {&#13;
			var _origin = typeof o.origin == "string" ? decode_cell(o.origin) : o.origin;&#13;
			_R = _origin.r; _C = _origin.c;&#13;
		}&#13;
	}&#13;
	var range = ({s: {c:0, r:0}, e: {c:_C, r:_R + js.length - 1 + offset}});&#13;
	if(ws['!ref']) {&#13;
		var _range = safe_decode_range(ws['!ref']);&#13;
		range.e.c = Math.max(range.e.c, _range.e.c);&#13;
		range.e.r = Math.max(range.e.r, _range.e.r);&#13;
		if(_R == -1) { _R = _range.e.r + 1; range.e.r = _R + js.length - 1 + offset; }&#13;
	} else {&#13;
		if(_R == -1) { _R = 0; range.e.r = js.length - 1 + offset; }&#13;
	}&#13;
	var hdr = o.header || [], C = 0;&#13;
	var ROW = [];&#13;
	js.forEach(function (JS, R) {&#13;
		if(dense &amp;&amp; !ws[_R + R + offset]) ws[_R + R + offset] = [];&#13;
		if(dense) ROW = ws[_R + R + offset];&#13;
		keys(JS).forEach(function(k) {&#13;
			if((C=hdr.indexOf(k)) == -1) hdr[C=hdr.length] = k;&#13;
			var v = JS[k];&#13;
			var t = 'z';&#13;
			var z = "";&#13;
			var ref = dense ? "" : encode_cell({c:_C + C,r:_R + R + offset});&#13;
			var cell = dense ? ROW[_C + C] : ws[ref];&#13;
			if(v &amp;&amp; typeof v === 'object' &amp;&amp; !(v instanceof Date)){&#13;
				ws[ref] = v;&#13;
			} else {&#13;
				if(typeof v == 'number') t = 'n';&#13;
				else if(typeof v == 'boolean') t = 'b';&#13;
				else if(typeof v == 'string') t = 's';&#13;
				else if(v instanceof Date) {&#13;
					t = 'd';&#13;
					if(!o.cellDates) { t = 'n'; v = datenum(v); }&#13;
					z = (cell != null &amp;&amp; cell.z &amp;&amp; fmt_is_date(cell.z)) ? cell.z : (o.dateNF || table_fmt[14]);&#13;
				}&#13;
				else if(v === null &amp;&amp; o.nullError) { t = 'e'; v = 0; }&#13;
				if(!cell) {&#13;
					if(!dense) ws[ref] = cell = ({t:t, v:v});&#13;
					else ROW[_C + C] = cell = ({t:t, v:v});&#13;
				} else {&#13;
					cell.t = t; cell.v = v;&#13;
					delete cell.w; delete cell.R;&#13;
					if(z) cell.z = z;&#13;
				}&#13;
				if(z) cell.z = z;&#13;
			}&#13;
		});&#13;
	});&#13;
	range.e.c = Math.max(range.e.c, _C + hdr.length - 1);&#13;
	var __R = encode_row(_R);&#13;
	if(dense &amp;&amp; !ws[_R]) ws[_R] = [];&#13;
	if(offset) for(C = 0; C &lt; hdr.length; ++C) {&#13;
		if(dense) ws[_R][C + _C] = {t:'s', v:hdr[C]};&#13;
		else ws[encode_col(C + _C) + __R] = {t:'s', v:hdr[C]};&#13;
	}&#13;
	ws['!ref'] = encode_range(range);&#13;
	return ws;&#13;
}&#13;
function json_to_sheet(js, opts) { return sheet_add_json(null, js, opts); }&#13;
&#13;
/* get cell, creating a stub if necessary */&#13;
function ws_get_cell_stub(ws, R, C) {&#13;
	/* A1 cell address */&#13;
	if(typeof R == "string") {&#13;
		/* dense */&#13;
		if(Array.isArray(ws)) {&#13;
			var RC = decode_cell(R);&#13;
			if(!ws[RC.r]) ws[RC.r] = [];&#13;
			return ws[RC.r][RC.c] || (ws[RC.r][RC.c] = {t:'z'});&#13;
		}&#13;
		return ws[R] || (ws[R] = {t:'z'});&#13;
	}&#13;
	/* cell address object */&#13;
	if(typeof R != "number") return ws_get_cell_stub(ws, encode_cell(R));&#13;
	/* R and C are 0-based indices */&#13;
	return ws_get_cell_stub(ws, encode_cell({r:R,c:C||0}));&#13;
}&#13;
&#13;
/* find sheet index for given name / validate index */&#13;
function wb_sheet_idx(wb, sh) {&#13;
	if(typeof sh == "number") {&#13;
		if(sh &gt;= 0 &amp;&amp; wb.SheetNames.length &gt; sh) return sh;&#13;
		throw new Error("Cannot find sheet # " + sh);&#13;
	} else if(typeof sh == "string") {&#13;
		var idx = wb.SheetNames.indexOf(sh);&#13;
		if(idx &gt; -1) return idx;&#13;
		throw new Error("Cannot find sheet name |" + sh + "|");&#13;
	} else throw new Error("Cannot find sheet |" + sh + "|");&#13;
}&#13;
&#13;
/* simple blank workbook object */&#13;
function book_new() {&#13;
	return { SheetNames: [], Sheets: {} };&#13;
}&#13;
&#13;
/* add a worksheet to the end of a given workbook */&#13;
function book_append_sheet(wb, ws, name, roll) {&#13;
	var i = 1;&#13;
	if(!name) for(; i &lt;= 0xFFFF; ++i, name = undefined) if(wb.SheetNames.indexOf(name = "Sheet" + i) == -1) break;&#13;
	if(!name || wb.SheetNames.length &gt;= 0xFFFF) throw new Error("Too many worksheets");&#13;
	if(roll &amp;&amp; wb.SheetNames.indexOf(name) &gt;= 0) {&#13;
		var m = name.match(/(^.*?)(\d+)$/);&#13;
		i = m &amp;&amp; +m[2] || 0;&#13;
		var root = m &amp;&amp; m[1] || name;&#13;
		for(++i; i &lt;= 0xFFFF; ++i) if(wb.SheetNames.indexOf(name = root + i) == -1) break;&#13;
	}&#13;
	check_ws_name(name);&#13;
	if(wb.SheetNames.indexOf(name) &gt;= 0) throw new Error("Worksheet with name |" + name + "| already exists!");&#13;
&#13;
	wb.SheetNames.push(name);&#13;
	wb.Sheets[name] = ws;&#13;
	return name;&#13;
}&#13;
&#13;
/* set sheet visibility (visible/hidden/very hidden) */&#13;
function book_set_sheet_visibility(wb, sh, vis) {&#13;
	if(!wb.Workbook) wb.Workbook = {};&#13;
	if(!wb.Workbook.Sheets) wb.Workbook.Sheets = [];&#13;
&#13;
	var idx = wb_sheet_idx(wb, sh);&#13;
	// $FlowIgnore&#13;
	if(!wb.Workbook.Sheets[idx]) wb.Workbook.Sheets[idx] = {};&#13;
&#13;
	switch(vis) {&#13;
		case 0: case 1: case 2: break;&#13;
		default: throw new Error("Bad sheet visibility setting " + vis);&#13;
	}&#13;
	// $FlowIgnore&#13;
	wb.Workbook.Sheets[idx].Hidden = vis;&#13;
}&#13;
&#13;
/* set number format */&#13;
function cell_set_number_format(cell, fmt) {&#13;
	cell.z = fmt;&#13;
	return cell;&#13;
}&#13;
&#13;
/* set cell hyperlink */&#13;
function cell_set_hyperlink(cell, target, tooltip) {&#13;
	if(!target) {&#13;
		delete cell.l;&#13;
	} else {&#13;
		cell.l = ({ Target: target });&#13;
		if(tooltip) cell.l.Tooltip = tooltip;&#13;
	}&#13;
	return cell;&#13;
}&#13;
function cell_set_internal_link(cell, range, tooltip) { return cell_set_hyperlink(cell, "#" + range, tooltip); }&#13;
&#13;
/* add to cell comments */&#13;
function cell_add_comment(cell, text, author) {&#13;
	if(!cell.c) cell.c = [];&#13;
	cell.c.push({t:text, a:author||"xlsx"});&#13;
}&#13;
&#13;
/* set array formula and flush related cells */&#13;
function sheet_set_array_formula(ws, range, formula, dynamic) {&#13;
	var rng = typeof range != "string" ? range : safe_decode_range(range);&#13;
	var rngstr = typeof range == "string" ? range : encode_range(range);&#13;
	for(var R = rng.s.r; R &lt;= rng.e.r; ++R) for(var C = rng.s.c; C &lt;= rng.e.c; ++C) {&#13;
		var cell = ws_get_cell_stub(ws, R, C);&#13;
		cell.t = 'n';&#13;
		cell.F = rngstr;&#13;
		delete cell.v;&#13;
		if(R == rng.s.r &amp;&amp; C == rng.s.c) {&#13;
			cell.f = formula;&#13;
			if(dynamic) cell.D = true;&#13;
		}&#13;
	}&#13;
	var wsr = decode_range(ws["!ref"]);&#13;
	if(wsr.s.r &gt; rng.s.r) wsr.s.r = rng.s.r;&#13;
	if(wsr.s.c &gt; rng.s.c) wsr.s.c = rng.s.c;&#13;
	if(wsr.e.r &lt; rng.e.r) wsr.e.r = rng.e.r;&#13;
	if(wsr.e.c &lt; rng.e.c) wsr.e.c = rng.e.c;&#13;
	ws["!ref"] = encode_range(wsr);&#13;
	return ws;&#13;
}&#13;
&#13;
var utils = {&#13;
	encode_col: encode_col,&#13;
	encode_row: encode_row,&#13;
	encode_cell: encode_cell,&#13;
	encode_range: encode_range,&#13;
	decode_col: decode_col,&#13;
	decode_row: decode_row,&#13;
	split_cell: split_cell,&#13;
	decode_cell: decode_cell,&#13;
	decode_range: decode_range,&#13;
	format_cell: format_cell,&#13;
	sheet_add_aoa: sheet_add_aoa,&#13;
	sheet_add_json: sheet_add_json,&#13;
	sheet_add_dom: sheet_add_dom,&#13;
	aoa_to_sheet: aoa_to_sheet,&#13;
	json_to_sheet: json_to_sheet,&#13;
	table_to_sheet: parse_dom_table,&#13;
	table_to_book: table_to_book,&#13;
	sheet_to_csv: sheet_to_csv,&#13;
	sheet_to_txt: sheet_to_txt,&#13;
	sheet_to_json: sheet_to_json,&#13;
	sheet_to_html: sheet_to_html,&#13;
	sheet_to_formulae: sheet_to_formulae,&#13;
	sheet_to_row_object_array: sheet_to_json,&#13;
	sheet_get_cell: ws_get_cell_stub,&#13;
	book_new: book_new,&#13;
	book_append_sheet: book_append_sheet,&#13;
	book_set_sheet_visibility: book_set_sheet_visibility,&#13;
	cell_set_number_format: cell_set_number_format,&#13;
	cell_set_hyperlink: cell_set_hyperlink,&#13;
	cell_set_internal_link: cell_set_internal_link,&#13;
	cell_add_comment: cell_add_comment,&#13;
	sheet_set_array_formula: sheet_set_array_formula,&#13;
	consts: {&#13;
		SHEET_VISIBLE: 0,&#13;
		SHEET_HIDDEN: 1,&#13;
		SHEET_VERY_HIDDEN: 2&#13;
	}&#13;
};&#13;
&#13;
var _Readable;&#13;
function set_readable(R) { _Readable = R; }&#13;
&#13;
function write_csv_stream(sheet, opts) {&#13;
	var stream = _Readable();&#13;
	var o = opts == null ? {} : opts;&#13;
	if(sheet == null || sheet["!ref"] == null) { stream.push(null); return stream; }&#13;
	var r = safe_decode_range(sheet["!ref"]);&#13;
	var FS = o.FS !== undefined ? o.FS : ",", fs = FS.charCodeAt(0);&#13;
	var RS = o.RS !== undefined ? o.RS : "\n", rs = RS.charCodeAt(0);&#13;
	var endregex = new RegExp((FS=="|" ? "\\|" : FS)+"+$");&#13;
	var row = "", cols = [];&#13;
	o.dense = Array.isArray(sheet);&#13;
	var colinfo = o.skipHidden &amp;&amp; sheet["!cols"] || [];&#13;
	var rowinfo = o.skipHidden &amp;&amp; sheet["!rows"] || [];&#13;
	for(var C = r.s.c; C &lt;= r.e.c; ++C) if (!((colinfo[C]||{}).hidden)) cols[C] = encode_col(C);&#13;
	var R = r.s.r;&#13;
	var BOM = false, w = 0;&#13;
	stream._read = function() {&#13;
		if(!BOM) { BOM = true; return stream.push("\uFEFF"); }&#13;
		while(R &lt;= r.e.r) {&#13;
			++R;&#13;
			if ((rowinfo[R-1]||{}).hidden) continue;&#13;
			row = make_csv_row(sheet, r, R-1, cols, fs, rs, FS, o);&#13;
			if(row != null) {&#13;
				if(o.strip) row = row.replace(endregex,"");&#13;
				if(row || (o.blankrows !== false)) return stream.push((w++ ? RS : "") + row);&#13;
			}&#13;
		}&#13;
		return stream.push(null);&#13;
	};&#13;
	return stream;&#13;
}&#13;
&#13;
function write_html_stream(ws, opts) {&#13;
	var stream = _Readable();&#13;
&#13;
	var o = opts || {};&#13;
	var header = o.header != null ? o.header : HTML_BEGIN;&#13;
	var footer = o.footer != null ? o.footer : HTML_END;&#13;
	stream.push(header);&#13;
	var r = decode_range(ws['!ref']);&#13;
	o.dense = Array.isArray(ws);&#13;
	stream.push(make_html_preamble(ws, r, o));&#13;
	var R = r.s.r;&#13;
	var end = false;&#13;
	stream._read = function() {&#13;
		if(R &gt; r.e.r) {&#13;
			if(!end) { end = true; stream.push("&lt;/table&gt;" + footer); }&#13;
			return stream.push(null);&#13;
		}&#13;
		while(R &lt;= r.e.r) {&#13;
			stream.push(make_html_row(ws, r, R, o));&#13;
			++R;&#13;
			break;&#13;
		}&#13;
	};&#13;
	return stream;&#13;
}&#13;
&#13;
function write_json_stream(sheet, opts) {&#13;
	var stream = _Readable({objectMode:true});&#13;
&#13;
	if(sheet == null || sheet["!ref"] == null) { stream.push(null); return stream; }&#13;
	var val = {t:'n',v:0}, header = 0, offset = 1, hdr = [], v=0, vv="";&#13;
	var r = {s:{r:0,c:0},e:{r:0,c:0}};&#13;
	var o = opts || {};&#13;
	var range = o.range != null ? o.range : sheet["!ref"];&#13;
	if(o.header === 1) header = 1;&#13;
	else if(o.header === "A") header = 2;&#13;
	else if(Array.isArray(o.header)) header = 3;&#13;
	switch(typeof range) {&#13;
		case 'string': r = safe_decode_range(range); break;&#13;
		case 'number': r = safe_decode_range(sheet["!ref"]); r.s.r = range; break;&#13;
		default: r = range;&#13;
	}&#13;
	if(header &gt; 0) offset = 0;&#13;
	var rr = encode_row(r.s.r);&#13;
	var cols = [];&#13;
	var counter = 0;&#13;
	var dense = Array.isArray(sheet);&#13;
	var R = r.s.r, C = 0;&#13;
	var header_cnt = {};&#13;
	if(dense &amp;&amp; !sheet[R]) sheet[R] = [];&#13;
	var colinfo = o.skipHidden &amp;&amp; sheet["!cols"] || [];&#13;
	var rowinfo = o.skipHidden &amp;&amp; sheet["!rows"] || [];&#13;
	for(C = r.s.c; C &lt;= r.e.c; ++C) {&#13;
		if(((colinfo[C]||{}).hidden)) continue;&#13;
		cols[C] = encode_col(C);&#13;
		val = dense ? sheet[R][C] : sheet[cols[C] + rr];&#13;
		switch(header) {&#13;
			case 1: hdr[C] = C - r.s.c; break;&#13;
			case 2: hdr[C] = cols[C]; break;&#13;
			case 3: hdr[C] = o.header[C - r.s.c]; break;&#13;
			default:&#13;
				if(val == null) val = {w: "__EMPTY", t: "s"};&#13;
				vv = v = format_cell(val, null, o);&#13;
				counter = header_cnt[v] || 0;&#13;
				if(!counter) header_cnt[v] = 1;&#13;
				else {&#13;
					do { vv = v + "_" + (counter++); } while(header_cnt[vv]); header_cnt[v] = counter;&#13;
					header_cnt[vv] = 1;&#13;
				}&#13;
				hdr[C] = vv;&#13;
		}&#13;
	}&#13;
	R = r.s.r + offset;&#13;
	stream._read = function() {&#13;
		while(R &lt;= r.e.r) {&#13;
			if ((rowinfo[R-1]||{}).hidden) continue;&#13;
			var row = make_json_row(sheet, r, R, cols, header, hdr, dense, o);&#13;
			++R;&#13;
			if((row.isempty === false) || (header === 1 ? o.blankrows !== false : !!o.blankrows)) {&#13;
				stream.push(row.row);&#13;
				return;&#13;
			}&#13;
		}&#13;
		return stream.push(null);&#13;
	};&#13;
	return stream;&#13;
}&#13;
&#13;
var __stream = {&#13;
	to_json: write_json_stream,&#13;
	to_html: write_html_stream,&#13;
	to_csv: write_csv_stream,&#13;
	set_readable: set_readable&#13;
};&#13;
if(typeof parse_xlscfb !== "undefined") XLSX.parse_xlscfb = parse_xlscfb;&#13;
XLSX.parse_zip = parse_zip;&#13;
XLSX.read = readSync; //xlsread&#13;
XLSX.readFile = readFileSync; //readFile&#13;
XLSX.readFileSync = readFileSync;&#13;
XLSX.write = writeSync;&#13;
XLSX.writeFile = writeFileSync;&#13;
XLSX.writeFileSync = writeFileSync;&#13;
XLSX.writeFileAsync = writeFileAsync;&#13;
XLSX.utils = utils;&#13;
XLSX.writeXLSX = writeSyncXLSX;&#13;
XLSX.writeFileXLSX = writeFileSyncXLSX;&#13;
XLSX.SSF = SSF;&#13;
if(typeof __stream !== "undefined") XLSX.stream = __stream;&#13;
if(typeof CFB !== "undefined") XLSX.CFB = CFB;&#13;
if(typeof require !== "undefined") {&#13;
  var strmod = require('stream');&#13;
  if((strmod||{}).Readable) set_readable(strmod.Readable);&#13;
	try { _fs = require('fs'); } catch(e) {}&#13;
}&#13;
}&#13;
/*global define */&#13;
if(typeof exports !== 'undefined') make_xlsx_lib(exports);&#13;
else if(typeof module !== 'undefined' &amp;&amp; module.exports) make_xlsx_lib(module.exports);&#13;
else if(typeof define === 'function' &amp;&amp; define.amd) define('xlsx', function() { if(!XLSX.version) make_xlsx_lib(XLSX); return XLSX; });&#13;
else make_xlsx_lib(XLSX);&#13;
/* NOTE: the following extra line is needed for "Lightning Locker Service" */&#13;
//if(typeof window !== 'undefined' &amp;&amp; !window.XLSX) try { window.XLSX = XLSX; } catch(e) {});</script><sys_class_name>sys_script_include</sys_class_name><sys_created_by>toma.istvan</sys_created_by><sys_created_on>2022-11-14 09:08:25</sys_created_on><sys_id>11b0e2931b0f5910c7c9fc078b4bcbe0</sys_id><sys_mod_count>1</sys_mod_count><sys_name>xlsx</sys_name><sys_package display_value="CMB" source="x_tsigh_cmb">365c71ab1be95110c7c9fc078b4bcb2c</sys_package><sys_policy>read</sys_policy><sys_scope display_value="CMB">365c71ab1be95110c7c9fc078b4bcb2c</sys_scope><sys_update_name>sys_script_include_11b0e2931b0f5910c7c9fc078b4bcbe0</sys_update_name><sys_updated_by>toma.istvan</sys_updated_by><sys_updated_on>2022-11-14 11:46:13</sys_updated_on></sys_script_include></record_update>]]></payload>
        <payload_hash>-2053251476</payload_hash>
        <record_name>xlsx</record_name>
        <reverted_from/>
        <source>155d3a0d1b7d9510c7c9fc078b4bcb27</source>
        <source_table>sys_update_set</source_table>
        <state>previous</state>
        <sys_created_by>toma.istvan</sys_created_by>
        <sys_created_on>2022-11-14 11:46:15</sys_created_on>
        <sys_id>fb95cf531b8f5910c7c9fc078b4bcba8</sys_id>
        <sys_mod_count>0</sys_mod_count>
        <sys_recorded_at>18475f61ee00000001</sys_recorded_at>
        <sys_updated_by>toma.istvan</sys_updated_by>
        <sys_updated_on>2022-11-14 11:46:15</sys_updated_on>
        <type>Script Include</type>
        <update_guid>a395cf53898f59106564fe1d2b3dcda8</update_guid>
        <update_guid_history>a395cf53898f59106564fe1d2b3dcda8:-2053251476,f77166d3fe0f59100999ad220088c50f:2017351748</update_guid_history>
    </sys_update_version>
    <sys_metadata_delete action="INSERT_OR_UPDATE">
        <sys_audit_delete/>
        <sys_class_name>sys_metadata_delete</sys_class_name>
        <sys_created_by>istvan.toma</sys_created_by>
        <sys_created_on>2022-11-28 14:30:09</sys_created_on>
        <sys_db_object display_value="" name="sys_script_include">sys_script_include</sys_db_object>
        <sys_id>139b33fe55ed46aa8a83f591a2ddf809</sys_id>
        <sys_metadata>11b0e2931b0f5910c7c9fc078b4bcbe0</sys_metadata>
        <sys_mod_count>0</sys_mod_count>
        <sys_name>xlsx</sys_name>
        <sys_package display_value="CMB" source="x_tsigh_cmb">365c71ab1be95110c7c9fc078b4bcb2c</sys_package>
        <sys_parent/>
        <sys_policy>read</sys_policy>
        <sys_scope display_value="CMB">365c71ab1be95110c7c9fc078b4bcb2c</sys_scope>
        <sys_scope_delete display_value="">0c3af6fb7fd2405a81b156e2f1c96044</sys_scope_delete>
        <sys_update_name>sys_script_include_11b0e2931b0f5910c7c9fc078b4bcbe0</sys_update_name>
        <sys_update_version display_value="sys_script_include_11b0e2931b0f5910c7c9fc078b4bcbe0">fb95cf531b8f5910c7c9fc078b4bcba8</sys_update_version>
        <sys_updated_by>istvan.toma</sys_updated_by>
        <sys_updated_on>2022-11-28 14:30:09</sys_updated_on>
    </sys_metadata_delete>
</record_update>
